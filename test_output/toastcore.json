{
  "versionstring": "** LambdaMOO Database, Format Version 17 **",
  "version": 17,
  "total_objects": 128,
  "total_verbs": 1949,
  "total_players": 6,
  "finalizations": [],
  "clocks": [],
  "objects": {
    "0": {
      "id": 0,
      "name": "The System Object",
      "flags": 24,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "do_login_command",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"...This code should only be run as a server task...\";",
            "if (callers())",
            "return E_PERM;",
            "endif",
            "\"...perform a threaded DNS name lookup and store the result for the duration of the connection...\";",
            "$login:connection_name_lookup(player);",
            "if (typeof(h = $network:incoming_connection(player)) == OBJ)",
            "\"connected to an object\";",
            "$login:delete_name_lookup(player);",
            "switch_player(player, h);",
            "return;",
            "elseif (h)",
            "return 0;",
            "endif",
            "host = $string_utils:connection_hostname(player);",
            "if ($login:redlisted(host))",
            "boot_player(player);",
            "server_log(tostr(\"REDLISTED: \", player, \" from \", host));",
            "return 0;",
            "endif",
            "\"HTTP server by Krate\";",
            "try",
            "newargs = $http:handle_connection(@args);",
            "if (!newargs)",
            "return 0;",
            "endif",
            "args = newargs;",
            "except v (ANY)",
            "endtry",
            "\"...checks to see if the login is spamming the server with too many commands...\";",
            "if (!$login:maybe_limit_commands())",
            "$telnet:new_connection(player);",
            "args = $login:parse_command(@args);",
            "retval = $login:(args[1])(@listdelete(args, 1));",
            "if (typeof(retval) == OBJ)",
            "$login:delete_name_lookup(player);",
            "switch_player(player, retval);",
            "return;",
            "else",
            "return retval;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "server_started",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (!callers())",
            "$server[\"last_restart_time\"] = time();",
            "$network:server_started();",
            "$login:server_started();",
            "endif"
          ]
        },
        {
          "name": "core_object_info core_objects",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "set_task_perms($no_one);",
            "{?core_variant = \"Imnotsurewhatthisshouldbeyetdontdependonthis\", ?in_mcd = 0} = args;",
            "if (in_mcd)",
            "{vb, perms, loc} = callers()[1][2..4];",
            "if (((vb != \"make-core-database\") || (!perms.wizard)) || (loc != $wiz))",
            "raise(E_PERM);",
            "endif",
            "endif",
            "core_objects = {};",
            "proxy_original = proxy_incore = core_properties = skipped_parents = namespaces = {};",
            "todo = {{#0, {\"sysobj\", \"owner\"}}};",
            "\"...lucky for us #0 has a self-referential property\";",
            "while ({?sfc, @todo} = todo)",
            "{o, ?props_to_follow = {}} = sfc;",
            "o_props = {};",
            "for p in (props_to_follow)",
            "v = o.(p);",
            "\"...namespaces should be maps with only object values.\";",
            "if (typeof(v) == MAP)",
            "map_values = mapvalues(v);",
            "for x in (map_values)",
            "if (typeof(x) != OBJ)",
            "continue p;",
            "endif",
            "endfor",
            "namespaces = {@namespaces, {o, p, v}};",
            "core_objects = {@core_objects, @map_values};",
            "else",
            "for v in ((typeof(o.(p)) == MAP) ? mapvalues(o.(p)) | {o.(p)})",
            "if ((typeof(v) != OBJ) || (!valid(v)))",
            "continue p;",
            "endif",
            "o_props = {@o_props, p};",
            "if ((v in proxy_original) || (v in core_objects))",
            "\"...we have been here before...\";",
            "continue p;",
            "endif",
            "if ($object_utils:has_callable_verb(v, \"proxy_for_core\"))",
            "\"...proxy_for_core() returns an object to\";",
            "\"...take the place of v in the final core.\";",
            "\"...For * verbs, proxy_for_core will also accept {}\";",
            "proxy_original[1..0] = {v};",
            "try",
            "vnew = v:proxy_for_core(core_variant, in_mcd);",
            "if ((typeof(vnew) in {OBJ, LIST}) == 0)",
            "raise(E_TYPE, \"returned non-object, non-empty list\");",
            "elseif ((vnew in proxy_original) > 1)",
            "raise(E_RECMOVE, \"proxy loop\");",
            "endif",
            "except e (ANY)",
            "player:notify(tostr(\"Error from \", v, \":proxy_for_core => \", e[2]));",
            "player:notify(toliteral(e[4]));",
            "vnew = #-1;",
            "endtry",
            "if ((vnew == v) || (typeof(vnew) == LIST))",
            "proxy_original[1..1] = {};",
            "else",
            "proxy_incore[1..0] = {vnew};",
            "if ((vnew in core_objects) || (!valid(vnew)))",
            "continue p;",
            "endif",
            "v = vnew;",
            "endif",
            "endif",
            "if ($object_utils:has_callable_verb(v, \"include_for_core\"))",
            "\"...include_for_core() returns a list of properties on v\";",
            "\"...to be searched for additional core objects.\";",
            "try",
            "v_props = v:include_for_core(core_variant);",
            "if (typeof(v_props) != LIST)",
            "raise(E_TYPE, \"returned non-list\");",
            "endif",
            "if (v_props)",
            "todo = {@todo, {v, v_props}};",
            "endif",
            "except e (ANY)",
            "player:notify(tostr(\"Error from \", v, \":include_for_core => \", e[2]));",
            "player:notify(toliteral(e[4]));",
            "endtry",
            "endif",
            "core_objects = setadd(core_objects, v);",
            "endfor",
            "endif",
            "endfor",
            "core_properties = {@core_properties, {o, o_props}};",
            "endwhile",
            "for o in (core_objects)",
            "p = parent(o);",
            "while (valid(p))",
            "if (!(p in core_objects))",
            "skipped_parents = setadd(skipped_parents, p);",
            "endif",
            "p = parent(p);",
            "endwhile",
            "endfor",
            "if (verb == \"core_object_info\")",
            "\"... what make-core-database needs\";",
            "return {core_objects, core_properties, skipped_parents, proxy_original, proxy_incore, namespaces};",
            "else",
            "\"... what most people care about\";",
            "return core_objects;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "`delete_property(this, \"mail_name_db\") ! E_PROPNF';",
            "`delete_verb(this, \"do_command\") ! E_VERBNF';",
            "$server[\"core_history\"] = {{$network.MOO_name, server_version(), time()}, @$server[\"core_history\"]};",
            "$wiz_utils.shutdown_message = \"\";",
            "$server[\"shutdown_time\"] = 0;",
            "$server_options.dump_interval = 3600;",
            "$wiz_utils.gripe_recipients = {player};",
            "for v in ({\"do_login_command\", \"server_started\"})",
            "c = {};",
            "for i in (verb_code(this, v))",
            "c = {@c, strsub(i, \"$local.login\", \"$login\")};",
            "endfor",
            "set_verb_code(#0, v, c);",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "user_created user_connected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"Copied from The System Object (#0):user_connected by Slartibartfast (#4242) Sun May 21 18:14:16 1995 PDT\";",
            "if (callers())",
            "return;",
            "endif",
            "$mcp:(verb)(@args);",
            "user = args[1];",
            "set_task_perms(user);",
            "try",
            "user.location:confunc(user);",
            "user:confunc();",
            "except id (ANY)",
            "user:tell(\"Confunc failed: \", id[2], \".\");",
            "for tb in (id[4])",
            "user:tell(\"... called from \", tb[4], \":\", tb[2], (tb[4] != tb[1]) ? tostr(\" (this == \", tb[1], \")\") | \"\", \", line \", tb[6]);",
            "endfor",
            "user:tell(\"(End of traceback)\");",
            "endtry"
          ]
        },
        {
          "name": "user_disconnected user_client_disconnected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (callers())",
            "return;",
            "endif",
            "if (args[1] < #0)",
            "\"not logged in user.  probably should do something clever here involving Carrot's no-spam hack.  --yduJ\";",
            "\"...'forget' that we already performed a name lookup on this connection...\";",
            "$login:delete_name_lookup(args[1]);",
            "return;",
            "endif",
            "$mcp:(verb)(@args);",
            "user = args[1];",
            "user.last_disconnect_time = time();",
            "set_task_perms(user);",
            "where = user.location;",
            "`user:disfunc() ! ANY => 0';",
            "if (user.location != where)",
            "`where.location:disfunc(user) ! ANY => 0';",
            "endif",
            "`user.location:disfunc(user) ! ANY => 0';"
          ]
        },
        {
          "name": "bf_chparent chparent",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"chparent(object, new-parent) -- see help on the builtin.\";",
            "who = caller_perms();",
            "{what, papa} = args;",
            "if (typeof(what) != OBJ)",
            "retval = E_TYPE;",
            "elseif (!valid(what))",
            "retval = E_INVARG;",
            "elseif (typeof(papa) != OBJ)",
            "retval = E_TYPE;",
            "elseif ((!valid(papa)) && (papa != #-1))",
            "retval = E_INVIND;",
            "elseif (!$perm_utils:controls(who, what))",
            "retval = E_PERM;",
            "elseif ((is_player(what) && (!$object_utils:isa(papa, $player_class))) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((is_player(what) && (!$object_utils:isa(what, $player_class))) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((children(what) && $object_utils:isa(what, $player_class)) && (!$object_utils:isa(papa, $player_class)))",
            "retval = E_PERM;",
            "elseif ((is_player(what) && (what in $wiz_utils.chparent_restricted)) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((((what.location == $mail_agent) && $object_utils:isa(what, $mail_recipient)) && (!$object_utils:isa(papa, $mail_recipient))) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((!valid(papa)) || ($perm_utils:controls(who, papa) || papa.f))",
            "retval = `chparent(@args) ! ANY';",
            "else",
            "retval = E_PERM;",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "bf_add_verb add_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"add_verb() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_verb exists and is true and caller_perms() are not wizardly.\";",
            "who = caller_perms();",
            "what = args[1];",
            "info = args[2];",
            "if (typeof(what) != OBJ)",
            "retval = E_TYPE;",
            "elseif (!valid(what))",
            "retval = E_INVARG;",
            "elseif ((!$perm_utils:controls(who, what)) && (!what.w))",
            "\"caller_perms() is not allowed to hack on the object in question\";",
            "retval = E_PERM;",
            "elseif (!$perm_utils:controls(who, info[1]))",
            "\"caller_perms() is not permitted to add a verb with the specified owner.\";",
            "retval = E_PERM;",
            "elseif (index(info[2], \"w\") && (!$server_options.permit_writable_verbs))",
            "retval = E_INVARG;",
            "elseif (!$quota_utils:verb_addition_permitted(who))",
            "retval = E_QUOTA;",
            "elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:verb_addition_permitted(what.owner)))",
            "retval = E_QUOTA;",
            "elseif (!who.programmer)",
            "retval = E_PERM;",
            "else",
            "\"we now know that the caller's perms control the object or the object is writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)\";",
            "retval = `add_verb(@args) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "bf_add_property add_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"add_property() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_property exists and is true and caller_perms() are not wizardly.\";",
            "who = caller_perms();",
            "{what, propname, value, info} = args;",
            "if (typeof(what) != OBJ)",
            "retval = E_TYPE;",
            "elseif (!valid(what))",
            "retval = E_INVARG;",
            "elseif ((!$perm_utils:controls(who, what)) && (!what.w))",
            "retval = E_PERM;",
            "elseif (!$perm_utils:controls(who, info[1]))",
            "retval = E_PERM;",
            "elseif (!$quota_utils:property_addition_permitted(who))",
            "retval = E_QUOTA;",
            "elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:property_addition_permitted(what.owner)))",
            "retval = E_QUOTA;",
            "\"elseif (!who.programmer)\";",
            "\"  return E_PERM;     I wanted to do this, but $builder:@newmessage relies upon nonprogs being able to call add_property.  --Nosredna\";",
            "elseif ((propname in {\"object_size\", \"size_quota\", \"queued_task_limit\"}) && (!who.wizard))",
            "retval = E_PERM;",
            "else",
            "\"we now know that the caller's perms control the object (or the object is writable), and that the caller's perms are permitted to control the new property's owner.\";",
            "retval = `add_property(@args) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "bf_recycle recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"recycle(object) -- see help on the builtin. This verb is called by the server when $server_options.protect_recycle exists and is true and caller_perms() are not wizardly.\";",
            "{what} = args;",
            "if (!valid(what))",
            "retval = E_INVARG;",
            "elseif (!$perm_utils:controls(who = caller_perms(), what))",
            "retval = E_PERM;",
            "elseif ((p = `is_player(what) ! E_TYPE => 0') && (!who.wizard))",
            "for p in ($wiz_utils:connected_wizards_unadvertised())",
            "p:tell($string_utils:pronoun_sub(\"%N (%#) is currently trying to destroy %t (%[#t])\", who, what));",
            "endfor",
            "retval = E_PERM;",
            "else",
            "if (p)",
            "$wiz_utils:unset_player(what);",
            "endif",
            "$recycler:kill_all_tasks(what);",
            "retval = `recycle(what) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "user_reconnected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (callers())",
            "return;",
            "endif",
            "$mcp:(verb)(@args);",
            "if ($object_utils:isa(user = args[1], $guest))",
            "\"from $guest:boot\";",
            "oldloc = user.location;",
            "move(user, $nothing);",
            "\"..force enterfunc to be called so that the newbie gets a room description.\";",
            "move(user, user.home);",
            "user:do_reset();",
            "if ($object_utils:isa(oldloc, $room))",
            "oldloc:announce(\"In the distance you hear someone's alarm clock going off.\");",
            "if (oldloc != user.location)",
            "oldloc:announce(user.name, \" wavers and vanishes into insubstantial mist.\");",
            "else",
            "oldloc:announce(user.name, \" undergoes a wrenching personality shift.\");",
            "endif",
            "endif",
            "set_task_perms(user);",
            "`user:confunc() ! ANY';",
            "else",
            "set_task_perms(user);",
            "`user:reconfunc() ! ANY';",
            "endif"
          ]
        },
        {
          "name": "bf_set_verb_info set_verb_info",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"set_verb_info() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_set_verb_info exists and is true and caller_perms() are not wizardly.\";",
            "{o, v, i} = args;",
            "if (typeof(vi = `verb_info(o, v) ! ANY') == ERR)",
            "\"probably verb doesn't exist\";",
            "retval = vi;",
            "elseif (!$perm_utils:controls(cp = caller_perms(), vi[1]))",
            "\"perms don't control the current verb owner\";",
            "retval = E_PERM;",
            "elseif ((typeof(i) != LIST) || (typeof(no = i[1]) != OBJ))",
            "\"info is malformed\";",
            "retval = E_TYPE;",
            "elseif ((!valid(no)) || (!is_player(no)))",
            "\"invalid new verb owner\";",
            "retval = E_INVARG;",
            "elseif (!$perm_utils:controls(cp, no))",
            "\"perms don't control prospective verb owner\";",
            "retval = E_PERM;",
            "elseif (index(i[2], \"w\") && (!`$server_options.permit_writable_verbs ! E_PROPNF, E_INVIND => 1'))",
            "retval = E_INVARG;",
            "else",
            "retval = `set_verb_info(o, v, i) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "bf_match match",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "m = `match(@args) ! ANY';",
            "return ((typeof(m) == ERR) && $code_utils:dflag_on()) ? raise(m) | m;"
          ]
        },
        {
          "name": "bf_rmatch rmatch",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "r = `rmatch(@args) ! ANY';",
            "return ((typeof(r) == ERR) && $code_utils:dflag_on()) ? raise(r) | r;"
          ]
        },
        {
          "name": "checkpoint_finished",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "callers() && raise(E_PERM);",
            "$login.checkpoint_in_progress = 0;",
            "`$local.checkpoint_notification:checkpoint_finished(@args) ! ANY';"
          ]
        },
        {
          "name": "do_out_of_band_command doobc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"do_out_of_band_command -- a cheap and very dirty do_out_of_band verb.  Forwards to verb on player with same name if it exists, otherwise forwards to $login.  May only be called by the server in response to an out of band command, otherwise E_PERM is returned.\";",
            "if (((caller == #-1) && (caller_perms() == #-1)) && (callers() == {}))",
            "if (valid(player) && is_player(player))",
            "$mcp:(verb)(@args);",
            "set_task_perms(player);",
            "$object_utils:has_callable_verb(player, \"do_out_of_band_command\") && player:do_out_of_band_command(@args);",
            "elseif ($telnet:(verb)(@args))",
            "return;",
            "else",
            "$login:do_out_of_band_command(@args);",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "handle_uncaught_error",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (!callers())",
            "{code, msg, value, stack, traceback} = args;",
            "if (!$object_utils:connected(player))",
            "\"Mail the player the traceback if e isn't connected.\";",
            "$mail_agent:send_message(#0, player, {\"traceback\", $wiz_utils.gripe_recipients}, traceback);",
            "endif",
            "\"now let the player do something with it if e wants...\";",
            "return `player:(verb)(@args) ! ANY';",
            "endif"
          ]
        },
        {
          "name": "checkpoint_started",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "callers() && raise(E_PERM);",
            "$login.checkpoint_in_progress = 1;",
            "`$local.checkpoint_notification:checkpoint_started(@args) ! ANY';"
          ]
        },
        {
          "name": "bf_force_input",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"Copied from Jay (#3920):bf_force_input Mon Jun 16 20:55:27 1997 PDT\";",
            "\"force_input(conn, line [, at-front])\";",
            "\"see help on the builtin for more information. This verb is called by the server when $server_options.protect_force_input exists and is true and caller_perms() are not wizardly.\";",
            "{conn, line, ?at_front = 0} = args;",
            "if (caller_perms() != conn)",
            "retval = E_PERM;",
            "elseif (conn in $login.newted)",
            "retval = E_PERM;",
            "else",
            "retval = `force_input(@args) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"Let's keep bozos from partying.  --Nosredna the partypooper\";",
            "return pass(#-1);"
          ]
        },
        {
          "name": "bf_set_property_info set_property_info",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "who = caller_perms();",
            "retval = 0;",
            "try",
            "{what, propname, info} = args;",
            "except (E_ARGS)",
            "retval = E_ARGS;",
            "endtry",
            "try",
            "{owner, perms, ?newname = 0} = info;",
            "except (E_ARGS)",
            "retval = E_ARGS;",
            "except (E_TYPE)",
            "retval = E_TYPE;",
            "endtry",
            "if (retval != 0)",
            "elseif ((newname in {\"object_size\", \"size_quota\", \"queued_task_limit\"}) && (!who.wizard))",
            "retval = E_PERM;",
            "else",
            "set_task_perms(who);",
            "retval = `set_property_info(@args) ! ANY';",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        },
        {
          "name": "include_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "return properties(this);"
          ]
        },
        {
          "name": "handle_task_timeout",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "if (!callers())",
            "{resource, stack, traceback} = args;",
            "if (!$object_utils:connected(player))",
            "\"Mail the player the traceback if e isn't connected.\";",
            "$mail_agent:send_message(#0, player, {\"traceback\", $wiz_utils.gripe_recipients}, traceback);",
            "endif",
            "\"now let the player do something with it if e wants...\";",
            "return `player:(verb)(@args) ! ANY';",
            "endif"
          ]
        },
        {
          "name": "bf_read",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "set_task_perms(caller_perms());",
            "`player.reading_input = 1 ! E_PROPNF, E_INVIND';",
            "input = `read(@args) ! ANY';",
            "`clear_property(player, \"reading_input\") ! E_PROPNF, E_INVARG';",
            "return ((typeof(input) == ERR) && $code_utils:dflag_on()) ? raise(input) | input;"
          ]
        },
        {
          "name": "sin",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "{?time = 0, @ann} = args;",
            "return $command_utils:suspend_if_needed(time, @ann);"
          ]
        },
        {
          "name": "s ies es",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "\"A quick and dirty way to pluralize a word based on a number (oftentimes the result of a length() check).\";",
            "\"Usage: $verb(word, amount)\";",
            "\"$s(\\\"credit\\\", 2) => \\\"credits\\\"\";",
            "\"$ies(\\\"battery\\\", 2) => \\\"batteries\\\";\";",
            "\"$es(\\\"watch\\\", 2) => \\\"watches\\\";\";",
            "{word, value} = args;",
            "return (value in {1, 1.0}) ? word | (((verb == \"ies\") ? word[1..$ - 1] | word) + verb);"
          ]
        },
        {
          "name": "bf_chparents chparents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 0,
          "code": [
            "who = caller_perms();",
            "{what, papas, ?anon_kids = {}} = args;",
            "if (typeof(what) != OBJ)",
            "retval = E_TYPE;",
            "elseif (!valid(what))",
            "retval = E_INVARG;",
            "elseif (typeof(papas) != LIST)",
            "retval = E_TYPE;",
            "elseif (!$perm_utils:controls(who, what))",
            "retval = E_PERM;",
            "elseif ((is_player(what) && (!occupants(papas, $player_class))) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((children(what) && $object_utils:isa(what, $player_class)) && (!occupants(papas, $player_class)))",
            "retval = E_PERM;",
            "elseif ((is_player(what) && (what in $wiz_utils.chparent_restricted)) && (!who.wizard))",
            "retval = E_PERM;",
            "elseif ((((what.location == $mail_agent) && $object_utils:isa(what, $mail_recipient)) && (!$object_utils:isa(papa, $mail_recipient))) && (!who.wizard))",
            "retval = E_PERM;",
            "else",
            "for x in (papas)",
            "if ((!$perm_utils:controls(who, x)) && (!x.f))",
            "retval = E_PERM;",
            "break;",
            "endif",
            "endfor",
            "if (`typeof(retval) ! ANY => 0' != ERR)",
            "retval = `chparents(@args) ! ANY';",
            "endif",
            "endif",
            "return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"
          ]
        }
      ],
      "propnames": [
        "builder",
        "login",
        "last_huh",
        "guest_log",
        "biglist",
        "big_mail_recipient",
        "limbo",
        "registration_db",
        "new_player_log",
        "wiz_utils",
        "site_db",
        "math_utils",
        "set_utils",
        "new_prog_log",
        "guest",
        "spell",
        "seq_utils",
        "quota_log",
        "you",
        "hacker",
        "generic_db",
        "no_one",
        "player_db",
        "player_class",
        "gender_utils",
        "trig_utils",
        "time_utils",
        "mail_recipient",
        "mail_agent",
        "mail_editor",
        "note_editor",
        "verb_editor",
        "generic_editor",
        "match_utils",
        "object_utils",
        "lock_utils",
        "letter",
        "list_utils",
        "command_utils",
        "player",
        "wiz",
        "prog",
        "code_utils",
        "help",
        "nothing",
        "failed_match",
        "ambiguous_match",
        "perm_utils",
        "building_utils",
        "string_utils",
        "news",
        "note",
        "container",
        "thing",
        "exit",
        "room",
        "player_start",
        "root_class",
        "recycler",
        "generic_options",
        "maxint",
        "minint",
        "error",
        "newt_log",
        "toad_log",
        "site_log",
        "housekeeper",
        "network",
        "generic_biglist_home",
        "feature",
        "local",
        "generic_utils",
        "quota_utils",
        "paranoid_db",
        "sysobj",
        "byte_quota_utils",
        "object_quota_utils",
        "feature_warehouse",
        "password_verifier",
        "frand_class",
        "mail_recipient_class",
        "stage_talk",
        "pasting_feature",
        "matrix_utils",
        "convert_utils",
        "gendered_object",
        "list_editor",
        "http",
        "ansi_pc",
        "ansi_utils",
        "mcp",
        "waif",
        "anon",
        "server",
        "help_db",
        "generic_help",
        "options",
        "server_options",
        "shapes",
        "proto",
        "str_proto",
        "map_proto",
        "list_proto",
        "int_proto",
        "obj_proto",
        "frobs",
        "edit_utils",
        "edit_state",
        "menu_utils",
        "edit_session",
        "telnet"
      ],
      "propdefs": [
        {
          "value": 4,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 10,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 11,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 12,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 13,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 14,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 15,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 16,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 17,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 24,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 25,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 26,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 27,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 29,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 31,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 32,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 33,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 34,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 35,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 36,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 37,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 38,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 39,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 40,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 41,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 26,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 43,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 45,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 46,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 47,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 48,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 49,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 50,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 51,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 52,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 53,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 54,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 55,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 56,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 6,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 57,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 58,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 59,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 60,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -3,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -2,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 42,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 21,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 20,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 61,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 9,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 8,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 5,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 7,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 3,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 63,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 68,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 9223372036854775807,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -9223372036854775807,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 69,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 70,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 70,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 70,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 71,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 72,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 73,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 74,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 78,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 79,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 80,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 79,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 81,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 83,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 87,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 88,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 40,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 89,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 90,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 91,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 93,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 94,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 95,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 97,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 100,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 99,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 110,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 118,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 122,
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "core_history": [
              [
                "a 2018 LambdaCore",
                "2.6.0",
                1576791887
              ]
            ],
            "last_restart_time": 1671224785,
            "name": "LambdaMOO-ToastStunt",
            "shutdown_time": 0
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "ansi": 101,
            "builder": 84,
            "builtin_function": 28,
            "core": 19,
            "editor": 44,
            "frand": 92,
            "mail": 85,
            "prog": 22,
            "toaststunt": 86,
            "verb": 18,
            "wiz": 23
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": 30,
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "ansi": 102,
            "build": 77,
            "display": 67,
            "edit": 66,
            "mail": 65,
            "prog": 76
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": 82,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 75,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 120,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 119,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 117,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 115,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 114,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 111,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 124,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 125,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 126,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 127,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 64,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "The System Object"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "The known universe.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            37896,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "1": {
      "id": 1,
      "name": "Root Class",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        -1
      ],
      "children": [
        3,
        0,
        5,
        7,
        46,
        45,
        94,
        37,
        15,
        73,
        18,
        12,
        11,
        10,
        68,
        69,
        72,
        78,
        80,
        82,
        30,
        103,
        107,
        109,
        110,
        118,
        32,
        64
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "initialize",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "if ((typeof(this) != ANON) && (typeof(this.owner.owned_objects) == LIST))",
            "this.owner.owned_objects = setadd(this.owner.owned_objects, this);",
            "endif",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "if (is_clear_property(this, \"object_size\"))",
            "\"If this isn't clear, then we're being hacked.\";",
            "this.object_size = {0, 0};",
            "endif",
            "this.key = 0;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "try",
            "if ((typeof(this.owner.owned_objects) == LIST) && (!is_clear_property(this.owner, \"owned_objects\")))",
            "this.owner.owned_objects = setremove(this.owner.owned_objects, this);",
            "$recycler.lost_souls = setadd($recycler.lost_souls, this);",
            "endif",
            "except (ANY)",
            "\"Oy, doesn't have a .owned_objects??, or maybe .owner is $nothing\";",
            "\"Should probably do something...like send mail somewhere.\";",
            "endtry",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"set_name(newname) attempts to change this.name to newname\";",
            "\"  => E_PERM   if you don't own this or aren't its parent, or are a player trying to do an end-run around $player_db...\";",
            "if ((!caller_perms().wizard) && (`is_player(this) ! ANY => 0' || ((caller_perms() != this.owner) && (this != caller))))",
            "return E_PERM;",
            "else",
            "return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;",
            "endif"
          ]
        },
        {
          "name": "title",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return this.name;"
          ]
        },
        {
          "name": "titlec",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return `this.namec ! E_PROPNF => $string_utils:capitalize(this:title())';"
          ]
        },
        {
          "name": "set_aliases",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"set_aliases(alias_list) attempts to change this.aliases to alias_list\";",
            "\"  => E_PERM   if you don't own this or aren't its parent\";",
            "\"  => E_TYPE   if alias_list is not a list\";",
            "\"  => E_INVARG if any element of alias_list is not a string\";",
            "\"  => 1        if aliases are set exactly as expected (default)\";",
            "\"  => 0        if aliases were set differently than expected\";",
            "\"              (children with custom :set_aliases should be aware of this)\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "elseif (typeof(aliases = args[1]) != LIST)",
            "return E_TYPE;",
            "else",
            "for s in (aliases)",
            "if (typeof(s) != STR)",
            "return E_INVARG;",
            "endif",
            "endfor",
            "this.aliases = aliases;",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "match",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "c = this:contents();",
            "return $string_utils:match(args[1], c, \"name\", c, \"aliases\");"
          ]
        },
        {
          "name": "match_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\":match_object(string [,who])\";",
            "args[2..1] = {this};",
            "return $string_utils:match_object(@args);"
          ]
        },
        {
          "name": "set_description",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"set_description(newdesc) attempts to change this.description to newdesc\";",
            "\"  => E_PERM   if you don't own this or aren't its parent\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "elseif (typeof(desc = args[1]) in {LIST, STR})",
            "this.description = desc;",
            "return 1;",
            "else",
            "return E_TYPE;",
            "endif"
          ]
        },
        {
          "name": "description",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return this.description;"
          ]
        },
        {
          "name": "look_self",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "desc = this:description();",
            "if (desc)",
            "player:tell_lines(desc);",
            "else",
            "player:tell(\"You see nothing special.\");",
            "endif"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "if (is_player(this))",
            "notify(this, @args);",
            "endif"
          ]
        },
        {
          "name": "tell",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "this:notify(tostr(@args));"
          ]
        },
        {
          "name": "tell_lines",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "lines = args[1];",
            "if (typeof(lines) == LIST)",
            "for line in (lines)",
            "this:tell(line);",
            "endfor",
            "else",
            "this:tell(lines);",
            "endif"
          ]
        },
        {
          "name": "accept",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "set_task_perms(caller_perms());",
            "return this:acceptable(@args);"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "set_task_perms(this.owner);",
            "return `move(this, args[1]) ! ANY';"
          ]
        },
        {
          "name": "eject eject_nice eject_basic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"eject(victim) --- usable by the owner of this to remove victim from this.contents.  victim goes to its home if different from here, or $nothing or $player_start according as victim is a player.\";",
            "\"eject_basic(victim) --- victim goes to $nothing or $player_start according as victim is a player; victim:moveto is not called.\";",
            "what = args[1];",
            "nice = verb != \"eject_basic\";",
            "perms = caller_perms();",
            "if ((!perms.wizard) && (perms != this.owner))",
            "raise(E_PERM);",
            "elseif ((!(what in this.contents)) || what.wizard)",
            "return 0;",
            "endif",
            "if ((((nice && $object_utils:has_property(what, \"home\")) && (typeof(where = what.home) == OBJ)) && (where != this)) && (is_player(what) ? `where:accept_for_abode(what) ! ANY' | `where:acceptable(what) ! ANY'))",
            "else",
            "where = is_player(what) ? $player_start | $nothing;",
            "endif",
            "fork (0)",
            "if (what.location == this)",
            "\"It didn't move when we asked it to, or :moveto is broken. Force it.\";",
            "move(what, where);",
            "endif",
            "endfork",
            "return nice ? `what:moveto(where) ! ANY' | `move(what, where) ! ANY';"
          ]
        },
        {
          "name": "is_unlocked_for",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return (this.key == 0) || $lock_utils:eval_key(this.key, args[1]);"
          ]
        },
        {
          "name": "huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "set_task_perms((caller_perms() != #-1) ? caller_perms() | player);",
            "$command_utils:do_huh(verb, args);"
          ]
        },
        {
          "name": "set_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\":set_message(msg_name,new_value)\";",
            "\"Does the actual dirty work of @<msg_name> object is <new_value>\";",
            "\"changing the raw value of the message msg_name to be new_value.\";",
            "\"Both msg_name and new_value should be strings, though their interpretation is up to the object itself.\";",
            "\" => error value (use E_PROPNF if msg_name isn't recognized)\";",
            "\" => string error message if something else goes wrong.\";",
            "\" => 1 (true non-string) if the message is successfully set\";",
            "\" => 0 (false non-error) if the message is successfully `cleared'\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "else",
            "return `this.(args[1] + \"_msg\") = args[2] ! ANY' && 1;",
            "endif"
          ]
        },
        {
          "name": "do_examine",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"do_examine(examiner)\";",
            "\"the guts of examine\";",
            "\"call a series of verbs and report their return values to the player\";",
            "who = args[1];",
            "if (caller == who)",
            "who:notify_lines(this:examine_names(who) || {});",
            "who:notify_lines(this:examine_owner(who) || {});",
            "who:notify_lines(this:examine_desc(who) || {});",
            "who:notify_lines(this:examine_key(who) || {});",
            "who:notify_lines(this:examine_contents(who) || {});",
            "who:notify_lines(this:examine_verbs(who) || {});",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "examine_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_key(examiner)\";",
            "\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";",
            "\"the default will only tell the key to a wizard or this object's owner.\";",
            "who = args[1];",
            "if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))",
            "return {tostr(\"Key:  \", $lock_utils:unparse_key(this.key))};",
            "endif"
          ]
        },
        {
          "name": "examine_names",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_names(examiner)\";",
            "\"Return a list of strings to be told to the player, indicating the name and aliases (and, by default, the object number) of this.\";",
            "return {tostr(this.name, \" (aka \", $string_utils:english_list({tostr(this), @this.aliases}), \")\")};"
          ]
        },
        {
          "name": "examine_desc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_desc(who) - return the description, probably\";",
            "\"who is the player examining\";",
            "\"this should probably go away\";",
            "desc = this:description();",
            "if (desc)",
            "if (typeof(desc) != LIST)",
            "desc = {desc};",
            "endif",
            "return desc;",
            "else",
            "return {\"(No description set.)\"};",
            "endif"
          ]
        },
        {
          "name": "examine_contents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_contents(examiner)\";",
            "\"by default, calls :tell_contents.\";",
            "\"Should probably go away.\";",
            "who = args[1];",
            "if (caller == this)",
            "try",
            "this:tell_contents(this.contents, this.ctype);",
            "except (ANY)",
            "\"Just ignore it. We shouldn't care about the contents unless the object wants to tell us about them via :tell_contents ($container, $room)\";",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "examine_verbs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"Return a list of strings to be told to the player.  Standard format says \\\"Obvious verbs:\\\" followed by a series of lines explaining syntax for each usable verb.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "who = args[1];",
            "name = dobjstr;",
            "vrbs = {};",
            "commands_ok = `this:examine_commands_ok(who) ! ANY => 0';",
            "dull_classes = {$root_class, $room, $player, $prog, $builder};",
            "what = this;",
            "hidden_verbs = this:hidden_verbs(who);",
            "while (what != $nothing)",
            "$command_utils:suspend_if_needed(0);",
            "if (!(what in dull_classes))",
            "for i in [1..length(verbs(what))]",
            "$command_utils:suspend_if_needed(0);",
            "info = verb_info(what, i);",
            "syntax = verb_args(what, i);",
            "if (this:examine_verb_ok(what, i, info, syntax, commands_ok, hidden_verbs))",
            "{dobj, prep, iobj} = syntax;",
            "if (syntax == {\"any\", \"any\", \"any\"})",
            "prep = \"none\";",
            "endif",
            "if (prep != \"none\")",
            "for x in ($string_utils:explode(prep, \"/\"))",
            "if (length(x) <= length(prep))",
            "prep = x;",
            "endif",
            "endfor",
            "endif",
            "\"This is the correct way to handle verbs ending in *\";",
            "vname = info[3];",
            "while (j = index(vname, \"* \"))",
            "vname = tostr(vname[1..j - 1], \"<anything>\", vname[j + 1..$]);",
            "endwhile",
            "if (vname[$] == \"*\")",
            "vname = vname[1..$ - 1] + \"<anything>\";",
            "endif",
            "vname = strsub(vname, \" \", \"/\");",
            "rest = \"\";",
            "if (prep != \"none\")",
            "rest = \" \" + ((prep == \"any\") ? \"<anything>\" | prep);",
            "if (iobj != \"none\")",
            "rest = tostr(rest, \" \", (iobj == \"this\") ? name | \"<anything>\");",
            "endif",
            "endif",
            "if (dobj != \"none\")",
            "rest = tostr(\" \", (dobj == \"this\") ? name | \"<anything>\", rest);",
            "endif",
            "vrbs = setadd(vrbs, (\"  \" + vname) + rest);",
            "endif",
            "endfor",
            "endif",
            "what = parent(what);",
            "endwhile",
            "if ($code_utils:verb_or_property(this, \"help_msg\"))",
            "vrbs = {@vrbs, tostr(\"  help \", dobjstr)};",
            "endif",
            "return vrbs && {\"Obvious verbs:\", @vrbs};"
          ]
        },
        {
          "name": "get_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\":get_message(msg_name)\";",
            "\"Use this to obtain a given user-customizable message's raw value, i.e., the value prior to any pronoun-substitution or incorporation of any variant elements --- the value one needs to supply to :set_message().\";",
            "\"=> error (use E_PROPNF if msg_name isn't recognized)\";",
            "\"=> string or list-of-strings raw value\";",
            "\"=> {2, @(list of {msg_name_n,rawvalue_n} pairs to give to :set_message)}\";",
            "\"=> {1, other kind of raw value}\";",
            "\"=> {E_NONE, error message} \";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (((t = typeof(msg = `this.(args[1] + \"_msg\") ! ANY')) in {ERR, STR}) || (((t == LIST) && msg) && (typeof(msg[1]) == STR)))",
            "return msg;",
            "else",
            "return {1, msg};",
            "endif"
          ]
        },
        {
          "name": "room_announce*_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "try",
            "this.location:(verb)(@args);",
            "except (ANY)",
            "endtry"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "if (caller_perms().wizard)",
            "deletes = {};",
            "for vnum in [1..length(verbs(this))]",
            "$command_utils:suspend_if_needed(0);",
            "for name in ($string_utils:explode(verb_info(this, vnum)[3]))",
            "if (rindex(name, \"(old)\") == max(1, length(name) - 4))",
            "deletes[1..0] = {vnum};",
            "break;",
            "elseif (rindex(name, \"(core)\") == max(1, length(name) - 5))",
            "deletes[1..0] = {vnum};",
            "set_verb_code(this, name[1..$ - 6], verb_code(this, vnum));",
            "break;",
            "endif",
            "endfor",
            "endfor",
            "for vnum in (deletes)",
            "delete_verb(this, vnum);",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "contents",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"Returns a list of the objects that are apparently inside this one.  Don't confuse this with .contents, which is a property kept consistent with .location by the server.  This verb should be used in `VR' situations, for instance when looking in a room, and does not necessarily have anything to do with the value of .contents (although the default implementation does).  `Non-VR' commands (like @contents) should look directly at .contents.\";",
            "return this.contents;"
          ]
        },
        {
          "name": "examine_verb_ok",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_verb_ok(loc, index, info, syntax, commands_ok, hidden_verbs)\";",
            "\"loc is the object that defines the verb; index is which verb on the object; info is verb_info; syntax is verb_args; commands_ok is determined by this:commands_ok, probably, but passed in so we don't have to calculate it for each verb.\";",
            "\"hidden_verbs is passed in for the same reasons.  It should be a list, each of whose entries is either a string with the full verb name to be hidden (e.g., \\\"d*rop th*row\\\") or a list of the form {verb location, full verb name, args}.\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "{loc, index, info, syntax, commands_ok, hidden_verbs} = args;",
            "vname = info[3];",
            "return (((((syntax[2..3] != {\"none\", \"this\"}) && (!index(vname, \"(\"))) && (commands_ok || (\"this\" in syntax))) && `verb_code(loc, index) ! ANY') && (!(vname in hidden_verbs))) && (!({loc, vname, syntax} in hidden_verbs));",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "is_listening",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"return 1 if the object can hear a :tell, or cares. Useful for active objects that want to stop when nothing is listening.\";",
            "return 0;"
          ]
        },
        {
          "name": "hidden_verbs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"hidden_verbs(who)\";",
            "\"returns a list of verbs on this that should be hidden from examine\";",
            "\"the player who's examining is passed in, so objects can hide verbs from specific players\";",
            "\"verbs are returned as {location, full_verb_name, args} or just full_verb_name.  full_verb name is what shows up in verb_info(object, verb)[2], for example \\\"d*op th*row\\\".\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "hidden = {};",
            "what = this;",
            "while (what != $nothing)",
            "for i in [1..length(verbs(what))]",
            "info = verb_info(what, i);",
            "if (!index(info[2], \"r\"))",
            "hidden = setadd(hidden, {what, info[3], verb_args(what, i)});",
            "endif",
            "endfor",
            "what = parent(what);",
            "endwhile",
            "return hidden;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "examine_owner",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "\"examine_owner(examiner)\";",
            "\"Return a list of strings to be told to the player, indicating who owns this.\";",
            "return {tostr(\"Owned by \", this.owner.name, \".\")};"
          ]
        },
        {
          "name": "announce*_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return;"
          ]
        },
        {
          "name": "tell_lines_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "lines = args[1];",
            "if (typeof(lines) == LIST)",
            "for line in (lines)",
            "this:tell(line);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "else",
            "this:tell(lines);",
            "endif"
          ]
        },
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 1,
          "code": [
            "return 0;",
            "\"intended as a 'quiet' way to determine if :accept will succeed. Currently, some objects have a noisy :accept verb since it is the only thing that a builtin move() call is guaranteed to call.\";",
            "\"if you want to tell, before trying, whether :accept will fail, use :acceptable instead. Normally, they'll do the same thing.\";"
          ]
        }
      ],
      "propnames": [
        "key",
        "aliases",
        "description",
        "object_size"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            32226,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "2": {
      "id": 2,
      "name": "Wizard",
      "flags": 7,
      "owner": 2,
      "location": 15,
      "parents": [
        57
      ],
      "children": [],
      "last_move": {
        "source": 62,
        "time": 1671224834
      },
      "contents": [],
      "verbs": [],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": 1671224834,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            15,
            17,
            20,
            21,
            24,
            29,
            34,
            40,
            42,
            52,
            53,
            54,
            56,
            57,
            58,
            64,
            70,
            72,
            75,
            78,
            82,
            87,
            94,
            97,
            111,
            114,
            115,
            117,
            118,
            119,
            120,
            122,
            124,
            125,
            126,
            127
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 100,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Wizard"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "3": {
      "id": 3,
      "name": "generic room",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        50,
        62
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))",
            "\"Need the first check because guests don't control themselves\";",
            "this:look_self(player.brief);",
            "this:announce($string_utils:pronoun_sub(\"%N %<has> connected.\", player));",
            "endif"
          ]
        },
        {
          "name": "disfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))",
            "this:announce($string_utils:pronoun_sub(\"%N %<has> disconnected.\", player));",
            "\"need the first check since guests don't control themselves\";",
            "if (!$object_utils:isa(player, $guest))",
            "\"guest disfuncs are handled by $guest:disfunc. Don't add them here\";",
            "$housekeeper:move_players_home(player);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "say",
          "owner": 2,
          "perms": 85,
          "preps": -2,
          "object": 3,
          "code": [
            "try",
            "player:tell(\"You say, \\\"\", argstr, \"\\\"\");",
            "this:announce(player.name, \" \", $gender_utils:get_conj(\"says\", player), \", \\\"\", argstr, \"\\\"\");",
            "except (ANY)",
            "\"Don't really need to do anything but ignore the idiot who has a bad :tell\";",
            "endtry"
          ]
        },
        {
          "name": "emote",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 3,
          "code": [
            "if ((argstr != \"\") && (argstr[1] == \":\"))",
            "this:announce_all(player.name, argstr[2..length(argstr)]);",
            "else",
            "this:announce_all(player.name, \" \", argstr);",
            "endif"
          ]
        },
        {
          "name": "announce",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "for dude in (setremove(this:contents(), player))",
            "try",
            "dude:tell(@args);",
            "except (ANY)",
            "\"Just skip the dude with the bad :tell\";",
            "continue dude;",
            "endtry",
            "endfor"
          ]
        },
        {
          "name": "match_exit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "what = args[1];",
            "if (what)",
            "yes = $failed_match;",
            "for e in (this.exits)",
            "if (valid(e) && (what in {e.name, @e.aliases}))",
            "if (yes == $failed_match)",
            "yes = e;",
            "elseif (yes != e)",
            "return $ambiguous_match;",
            "endif",
            "endif",
            "endfor",
            "return yes;",
            "else",
            "return $nothing;",
            "endif"
          ]
        },
        {
          "name": "add_exit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(caller_perms());",
            "return `this.exits = setadd(this.exits, args[1]) ! E_PERM' != E_PERM;"
          ]
        },
        {
          "name": "tell_contents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "{contents, ctype} = args;",
            "if ((!this.dark) && (contents != {}))",
            "if (ctype == 0)",
            "player:tell(\"Contents:\");",
            "for thing in (contents)",
            "player:tell(\"  \", thing:title());",
            "endfor",
            "elseif (ctype == 1)",
            "for thing in (contents)",
            "if (is_player(thing))",
            "player:tell($string_utils:pronoun_sub(tostr(\"%N \", $gender_utils:get_conj(\"is\", thing), \" here.\"), thing));",
            "else",
            "player:tell(\"You see \", thing:title(), \" here.\");",
            "endif",
            "endfor",
            "elseif (ctype == 2)",
            "player:tell(\"You see \", $string_utils:title_list(contents), \" here.\");",
            "elseif (ctype == 3)",
            "players = things = {};",
            "for x in (contents)",
            "if (is_player(x))",
            "players = {@players, x};",
            "else",
            "things = {@things, x};",
            "endif",
            "endfor",
            "if (things)",
            "player:tell(\"You see \", $string_utils:title_list(things), \" here.\");",
            "endif",
            "if (players)",
            "player:tell($string_utils:title_listc(players), (length(players) == 1) ? \" \" + $gender_utils:get_conj(\"is\", players[1]) | \" are\", \" here.\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@exits",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 3,
          "code": [
            "if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))",
            "player:tell(\"Sorry, only the owner of a room may list its exits.\");",
            "elseif (this.exits == {})",
            "player:tell(\"This room has no conventional exits.\");",
            "else",
            "try",
            "for exit in (this.exits)",
            "try",
            "player:tell(exit.name, \" (\", exit, \") leads to \", valid(exit.dest) ? exit.dest.name | \"???\", \" (\", exit.dest, \") via {\", $string_utils:from_list(exit.aliases, \", \"), \"}.\");",
            "except (ANY)",
            "player:tell(\"Bad exit or missing .dest property:  \", $string_utils:nn(exit));",
            "continue exit;",
            "endtry",
            "endfor",
            "except (E_TYPE)",
            "player:tell(\"Bad .exits property. This should be a list of exit objects. Please fix this.\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "look_self",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "{?brief = 0} = args;",
            "player:tell(this:title());",
            "if (!brief)",
            "pass();",
            "endif",
            "this:tell_contents(setremove(this:contents(), player), this.ctype);"
          ]
        },
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "what = args[1];",
            "return this:is_unlocked_for(what) && (((this:free_entry(@args) || ((what == this.blessed_object) && (task_id() == this.blessed_task))) || (what.owner == this.owner)) || ((typeof(this.residents) == LIST) && ((what in this.residents) || (what.owner in this.residents))));"
          ]
        },
        {
          "name": "add_entrance",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(caller_perms());",
            "return `this.entrances = setadd(this.entrances, args[1]) ! E_PERM' != E_PERM;"
          ]
        },
        {
          "name": "bless_for_entry",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if (caller in {@this.entrances, this})",
            "this.blessed_object = args[1];",
            "this.blessed_task = task_id();",
            "endif"
          ]
        },
        {
          "name": "@entrances",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 3,
          "code": [
            "if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))",
            "player:tell(\"Sorry, only the owner of a room may list its entrances.\");",
            "elseif (this.entrances == {})",
            "player:tell(\"This room has no conventional entrances.\");",
            "else",
            "try",
            "for exit in (this.entrances)",
            "try",
            "player:tell(exit.name, \" (\", exit, \") comes from \", valid(exit.source) ? exit.source.name | \"???\", \" (\", exit.source, \") via {\", $string_utils:from_list(exit.aliases, \", \"), \"}.\");",
            "except (ANY)",
            "player:tell(\"Bad entrance object or missing .source property: \", $string_utils:nn(exit));",
            "continue exit;",
            "endtry",
            "endfor",
            "except (E_TYPE)",
            "player:tell(\"Bad .entrances property. This should be a list of exit objects. Please fix this.\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "go",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 3,
          "code": [
            "if ((!args) || (!(dir = args[1])))",
            "player:tell(\"You need to specify a direction.\");",
            "return E_INVARG;",
            "elseif (valid(exit = player.location:match_exit(dir)))",
            "exit:invoke();",
            "if (length(args) > 1)",
            "old_room = player.location;",
            "\"Now give objects in the room we just entered a chance to act.\";",
            "suspend(0);",
            "if (player.location == old_room)",
            "\"player didn't move or get moved while we were suspended\";",
            "player.location:go(@listdelete(args, 1));",
            "endif",
            "endif",
            "elseif (exit == $failed_match)",
            "player:tell(\"You can't go that way (\", dir, \").\");",
            "else",
            "player:tell(\"I don't know which direction `\", dir, \"' you mean.\");",
            "endif"
          ]
        },
        {
          "name": "l*ook",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 3,
          "code": [
            "if ((dobjstr == \"\") && (!prepstr))",
            "this:look_self();",
            "elseif ((prepstr != \"in\") && (prepstr != \"on\"))",
            "if ((!dobjstr) && (prepstr == \"at\"))",
            "dobjstr = iobjstr;",
            "iobjstr = \"\";",
            "else",
            "dobjstr = dobjstr + (prepstr && ((dobjstr && \" \") + prepstr));",
            "dobjstr = dobjstr + (iobjstr && ((dobjstr && \" \") + iobjstr));",
            "endif",
            "dobj = this:match_object(dobjstr);",
            "if (!$command_utils:object_match_failed(dobj, dobjstr))",
            "dobj:look_self();",
            "endif",
            "elseif (!iobjstr)",
            "player:tell(verb, \" \", prepstr, \" what?\");",
            "else",
            "iobj = this:match_object(iobjstr);",
            "if (!$command_utils:object_match_failed(iobj, iobjstr))",
            "if (dobjstr == \"\")",
            "iobj:look_self();",
            "elseif ((thing = iobj:match(dobjstr)) == $failed_match)",
            "player:tell(\"I don't see any \\\"\", dobjstr, \"\\\" \", prepstr, \" \", iobj.name, \".\");",
            "elseif (thing == $ambiguous_match)",
            "player:tell(\"There are several things \", prepstr, \" \", iobj.name, \" one might call \\\"\", dobjstr, \"\\\".\");",
            "else",
            "thing:look_self();",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "announce_all",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "for dude in (this:contents())",
            "try",
            "dude:tell(@args);",
            "except (ANY)",
            "\"Just ignore the dude with the stupid :tell\";",
            "continue dude;",
            "endtry",
            "endfor"
          ]
        },
        {
          "name": "announce_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\":announce_all_but(LIST objects to ignore, text)\";",
            "{ignore, @text} = args;",
            "contents = this:contents();",
            "for l in (ignore)",
            "contents = setremove(contents, l);",
            "endfor",
            "for listener in (contents)",
            "try",
            "listener:tell(@text);",
            "except (ANY)",
            "\"Ignure listener with bad :tell\";",
            "continue listener;",
            "endtry",
            "endfor"
          ]
        },
        {
          "name": "enterfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "object = args[1];",
            "if (is_player(object) && (object.location == this))",
            "player = object;",
            "this:look_self(player.brief);",
            "endif",
            "if (object == this.blessed_object)",
            "this.blessed_object = #-1;",
            "endif"
          ]
        },
        {
          "name": "exitfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return;"
          ]
        },
        {
          "name": "remove_exit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "exit = args[1];",
            "if (caller != exit)",
            "set_task_perms(caller_perms());",
            "endif",
            "return `this.exits = setremove(this.exits, exit) ! E_PERM' != E_PERM;"
          ]
        },
        {
          "name": "remove_entrance",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "exit = args[1];",
            "if (caller != exit)",
            "set_task_perms(caller_perms());",
            "endif",
            "return `this.entrances = setremove(this.entrances, exit) ! E_PERM' != E_PERM;"
          ]
        },
        {
          "name": "@add-exit",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:tell(\"Usage:  @add-exit <exit-number>\");",
            "return;",
            "endif",
            "exit = this:match_object(dobjstr);",
            "if ($command_utils:object_match_failed(exit, dobjstr))",
            "return;",
            "endif",
            "if (!($exit in $object_utils:ancestors(exit)))",
            "player:tell(\"That doesn't look like an exit object to me...\");",
            "return;",
            "endif",
            "try",
            "dest = exit.dest;",
            "except (E_PERM)",
            "player:tell(\"You can't read the exit's destination to check that it's consistent!\");",
            "return;",
            "endtry",
            "try",
            "source = exit.source;",
            "except (E_PERM)",
            "player:tell(\"You can't read that exit's source to check that it's consistent!\");",
            "return;",
            "endtry",
            "if (source == $nothing)",
            "player:tell(\"That exit's source has not yet been set; set it to be this room, then run @add-exit again.\");",
            "return;",
            "elseif (source != this)",
            "player:tell(\"That exit wasn't made to be attached here; it was made as an exit from \", source.name, \" (\", source, \").\");",
            "return;",
            "elseif (((typeof(dest) != OBJ) || (!valid(dest))) || (!($room in $object_utils:ancestors(dest))))",
            "player:tell(\"That exit doesn't lead to a room!\");",
            "return;",
            "endif",
            "if (!this:add_exit(exit))",
            "player:tell(\"Sorry, but you must not have permission to add exits to this room.\");",
            "else",
            "player:tell(\"You have added \", exit, \" as an exit that goes to \", exit.dest.name, \" (\", exit.dest, \") via \", $string_utils:english_list(setadd(exit.aliases, exit.name)), \".\");",
            "endif"
          ]
        },
        {
          "name": "@add-entrance",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:tell(\"Usage:  @add-entrance <exit-number>\");",
            "return;",
            "endif",
            "exit = this:match_object(dobjstr);",
            "if ($command_utils:object_match_failed(exit, dobjstr))",
            "return;",
            "endif",
            "if (!($exit in $object_utils:ancestors(exit)))",
            "player:tell(\"That doesn't look like an exit object to me...\");",
            "return;",
            "endif",
            "try",
            "dest = exit.dest;",
            "except (E_PERM)",
            "player:tell(\"You can't read the exit's destination to check that it's consistent!\");",
            "return;",
            "endtry",
            "if (dest != this)",
            "player:tell(\"That exit doesn't lead here!\");",
            "return;",
            "endif",
            "if (!this:add_entrance(exit))",
            "player:tell(\"Sorry, but you must not have permission to add entrances to this room.\");",
            "else",
            "player:tell(\"You have added \", exit, \" as an entrance that gets here via \", $string_utils:english_list(setadd(exit.aliases, exit.name)), \".\");",
            "endif"
          ]
        },
        {
          "name": "recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\"Make a mild attempt to keep people and objects from ending up in #-1 when people recycle a room\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "\"... first try spilling them out onto the floor of enclosing room if any\";",
            "if (valid(this.location))",
            "for x in (this.contents)",
            "try",
            "x:moveto(this.location);",
            "except (ANY)",
            "continue x;",
            "endtry",
            "endfor",
            "endif",
            "\"... try sending them home...\";",
            "for x in (this.contents)",
            "if (is_player(x))",
            "if ((typeof(x.home) == OBJ) && valid(x.home))",
            "try",
            "x:moveto(x.home);",
            "except (ANY)",
            "continue x;",
            "endtry",
            "endif",
            "if (x.location == this)",
            "move(x, $player_start);",
            "endif",
            "elseif (valid(x.owner))",
            "try",
            "x:moveto(x.owner);",
            "except (ANY)",
            "continue x;",
            "endtry",
            "endif",
            "endfor",
            "pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "e east w west s south n north ne northeast nw northwest se southeast sw southwest u up d down",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms((caller_perms() == #-1) ? player | caller_perms());",
            "exit = this:match_exit(verb);",
            "if (valid(exit))",
            "exit:invoke();",
            "elseif (exit == $failed_match)",
            "player:tell(\"You can't go that way.\");",
            "else",
            "player:tell(\"I don't know which direction `\", verb, \"' you mean.\");",
            "endif"
          ]
        },
        {
          "name": "@eject @eject! @eject!!",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(player);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "elseif (dobj.location != this)",
            "is = $gender_utils:get_conj(\"is\", dobj);",
            "player:tell(dobj.name, \"(\", dobj, \") \", is, \" not here.\");",
            "return;",
            "elseif (!$perm_utils:controls(player, this))",
            "player:tell(\"You are not the owner of this room.\");",
            "return;",
            "elseif (dobj.wizard)",
            "player:tell(\"Sorry, you can't \", verb, \" a wizard.\");",
            "dobj:tell(player.name, \" tried to \", verb, \" you.\");",
            "return;",
            "endif",
            "iobj = this;",
            "player:tell(this:ejection_msg());",
            "this:((verb == \"@eject\") ? \"eject\" | \"eject_basic\")(dobj);",
            "if (verb != \"@eject!!\")",
            "dobj:tell(this:victim_ejection_msg());",
            "endif",
            "this:announce_all_but({player, dobj}, this:oejection_msg());"
          ]
        },
        {
          "name": "ejection_msg oejection_msg victim_ejection_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return $gender_utils:pronoun_sub(this.(verb));"
          ]
        },
        {
          "name": "accept_for_abode",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "who = args[1];",
            "return this:basic_accept_for_abode(who) && this:acceptable(who);"
          ]
        },
        {
          "name": "@resident*s",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "if (!$perm_utils:controls(player, this))",
            "player:tell(\"You must own this room to manipulate the legal residents list.  Try contacting \", this.owner.name, \".\");",
            "else",
            "if (typeof(this.residents) != LIST)",
            "this.residents = {this.residents};",
            "endif",
            "if (!dobjstr)",
            "\"First, remove !valid objects from this room...\";",
            "for x in (this.residents)",
            "if ((typeof(x) != OBJ) || (!$recycler:valid(x)))",
            "player:tell(\"Warning: removing \", x, \", an invalid object, from the residents list.\");",
            "this.residents = setremove(this.residents, x);",
            "endif",
            "endfor",
            "player:tell(\"Allowable residents in this room:  \", $string_utils:english_list($list_utils:map_prop(this.residents, \"name\"), \"no one\"), \".\");",
            "return;",
            "elseif (dobjstr[1] == \"!\")",
            "notflag = 1;",
            "dobjstr = dobjstr[2..$];",
            "else",
            "notflag = 0;",
            "endif",
            "result = $string_utils:match_player_or_object(dobjstr);",
            "if (!result)",
            "return;",
            "else",
            "\"a one element list was returned to us if it won.\";",
            "result = result[1];",
            "if (notflag)",
            "if (!(result in this.residents))",
            "player:tell(result.name, \" doesn't appear to be in the residents list of \", this.name, \".\");",
            "else",
            "this.residents = setremove(this.residents, result);",
            "player:tell(result.name, \" removed from the residents list of \", this.name, \".\");",
            "endif",
            "else",
            "if (result in this.residents)",
            "is = $gender_utils:get_conj(\"is\", result);",
            "player:tell(result.name, \" \", is, \" already an allowed resident of \", this.name, \".\");",
            "else",
            "this.residents = {@this.residents, result};",
            "player:tell(result.name, \" added to the residents list of \", this.name, \".\");",
            "endif",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "match",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "target = {@this:contents(), @this:exits()};",
            "return $string_utils:match(args[1], target, \"name\", target, \"aliases\");"
          ]
        },
        {
          "name": "@remove-exit",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:tell(\"Usage:  @remove-exit <exit>\");",
            "return;",
            "endif",
            "exit = this:match_object(dobjstr);",
            "if (!(exit in this.exits))",
            "if ($command_utils:object_match_failed(exit, dobjstr))",
            "return;",
            "endif",
            "player:tell(\"Couldn't find \\\"\", dobjstr, \"\\\" in the exits list of \", this.name, \".\");",
            "return;",
            "elseif (!this:remove_exit(exit))",
            "player:tell(\"Sorry, but you do not have permission to remove exits from this room.\");",
            "else",
            "name = valid(exit) ? exit.name | \"<recycled>\";",
            "player:tell(\"Exit \", exit, \" (\", name, \") removed from exit list of \", this.name, \" (\", this, \").\");",
            "endif"
          ]
        },
        {
          "name": "@remove-entrance",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 3,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:tell(\"Usage:  @remove-entrance <entrance>\");",
            "return;",
            "endif",
            "entrance = $string_utils:match(dobjstr, this.entrances, \"name\", this.entrances, \"aliases\");",
            "if (!valid(entrance))",
            "\"Try again to parse it.  Maybe they gave object number.  Don't complain if it's invalid though; maybe it's been recycled in some nefarious way.\";",
            "entrance = this:match_object(dobjstr);",
            "endif",
            "if (!(entrance in this.entrances))",
            "player:tell(\"Couldn't find \\\"\", dobjstr, \"\\\" in the entrances list of \", this.name, \".\");",
            "return;",
            "elseif (!this:remove_entrance(entrance))",
            "player:tell(\"Sorry, but you do not have permission to remove entrances from this room.\");",
            "else",
            "name = valid(entrance) ? entrance.name | \"<recycled>\";",
            "player:tell(\"Entrance \", entrance, \" (\", name, \") removed from entrance list of \", this.name, \" (\", this, \").\");",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "who_location_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg, args[1]) | \"\";"
          ]
        },
        {
          "name": "exits entrances",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.(verb);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "obvious_exits obvious_entrances",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "exits = {};",
            "for exit in (`(verb == \"obvious_exits\") ? this.exits | this.entrances ! ANY => {}')",
            "if (`$code_utils:verb_or_property(exit, \"obvious\") ! ANY')",
            "exits = setadd(exits, exit);",
            "endif",
            "endfor",
            "return exits;"
          ]
        },
        {
          "name": "here_huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\":here_huh(verb,args)  -- room-specific :huh processing.  This should return 1 if it finds something interesting to do and 0 otherwise; see $command_utils:do_huh.\";",
            "\"For the generic room, we check for the case of the caller specifying an exit for which a corresponding verb was never defined.\";",
            "set_task_perms(caller_perms());",
            "if (args[2] || ($failed_match == (exit = this:match_exit(verb = args[1]))))",
            "\"... okay, it's not an exit.  we give up...\";",
            "return 0;",
            "elseif (valid(exit))",
            "exit:invoke();",
            "else",
            "\"... ambiguous exit ...\";",
            "player:tell(\"I don't know which direction `\", verb, \"' you mean.\");",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "room_announce*_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "this:(verb[6..$])(@args);"
          ]
        },
        {
          "name": "examine_commands_ok",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return this == args[1].location;"
          ]
        },
        {
          "name": "examine_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\"examine_key(examiner)\";",
            "\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";",
            "\"the default will only tell the key to a wizard or this object's owner.\";",
            "who = args[1];",
            "if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))",
            "return {tostr(this:title(), \" will accept only objects matching the following key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};",
            "endif"
          ]
        },
        {
          "name": "examine_contents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\"examine_contents(who)\";",
            "if (caller == this)",
            "this:tell_contents(this.contents, this.ctype);",
            "endif"
          ]
        },
        {
          "name": "free_entry",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return this.free_entry;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "if (this == $player_start)",
            "\"... If there are ever multiple rooms, then the question of\";",
            "\"....which one is to be $player_start may well be an option of some sort,\";",
            "\"... so this goes better here than hardcoded into some specific room:init_for_core verb.\";",
            "move(player, this);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "dark",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "return this.(verb);"
          ]
        },
        {
          "name": "announce_lines_x",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "\"Copied from generic room (#3):announce by Haakon (#2) Thu Oct 24 16:15:01 1996 PDT\";",
            "for dude in (setremove(this:contents(), player))",
            "try",
            "dude:tell_lines(@args);",
            "except id (ANY)",
            "endtry",
            "endfor"
          ]
        },
        {
          "name": "basic_accept_for_abode",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 3,
          "code": [
            "who = args[1];",
            "return valid(who) && ((this.free_home || $perm_utils:controls(who, this)) || ((typeof(residents = this.residents) == LIST) ? who in this.residents | (who == this.residents)));"
          ]
        }
      ],
      "propnames": [
        "who_location_msg",
        "free_home",
        "victim_ejection_msg",
        "ejection_msg",
        "oejection_msg",
        "residents",
        "free_entry",
        "entrances",
        "blessed_object",
        "blessed_task",
        "exits",
        "dark",
        "ctype"
      ],
      "propdefs": [
        {
          "value": "%T",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You have been expelled from %i by %n.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You expel %d from %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%N unceremoniously %{!expels} %d from %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 3,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic room"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            43072,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "4": {
      "id": 4,
      "name": "generic builder",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        88
      ],
      "children": [
        58,
        96
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@quota",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "if (dobjstr == \"\")",
            "dobj = player;",
            "else",
            "dobj = $string_utils:match_player(dobjstr);",
            "endif",
            "if (!valid(dobj))",
            "player:notify(\"Show whose quota?\");",
            "return;",
            "endif",
            "$quota_utils:display_quota(dobj);",
            "try",
            "if (dobj in $local.informed_quota_consumers.uninformed_quota_consumers)",
            "player:notify(tostr(\"Note that quota is held in escrow -- `look \", $local.informed_quota_consumers, \"' for more details.\"));",
            "endif",
            "except id (ANY)",
            "endtry"
          ]
        },
        {
          "name": "@create",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "nargs = length(args);",
            "pos = \"named\" in args;",
            "if ((pos <= 1) || (pos == nargs))",
            "pos = \"called\" in args;",
            "endif",
            "if ((pos <= 1) || (pos == nargs))",
            "player:notify(\"Usage:  @create <parent-class> named [name:]alias,...,alias\");",
            "player:notify(\"   or:  @create <parent-class> named name-and-alias,alias,...,alias\");",
            "player:notify(\"\");",
            "player:notify(\"where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.\");",
            "player:notify(\"You can use \\\"called\\\" instead of \\\"named\\\", if you wish.\");",
            "return;",
            "endif",
            "parentstr = $string_utils:from_list(args[1..pos - 1], \" \");",
            "namestr = $string_utils:from_list(args[pos + 1..$], \" \");",
            "if (!namestr)",
            "player:notify(\"You must provide a name.\");",
            "return;",
            "endif",
            "if (parentstr[1] == \"$\")",
            "parent = $string_utils:literal_object(parentstr);",
            "if ((parent == $failed_match) || (typeof(parent) != OBJ))",
            "player:notify(tostr(\"\\\"\", parentstr, \"\\\" does not name an object.\"));",
            "return;",
            "endif",
            "else",
            "parent = player:my_match_object(parentstr);",
            "if ($command_utils:object_match_failed(parent, parentstr))",
            "return;",
            "endif",
            "endif",
            "object = player:_create(parent);",
            "if (typeof(object) == ERR)",
            "player:notify(tostr(object));",
            "return;",
            "endif",
            "for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))",
            "object.(f) = 1;",
            "endfor",
            "\"move() shouldn't, but could bomb. Say if player has a stupid :accept\";",
            "`move(object, player) ! ANY';",
            "$building_utils:set_names(object, namestr);",
            "if ((other_names = setremove(object.aliases, object.name)) != {})",
            "aka = (\" (aka \" + $string_utils:english_list(other_names)) + \")\";",
            "else",
            "aka = \"\";",
            "endif",
            "player:notify(tostr(\"You now have \", object.name, aka, \" with object number \", object, \" and parent \", parent.name, \" (\", parent, \").\"));"
          ]
        },
        {
          "name": "@recycle",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "dobj = player:my_match_object(dobjstr);",
            "if (dobj == $nothing)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>\"));",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "\"...bogus object...\";",
            "elseif (player == dobj)",
            "player:notify($wiz_utils.suicide_string);",
            "elseif (!$perm_utils:controls(player, dobj))",
            "player:notify(tostr(E_PERM));",
            "else",
            "name = dobj.name;",
            "result = player:_recycle(dobj);",
            "if (typeof(result) == ERR)",
            "player:notify(tostr(result));",
            "else",
            "player:notify(tostr(name, \" (\", dobj, \") recycled.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@recreate",
          "owner": 2,
          "perms": 89,
          "preps": 13,
          "object": 4,
          "code": [
            "\"@recreate <object> as <parent-class> named [name:]alias,alias,...\";",
            "\"  effectively recycles and creates <object> all over again.\";",
            "set_task_perms(player);",
            "as = prepstr in args;",
            "named = \"named\" in args;",
            "if ((named <= (as + 1)) || (named == length(args)))",
            "named = \"called\" in args;",
            "endif",
            "if ((named <= (as + 1)) || (named == length(args)))",
            "player:notify_lines({tostr(\"Usage:  \", verb, \" <object> as <parent-class> named [name:]alias,...,alias\"), \"\", \"where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.  The [name:]alias... specification is as in @create.\", \"\", \"You can use \\\"called\\\" instead of \\\"named\\\", if you wish.\"});",
            "return;",
            "elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr, 1))",
            "return;",
            "elseif (valid(dobj) && is_player(dobj))",
            "player:notify(\"You really *don't* want to do that!\");",
            "return;",
            "endif",
            "parentstr = $string_utils:from_list(args[as + 1..named - 1], \" \");",
            "namestr = $string_utils:from_list(args[named + 1..$], \" \");",
            "if (parentstr[1] == \"$\")",
            "parent = $string_utils:literal_object(parentstr);",
            "if ((parent == $failed_match) || (typeof(parent) != OBJ))",
            "player:notify(tostr(\"\\\"\", parentstr, \"\\\" does not name an object.\"));",
            "return;",
            "endif",
            "else",
            "parent = player:my_match_object(parentstr);",
            "if ($command_utils:object_match_failed(parent, parentstr))",
            "return;",
            "endif",
            "endif",
            "if (!(e = $building_utils:recreate(dobj, parent)))",
            "player:notify(tostr(e));",
            "return;",
            "endif",
            "for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))",
            "dobj.(f) = 1;",
            "endfor",
            "\"move() shouldn't, but could, bomb. Say if player has a stupid :accept\";",
            "`move(dobj, player) ! ANY';",
            "$building_utils:set_names(dobj, namestr);",
            "if ((other_names = setremove(dobj.aliases, dobj.name)) != {})",
            "aka = (\" (aka \" + $string_utils:english_list(other_names)) + \")\";",
            "else",
            "aka = \"\";",
            "endif",
            "player:notify(tostr(\"Object number \", dobj, \" is now \", dobj.name, aka, \" with parent \", parent.name, \" (\", parent, \").\"));"
          ]
        },
        {
          "name": "@dig",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "nargs = length(args);",
            "if (nargs == 1)",
            "room = args[1];",
            "exit_spec = \"\";",
            "elseif ((nargs >= 3) && (args[2] == \"to\"))",
            "exit_spec = args[1];",
            "room = $string_utils:from_list(args[3..$], \" \");",
            "elseif (argstr && (!prepstr))",
            "room = argstr;",
            "exit_spec = \"\";",
            "else",
            "player:notify(tostr(\"Usage:  \", verb, \" <new-room-name>\"));",
            "player:notify(tostr(\"    or  \", verb, \" <exit-description> to <new-room-name-or-old-room-object-number>\"));",
            "return;",
            "endif",
            "if (room != tostr(other_room = toobj(room)))",
            "room_kind = player:build_option(\"dig_room\");",
            "if (room_kind == 0)",
            "room_kind = $room;",
            "endif",
            "other_room = player:_create(room_kind);",
            "if (typeof(other_room) == ERR)",
            "player:notify(tostr(\"Cannot create new room as a child of \", $string_utils:nn(room_kind), \": \", other_room, \".  See `help @build-options' for information on how to specify the kind of room this command tries to create.\"));",
            "return;",
            "endif",
            "for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))",
            "other_room.(f) = 1;",
            "endfor",
            "other_room.name = room;",
            "other_room.aliases = {room};",
            "move(other_room, $nothing);",
            "player:notify(tostr(other_room.name, \" (\", other_room, \") created.\"));",
            "elseif (nargs == 1)",
            "player:notify(\"You can't dig a room that already exists!\");",
            "return;",
            "elseif ((!valid(player.location)) || (!($room in $object_utils:ancestors(player.location))))",
            "player:notify(tostr(\"You may only use the \", verb, \" command from inside a room.\"));",
            "return;",
            "elseif ((!valid(other_room)) || (!($room in $object_utils:ancestors(other_room))))",
            "player:notify(tostr(other_room, \" doesn't look like a room to me...\"));",
            "return;",
            "endif",
            "if (exit_spec)",
            "exit_kind = player:build_option(\"dig_exit\");",
            "if (exit_kind == 0)",
            "exit_kind = $exit;",
            "endif",
            "exits = $string_utils:explode(exit_spec, \"|\");",
            "if ((length(exits) < 1) || (length(exits) > 2))",
            "player:notify(\"The exit-description must have the form\");",
            "player:notify(\"     [name:]alias,...,alias\");",
            "player:notify(\"or   [name:]alias,...,alias|[name:]alias,...,alias\");",
            "return;",
            "endif",
            "do_recreate = !player:build_option(\"bi_create\");",
            "to_ok = $building_utils:make_exit(exits[1], player.location, other_room, do_recreate, exit_kind);",
            "if (to_ok && (length(exits) == 2))",
            "$building_utils:make_exit(exits[2], other_room, player.location, do_recreate, exit_kind);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@audit",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "\"Usage:  @audit [player] [from <start>] [to <end>] [for <matching string>]\";",
            "set_task_perms(player);",
            "dobj = $string_utils:match_player(dobjstr);",
            "if (!dobjstr)",
            "dobj = player;",
            "elseif ($command_utils:player_match_result(dobj, dobjstr)[1])",
            "return;",
            "endif",
            "dobjwords = $string_utils:words(dobjstr);",
            "if (args[1..length(dobjwords)] == dobjwords)",
            "args = args[length(dobjwords) + 1..$];",
            "endif",
            "if (!(parse_result = $code_utils:_parse_audit_args(@args)))",
            "player:notify(tostr(\"Usage:  \", verb, \" [player] [from <start>] [to <end>] [for <match>]\"));",
            "return;",
            "endif",
            "return $building_utils:do_audit(dobj, @parse_result);"
          ]
        },
        {
          "name": "@count",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "if (!dobjstr)",
            "dobj = player;",
            "elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])",
            "return;",
            "endif",
            "set_task_perms(player);",
            "if (typeof(dobj.owned_objects) == LIST)",
            "count = length(dobj.owned_objects);",
            "player:notify(tostr(dobj.name, \" currently owns \", count, \" object\", (count == 1) ? \".\" | \"s.\"));",
            "if ($quota_utils.byte_based)",
            "player:notify(tostr(\"Total bytes consumed:  \", $string_utils:group_number($quota_utils:get_size_quota(dobj)[2]), \".\"));",
            "endif",
            "else",
            "player:notify(tostr(dobj.name, \" is not enrolled in the object ownership system.  Use @countDB instead.\"));",
            "endif"
          ]
        },
        {
          "name": "@countDB",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "if (!dobjstr)",
            "dobj = player;",
            "elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])",
            "return;",
            "endif",
            "set_task_perms(player);",
            "count = 0;",
            "for o in [#1..max_object()]",
            "if ($command_utils:running_out_of_time())",
            "player:notify(\"Counting...\");",
            "suspend(5);",
            "endif",
            "if (valid(o) && (o.owner == dobj))",
            "count = count + 1;",
            "endif",
            "endfor",
            "player:notify(tostr(dobj.name, \" currently owns \", count, \" object\", (count == 1) ? \".\" | \"s.\"));"
          ]
        },
        {
          "name": "@sort-owned*-objects",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "\"$player:owned_objects -- sorts a players .owned_objects property in ascending\";",
            "\"order so it looks nice on @audit.\";",
            "if (player != this)",
            "return E_PERM;",
            "endif",
            "if (typeof(player.owned_objects) == LIST)",
            "if ((!dobjstr) || (index(\"object\", dobjstr) == 1))",
            "ret = $list_utils:sort_suspended(0, player.owned_objects);",
            "elseif (index(\"size\", dobjstr) == 1)",
            "ret = $list_utils:reverse_suspended($list_utils:sort_suspended(0, player.owned_objects, $list_utils:slice($list_utils:map_prop(player.owned_objects, \"object_size\"))));",
            "endif",
            "if (typeof(ret) == LIST)",
            "player.owned_objects = ret;",
            "player:tell(\"Your .owned_objects list has been sorted.\");",
            "return 1;",
            "else",
            "player:tell(\"Something went wrong. .owned_objects not sorted.\");",
            "return 0;",
            "endif",
            "else",
            "player:tell(\"You are not enrolled in .owned_objects scheme, sorry.\");",
            "endif"
          ]
        },
        {
          "name": "@add-owned",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "if (player != this)",
            "player:tell(\"Permission Denied\");",
            "return E_PERM;",
            "endif",
            "if (!valid(dobj))",
            "player:tell(\"Don't understand `\", dobjstr, \"' as an object to add.\");",
            "elseif (dobj.owner != player)",
            "player:tell(\"You don't own \", dobj.name, \".\");",
            "elseif (dobj in player.owned_objects)",
            "player:tell(dobj.name, \" is already recorded in your .owned_objects.\");",
            "else",
            "player.owned_objects = setadd(player.owned_objects, dobj);",
            "player:tell(\"Added \", dobj, \" to your .owned_objects.\");",
            "endif"
          ]
        },
        {
          "name": "@verify-owned",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 4,
          "code": [
            "for x in (player.owned_objects)",
            "if ((!valid(x)) || (x.owner != player))",
            "player.owned_objects = setremove(player.owned_objects, x);",
            "if (valid(x))",
            "player:tell(\"Removing \", x.name, \"(\", x, \"), owned by \", valid(x.owner) ? x.owner.name | \"<recycled player>\", \" from your .owned_objects property.\");",
            "else",
            "player:tell(\"Removing invalid object \", x, \" from your .owned_objects property.\");",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(2, tostr(\"Suspending @verify-owned ... \", x));",
            "endfor",
            "player:tell(\".owned_objects property verified.\");"
          ]
        },
        {
          "name": "@unlock",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "try",
            "dobj.key = 0;",
            "player:notify(tostr(\"Unlocked \", dobj.name, \".\"));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry"
          ]
        },
        {
          "name": "@lock",
          "owner": 2,
          "perms": 89,
          "preps": 0,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "key = $lock_utils:parse_keyexp(iobjstr, player);",
            "if (typeof(key) == STR)",
            "player:notify(\"That key expression is malformed:\");",
            "player:notify(tostr(\"  \", key));",
            "else",
            "try",
            "dobj.key = key;",
            "player:notify(tostr(\"Locked \", dobj.name, \" to this key:\"));",
            "player:notify(tostr(\"  \", $lock_utils:unparse_key(key)));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "@newmess*age",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "\"Usage:  @newmessage <message-name> [<message>] [on <object>]\";",
            "\"Add a message property to an object (default is player), and optionally\";",
            "\"set its value.  For use by non-programmers, who aren't allowed to add\";",
            "\"properties generally.\";",
            "\"To undo the effects of this, use @unmessage.\";",
            "set_task_perms(player);",
            "dobjwords = $string_utils:words(dobjstr);",
            "if (!dobjwords)",
            "player:notify(tostr(\"Usage:  \", verb, \" <message-name> [<message>] [on <object>]\"));",
            "return;",
            "endif",
            "object = valid(iobj) ? iobj | player;",
            "name = this:_messagify(dobjwords[1]);",
            "value = dobjstr[length(dobjwords[1]) + 2..$];",
            "nickname = \"@\" + name[1..$ - 4];",
            "e = `add_property(object, name, value, {player, \"rc\"}) ! ANY';",
            "if (typeof(e) != ERR)",
            "player:notify(tostr(nickname, \" on \", object.name, \" is now \\\"\", object.(name), \"\\\".\"));",
            "elseif (e != E_INVARG)",
            "player:notify(tostr(e));",
            "elseif ($object_utils:has_property(object, name))",
            "\"object already has property\";",
            "player:notify(tostr(object.name, \" already has a \", nickname, \" message.\"));",
            "else",
            "player:notify(tostr(\"Unable to add \", nickname, \" message to \", object.name, \": \", e));",
            "endif"
          ]
        },
        {
          "name": "@unmess*age",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "\"Usage:  @unmessage <message-name> [from <object>]\";",
            "\"Remove a message property from an object (default is player).\";",
            "set_task_perms(player);",
            "if ((!dobjstr) || (length($string_utils:words(dobjstr)) > 1))",
            "player:notify(tostr(\"Usage:  \", verb, \" <message-name> [from <object>]\"));",
            "return;",
            "endif",
            "object = valid(iobj) ? iobj | player;",
            "name = this:_messagify(dobjstr);",
            "nickname = \"@\" + name[1..$ - 4];",
            "try",
            "delete_property(object, name);",
            "player:notify(tostr(nickname, \" message removed from \", object.name, \".\"));",
            "except (E_PROPNF)",
            "player:notify(tostr(\"No \", nickname, \" message found on \", object.name, \".\"));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry"
          ]
        },
        {
          "name": "_messagify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "\"Given any of several formats people are likely to use for a @message\";",
            "\"property, return the canonical form (\\\"foobar_msg\\\").\";",
            "name = args[1];",
            "if (name[1] == \"@\")",
            "name = name[2..$];",
            "endif",
            "if ((length(name) < 4) || (name[$ - 3..$] != \"_msg\"))",
            "name = name + \"_msg\";",
            "endif",
            "return name;"
          ]
        },
        {
          "name": "@kids",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 4,
          "code": [
            "\"'@kids <obj>' - List the children of an object. This is handy for seeing whether anybody's actually using your carefully-wrought public objects.\";",
            "thing = player:my_match_object(dobjstr);",
            "if (!$command_utils:object_match_failed(thing, dobjstr))",
            "kids = children(thing);",
            "if (kids)",
            "player:notify(tostr(thing:title(), \"(\", thing, \") has \", length(kids), \" kid\", (length(kids) == 1) ? \"\" | \"s\", \".\"));",
            "player:notify(tostr($string_utils:names_of(kids)));",
            "else",
            "player:notify(tostr(thing:title(), \"(\", thing, \") has no kids.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@contents",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "\"'@contents <obj> - list the contents of an object, with object numbers.\";",
            "set_task_perms(player);",
            "if (!dobjstr)",
            "dobj = player.location;",
            "else",
            "dobj = player:my_match_object(dobjstr);",
            "endif",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "else",
            "contents = dobj.contents;",
            "if (contents)",
            "player:notify(tostr(dobj:title(), \"(\", dobj, \") contains:\"));",
            "player:notify(tostr($string_utils:names_of(contents)));",
            "else",
            "player:notify(tostr(dobj:title(), \"(\", dobj, \") contains nothing.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@par*ents",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "\"'@parents <thing>' - List <thing> and its ancestors, all the way back to the Root Class (#1).\";",
            "if (player != this)",
            "return player:notify(\"Permission denied: not a builder.\");",
            "elseif (!dobjstr)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>\"));",
            "return;",
            "endif",
            "set_task_perms(player);",
            "o = player:my_match_object(dobjstr);",
            "if (!$command_utils:object_match_failed(o, dobjstr))",
            "player:notify($string_utils:names_of({o, @$object_utils:ancestors(o)}));",
            "endif"
          ]
        },
        {
          "name": "@location*s",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "\"@locations <thing> - List <thing> and its containers, all the way back to the outermost one.\";",
            "set_task_perms(player);",
            "if (!dobjstr)",
            "what = player;",
            "elseif ((!valid(what = player:my_match_object(dobjstr))) && (!valid(what = $string_utils:match_player(dobjstr))))",
            "$command_utils:object_match_failed(dobj, dobjstr);",
            "return;",
            "endif",
            "player:notify($string_utils:names_of({what, @$object_utils:locations(what)}));"
          ]
        },
        {
          "name": "classes_2",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "{root, indent, members, printed} = args;",
            "if (root in members)",
            "player:tell(indent, root.name, \" (\", root, \")\");",
            "else",
            "player:tell(indent, \"<\", root.name, \" (\", root, \")>\");",
            "endif",
            "printed = setremove(printed, root);",
            "indent = indent + \"  \";",
            "set_task_perms(caller_perms());",
            "for c in ($list_utils:sort_suspended(2, $set_utils:intersection(children(root), printed)))",
            "$command_utils:suspend_if_needed(10);",
            "this:classes_2(c, indent, members, printed);",
            "endfor"
          ]
        },
        {
          "name": "_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "set_task_perms(caller_perms());",
            "if (this:build_option(\"bi_create\"))",
            "return $quota_utils:bi_create(@args);",
            "else",
            "return $recycler:(verb)(@args);",
            "endif"
          ]
        },
        {
          "name": "_recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "set_task_perms(caller_perms());",
            "if (this:build_option(\"bi_create\"))",
            "return recycle(@args);",
            "else",
            "return $recycler:(verb)(@args);",
            "endif"
          ]
        },
        {
          "name": "@chparent",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 4,
          "code": [
            "set_task_perms(player);",
            "if ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))",
            "\"...bogus object...\";",
            "elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))",
            "\"...bogus new parent...\";",
            "elseif ((this != player) && (!$object_utils:isa(player, $player)))",
            "\"...They chparented to #1 and want to chparent back to $prog.  Probably for some nefarious purpose...\";",
            "player:notify(\"You don't seem to already be a valid player class.  Perhaps chparenting away from the $player hierarchy was not such a good idea.  Permission denied.\");",
            "elseif (is_player(object) && (!$object_utils:isa(parent, $player)))",
            "player:notify(tostr(object, \" is a player and \", parent, \" is not a player class.\"));",
            "player:notify(\"You really *don't* want to do this.  Trust me.\");",
            "else",
            "if ($object_utils:isa(object, $mail_recipient))",
            "if (!$command_utils:yes_or_no(\"Chparenting a mailing list is usually a really bad idea.  Do you really want to do it?  (If you don't know why we're asking this question, please say 'no'.)\"))",
            "return player:tell(\"Aborted.\");",
            "endif",
            "endif",
            "try",
            "result = player:_chparent(object, parent);",
            "player:notify(\"Parent changed.\");",
            "except (E_INVARG)",
            "if (valid(object) && valid(parent))",
            "player:notify(tostr(\"Some property existing on \", parent, \" is defined on \", object, \" or one of its descendants.\"));",
            "player:notify(tostr(\"Try @check-chparent \", dobjstr, \" to \", iobjstr));",
            "else",
            "player:notify(\"Either that is not a valid object or not a valid parent\");",
            "endif",
            "except (E_PERM)",
            "player:notify(\"Either you don't own the object, don't own the parent, or the parent is not fertile.\");",
            "except (E_RECMOVE)",
            "player:notify(\"That parent object is a descendant of the object!\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "@check-chp*arent",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 4,
          "code": [
            "\"Copied from generic programmer (#217):@check-chparent by ur-Rog (#6349) Sun Nov  8 22:13:53 1992 PST\";",
            "\"@check-chparent object to newparent\";",
            "\"checks for property name conflicts that would make @chparent bomb.\";",
            "set_task_perms(player);",
            "if (!(dobjstr && iobjstr))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object> to <newparent>\"));",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))",
            "\"...bogus object...\";",
            "elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))",
            "\"...bogus new parent...\";",
            "elseif (player != this)",
            "player:notify(tostr(E_PERM));",
            "elseif (typeof(result = $object_utils:property_conflicts(object, parent)) == ERR)",
            "player:notify(tostr(result));",
            "elseif (result)",
            "su = $string_utils;",
            "player:notify(\"\");",
            "player:notify(su:left(\"Property\", 30) + \"Also Defined on\");",
            "player:notify(su:left(\"--------\", 30) + \"---------------\");",
            "for r in (result)",
            "player:notify(su:left(tostr(parent, \".\", r[1]), 30) + su:from_list(listdelete(r, 1), \" \"));",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "else",
            "player:notify(\"No property conflicts found.\");",
            "endif"
          ]
        },
        {
          "name": "@set*prop",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 4,
          "code": [
            "\"Syntax:  @set <object>.<prop-name> to <value>\";",
            "\"\";",
            "\"Changes the value of the specified object's property to the given value.\";",
            "\"You must have permission to modify the property, either because you own the property or if it is writable.\";",
            "set_task_perms(player);",
            "if (this != player)",
            "return player:tell(E_PERM);",
            "endif",
            "l = $code_utils:parse_propref(dobjstr);",
            "if (l)",
            "dobj = player:my_match_object(l[1], player.location);",
            "if ($command_utils:object_match_failed(dobj, l[1]))",
            "return;",
            "endif",
            "prop = l[2];",
            "to_i = \"to\" in args;",
            "at_i = \"at\" in args;",
            "i = (to_i && at_i) ? min(to_i, at_i) | (to_i || at_i);",
            "iobjstr = argstr[$string_utils:word_start(argstr)[i][2] + 1..$];",
            "iobjstr = $string_utils:trim(iobjstr);",
            "if (!iobjstr)",
            "try",
            "val = dobj.(prop) = \"\";",
            "except e (ANY)",
            "player:tell(\"Unable to set \", dobj, \".\", prop, \": \", e[2]);",
            "return;",
            "endtry",
            "iobjstr = \"\\\"\\\"\";",
            "\"elseif (iobjstr[1] == \\\"\\\\\\\"\\\")\";",
            "\"val = dobj.(prop) = iobjstr;\";",
            "\"iobjstr = \\\"\\\\\\\"\\\" + iobjstr + \\\"\\\\\\\"\\\";\";",
            "else",
            "val = $string_utils:to_value(iobjstr);",
            "if (!val[1])",
            "player:tell(\"Could not parse: \", iobjstr);",
            "return;",
            "elseif (!$object_utils:has_property(dobj, prop))",
            "player:tell(\"That object does not define that property.\");",
            "return;",
            "endif",
            "try",
            "val = dobj.(prop) = val[2];",
            "except e (ANY)",
            "player:tell(\"Unable to set \", dobj, \".\", prop, \": \", e[2]);",
            "return;",
            "endtry",
            "endif",
            "player:tell(\"Property \", dobj, \".\", prop, \" set to \", $string_utils:print(val), \".\");",
            "else",
            "player:tell(\"Property \", dobjstr, \" not found.\");",
            "endif"
          ]
        },
        {
          "name": "build_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "\":build_option(name)\";",
            "\"Returns the value of the specified builder option\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return $options[\"build\"]:get(this.build_options, args[1]);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_build_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "\":set_build_option(oname,value)\";",
            "\"Changes the value of the named option.\";",
            "\"Returns a string error if something goes wrong.\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return tostr(E_PERM);",
            "endif",
            "\"...this is kludgy, but it saves me from writing the same verb n times.\";",
            "\"...there's got to be a better way to do this...\";",
            "verb[1..4] = \"\";",
            "foo_options = verb + \"s\";",
            "prop = verb[1..index(verb, \"_\") - 1];",
            "\"...\";",
            "if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)",
            "return s;",
            "elseif (s == this.(foo_options))",
            "return 0;",
            "else",
            "this.(foo_options) = s;",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "@build-o*ptions @buildo*ptions @builder-o*ptions @buildero*ptions",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "\"@<what>-option <option> [is] <value>   sets <option> to <value>\";",
            "\"@<what>-option <option>=<value>        sets <option> to <value>\";",
            "\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";",
            "\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option <option>      displays value of <option>\";",
            "set_task_perms(player);",
            "what = \"build\";",
            "options = what + \"_options\";",
            "option_pkg = $options[what];",
            "set_option = (\"set_\" + what) + \"_option\";",
            "if (!args)",
            "player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});",
            "return;",
            "elseif (typeof(presult = option_pkg:parse(args)) == STR)",
            "player:notify(presult);",
            "return;",
            "else",
            "if (length(presult) > 1)",
            "if (typeof(sresult = this:(set_option)(@presult)) == STR)",
            "player:notify(sresult);",
            "return;",
            "elseif (!sresult)",
            "player:notify(\"No change.\");",
            "return;",
            "endif",
            "endif",
            "player:notify_lines(option_pkg:show(this.(options), presult[1]));",
            "endif"
          ]
        },
        {
          "name": "@meas*ure",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 4,
          "code": [
            "\"Syntax:\";",
            "\"  @measure object <object name>\";",
            "\"  @measure summary [player]\";",
            "\"  @measure new [player]\";",
            "\"  @measure breakdown <object name>\";",
            "\"  @measure recent [number of days] [player]\";",
            "if (length(args) < 1)",
            "player:tell_lines($code_utils:verb_documentation());",
            "return;",
            "endif",
            "if (index(\"object\", args[1]) == 1)",
            "\"Object.\";",
            "what = player.location:match_object(name = $string_utils:from_list(args[2..$], \" \"));",
            "lag = $login:current_lag();",
            "if (!valid(what))",
            "player:tell(\"Sorry, I didn't understand `\", name, \"'\");",
            "elseif (((((($object_utils:has_property(what, \"object_size\") && (what.object_size[1] > $byte_quota_utils.too_large)) && (!player.wizard)) && (player != $byte_quota_utils.owner)) && (player != $hacker)) && (player != what.owner)) && (lag > 0))",
            "player:tell($string_utils:nn(what), \" when last measured was \", $string_utils:group_number(what.object_size[1]), \" bytes.  To reduce lag induced by multiple players re-measuring large objects multiple times, you may not measure that object.\");",
            "elseif (((lag > 0) && (`what.object_size[2] ! ANY => 0' > (time() - 86400))) && (!$command_utils:yes_or_no(tostr(\"That object was measured only \", $string_utils:from_seconds(time() - what.object_size[2]), \" ago.  Please don't lag the MOO by remeasuring things frequently.  Are you sure you want to remeasure it?\"))))",
            "return player:tell(\"Not measuring.  It was \", $string_utils:group_number(what.object_size[1]), \" bytes when last measured.\");",
            "else",
            "player:tell(\"Checking size of \", what.name, \" (\", what, \")...\");",
            "player:tell(\"Size of \", what.name, \" (\", what, \") is \", $string_utils:group_number($byte_quota_utils:object_bytes(what)), \" bytes.\");",
            "endif",
            "elseif (index(\"summary\", args[1]) == 1)",
            "\"Summarize player.\";",
            "if (length(args) == 1)",
            "what = player;",
            "else",
            "what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], \" \"));",
            "endif",
            "if (!valid(what))",
            "player:tell(\"Sorry, I don't know who you mean by `\", name, \"'\");",
            "else",
            "$byte_quota_utils:do_summary(what);",
            "endif",
            "elseif (index(\"new\", args[1]) == 1)",
            "if (length(args) == 1)",
            "what = player;",
            "elseif (!valid(what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], \" \"))))",
            "return $command_utils:player_match_failed(what, name);",
            "endif",
            "player:tell(\"Measuring the sizes of \", what.name, \"'s recently created objects...\");",
            "total = 0;",
            "unmeasured_index = 4;",
            "unmeasured_multiplier = 100;",
            "nunmeasured = 0;",
            "if (typeof(what.owned_objects) == LIST)",
            "for x in (what.owned_objects)",
            "if (!$object_utils:has_property(x, \"object_size\"))",
            "nunmeasured = nunmeasured + 1;",
            "elseif (!x.object_size[1])",
            "player:tell(\"Measured \", $string_utils:nn(x), \":  \", size = $byte_quota_utils:object_bytes(x), \" bytes.\");",
            "total = total + size;",
            "endif",
            "$command_utils:suspend_if_needed(5);",
            "endfor",
            "if (nunmeasured && (what.size_quota[unmeasured_index] < (unmeasured_multiplier * nunmeasured)))",
            "what.size_quota[unmeasured_index] = (what.size_quota[unmeasured_index] % unmeasured_multiplier) + (nunmeasured * unmeasured_multiplier);",
            "endif",
            "player:tell(\"Total bytes used in new creations: \", total, \".\", nunmeasured ? tostr(\" There were a total of \", nunmeasured, \" object(s) found with no .object_size property. This will prevent additional building.\") | \"\");",
            "else",
            "player:tell(\"Sorry, \", what.name, \" is not enrolled in the object measurement scheme.\");",
            "endif",
            "elseif (index(\"recent\", args[1]) == 1)",
            "\"@measure recent days player\";",
            "if (length(args) > 1)",
            "days = $code_utils:toint(args[2]);",
            "else",
            "days = $byte_quota_utils.cycle_days;",
            "endif",
            "if (!days)",
            "return player:tell(\"Couldn't understand `\", args[2], \"' as a positive integer.\");",
            "endif",
            "if (length(args) > 2)",
            "if (!valid(who = $string_utils:match_player(name = $string_utils:from_list(args[3..$], \" \"))))",
            "return $command_utils:player_match_failed(who, name);",
            "endif",
            "else",
            "who = player;",
            "endif",
            "if (typeof(who.owned_objects) == LIST)",
            "player:tell(\"Re-measuring objects of \", $string_utils:nn(who), \" which have not been measured in the past \", days, \" days.\");",
            "when = time() - (days * 86400);",
            "which = {};",
            "for x in (who.owned_objects)",
            "if (x.object_size[2] < when)",
            "$byte_quota_utils:object_size(x);",
            "which = setadd(which, x);",
            "$command_utils:suspend_if_needed(3, \"...measuring\");",
            "endif",
            "endfor",
            "player:tell(\"Done, re-measured \", length(which), \" objects.\", (length(which) > 0) ? \"  Recommend you use @measure summary to update the display of @quota.\" | \"\");",
            "else",
            "player:tell(\"Sorry, \", who.name, \" is not enrolled in the object measurement scheme.\");",
            "endif",
            "elseif (index(\"breakdown\", args[1]) == 1)",
            "what = player.location:match_object(name = $string_utils:from_list(args[2..$], \" \"));",
            "if (!valid(what))",
            "player:tell(\"Sorry, I didn't understand `\", name, \"'\");",
            "elseif (!$byte_quota_utils:can_peek(player, what.owner))",
            "return player:tell(\"Sorry, you don't control \", what.name, \" (\", what, \")\");",
            "else",
            "if (mail = $command_utils:yes_or_no(\"This might be kinda long.  Want me to mail you the result?\"))",
            "player:tell(\"Result will be mailed.\");",
            "endif",
            "info = $byte_quota_utils:do_breakdown(what);",
            "if (typeof(info) == ERR)",
            "player:tell(info);",
            "endif",
            "if (mail)",
            "$mail_agent:send_message($byte_quota_utils.owner, {player}, tostr(\"Object breakdown of \", what.name, \" (\", what, \")\"), info);",
            "else",
            "player:tell_lines_suspended(info);",
            "endif",
            "endif",
            "else",
            "player:tell(\"Not a sub-command of @measure: \", args[1]);",
            "player:tell_lines($code_utils:verb_documentation());",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 4,
          "code": [
            "if (caller_perms().wizard)",
            "if (this == $builder)",
            "this.build_options = {};",
            "else",
            "clear_property(this, \"build_options\");",
            "endif",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "@listedit @pedit",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 4,
          "code": [
            "\"@listedit|@pedit object.prop -- invokes the list editor.\";",
            "\"   if you are editing a list of strings, you're better off using @notedit.\";",
            "$list_editor:invoke(dobjstr, verb);"
          ]
        }
      ],
      "propnames": [
        "build_options"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 84,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic builder"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "You see a player who should type '@describe me as ...'.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            48748,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "5": {
      "id": 5,
      "name": "generic thing",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        8,
        9,
        63,
        74,
        87,
        97
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "g*et t*ake",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 5,
          "code": [
            "set_task_perms(callers() ? caller_perms() | player);",
            "if (this.location == player)",
            "player:tell(\"You already have that!\");",
            "elseif (this.location != player.location)",
            "player:tell(\"I don't see that here.\");",
            "else",
            "this:moveto(player);",
            "if (this.location == player)",
            "player:tell(this:take_succeeded_msg() || \"Taken.\");",
            "if (msg = this:otake_succeeded_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "else",
            "player:tell(this:take_failed_msg() || \"You can't pick that up.\");",
            "if (msg = this:otake_failed_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "d*rop th*row",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 5,
          "code": [
            "set_task_perms(callers() ? caller_perms() | player);",
            "if (this.location != player)",
            "player:tell(\"You don't have that.\");",
            "elseif (!player.location:acceptable(this))",
            "player:tell(\"You can't drop that here.\");",
            "else",
            "this:moveto(player.location);",
            "if (this.location == player.location)",
            "player:tell_lines(this:drop_succeeded_msg() || \"Dropped.\");",
            "if (msg = this:odrop_succeeded_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "else",
            "player:tell_lines(this:drop_failed_msg() || \"You can't seem to drop that here.\");",
            "if (msg = this:odrop_failed_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 5,
          "code": [
            "where = args[1];",
            "\"if (!valid(where) || this:is_unlocked_for(where))\";",
            "if (this:is_unlocked_for(where))",
            "pass(where);",
            "endif"
          ]
        },
        {
          "name": "take_failed_msg take_succeeded_msg otake_failed_msg otake_succeeded_msg drop_failed_msg drop_succeeded_msg odrop_failed_msg odrop_succeeded_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 5,
          "code": [
            "set_task_perms(caller_perms());",
            "return $string_utils:pronoun_sub(this.(verb));"
          ]
        },
        {
          "name": "gi*ve ha*nd",
          "owner": 2,
          "perms": 109,
          "preps": 1,
          "object": 5,
          "code": [
            "set_task_perms(callers() ? caller_perms() | player);",
            "if (this.location != player)",
            "player:tell(\"You don't have that!\");",
            "elseif (!valid(player.location))",
            "player:tell(\"I see no \\\"\", iobjstr, \"\\\" here.\");",
            "elseif ($command_utils:object_match_failed(who = player.location:match_object(iobjstr), iobjstr))",
            "elseif (who.location != player.location)",
            "player:tell(\"I see no \\\"\", iobjstr, \"\\\" here.\");",
            "elseif (who == player)",
            "player:tell(\"Give it to yourself?\");",
            "else",
            "this:moveto(who);",
            "if (this.location == who)",
            "player:tell(\"You hand \", this:title(), \" to \", who:title(), \".\");",
            "who:tell(player:titlec(), \" \", $gender_utils:get_conj(\"hands/hand\", player), \" you \", this:title(), \".\");",
            "else",
            "player:tell(who:titlec(), \" \", $gender_utils:get_conj(\"does/do\", who), \" not want that item.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "examine_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 5,
          "code": [
            "\"examine_key(examiner)\";",
            "\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";",
            "\"the default will only tell the key to a wizard or this object's owner.\";",
            "who = args[1];",
            "if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))",
            "return {tostr(this:title(), \" can only be moved to locations matching this key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "drop_failed_msg",
        "drop_succeeded_msg",
        "odrop_failed_msg",
        "odrop_succeeded_msg",
        "otake_succeeded_msg",
        "otake_failed_msg",
        "take_succeeded_msg",
        "take_failed_msg"
      ],
      "propdefs": [
        {
          "value": "You can't seem to drop %t here.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You drop %t.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "tries to drop %t but fails!",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "drops %t.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "picks up %t.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You take %t.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You can't pick that up.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic thing"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            7011,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "6": {
      "id": 6,
      "name": "generic player",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        94
      ],
      "children": [
        100
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.home = (this in {$no_one, $hacker, $generic_editor.owner}) ? $nothing | $player_start;",
            "if (a = $list_utils:assoc(this, {{$prog, {$help_db[\"prog\"], $help_db[\"builtin_function\"], $help_db[\"verb\"], $help_db[\"core\"], $help_db[\"toaststunt\"]}}, {$wiz, $help_db[\"wiz\"]}, {$mail_recipient_class, $help_db[\"mail\"]}, {$builder, $help_db[\"builder\"]}, {$frand_class, $help_db[\"frand\"]}}))",
            "this.help = a[2];",
            "else",
            "this.help = 0;",
            "endif",
            "if (this != $player)",
            "for p in ({\"last_connect_place\", \"all_connect_places\", \"features\", \"previous_connection\", \"last_connect_time\"})",
            "clear_property(this, p);",
            "endfor",
            "if (is_player(this))",
            "this.first_connect_time = $maxint;",
            "this.last_disconnect_time = $maxint;",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))",
            "return E_PERM;",
            "endif",
            "this:(\"@last-connection\")();",
            "$news:check();"
          ]
        },
        {
          "name": "disfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))",
            "return E_PERM;",
            "endif",
            "this:expunge_rmm();",
            "this:erase_paranoid_data();",
            "this:gc_gaglist();",
            "return;"
          ]
        },
        {
          "name": "initialize",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "this.help = 0;",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "return !is_player(args[1]);"
          ]
        },
        {
          "name": "my_huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Extra parsing of player commands.  Called by $command_utils:do_huh.\";",
            "\"This version of my_huh just handles features.\";",
            "permissions = (((caller == this) || $perm_utils:controls(caller_perms(), this)) && $command_utils:validate_feature(@args)) ? this | $no_one;",
            "\"verb - obvious                 pass - would be args\";",
            "\"plist - list of prepspecs that this command matches\";",
            "\"dlist and ilist - likewise for dobjspecs, iobjspecs\";",
            "verb = args[1];",
            "if (`$server_options.support_numeric_verbname_strings ! E_PROPNF => 0' && $string_utils:is_integer(verb))",
            "return;",
            "endif",
            "pass = args[2];",
            "plist = {\"any\", prepstr ? $code_utils:full_prep(prepstr) | \"none\"};",
            "dlist = dobjstr ? {\"any\"} | {\"none\", \"any\"};",
            "ilist = iobjstr ? {\"any\"} | {\"none\", \"any\"};",
            "for fobj in (this.features)",
            "if (!$recycler:valid(fobj))",
            "this:remove_feature(fobj);",
            "else",
            "fverb = 0;",
            "try",
            "\"Ask the FO for a matching verb.\";",
            "fverb = fobj:has_feature_verb(verb, dlist, plist, ilist);",
            "except e (E_VERBNF)",
            "\"Try to match it ourselves.\";",
            "if (`valid(loc = $object_utils:has_callable_verb(fobj, verb)[1]) ! ANY => 0')",
            "vargs = verb_args(loc, verb);",
            "if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))",
            "fverb = verb;",
            "endif",
            "endif",
            "endtry",
            "if (fverb)",
            "\"(got rid of notify_huh - use @find to locate feature verbs)\";",
            "set_task_perms(permissions);",
            "fobj:(fverb)(@pass);",
            "return 1;",
            "endif",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "player:tell(\"You have too many features.  Parsing your command runs out of ticks while checking \", fobj.name, \" (\", fobj, \").\");",
            "return 1;",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "last_huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":last_huh(verb,args)  final attempt to parse a command...\";",
            "set_task_perms(caller_perms());",
            "{verb, args} = args;",
            "if ((verb[1] == \"@\") && (prepstr == \"is\"))",
            "\"... set or show _msg property ...\";",
            "set_task_perms(player);",
            "$last_huh:(verb)(@args);",
            "return 1;",
            "elseif (verb in {\"give\", \"hand\", \"get\", \"take\", \"drop\", \"throw\"})",
            "$last_huh:(verb)(@args);",
            "return 1;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "my_match_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":my_match_object(string [,location])\";",
            "return $string_utils:match_object(@{@args, this.location}[1..2], this);"
          ]
        },
        {
          "name": "tell_contents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "c = args[1];",
            "if (c)",
            "longear = {};",
            "gear = {};",
            "width = player:linelen();",
            "half = width / 2;",
            "player:tell(\"Carrying:\");",
            "for thing in (c)",
            "cx = tostr(\" \", thing:title());",
            "if (length(cx) > half)",
            "longear = {@longear, cx};",
            "else",
            "gear = {@gear, cx};",
            "endif",
            "endfor",
            "player:tell_lines($string_utils:columnize(gear, 2, width));",
            "player:tell_lines(longear);",
            "endif"
          ]
        },
        {
          "name": "titlec",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "return `this.namec ! E_PROPNF => this:title()';"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "line = args[1];",
            "if (!(this in connected_players()))",
            "\"...drop it on the floor...\";",
            "return 0;",
            "elseif ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "if (this.pagelen)",
            "\"...need wizard perms if this and this.owner are different, since...\";",
            "\"...only this can notify() and only this.owner can read .linebuffer...\";",
            "if ((player == this) && (this.linetask[2] != task_id()))",
            "\"...player has started a new task...\";",
            "\"....linetask[2] is the taskid of the most recent player task...\";",
            "if (this.linetask[2] != this.linetask[1])",
            "this.linesleft = this.pagelen - 2;",
            "endif",
            "this.linetask[2] = task_id();",
            "endif",
            "\"... digest the current line...\";",
            "if (this.linelen > 0)",
            "lbuf = {@this.linebuffer, @this:linesplit(line, this.linelen)};",
            "else",
            "lbuf = {@this.linebuffer, line};",
            "endif",
            "\"... print out what we can...\";",
            "if (this.linesleft)",
            "howmany = min(this.linesleft, length(lbuf));",
            "for l in (lbuf[1..howmany])",
            "pass(l);",
            "endfor",
            "this.linesleft = this.linesleft - howmany;",
            "lbuf[1..howmany] = {};",
            "endif",
            "if (lbuf)",
            "\"...see if we need to say ***More***\";",
            "if (this.linetask[1] != this.linetask[2])",
            "\"....linetask[1] is the taskid of the most recent player task\";",
            "\"...   for which ***More*** was printed...\";",
            "this.linetask[1] = this.linetask[2];",
            "fork (0)",
            "if (lb = this.linebuffer)",
            "pass(strsub(this.more_msg, \"%n\", tostr(length(lb))));",
            "endif",
            "endfork",
            "endif",
            "llen = length(lbuf);",
            "if (llen > 500)",
            "\"...way too much saved text, flush some of it...\";",
            "lbuf[1..llen - 100] = {\"*** buffer overflow, lines flushed ***\"};",
            "endif",
            "endif",
            "this.linebuffer = lbuf;",
            "else",
            "if (this.linelen > 0)",
            "for l in (this:linesplit(line, this.linelen))",
            "pass(l);",
            "endfor",
            "else",
            "pass(line);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "notify_lines",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))",
            "set_task_perms(caller_perms());",
            "for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)",
            "this:notify(tostr(line));",
            "endfor",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "linesplit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":linesplit(line,len) => list of substrings of line\";",
            "\"used by :notify to split up long lines if .linelen>0\";",
            "{line, len} = args;",
            "cline = {};",
            "while (length(line) > len)",
            "cutoff = rindex(line[1..len], \" \");",
            "if (nospace = cutoff < ((4 * len) / 5))",
            "cutoff = len + 1;",
            "nospace = line[cutoff] != \" \";",
            "endif",
            "cline = {@cline, line[1..cutoff - 1]};",
            "line = (nospace ? \" \" | \"\") + line[cutoff..$];",
            "endwhile",
            "return {@cline, line};"
          ]
        },
        {
          "name": "linelen",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "return abs(this.linelen);"
          ]
        },
        {
          "name": "@more",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "if (player != this)",
            "\"... somebody's being sneaky...\";",
            "\"... Can't do set_task_perms(player) since we need to be `this'...\";",
            "\"... to notify and `this.owner' to change +c properties...\";",
            "return;",
            "elseif (!(lbuf = this.linebuffer))",
            "this.linesleft = this.pagelen - 2;",
            "notify(this, \"*** No more ***\");",
            "elseif (index(\"flush\", dobjstr || \"x\") == 1)",
            "this.linesleft = this.pagelen - 2;",
            "notify(this, tostr(\"*** Flushed ***  \", length(lbuf), \" lines\"));",
            "this.linebuffer = {};",
            "elseif ((index(\"rest\", dobjstr || \"x\") == 1) || (!this.pagelen))",
            "this.linesleft = this.pagelen - 2;",
            "for l in (lbuf)",
            "notify(this, l);",
            "endfor",
            "this.linebuffer = {};",
            "else",
            "howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));",
            "for l in (lbuf[1..howmany])",
            "notify(this, l);",
            "endfor",
            "this.linesleft = (this.pagelen - 2) - howmany;",
            "this.linebuffer = lbuf[howmany + 1..llen];",
            "if (howmany < llen)",
            "notify(this, strsub(this.more_msg, \"%n\", tostr(llen - howmany)));",
            "this.linetask[1] = task_id();",
            "endif",
            "endif",
            "this.linetask[2] = task_id();"
          ]
        },
        {
          "name": "@wrap",
          "owner": 36,
          "perms": 9,
          "preps": -2,
          "object": 6,
          "code": [
            "if (player != this)",
            "\"... someone is being sneaky...\";",
            "\"... Can't do set_task_perms(player) since we need to be `this'...\";",
            "\"... to notify and `this.owner' to change +c properties...\";",
            "return;",
            "endif",
            "linelen = player.linelen;",
            "if (!(prepstr in {\"on\", \"off\"}))",
            "player:notify(\"Usage:  @wrap on|off\");",
            "player:notify(tostr(\"Word wrap is currently \", (linelen > 0) ? \"on\" | \"off\", \".\"));",
            "return;",
            "endif",
            "player.linelen = abs(linelen) * ((prepstr == \"on\") ? 1 | -1);",
            "player:notify(tostr(\"Word wrap is now \", prepstr, \".\"));"
          ]
        },
        {
          "name": "@linelen*gth",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "if (callers() ? (caller != this) && (!$perm_utils:controls(caller_perms(), this)) | (player != this))",
            "\"... somebody is being sneaky ...\";",
            "return;",
            "endif",
            "curlen = player.linelen;",
            "wrap = curlen > 0;",
            "wrapstr = wrap ? \"on\" | \"off\";",
            "if (!dobjstr)",
            "player:notify(tostr(\"Usage:  \", verb, \" <number>\"));",
            "player:notify(tostr(\"Current line length is \", abs(curlen), \".  Word wrapping is \", wrapstr, \".\"));",
            "return;",
            "endif",
            "newlen = toint(dobjstr);",
            "if (newlen < 0)",
            "player:notify(\"Line length can't be a negative number.\");",
            "return;",
            "elseif (newlen == 0)",
            "return player:notify(\"Linelength zero makes no sense.  You want to use '@wrap off' if you want to turn off wrapping.\");",
            "elseif (newlen < 10)",
            "player:notify(\"You don't want your linelength that small.  Setting it to 10.\");",
            "newlen = 10;",
            "elseif (newlen > 1000)",
            "player:notify(\"You don't want your line length that large.  Setting it to 1000.\");",
            "newlen = 1000;",
            "endif",
            "this:set_linelength(newlen);",
            "player:notify(tostr(\"Line length is now \", abs(player.linelen), \".  Word wrapping is \", wrapstr, \".\"));",
            "if (!wrap)",
            "player:notify(\"To enable word wrapping, type `@wrap on'.\");",
            "endif"
          ]
        },
        {
          "name": "@pagelen*gth",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "\"@pagelength number  -- sets page buffering to that many lines (or 0 to turn off page buffering)\";",
            "if (player != this)",
            "\"... somebody is being sneaky ...\";",
            "\"... Can't do set_task_perms(player) since we need to be `this'...\";",
            "\"... to notify and `this.owner' to change +c properties...\";",
            "return;",
            "elseif (!dobjstr)",
            "notify(player, tostr(\"Usage:  \", verb, \" <number>\"));",
            "notify(player, tostr(\"Current page length is \", player.pagelen, \".\"));",
            "return;",
            "elseif (0 > (newlen = toint(dobjstr)))",
            "notify(player, \"Page length can't be a negative number.\");",
            "return;",
            "elseif (newlen == 0)",
            "player.pagelen = 0;",
            "notify(player, \"Page buffering off.\");",
            "if (lb = this.linebuffer)",
            "\"queued text remains\";",
            "this:notify_lines(lb);",
            "clear_property(this, \"linebuffer\");",
            "endif",
            "elseif (newlen < 5)",
            "player.pagelen = 5;",
            "notify(player, \"Too small.  Setting it to 5.\");",
            "else",
            "notify(player, tostr(\"Page length is now \", player.pagelen = newlen, \".\"));",
            "endif",
            "if (this.linebuffer)",
            "notify(this, strsub(this.more_msg, \"%n\", tostr(length(this.linebuffer))));",
            "player.linetask = {task_id(), task_id()};",
            "player.linesleft = 0;",
            "else",
            "player.linetask = {0, task_id()};",
            "player.linesleft = player.pagelen - 2;",
            "endif"
          ]
        },
        {
          "name": "tell",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (this.gaglist || this.paranoid)",
            "\"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.\";",
            "if (this:gag_p())",
            "return;",
            "endif",
            "if (this.paranoid == 1)",
            "$paranoid_db:add_data(this, {{@callers(1), {player, \"<cmd-line>\", player}}, args});",
            "elseif (this.paranoid == 2)",
            "z = this:whodunnit({@callers(), {player, \"\", player}}, {this, $no_one}, {})[3];",
            "args = {\"(\", z.name, \" \", z, \") \", @args};",
            "endif",
            "endif",
            "pass(@args);"
          ]
        },
        {
          "name": "gag_p",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (player in this.gaglist)",
            "return 1;",
            "elseif (gag = this.gaglist)",
            "for x in (callers())",
            "if (((x[1] == #-1) && (x[3] == #-1)) && (x[2] != \"\"))",
            "elseif ((x[1] in gag) || (x[4] in gag))",
            "return 1;",
            "endif",
            "endfor",
            "endif",
            "return 0;",
            "\"--- old definition --\";",
            "if (player in this.gaglist)",
            "return 1;",
            "elseif (this.gaglist)",
            "for x in (callers())",
            "if (valid(x[1]))",
            "if (x[1] in this.gaglist)",
            "return 1;",
            "endif",
            "endif",
            "endfor",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "set_gaglist",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":set_gaglist(@newlist) => this.gaglist = newlist\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "else",
            "return this.gaglist = args;",
            "endif"
          ]
        },
        {
          "name": "@gag*!",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "set_task_perms(player);",
            "if (player != this)",
            "player:notify(\"Permission denied.\");",
            "return;",
            "endif",
            "if (!args)",
            "player:notify(tostr(\"Usage:  \", verb, \" <player or object> [<player or object>...]\"));",
            "return;",
            "endif",
            "victims = $string_utils:match_player_or_object(@args);",
            "changed = 0;",
            "for p in (victims)",
            "if (p in player.gaglist)",
            "player:notify(tostr(\"You are already gagging \", p.name, \".\"));",
            "elseif (p == player)",
            "player:notify(\"Gagging yourself is a bad idea.\");",
            "elseif (children(p) && (verb != \"@gag!\"))",
            "player:tell(\"If you really want to gag all descendents of \", $string_utils:nn(p), \", use `@gag! \", p, \"' instead.\");",
            "else",
            "changed = 1;",
            "player:set_gaglist(@setadd(this.gaglist, p));",
            "endif",
            "endfor",
            "if (changed)",
            "this:(\"@listgag\")();",
            "endif"
          ]
        },
        {
          "name": "@listgag @gaglist @gagged",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(valid(caller_perms()) ? caller_perms() | player);",
            "if (!this.gaglist)",
            "player:notify(tostr(\"You are \", callers() ? \"no longer gagging anything.\" | \"not gagging anything right now.\"));",
            "else",
            "player:notify(tostr(\"You are \", callers() ? \"now\" | \"currently\", \" gagging \", $string_utils:nn(this.gaglist), \".\"));",
            "endif",
            "gl = {};",
            "if (args)",
            "player:notify(\"Searching for players who may be gagging you...\");",
            "for p in (players())",
            "if ((typeof(`p.gaglist ! E_PERM') == LIST) && (this in p.gaglist))",
            "gl = {@gl, p};",
            "endif",
            "$command_utils:suspend_if_needed(10, \"...searching gaglist...\");",
            "endfor",
            "if (gl || (!callers()))",
            "player:notify(tostr($string_utils:nn(gl, \" \", \"No one\"), \" appear\", (length(gl) <= 1) ? \"s\" | \"\", \" to be gagging you.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@ungag",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "if ((player != this) || ((caller != this) && (!$perm_utils:controls(caller_perms(), this))))",
            "player:notify(\"Permission denied.\");",
            "elseif (dobjstr == \"\")",
            "player:notify(tostr(\"Usage:  \", verb, \" <player>  or  \", verb, \" everyone\"));",
            "elseif (dobjstr == \"everyone\")",
            "this.gaglist = {};",
            "player:notify(\"You are no longer gagging anyone or anything.\");",
            "else",
            "if (valid(dobj))",
            "match = dobj;",
            "elseif ((match = toobj(dobjstr)) > #0)",
            "else",
            "match = $string_utils:match(dobjstr, this.gaglist, \"name\", this.gaglist, \"aliases\");",
            "endif",
            "if (match == $failed_match)",
            "player:notify(tostr(\"You don't seem to be gagging anything named \", dobjstr, \".\"));",
            "elseif (match == $ambiguous_match)",
            "player:notify(tostr(\"I don't know which \\\"\", dobjstr, \"\\\" you mean.\"));",
            "else",
            "this.gaglist = setremove(this.gaglist, match);",
            "player:notify(tostr(valid(match) ? match.name | match, \" removed from gag list.\"));",
            "endif",
            "this:(\"@listgag\")();",
            "endif"
          ]
        },
        {
          "name": "whodunnit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "{record, trust, mistrust} = args;",
            "s = {this, \"???\", this};",
            "for w in (record)",
            "if (((((!valid(s[3])) || s[3].wizard) || (s[3] in trust)) && (!(s[3] in mistrust))) || (s[1] == this))",
            "s = w;",
            "else",
            "return s;",
            "endif",
            "endfor",
            "return s;"
          ]
        },
        {
          "name": "@ch*eck-full",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "responsible = $paranoid_db:get_data(this);",
            "if (length(verb) <= 6)",
            "\"@check, not @check-full\";",
            "n = 5;",
            "trust = {this, $no_one};",
            "\"... trust no one, my friend.... no one....  --Herod\";",
            "mistrust = {};",
            "for k in (args)",
            "if (z = $code_utils:toint(k))",
            "n = z;",
            "elseif (k[1] == \"!\")",
            "mistrust = listappend(mistrust, $string_utils:match_player(k[2..$]));",
            "else",
            "trust = listappend(trust, $string_utils:match_player(k));",
            "endif",
            "endfor",
            "msg_width = player:linelen() - 60;",
            "for q in ((n > (y = length(responsible))) ? responsible | responsible[(y - n) + 1..y])",
            "msg = tostr(@q[2]);",
            "if (length(msg) > msg_width)",
            "msg = msg[1..msg_width];",
            "endif",
            "s = this:whodunnit(q[1], trust, mistrust);",
            "text = valid(s[1]) ? s[1].name | \"** NONE **\";",
            "this:notify(tostr($string_utils:left(tostr((length(text) > 13) ? text[1..13] | text, \" (\", s[1], \")\"), 20), $string_utils:left(s[2], 15), $string_utils:left(tostr((length(s[3].name) > 13) ? s[3].name[1..13] | s[3].name, \" (\", s[3], \")\"), 20), msg));",
            "endfor",
            "this:notify(\"*** finished ***\");",
            "else",
            "\"@check-full, from @traceback by APHiD\";",
            "\"s_i_n's by Ho_Yan 10/18/94\";",
            "matches = {};",
            "if (length(match = argstr) == 0)",
            "player:notify(tostr(\"Usage: \", verb, \" <string> --or-- \", verb, \" <number>\"));",
            "return;",
            "endif",
            "if (!responsible)",
            "player:notify(\"No text has been saved by the monitor.  (See `help @paranoid').\");",
            "else",
            "if (typeof(x = $code_utils:toint(argstr)) == ERR)",
            "for line in (responsible)",
            "if (index(tostr(@line[$]), argstr))",
            "matches = {@matches, line};",
            "endif",
            "endfor",
            "else",
            "matches = responsible[($ - min(x, $)) + 1..$];",
            "endif",
            "if (matches)",
            "for match in (matches)",
            "$command_utils:suspend_if_needed(3);",
            "text = tostr(@match[$]);",
            "player:notify(\"Traceback for:\");",
            "player:notify(text);",
            "\"Moved cool display code to $code_utils, 3/29/95, Ho_Yan\";",
            "$code_utils:display_callers(listdelete(mm = match[1], length(mm)));",
            "endfor",
            "player:notify(\"**** finished ****\");",
            "else",
            "player:notify(tostr(\"No matches for \\\"\", argstr, \"\\\" found.\"));",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@paranoid",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "if ((args == {}) || ((typ = args[1]) == \"\"))",
            "$paranoid_db:set_kept_lines(this, 10);",
            "this.paranoid = 1;",
            "this:notify(\"Anti-spoofer on and keeping 10 lines.\");",
            "elseif (index(\"immediate\", typ))",
            "$paranoid_db:set_kept_lines(this, 0);",
            "this.paranoid = 2;",
            "this:notify(\"Anti-spoofer now in immediate mode.\");",
            "elseif (index(\"off\", typ) || (typ == \"0\"))",
            "this.paranoid = 0;",
            "$paranoid_db:set_kept_lines(this, 0);",
            "this:notify(\"Anti-spoofer off.\");",
            "elseif ((tostr(y = toint(typ)) != typ) || (y < 0))",
            "this:notify(tostr(\"Usage: \", verb, \" <lines to be kept>     to turn on your anti-spoofer.\"));",
            "this:notify(tostr(\"       \", verb, \" off                    to turn it off.\"));",
            "this:notify(tostr(\"       \", verb, \" immediate              to use immediate mode.\"));",
            "else",
            "this.paranoid = 1;",
            "kept = $paranoid_db:set_kept_lines(this, y);",
            "this:notify(tostr(\"Anti-spoofer on and keeping \", kept, \" lines.\"));",
            "endif"
          ]
        },
        {
          "name": "@sw*eep",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "buggers = 1;",
            "found_listener = 0;",
            "here = this.location;",
            "for thing in (setremove(here.contents, this))",
            "tellwhere = $object_utils:has_verb(thing, \"tell\");",
            "notifywhere = $object_utils:has_verb(thing, \"notify\");",
            "if (thing in connected_players())",
            "this:notify(tostr(thing.name, \" (\", thing, \") is listening.\"));",
            "found_listener = 1;",
            "elseif ($object_utils:has_callable_verb(thing, \"sweep_msg\") && (typeof(msg = thing:sweep_msg()) == STR))",
            "this:notify(tostr(thing.name, \" (\", thing, \") \", msg, \".\"));",
            "found_listener = 1;",
            "elseif (tellwhere && (((owner = verb_info(tellwhere[1], \"tell\")[1]) != this) && (!owner.wizard)))",
            "this:notify(tostr(thing.name, \" (\", thing, \") has been taught to listen by \", owner.name, \" (\", owner, \")\"));",
            "found_listener = 1;",
            "elseif (notifywhere && (((owner = verb_info(notifywhere[1], \"notify\")[1]) != this) && (!owner.wizard)))",
            "this:notify(tostr(thing.name, \" (\", thing, \") has been taught to listen by \", owner.name, \" (\", owner, \")\"));",
            "found_listener = 1;",
            "endif",
            "endfor",
            "buggers = {};",
            "for v in ({\"announce\", \"announce_all\", \"announce_all_but\", \"say\", \"emote\", \"huh\", \"here_huh\", \"huh2\", \"whisper\", \"here_explain_syntax\"})",
            "vwhere = $object_utils:has_verb(here, v);",
            "if (vwhere && (((owner = verb_info(vwhere[1], v)[1]) != this) && (!owner.wizard)))",
            "buggers = setadd(buggers, owner);",
            "endif",
            "endfor",
            "if (buggers != {})",
            "if ($object_utils:has_verb(here, \"sweep_msg\") && (typeof(msg = here:sweep_msg()) == STR))",
            "this:notify(tostr(here.name, \" (\", here, \") \", msg, \".\"));",
            "else",
            "this:notify(tostr(here.name, \" (\", here, \") may have been bugged by \", $string_utils:english_list($list_utils:map_prop(buggers, \"name\")), \".\"));",
            "endif",
            "elseif (!found_listener)",
            "this:notify(\"Communications look secure.\");",
            "endif"
          ]
        },
        {
          "name": "wh*isper",
          "owner": 2,
          "perms": 157,
          "preps": 1,
          "object": 6,
          "code": [
            "this:tell(player.name, \" whispers, \\\"\", dobjstr, \"\\\"\");",
            "player:tell(\"You whisper, \\\"\", dobjstr, \"\\\" to \", this.name, \".\");"
          ]
        },
        {
          "name": "page",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 6,
          "code": [
            "nargs = length(args);",
            "if (nargs < 1)",
            "player:notify(tostr(\"Usage: \", verb, \" <player> [with <message>]\"));",
            "return;",
            "endif",
            "who = $string_utils:match_player(args[1]);",
            "if ($command_utils:player_match_result(who, args[1])[1])",
            "return;",
            "elseif (who in this.gaglist)",
            "player:tell(\"You have \", who:title(), \" @gagged.  If you paged \", $gender_utils:get_pronoun(\"o\", who), \", \", $gender_utils:get_pronoun(\"s\", who), \" wouldn't be able to answer you.\");",
            "return;",
            "endif",
            "\"for pronoun_sub's benefit...\";",
            "dobj = who;",
            "iobj = player;",
            "header = player:page_origin_msg();",
            "text = \"\";",
            "if (nargs > 1)",
            "if ((args[2] == \"with\") && (nargs > 2))",
            "msg_start = 3;",
            "else",
            "msg_start = 2;",
            "endif",
            "msg = $string_utils:from_list(args[msg_start..nargs], \" \");",
            "text = tostr($string_utils:pronoun_sub(($string_utils:index_delimited(header, player.name) ? \"%S\" | \"%N\") + \" %<pages>, \\\"\"), msg, \"\\\"\");",
            "endif",
            "result = text ? who:receive_page(header, text) | who:receive_page(header);",
            "if (result == 2)",
            "\"not connected\";",
            "player:tell((typeof(msg = who:page_absent_msg()) == STR) ? msg | $string_utils:pronoun_sub(\"%n is not currently logged in.\", who));",
            "else",
            "player:tell(who:page_echo_msg());",
            "endif"
          ]
        },
        {
          "name": "receive_page",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"called by $player:page.  Two args, the page header and the text, all pre-processed by the page command.  Could be extended to provide haven abilities, multiline pages, etc.  Indeed, at the moment it just does :tell_lines, so we already do have multiline pages, if someone wants to take advantage of it.\";",
            "\"Return codes:\";",
            "\"  1:  page was received\";",
            "\"  2:  player is not connected\";",
            "\"  0:  page refused\";",
            "\"If a specialization wants to refuse a page, it should return 0 to say it was refused.  If it uses pass(@args) it should propagate back up the return value.  It is possible that this code should interact with gagging and return 0 if the page was gagged.\";",
            "if (this:is_listening())",
            "this:tell_lines_suspended(args);",
            "return 1;",
            "else",
            "return 2;",
            "endif"
          ]
        },
        {
          "name": "page_origin_msg page_echo_msg page_absent_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"set_task_perms(this.owner)\";",
            "return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(this.(verb), this) | \"\";"
          ]
        },
        {
          "name": "i inv*entory",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "if (c = player:contents())",
            "this:tell_contents(c);",
            "else",
            "player:tell(\"You are empty-handed.\");",
            "endif"
          ]
        },
        {
          "name": "look_self",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "player:tell(this:titlec());",
            "pass();",
            "if (!(this in connected_players()))",
            "player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} sleeping.\", this));",
            "elseif ((idle = idle_seconds(this)) < 60)",
            "player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} awake and %{!looks} alert.\", this));",
            "else",
            "time = $string_utils:from_seconds(idle);",
            "player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} awake, but %{!has} been staring off into space for \", this), time, \".\");",
            "endif",
            "if (c = this:contents())",
            "this:tell_contents(c);",
            "endif"
          ]
        },
        {
          "name": "home",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "start = this.location;",
            "if (start == this.home)",
            "player:tell(\"You're already home!\");",
            "return;",
            "elseif (typeof(this.home) != OBJ)",
            "player:tell(\"You've got a weird home, pal.  I've reset it to the default one.\");",
            "this.home = $player_start;",
            "elseif (!valid(this.home))",
            "player:tell(\"Oh no!  Your home's been recycled.  Time to look around for a new one.\");",
            "this.home = $player_start;",
            "else",
            "player:tell(\"You click your heels three times.\");",
            "endif",
            "this:moveto(this.home);",
            "if (!valid(start))",
            "elseif (start == this.location)",
            "start:announce(player.name, \" \", $gender_utils:get_conj(\"learns\", player), \" that you can never go home...\");",
            "else",
            "try",
            "start:announce(player.name, \" \", $gender_utils:get_conj(\"goes\", player), \" home.\");",
            "except e (E_VERBNF)",
            "\"start did not support announce\";",
            "endtry",
            "endif",
            "if (this.location == this.home)",
            "this.location:announce(player.name, \" \", $gender_utils:get_conj(\"comes\", player), \" home.\");",
            "elseif (this.location == start)",
            "player:tell(\"Either home doesn't want you, or you don't really want to go.\");",
            "else",
            "player:tell(\"Wait a minute!  This isn't your home...\");",
            "if (valid(this.location))",
            "this.location:announce(player.name, \" \", $gender_utils:get_conj(\"arrives\", player), \", looking quite bewildered.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@sethome",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(this);",
            "here = this.location;",
            "if (!$perm_utils:controls(player, player))",
            "player:notify(\"Players who do not own themselves may not modify their home.\");",
            "elseif (!$object_utils:has_callable_verb(here, \"accept_for_abode\"))",
            "player:notify(\"This is a pretty odd place.  You should make your home in an actual room.\");",
            "elseif (here:accept_for_abode(this))",
            "this.home = here;",
            "player:notify(tostr(here.name, \" is your new home.\"));",
            "else",
            "player:notify(tostr(\"This place doesn't want to be your home.  Contact \", here.owner.name, \" to be added to the residents list of this place, or choose another place as your home.\"));",
            "endif"
          ]
        },
        {
          "name": "g*et take",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 6,
          "code": [
            "player:tell(\"This is not a pick-up joint!\");",
            "this:tell(player.name, \" tried to pick you up.\");"
          ]
        },
        {
          "name": "@move @teleport",
          "owner": 2,
          "perms": 93,
          "preps": 1,
          "object": 6,
          "code": [
            "\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";",
            "set_task_perms((caller == this) ? this | $no_one);",
            "dobj = this:my_match_object(dobjstr);",
            "iobj = this:my_match_object(iobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr) || ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr)))",
            "return;",
            "endif",
            "if ((!$perm_utils:controls(this, dobj)) && (this != dobj))",
            "player:tell(\"You may only @move your own things.\");",
            "return;",
            "endif",
            "old_loc = dobj.location;",
            "if (old_loc == iobj)",
            "player:tell(dobj.name, \" is already \", valid(iobj) ? \"in \" + iobj.name | \"nowhere\", \".\");",
            "return;",
            "endif",
            "dobj:moveto(iobj);",
            "if (dobj.location == iobj)",
            "player:tell(\"Moved.\");",
            "if (is_player(dobj))",
            "if (valid(old_loc))",
            "old_loc:announce_all(dobj.name, \" disappears suddenly for parts unknown.\");",
            "if (dobj != player)",
            "dobj:tell(\"You have been moved by \", player.name, \".\");",
            "endif",
            "endif",
            "if (valid(dobj.location))",
            "dobj.location:announce(dobj.name, \" materializes out of thin air.\");",
            "endif",
            "endif",
            "elseif (dobj.location == old_loc)",
            "if ($object_utils:contains(dobj, iobj))",
            "player:tell(iobj.name, \" is inside of \", dobj.name, \"!\");",
            "else",
            "player:tell($string_utils:pronoun_sub(\"Either %d doesn't want to go, or %i doesn't want to accept %[dpo].\"));",
            "endif",
            "elseif (dobj == player)",
            "player:tell(\"You have been deflected from your original destination.\");",
            "else",
            "player:tell($string_utils:pronoun_sub(\"%D has been deflected from %[dpp] original destination.\"));",
            "endif"
          ]
        },
        {
          "name": "@eject @eject! @eject!!",
          "owner": 2,
          "perms": 89,
          "preps": 5,
          "object": 6,
          "code": [
            "set_task_perms(player);",
            "if (iobjstr == \"here\")",
            "iobj = player.location;",
            "elseif (iobjstr == \"me\")",
            "iobj = player;",
            "elseif ($command_utils:object_match_failed(iobj, iobjstr))",
            "return;",
            "endif",
            "if (!$perm_utils:controls(player, iobj))",
            "player:notify(tostr(\"You are not the owner of \", iobj.name, \".\"));",
            "return;",
            "endif",
            "if (dobjstr == \"me\")",
            "dobj = player;",
            "else",
            "dobj = $string_utils:literal_object(dobjstr);",
            "if (dobj == $failed_match)",
            "dobj = iobj:match(dobjstr);",
            "endif",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "endif",
            "if (dobj.location != iobj)",
            "player:notify(tostr(dobj.name, \"(\", dobj, \") is not in \", iobj.name, \"(\", iobj, \").\"));",
            "return;",
            "endif",
            "if (dobj.wizard)",
            "player:notify(tostr(\"Sorry, you can't \", verb, \" a wizard.\"));",
            "dobj:tell(player.name, \" tried to \", verb, \" you.\");",
            "return;",
            "endif",
            "iobj:((verb == \"@eject\") ? \"eject\" | \"eject_basic\")(dobj);",
            "player:notify($object_utils:has_callable_verb(iobj, \"ejection_msg\") ? iobj:ejection_msg() | $room:ejection_msg());",
            "if (verb != \"@eject!!\")",
            "dobj:tell($object_utils:has_callable_verb(iobj, \"victim_ejection_msg\") ? iobj:victim_ejection_msg() | $room:victim_ejection_msg());",
            "endif",
            "iobj:announce_all_but({player, dobj}, $object_utils:has_callable_verb(iobj, \"oejection_msg\") ? iobj:oejection_msg() | $room:oejection_msg());"
          ]
        },
        {
          "name": "where*is @where*is",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 6,
          "code": [
            "if (!args)",
            "them = connected_players();",
            "else",
            "who = $command_utils:player_match_result($string_utils:match_player(args), args);",
            "if (length(who) <= 1)",
            "if (!who[1])",
            "player:notify(\"Where is who?\");",
            "endif",
            "return;",
            "elseif (who[1])",
            "player:notify(\"\");",
            "endif",
            "them = listdelete(who, 1);",
            "endif",
            "lmax = rmax = 0;",
            "for p in (them)",
            "player:notify(tostr($string_utils:left($string_utils:nn(p), 25), \" \", $string_utils:nn(p.location)));",
            "endfor"
          ]
        },
        {
          "name": "@who",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 6,
          "code": [
            "if (caller != player)",
            "return E_PERM;",
            "endif",
            "plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();",
            "if (!plyrs)",
            "return;",
            "elseif (length(plyrs) > 100)",
            "player:tell(\"You have requested a listing of \", length(plyrs), \" players.  Please either specify individual players you are interested in, to reduce the number of players in any single request, or else use the `@users' command instead.  The lag thanks you.\");",
            "return;",
            "endif",
            "$code_utils:show_who_listing(plyrs);"
          ]
        },
        {
          "name": "@wizards",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "\"@wizards [all]\";",
            "if (caller != player)",
            "return E_PERM;",
            "endif",
            "if (args)",
            "$code_utils:show_who_listing($wiz_utils:all_wizards());",
            "else",
            "$code_utils:show_who_listing($wiz_utils:connected_wizards()) || player:notify(\"No wizards currently logged in.\");",
            "endif"
          ]
        },
        {
          "name": "?* help info*rmation @help",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 6,
          "code": [
            "set_task_perms(callers() ? caller_perms() | player);",
            "\"...this code explicitly relies on being !d in several places...\";",
            "if ((index(verb, \"?\") != 1) || (length(verb) <= 1))",
            "what = $string_utils:trimr(argstr);",
            "elseif (argstr)",
            "what = tostr(verb[2..$], \" \", $string_utils:trimr(argstr));",
            "else",
            "what = verb[2..$];",
            "endif",
            "\"...find a db that claims to know about `what'...\";",
            "dblist = $code_utils:help_db_list();",
            "result = $code_utils:help_db_search(what, dblist);",
            "if (!result)",
            "\"... note: all of the last-resort stuff...\";",
            "\"... is now located on $help:find_topics/get_topic...\";",
            "$wiz_utils:missed_help(what, result);",
            "player:notify(tostr(\"Sorry, but no help is available on `\", what, \"'.\"));",
            "elseif (result[1] == $ambiguous_match)",
            "$wiz_utils:missed_help(what, result);",
            "player:notify_lines(tostr(\"Sorry, but the topic-name `\", what, \"' is ambiguous.  I don't know which of the following topics you mean:\"));",
            "for x in ($help:columnize(@$help:sort_topics(result[2])))",
            "player:notify(tostr(\"   \", x));",
            "endfor",
            "else",
            "{help, topic} = result;",
            "if (topic != what)",
            "player:notify(tostr(\"Showing help on `\", topic, \"':\"));",
            "player:notify(\"----\");",
            "endif",
            "dblist = dblist[1 + (help in dblist)..$];",
            "if (1 == (text = help:get_topic(topic, dblist)))",
            "\"...get_topic took matters into its own hands...\";",
            "elseif (text)",
            "\"...these can get long...\";",
            "for line in ((typeof(text) == LIST) ? text | {text})",
            "if (typeof(line) != STR)",
            "player:notify(\"Odd results from help -- complain to a wizard.\");",
            "else",
            "player:notify(line);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "else",
            "player:notify(tostr(\"Help DB \", help, \" thinks it knows about `\", what, \"' but something's messed up.\"));",
            "player:notify(tostr(\"Tell \", help.owner.wizard ? \"\" | tostr(help.owner.name, \" (\", help.owner, \") or \"), \"a wizard.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "display_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":display_option(name) => returns the value of the specified @display option\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return $options[\"display\"]:get(this.display_options, args[1]);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "edit_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":edit_option(name) => returns the value of the specified edit option\";",
            "if ((caller == this) || ($object_utils:isa(caller, $generic_editor) || $perm_utils:controls(caller_perms(), this)))",
            "return $options[\"edit\"]:get(this.edit_options, args[1]);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_mail_option set_edit_option set_display_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":set_edit_option(oname,value)\";",
            "\":set_display_option(oname,value)\";",
            "\":set_mail_option(oname,value)\";",
            "\"Changes the value of the named option.\";",
            "\"Returns a string error if something goes wrong.\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return tostr(E_PERM);",
            "endif",
            "\"...this is kludgy, but it saves me from writing the same verb 3 times.\";",
            "\"...there's got to be a better way to do this...\";",
            "verb[1..4] = \"\";",
            "foo_options = verb + \"s\";",
            "prop = verb[1..index(verb, \"_\") - 1];",
            "\"...\";",
            "if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)",
            "return s;",
            "elseif (s == this.(foo_options))",
            "return 0;",
            "else",
            "this.(foo_options) = s;",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "@mailo*ptions @mail-o*ptions @edito*ptions @edit-o*ptions @displayo*ptions @display-o*ptions @generalo*ptions @general-o*ptions",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "\"@<what>-option <option> [is] <value>   sets <option> to <value>\";",
            "\"@<what>-option <option>=<value>        sets <option> to <value>\";",
            "\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";",
            "\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option <option>      displays value of <option>\";",
            "set_task_perms(player);",
            "what = {\"mail\", \"edit\", \"display\", \"general\"}[index(\"medg\", verb[2])];",
            "options = what + \"_options\";",
            "option_pkg = $options[what];",
            "set_option = (\"set_\" + what) + \"_option\";",
            "if (!args)",
            "player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});",
            "return;",
            "elseif (typeof(presult = option_pkg:parse(args)) == STR)",
            "player:notify(presult);",
            "return;",
            "else",
            "if (length(presult) > 1)",
            "if (typeof(sresult = this:(set_option)(@presult)) == STR)",
            "player:notify(sresult);",
            "return;",
            "elseif (!sresult)",
            "player:notify(\"No change.\");",
            "return;",
            "endif",
            "endif",
            "player:notify_lines(option_pkg:show(this.(options), presult[1]));",
            "endif"
          ]
        },
        {
          "name": "set_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"set_name(newname) attempts to change this.name to newname\";",
            "\"  => E_PERM   if you don't own this\";",
            "\"  => E_INVARG if the name is already taken or prohibited for some reason\";",
            "\"  => E_NACC   if the player database is not taking new names right now.\";",
            "\"  => E_ARGS   if the name is too long (controlled by $login.max_player_name)\";",
            "\"  => E_QUOTA  if the player is not allowed to change eir name.\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "elseif (!is_player(this))",
            "\"we don't worry about the names of player classes.\";",
            "set_task_perms(caller_perms());",
            "return pass(@args);",
            "elseif ($player_db.frozen)",
            "return E_NACC;",
            "elseif (length(name = args[1]) > $login.max_player_name)",
            "return E_ARGS;",
            "elseif (!($player_db:available(name, this) in {this, 1}))",
            "return E_INVARG;",
            "else",
            "old = this.name;",
            "this.name = name;",
            "if ((name != old) && (!(old in this.aliases)))",
            "$player_db:delete(old);",
            "endif",
            "$player_db:insert(name, this);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "set_aliases",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"set_aliases(alias_list)\";",
            "\"For changing player aliases, we check to make sure that none of the aliases match existing player names/aliases.  Aliases containing spaces are not entered in the $player_db and so are not subject to this restriction ($string_utils:match_player will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).\";",
            "\"Also we make sure that the .name is included in the .alias list.  In any situation where .name and .aliases are both being changed, do the name change first.\";",
            "\"  => 1        if successful, and aliases changed from previous setting.\";",
            "\"  => 0        if resulting work didn't change aliases from previous.\";",
            "\"  => E_PERM   if you don't own this\";",
            "\"  => E_NACC   if the player database is not taking new aliases right now.\";",
            "\"  => E_TYPE   if alias_list is not a list\";",
            "\"  => E_INVARG if any element of alias_list is not a string\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "elseif (!is_player(this))",
            "\"we don't worry about the names of player classes.\";",
            "return pass(@args);",
            "elseif ($player_db.frozen)",
            "return E_NACC;",
            "elseif (typeof(aliases = args[1]) != LIST)",
            "return E_TYPE;",
            "elseif ((length(aliases = setadd(aliases, this.name)) > ($object_utils:has_property($local, \"max_player_aliases\") ? $local.max_player_aliases | $maxint)) && (length(aliases) >= length(this.aliases)))",
            "return E_INVARG;",
            "else",
            "for a in (aliases)",
            "if (typeof(a) != STR)",
            "return E_INVARG;",
            "endif",
            "if ((!(index(a, \" \") || index(a, \"\t\"))) && (!($player_db:available(a, this) in {this, 1})))",
            "aliases = setremove(aliases, a);",
            "endif",
            "endfor",
            "old = this.aliases;",
            "this.aliases = aliases;",
            "for a in (old)",
            "if (!(a in aliases))",
            "$player_db:delete2(a, this);",
            "endif",
            "endfor",
            "for a in (aliases)",
            "if (!(index(a, \" \") || index(a, \"\t\")))",
            "$player_db:insert(a, this);",
            "endif",
            "endfor",
            "return this.aliases != old;",
            "endif"
          ]
        },
        {
          "name": "@rename*#",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 6,
          "code": [
            "if ((player != caller) || (player != this))",
            "return;",
            "endif",
            "set_task_perms(player);",
            "bynumber = verb == \"@rename#\";",
            "spec = $code_utils:parse_verbref(dobjstr);",
            "if (spec)",
            "if (!player.programmer)",
            "return player:notify(tostr(E_PERM));",
            "endif",
            "object = this:my_match_object(spec[1]);",
            "if (!$command_utils:object_match_failed(object, spec[1]))",
            "vname = spec[2];",
            "if (bynumber)",
            "vname = $code_utils:toint(vname);",
            "if (vname == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "endif",
            "try",
            "info = verb_info(object, vname);",
            "try",
            "result = set_verb_info(object, vname, listset(info, iobjstr, 3));",
            "player:notify(\"Verb name changed.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "except (E_VERBNF)",
            "player:notify(\"That object does not define that verb.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "elseif (bynumber)",
            "player:notify(\"@rename# can only be used with verbs.\");",
            "elseif (pspec = $code_utils:parse_propref(dobjstr))",
            "if (!player.programmer)",
            "return player:notify(tostr(E_PERM));",
            "endif",
            "object = this:my_match_object(pspec[1]);",
            "if (!$command_utils:object_match_failed(object, pspec[1]))",
            "pname = pspec[2];",
            "try",
            "info = property_info(object, pname);",
            "try",
            "result = set_property_info(object, pname, {@info, iobjstr});",
            "player:notify(\"Property name changed.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "except (E_PROPNF)",
            "player:notify(\"That object does not define that property.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "else",
            "object = this:my_match_object(dobjstr);",
            "if (!$command_utils:object_match_failed(object, dobjstr))",
            "old_name = object.name;",
            "old_aliases = object.aliases;",
            "if (e = $building_utils:set_names(object, iobjstr))",
            "if (strcmp(object.name, old_name) == 0)",
            "name_message = tostr(\"Name of \", object, \" (\", old_name, \") is unchanged\");",
            "else",
            "name_message = tostr(\"Name of \", object, \" changed to \\\"\", object.name, \"\\\"\");",
            "endif",
            "aliases = $string_utils:from_value(object.aliases, 1);",
            "if (object.aliases == old_aliases)",
            "alias_message = tostr(\".  Aliases are unchanged (\", aliases, \").\");",
            "else",
            "alias_message = tostr(\", with aliases \", aliases, \".\");",
            "endif",
            "player:notify(name_message + alias_message);",
            "elseif (e == E_INVARG)",
            "player:notify(\"That particular name change not allowed (see help @rename).\");",
            "if (object == player)",
            "player:notify($player_db:why_bad_name(player, iobjstr));",
            "endif",
            "elseif (e == E_NACC)",
            "player:notify(\"Oops.  You can't update that name right now; try again in a few minutes.\");",
            "elseif (e == E_ARGS)",
            "player:notify(tostr(\"Sorry, name too long.  Maximum number of characters in a name:  \", $login.max_player_name));",
            "elseif (e == 0)",
            "player:notify(\"Name and aliases remain unchanged.\");",
            "else",
            "player:notify(tostr(e));",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@addalias*# @add-alias*#",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 6,
          "code": [
            "\"Syntax: @addalias <alias>[,...,<alias>] to <object>\";",
            "\"        @addalias <alias>[,...,<alias>] to <object>:<verb>\";",
            "\"\";",
            "\"The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.\";",
            "\"\";",
            "\"Example:\";",
            "\"Muchkin wants to add new aliases to Rover the Wonder Dog:\";",
            "\"  @addalias Dog,Wonder Dog to Rover\";",
            "\"Since Rover the Wonder Dog already has the alias \\\"Dog\\\" but does not have the alias \\\"Wonder Dog\\\", Munchkin sees:\";",
            "\"  Rover the Wonder Dog(#4237) already has the alias Dog.\";",
            "\"  Alias Wonder Dog added to Rover the Wonder Dog(#4237).\";",
            "\"\";",
            "\"If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.\";",
            "\"\";",
            "\"Example:\";",
            "\"Munchkin wants to add his nicknames to his own list of aliases:\";",
            "\"  @addalias Foobar Davey to me\";",
            "\"@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias \\\"Davey\\\" so Munchkin sees:\";",
            "\"  DaveTheMan(#5432) is already using the alias Davey\";",
            "\"  Alias Foobar added to Munchkin(#1523).\";",
            "\"\";",
            "\"The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.\";",
            "if (player != this)",
            "return;",
            "endif",
            "set_task_perms(player);",
            "bynumber = verb[$] == \"#\";",
            "spec = $code_utils:parse_verbref(iobjstr);",
            "if (spec)",
            "if (!player.programmer)",
            "return player:notify(tostr(E_PERM));",
            "endif",
            "object = player:my_match_object(spec[1]);",
            "if (!$command_utils:object_match_failed(object, spec[1]))",
            "vname = spec[2];",
            "if (bynumber)",
            "if ((vname = $code_utils:toint(vname)) == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "endif",
            "try",
            "info = verb_info(object, vname);",
            "old_aliases = $string_utils:explode(info[3]);",
            "used = {};",
            "for alias in (new_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, \",\", \" \"))))",
            "if (alias in old_aliases)",
            "used = {@used, alias};",
            "new_aliases = setremove(new_aliases, alias);",
            "endif",
            "endfor",
            "if (used)",
            "player:notify(tostr(object.name, \"(\", object, \"):\", vname, \" already has the alias\", (length(used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(used), \".\"));",
            "endif",
            "if (new_aliases)",
            "info = listset(info, aliases = $string_utils:from_list({@old_aliases, @new_aliases}, \" \"), 3);",
            "try",
            "result = set_verb_info(object, vname, info);",
            "player:notify(tostr(\"Alias\", (length(new_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(new_aliases), \" added to verb \", object.name, \"(\", object, \"):\", vname));",
            "player:notify(tostr(\"Verbname is now \", object.name, \"(\", object, \"):\\\"\", aliases, \"\\\"\"));",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "if ((!new_aliases) && (!used))",
            "\"Pathological case, we failed to parse dobjstr, possibly consisted only of commas, spaces, or just the empty string\";",
            "player:notify(\"Did not understand what aliases to add from value:  \" + dobjstr);",
            "endif",
            "except (E_VERBNF)",
            "player:notify(\"That object does not define that verb.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "elseif (bynumber)",
            "player:notify(tostr(verb, \" can only be used with verbs.\"));",
            "else",
            "object = player:my_match_object(iobjstr);",
            "if (!$command_utils:object_match_failed(object, iobjstr))",
            "old_aliases = object.aliases;",
            "used = {};",
            "for alias in (new_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, \"trim\", $string_utils:explode(is_player(object) ? strsub(dobjstr, \" \", \",\") | dobjstr, \",\"))))",
            "if (alias in old_aliases)",
            "used = {@used, alias};",
            "new_aliases = setremove(new_aliases, alias);",
            "elseif (is_player(object) && valid(someone = $player_db:find_exact(alias)))",
            "player:notify(tostr(someone.name, \"(\", someone, \") is already using the alias \", alias, \".\"));",
            "new_aliases = setremove(new_aliases, alias);",
            "endif",
            "endfor",
            "if (used)",
            "player:notify(tostr(object.name, \"(\", object, \") already has the alias\", (length(used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(used), \".\"));",
            "endif",
            "if (new_aliases)",
            "if ((e = object:set_aliases(aliases = {@old_aliases, @new_aliases})) && (object.aliases == aliases))",
            "player:notify(tostr(\"Alias\", (length(new_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(new_aliases), \" added to \", object.name, \"(\", object, \").\"));",
            "player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are now \", $string_utils:from_value(aliases, 1)));",
            "elseif (e)",
            "player:notify(\"That particular name change not allowed (see help @rename or help @addalias).\");",
            "elseif (e == E_INVARG)",
            "if ($object_utils:has_property(#0, \"local\"))",
            "if ($object_utils:has_property($local, \"max_player_aliases\"))",
            "max = $local.max_player_aliases;",
            "player:notify((\"You are not allowed more than \" + tostr(max)) + \" aliases.\");",
            "endif",
            "else",
            "player:notify(\"You are not allowed any more aliases.\");",
            "endif",
            "elseif (e == E_NACC)",
            "player:notify(\"Oops.  You can't update that object's aliases right now; try again in a few minutes.\");",
            "elseif (e == 0)",
            "player:notify(\"Aliases not changed as expected!\");",
            "player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are now \", $string_utils:from_value(object.aliases, 1)));",
            "else",
            "player:notify(tostr(e));",
            "endif",
            "else",
            "player:tell(\"No new aliases found to add.\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@rmalias*# @rm-alias*#",
          "owner": 2,
          "perms": 89,
          "preps": 5,
          "object": 6,
          "code": [
            "\"Syntax: @rmalias <alias>[,...,<alias>] from <object>\";",
            "\"        @rmalias <alias>[,...,<alias>] from <object>:<verb>\";",
            "\"\";",
            "\"The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.\";",
            "\"[5/10/93 Nosredna: flushed above is_player feature\";",
            "\"Note that @rmalias will not affect the object's name, only its aliases.\";",
            "\"\";",
            "\"The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.\";",
            "if (player != this)",
            "return;",
            "endif",
            "set_task_perms(player);",
            "bynumber = verb[$] == \"#\";",
            "spec = $code_utils:parse_verbref(iobjstr);",
            "if (spec)",
            "if (!player.programmer)",
            "player:notify(tostr(E_PERM));",
            "endif",
            "object = player:my_match_object(spec[1]);",
            "if (!$command_utils:object_match_failed(object, spec[1]))",
            "vname = spec[2];",
            "if (bynumber)",
            "if ((vname = $code_utils:toint(vname)) == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "endif",
            "try",
            "info = verb_info(object, vname);",
            "old_aliases = $string_utils:explode(info[3]);",
            "not_used = {};",
            "for alias in (bad_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, \",\", \" \"))))",
            "if (!(alias in old_aliases))",
            "not_used = {@not_used, alias};",
            "bad_aliases = setremove(bad_aliases, alias);",
            "else",
            "old_aliases = setremove(old_aliases, alias);",
            "endif",
            "endfor",
            "if (not_used)",
            "player:notify(tostr(object.name, \"(\", object, \"):\", vname, \" does not have the alias\", (length(not_used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(not_used), \".\"));",
            "endif",
            "if (bad_aliases && old_aliases)",
            "info = listset(info, aliases = $string_utils:from_list(old_aliases, \" \"), 3);",
            "try",
            "result = set_verb_info(object, vname, info);",
            "player:notify(tostr(\"Alias\", (length(bad_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(bad_aliases), \" removed from verb \", object.name, \"(\", object, \"):\", vname));",
            "player:notify(tostr(\"Verbname is now \", object.name, \"(\", object, \"):\\\"\", aliases, \"\\\"\"));",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "elseif (!old_aliases)",
            "player:notify(\"You have to leave a verb with at least one alias.\");",
            "else",
            "player:notify(\"No aliases removed.\");",
            "endif",
            "except (E_VERBNF)",
            "player:notify(\"That object does not define that verb.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "elseif (bynumber)",
            "player:notify(tostr(verb, \" can only be used with verbs.\"));",
            "else",
            "object = player:my_match_object(iobjstr);",
            "if (!$command_utils:object_match_failed(object, iobjstr))",
            "old_aliases = object.aliases;",
            "not_used = {};",
            "for alias in (bad_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, \"trim\", $string_utils:explode(dobjstr, \",\"))))",
            "\"removed is_player(object) ? strsub(dobjstr, \\\" \\\", \\\",\\\") | --Nosredna\";",
            "if (!(alias in old_aliases))",
            "not_used = {@not_used, alias};",
            "bad_aliases = setremove(bad_aliases, alias);",
            "else",
            "old_aliases = setremove(old_aliases, alias);",
            "endif",
            "endfor",
            "if (not_used)",
            "player:notify(tostr(object.name, \"(\", object, \") does not have the alias\", (length(not_used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(not_used), \".\"));",
            "endif",
            "if (bad_aliases)",
            "if (e = object:set_aliases(old_aliases))",
            "player:notify(tostr(\"Alias\", (length(bad_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(bad_aliases), \" removed from \", object.name, \"(\", object, \").\"));",
            "player:notify(tostr(\"Aliases for \", object.name, \"(\", object, \") are now \", $string_utils:from_value(old_aliases, 1)));",
            "elseif (e == E_INVARG)",
            "player:notify(\"That particular name change not allowed (see help @rename or help @rmalias).\");",
            "elseif (e == E_NACC)",
            "player:notify(\"Oops.  You can't update that object's aliases right now; try again in a few minutes.\");",
            "elseif (e == 0)",
            "player:notify(\"Aliases not changed as expected!\");",
            "player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are \", $string_utils:from_value(object.aliases, 1)));",
            "else",
            "player:notify(tostr(e));",
            "endif",
            "else",
            "player:notify(\"Aliases unchanged.\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@desc*ribe",
          "owner": 2,
          "perms": 89,
          "preps": 13,
          "object": 6,
          "code": [
            "set_task_perms(player);",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "\"...lose...\";",
            "elseif (e = dobj:set_description(iobjstr))",
            "player:notify(\"Description set.\");",
            "else",
            "player:notify(tostr(e));",
            "endif"
          ]
        },
        {
          "name": "@mess*ages",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(player);",
            "if (dobjstr == \"\")",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>\"));",
            "return;",
            "endif",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "found_one = 0;",
            "props = $object_utils:all_properties(dobj);",
            "if (typeof(props) == ERR)",
            "player:notify(\"You can't read the messages on that.\");",
            "return;",
            "endif",
            "for pname in (props)",
            "len = length(pname);",
            "if ((len > 4) && (pname[len - 3..len] == \"_msg\"))",
            "found_one = 1;",
            "msg = `dobj.(pname) ! ANY';",
            "if (msg == E_PERM)",
            "value = \"isn't readable by you.\";",
            "elseif (!msg)",
            "value = \"isn't set.\";",
            "elseif (typeof(msg) == LIST)",
            "value = \"is a list.\";",
            "elseif (typeof(msg) != STR)",
            "value = \"is corrupted! **\";",
            "else",
            "value = \"is \" + $string_utils:print(msg);",
            "endif",
            "player:notify(tostr(\"@\", pname[1..len - 4], \" \", dobjstr, \" \", value));",
            "endif",
            "endfor",
            "if (!found_one)",
            "player:notify(\"That object doesn't have any messages to set.\");",
            "endif"
          ]
        },
        {
          "name": "@notedit",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "$note_editor:invoke(dobjstr, verb);"
          ]
        },
        {
          "name": "@last-c*onnection",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "\"@last-c           reports when and from where you last connected.\";",
            "\"@last-c all       adds the 10 most recent places you connected from.\";",
            "\"@last-c confunc   is like `@last-c' but is silent on first login.\";",
            "opts = {\"all\", \"confunc\"};",
            "i = 0;",
            "if (caller != this)",
            "return E_PERM;",
            "elseif (args && ((length(args) > 1) || (!(i = $string_utils:find_prefix(args[1], opts)))))",
            "this:notify(tostr(\"Usage:  \", verb, \" [all]\"));",
            "return;",
            "endif",
            "opt_all = i && (opts[i] == \"all\");",
            "opt_confunc = i && (opts[i] == \"confunc\");",
            "if (!(prev = this.previous_connection))",
            "this:notify(\"Something was broken when you logged in; tell a wizard.\");",
            "elseif (prev[1] == 0)",
            "opt_confunc || this:notify(\"Your previous connection was before we started keeping track.\");",
            "elseif (prev[1] > time())",
            "this:notify(\"This is your first time connected.\");",
            "else",
            "this:notify(tostr(\"Last connected \", this:ctime(prev[1]), \" from \", prev[2]));",
            "if (opt_all)",
            "this:notify(\"Previous connections have been from the following sites:\");",
            "for l in (this.all_connect_places)",
            "this:notify(\"   \" + l);",
            "endfor",
            "endif",
            "endif"
          ]
        },
        {
          "name": "set_brief",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"set_brief(value)\";",
            "\"set_brief(value, anything)\";",
            "\"If <anything> is given, add value to the current value; otherwise, just set the value.\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "else",
            "if (length(args) == 1)",
            "this.brief = args[1];",
            "else",
            "this.brief = this.brief + args[1];",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@mode",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "\"@mode <mode>\";",
            "\"Current modes are brief and verbose.\";",
            "\"General verb for setting player `modes'.\";",
            "\"Modes are coded right here in the verb.\";",
            "if (caller != this)",
            "player:tell(\"You can't set someone else's modes.\");",
            "return E_PERM;",
            "endif",
            "modes = {\"brief\", \"verbose\"};",
            "mode = `modes[$string_utils:find_prefix(dobjstr, modes)] ! E_TYPE, E_RANGE => 0';",
            "if (!mode)",
            "player:tell(\"Unknown mode \\\"\", dobjstr, \"\\\".  Known modes:\");",
            "for mode in (modes)",
            "player:tell(\"  \", mode);",
            "endfor",
            "return 0;",
            "elseif (mode == \"brief\")",
            "this:set_brief(1);",
            "elseif (mode == \"verbose\")",
            "this:set_brief(0);",
            "endif",
            "player:tell($string_utils:capitalize(mode), \" mode set.\");",
            "return 1;"
          ]
        },
        {
          "name": "exam*ine @exam*ine",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>\"));",
            "return E_INVARG;",
            "endif",
            "what = player.location:match_object(dobjstr);",
            "if ($command_utils:object_match_failed(what, dobjstr))",
            "return;",
            "endif",
            "what:do_examine(player);"
          ]
        },
        {
          "name": "add_feature",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Add a feature to this player's features list.  Caller must be this or have suitable permissions (this or wizardly).\";",
            "\"If this is a nonprogrammer, then ask feature if it is feature_ok (that is, if it has a verb :feature_ok which returns a true value, or a property .feature_ok which is true).\";",
            "\"After adding feature, call feature:feature_add(this).\";",
            "\"Returns true if successful, E_INVARG if not a valid object, and E_PERM if !feature_ok or if caller doesn't have permission.\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "feature = args[1];",
            "if ((typeof(feature) != OBJ) || (!valid(feature)))",
            "return E_INVARG;",
            "\"Not a valid object.\";",
            "endif",
            "if ($code_utils:verb_or_property(feature, \"feature_ok\", this))",
            "\"The object is willing to be a feature.\";",
            "if (typeof(this.features) == LIST)",
            "\"If list, we can simply setadd the feature.\";",
            "this.features = setadd(this.features, feature);",
            "else",
            "\"If not, we erase the old value and create a new list.\";",
            "this.features = {feature};",
            "endif",
            "\"Tell the feature it's just been added.\";",
            "try",
            "feature:feature_add(this);",
            "except (ANY)",
            "\"just ignore errors.\";",
            "endtry",
            "return 1;",
            "\"We're done.\";",
            "else",
            "return E_PERM;",
            "\"Feature isn't feature_ok.\";",
            "endif",
            "else",
            "return E_PERM;",
            "\"Caller doesn't have permission.\";",
            "endif"
          ]
        },
        {
          "name": "remove_feature",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Remove a feature from this player's features list.  Caller must be this, or have permissions of this, a wizard, or feature.owner.\";",
            "\"Returns true if successful, E_PERM if caller didn't have permission.\";",
            "feature = args[1];",
            "if (((caller == this) || $perm_utils:controls(caller_perms(), this)) || (caller_perms() == feature.owner))",
            "if (typeof(this.features) == LIST)",
            "\"If this is a list, we can just setremove...\";",
            "this.features = setremove(this.features, feature);",
            "\"Otherwise, we leave it alone.\";",
            "endif",
            "\"Let the feature know it's been removed.\";",
            "try",
            "feature:feature_remove(this);",
            "except (ANY)",
            "\"just ignore errors.\";",
            "endtry",
            "return 1;",
            "\"We're done.\";",
            "else",
            "return E_PERM;",
            "\"Caller didn't have permission.\";",
            "endif"
          ]
        },
        {
          "name": "@add-feature @addfeature",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Usage:\";",
            "\"  @add-feature\";",
            "\"  @add-feature <feature object>\";",
            "\"Modified 10 Oct 94, by Michele, to check the warehouse and match.\";",
            "\"Lists all features or adds an object to your features list.\";",
            "set_task_perms(player);",
            "if (dobjstr)",
            "if (dobj == $failed_match)",
            "dobj = $feature.warehouse:match_object(dobjstr);",
            "endif",
            "if (!$command_utils:object_match_failed(dobj, dobjstr))",
            "if (dobj in player.features)",
            "player:tell(dobjstr, \" is already one of your features.\");",
            "elseif (player:add_feature(dobj))",
            "player:tell(dobj, \" (\", dobj.name, \") added as a feature.\");",
            "else",
            "player:tell(\"You can't seem to add \", dobj, \" (\", dobj.name, \") to your features list.\");",
            "endif",
            "endif",
            "else",
            "player:tell(\"Usage:  @add-feature <object>\");",
            "if (length($feature.warehouse.contents) < 20)",
            "player:tell(\"Available features include:\");",
            "player:tell(\"--------------------------\");",
            "fe = {};",
            "for c in ($feature.warehouse.contents)",
            "fe = {(c in player.features) ? c:title() + \" (*)\" | c:title()};",
            "player:tell(\"  \" + $string_utils:english_list(fe));",
            "endfor",
            "player:tell(\"--------------------------\");",
            "player:tell(\"A * after the feature name means that you already have that feature.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@remove-feature @rmfeature",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Usage:  @remove-feature <feature object>\";",
            "\"Remove an object from your .features list.\";",
            "set_task_perms(player);",
            "if (dobjstr)",
            "features = player.features;",
            "if (!valid(dobj))",
            "dobj = $string_utils:match(dobjstr, features, \"name\", features, \"aliases\");",
            "endif",
            "if (!$command_utils:object_match_failed(dobj, dobjstr))",
            "if (dobj in features)",
            "player:remove_feature(dobj);",
            "player:tell(dobj, \" (\", dobj.name, \") removed from your features list.\");",
            "else",
            "player:tell(dobjstr, \" is not one of your features.\");",
            "endif",
            "endif",
            "else",
            "player:tell(\"Usage:  @remove-feature <object>\");",
            "endif"
          ]
        },
        {
          "name": "@features",
          "owner": 2,
          "perms": 93,
          "preps": 11,
          "object": 6,
          "code": [
            "\"Usage:  @features [<name>] for <player>\";",
            "\"List the feature objects matching <name> used by <player>.\";",
            "if (!iobjstr)",
            "player:tell(\"Usage: @features [<name>] for <player>\");",
            "return;",
            "elseif ($command_utils:player_match_failed(whose = $string_utils:match_player(iobjstr), iobjstr))",
            "return;",
            "endif",
            "features = {};",
            "for feature in (whose.features)",
            "if (!valid(feature))",
            "whose:remove_feature(feature);",
            "elseif ((!dobjstr) || ((dobjstr in feature.aliases) || ((pref = $string_utils:find_prefix(dobjstr, feature.aliases)) || (pref == $ambiguous_match))))",
            "features = listappend(features, feature);",
            "endif",
            "endfor",
            "if (features)",
            "len = max(length(\"Feature\"), length(tostr(max_object()))) + 1;",
            "player:tell($string_utils:left(\"Feature\", len), \"Name\");",
            "player:tell($string_utils:left(\"-------\", len), \"----\");",
            "for feature in (features)",
            "player:tell($string_utils:left(tostr(feature), len), feature.name);",
            "endfor",
            "player:tell($string_utils:left(\"-------\", len), \"----\");",
            "cstr = ((tostr(length(features)) + \" feature\") + ((length(features) > 1) ? \"s\" | \"\")) + \" found\";",
            "if (whose != this)",
            "cstr = ((((cstr + \" on \") + whose.name) + \" (\") + tostr(whose)) + \")\";",
            "endif",
            "if (dobjstr)",
            "cstr = ((cstr + \" matching \\\"\") + dobjstr) + \"\\\"\";",
            "endif",
            "cstr = cstr + \".\";",
            "player:tell(cstr);",
            "elseif (dobjstr)",
            "player:tell(\"No features found on \", whose.name, \" (\", whose, \") matching \\\"\", dobjstr, \"\\\".\");",
            "else",
            "player:tell(\"No features found on \", whose.name, \" (\", whose, \").\");",
            "endif"
          ]
        },
        {
          "name": "@features",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Usage:  @features [<name>]\";",
            "\"List the feature objects matching <name> used by player.\";",
            "iobjstr = player.name;",
            "iobj = player;",
            "this:(\"@features\")();"
          ]
        },
        {
          "name": "@memory",
          "owner": 36,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Return information about the MOO's current memory usage.\";",
            "\"memory_info returns in pages. You can get KB by multiplying by 4.\";",
            "\"Values: total size, resident set size, shared pages, text (code), data + stack\";",
            "mem = call_function(\"memory_usage\");",
            "MB = 0.001;",
            "PAGE = 4.0;",
            "player:tell($network.moo_name, \" Memory Statistics\");",
            "player:tell();",
            "player:tell(\"Total Memory Usage: \", (mem[1] * PAGE) * MB, \" MB\");",
            "player:tell(\"Resident Set Size:  \", (mem[2] * PAGE) * MB, \" MB\");",
            "player:tell(\"Shared Pages:       \", (mem[3] * PAGE) * MB, \" MB\");",
            "player:tell(\"Text (Code):        \", (mem[4] * PAGE) * MB, \" MB\");",
            "player:tell(\"Data + Stack:       \", (mem[5] * PAGE) * MB, \" MB\");"
          ]
        },
        {
          "name": "@version",
          "owner": 36,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "if ($object_utils:has_property($local, \"server_hardware\"))",
            "hw = (\" on \" + $local.server_hardware) + \".\";",
            "else",
            "hw = \".\";",
            "endif",
            "server_version = server_version();",
            "if (server_version[1] == \"v\")",
            "server_version[1..1] = \"\";",
            "endif",
            "player:notify(tostr(\"The MOO is currently running version \", server_version, \" of the \", $server[\"name\"], \" server code\", hw));",
            "try",
            "{MOOname, sversion, coretime} = $server[\"core_history\"][1];",
            "player:notify(tostr(\"The database was derived from a core created on \", $time_utils:time_sub(\"$n $t, $Y\", coretime), \" at \", MOOname, \" for version \", sversion, \" of the server.\"));",
            "except (E_RANGE)",
            "player:notify(\"The database was created from scratch.\");",
            "except (ANY)",
            "player:notify(\"No information is available on the database version.\");",
            "endtry"
          ]
        },
        {
          "name": "@uptime",
          "owner": 36,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "player:notify(tostr($network.MOO_name, \" has been up for \", $time_utils:english_time(time() - $server[\"last_restart_time\"], $server[\"last_restart_time\"]), \".\"));"
          ]
        },
        {
          "name": "@quit",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 6,
          "code": [
            "boot_player(player);",
            "\"-- argh, let the player decide; #3:disfunc() takes care of this --Rog\";",
            "\"player:moveto(player.home)\";"
          ]
        },
        {
          "name": "examine_commands_ok",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "return this == args[1];"
          ]
        },
        {
          "name": "is_listening",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"return true if player is active.\";",
            "return typeof(`idle_seconds(this) ! ANY') != ERR;"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (args[1] == #-1)",
            "return E_INVARG;",
            "this:notify(\"You are now in #-1, The Void.  Type `home' to get back.\");",
            "endif",
            "set_task_perms(caller_perms());",
            "pass(@args);"
          ]
        },
        {
          "name": "announce*_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "return this.location:(verb)(@args);",
            "\"temporarily let player:announce be noisy to player\";",
            "if (verb == \"announce_all_but\")",
            "if (this in args[1])",
            "return;",
            "endif",
            "args = args[2..$];",
            "endif",
            "this:tell(\"(from within you) \", @args);"
          ]
        },
        {
          "name": "linewrap",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Return a true value if this needs linewrapping.\";",
            "\"default is true if .linelen > 0\";",
            "return this.linelen > 0;"
          ]
        },
        {
          "name": "@set-note-string @set-note-text",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Usage:  @set-note-{string | text} {#xx | #xx.pname}\";",
            "\"        ...lines of text...\";",
            "\"        .\";",
            "\"\";",
            "\"For use by clients' local editors, to save new text for a note or object property.  See $note_editor:local_editing_info() for details.\";",
            "text = $command_utils:read_lines_escape((active = player in $note_editor.active) ? {} | {\"@edit\"}, {tostr(\"Changing \", argstr, \".\"), @active ? {} | {\"Type `@edit' to take this into the note editor.\"}});",
            "if (text && (text[1] == \"@edit\"))",
            "$note_editor:invoke(argstr, verb);",
            "who = $note_editor:loaded(player);",
            "if (who)",
            "$note_editor.texts[who] = text[2];",
            "endif",
            "return;",
            "endif",
            "set_task_perms(player);",
            "text = text[2];",
            "if ((verb == \"@set-note-string\") && (length(text) <= 1))",
            "text = text ? text[1] | \"\";",
            "endif",
            "if (spec = $code_utils:parse_propref(argstr))",
            "o = player:my_match_object(spec[1]);",
            "p = spec[2];",
            "if ($object_utils:has_verb(o, vb = \"set_\" + p) && (typeof(e = o:(vb)(text)) != ERR))",
            "player:tell(\"Set \", p, \" property of \", o.name, \" (\", o, \") via :\", vb, \".\");",
            "else",
            "original = text;",
            "for x in [1..length(text)]",
            "$sin(0);",
            "value = $string_utils:to_value(text[x]);",
            "if (value[1] != 1)",
            "player:tell(\"Error:  \", value[2]);",
            "player:tell(\"... assuming data is all text.\");",
            "text = original;",
            "break;",
            "else",
            "text[x] = value[2];",
            "endif",
            "endfor",
            "if (text != (e = `o.(p) = text ! ANY'))",
            "player:tell(\"Error:  \", e);",
            "else",
            "player:tell(\"Set \", p, \" property of \", o.name, \" (\", o, \").\");",
            "endif",
            "endif",
            "elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)",
            "e = note:set_text(text);",
            "if (typeof(e) == ERR)",
            "player:tell(\"Error:  \", e);",
            "else",
            "player:tell(\"Set text of \", note.name, \" (\", note, \").\");",
            "endif",
            "else",
            "player:tell(\"Error:  Malformed argument to \", verb, \": \", argstr);",
            "endif"
          ]
        },
        {
          "name": "ownership_quota",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this))",
            "return this.(verb);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "tell_lines",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "lines = args[1];",
            "if (typeof(lines) != LIST)",
            "lines = {lines};",
            "endif",
            "if (this.gaglist || this.paranoid)",
            "\"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.\";",
            "if (this:gag_p())",
            "return;",
            "endif",
            "if (this.paranoid == 2)",
            "z = this:whodunnit({@callers(1), {player, \"\", player}}, {this, $no_one}, {})[3];",
            "lines = {(((\"[start text by \" + z.name) + \" (\") + tostr(z)) + \")]\", @lines, (((\"[end text by \" + z.name) + \" (\") + tostr(z)) + \")]\"};",
            "elseif (this.paranoid == 1)",
            "$paranoid_db:add_data(this, {{@callers(1), {player, \"<cmd-line>\", player}}, lines});",
            "endif",
            "endif",
            "this:notify_lines(lines);"
          ]
        },
        {
          "name": "@lastlog",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Copied from generic room (#3):@lastlog by Haakon (#2) Wed Dec 30 13:30:02 1992 PST\";",
            "if (dobjstr != \"\")",
            "dobj = $string_utils:match_player(dobjstr);",
            "if (!valid(dobj))",
            "player:tell(\"Who?\");",
            "return;",
            "endif",
            "folks = {dobj};",
            "else",
            "folks = players();",
            "endif",
            "if (length(folks) > 100)",
            "player:tell(\"You have requested a listing of \", length(folks), \" players.  That is too long a list; specify individual players you are interested in.\");",
            "return;",
            "endif",
            "day = week = month = ever = never = {};",
            "a_day = (24 * 60) * 60;",
            "a_week = 7 * a_day;",
            "a_month = 30 * a_day;",
            "now = time();",
            "for x in (folks)",
            "when = x.last_connect_time;",
            "how_long = now - when;",
            "if ((when == 0) || (when > now))",
            "never = {@never, x};",
            "elseif (how_long < a_day)",
            "day = {@day, x};",
            "elseif (how_long < a_week)",
            "week = {@week, x};",
            "elseif (how_long < a_month)",
            "month = {@month, x};",
            "else",
            "ever = {@ever, x};",
            "endif",
            "endfor",
            "for entry in ({{day, \"the last day\"}, {week, \"the last week\"}, {month, \"the last 30 days\"}, {ever, \"recorded history\"}})",
            "if (entry[1])",
            "player:tell(\"Players who have connected within \", entry[2], \":\");",
            "for x in (entry[1])",
            "player:tell(\"  \", x.name, \" last connected \", ctime(x.last_connect_time), \".\");",
            "endfor",
            "endif",
            "endfor",
            "if (never)",
            "player:tell(\"Players who have never connected:\");",
            "player:tell(\"  \", $string_utils:english_list($list_utils:map_prop(never, \"name\")));",
            "endif"
          ]
        },
        {
          "name": "set_linelength",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Set linelength.  Linelength must be an integer >= 10.\";",
            "\"If wrap is currently off (i.e. linelength is less than 0), maintains sign.  That is, this function *takes* an absolute value, and coerces the sign to be appropriate.\";",
            "\"If you want to override the dwimming of wrap, pass in a second argument.\";",
            "\"returns E_PERM if not allowed, E_INVARG if linelength is too low, otherwise the linelength.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (abs(len = args[1]) < 10)",
            "return E_INVARG;",
            "elseif (length(args) > 1)",
            "this.linelen = len;",
            "else",
            "\"DWIM here.\";",
            "this.linelen = (this.linelen > 0) ? len | (-len);",
            "return len;",
            "endif"
          ]
        },
        {
          "name": "set_pagelength",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Set pagelength. Must be an integer >= 5, or 0 to turn pagelength off.\";",
            "\"Returns E_PERM if you shouldn't be doing this, E_INVARG if it's too low, otherwise, what it got set to.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (((len = args[1]) < 5) && (len != 0))",
            "return E_INVARG;",
            "else",
            "if ((this.pagelen = len) == 0)",
            "if (lb = this.linebuffer)",
            "\"queued text remains\";",
            "this:notify_lines(lb);",
            "clear_property(this, \"linebuffer\");",
            "endif",
            "endif",
            "return len;",
            "endif"
          ]
        },
        {
          "name": "set_home",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\"set_home(newhome) attempts to change this.home to newhome\";",
            "\"E_TYPE   if newhome doesn't have a callable :accept_for_abode verb.\";",
            "\"E_INVARG if newhome won't accept you as a resident.\";",
            "\"E_PERM   if you don't own this and aren't its parent.\";",
            "\"1        if it works.\";",
            "newhome = args[1];",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "if ($object_utils:has_callable_verb(newhome, \"accept_for_abode\"))",
            "if (newhome:accept_for_abode(this))",
            "return (typeof(e = `this.home = args[1] ! ANY') != ERR) || e;",
            "else",
            "return E_INVARG;",
            "endif",
            "else",
            "return E_TYPE;",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "@registerme",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "\"@registerme as <email-address> -- enter a new email address for player\";",
            "\"   will change the database entry, assign a new password, and mail the new password to the player at the given email address.\";",
            "if (player != this)",
            "return player:notify(tostr(E_PERM));",
            "endif",
            "who = this;",
            "if ($object_utils:isa(this, $guest))",
            "who:notify(\"Sorry, guests should use the '@request' command to request a character.\");",
            "return;",
            "endif",
            "connection = $string_utils:connection_hostname(who);",
            "if (!argstr)",
            "if ($wiz_utils:get_email_address(who))",
            "player:tell(\"You are currently registered as:  \", $wiz_utils:get_email_address(who));",
            "else",
            "player:tell(\"You are not currently registered.\");",
            "endif",
            "player:tell(\"Use @registerme as <address> to change this.\");",
            "return;",
            "elseif (((prepstr != \"as\") || (!iobjstr)) || dobjstr)",
            "player:tell(\"Usage: @registerme as <address>\");",
            "return;",
            "endif",
            "email = iobjstr;",
            "if (email == $wiz_utils:get_email_address(this))",
            "who:notify(\"That is your current address.  Not changed.\");",
            "return;",
            "elseif (reason = $wiz_utils:check_reregistration(this, email, connection))",
            "if (reason[1] == \"-\")",
            "if (!$command_utils:yes_or_no(reason[2..$] + \". Automatic registration not allowed. Ask to be registered at this address anyway?\"))",
            "who:notify(\"Okay.\");",
            "return;",
            "endif",
            "else",
            "return who:notify(tostr(reason, \" Please try again.\"));",
            "endif",
            "endif",
            "if ($network.active && (!reason))",
            "if (!$command_utils:yes_or_no(tostr(\"If you continue, your password will be changed, the new password mailed to `\", email, \"'. Do you want to continue?\")))",
            "return who:notify(\"Registration terminated.\");",
            "endif",
            "password = $wiz_utils:random_password(5);",
            "old = $wiz_utils:get_email_address(who) || \"[ unregistered ]\";",
            "who:notify(tostr(\"Registering you, and changing your password and mailing new one to \", email, \".\"));",
            "result = $network:sendmail(email, tostr(\"Your \", $network.MOO_Name, \" character, \", who.name), \"Reply-to: \" + $login.registration_address, @$generic_editor:fill_string(tostr(\"Your \", $network.MOO_name, \" character, \", $string_utils:nn(who), \" has been registered to this email address (\", email, \"), and a new password assigned.  The new password is `\", password, \"'. Please keep your password secure. You can change your password with the @password command.\"), 75));",
            "if (result != 0)",
            "who:notify(tostr(\"Mail sending did not work: \", reason, \". Reregistration terminated.\"));",
            "return;",
            "endif",
            "who:notify(tostr(\"Mail with your new password forwarded. If you do not get it, send regular email to \", $login.registration_address, \" with your character name.\"));",
            "$mail_agent:send_message($new_player_log, $new_player_log, \"reg \" + $string_utils:nn(this), {email, tostr(\"formerly \", old)});",
            "$registration_db:add(this, email, \"Reregistered at \" + ctime());",
            "$wiz_utils:set_email_address(this, email);",
            "who.password = $login:encrypt_password(password);",
            "who.last_password_time = time();",
            "else",
            "who:notify(\"No automatic reregistration: your request will be forwarded.\");",
            "if (typeof(curreg = $registration_db:find(email)) == LIST)",
            "additional_info = {\"Current registration information for this email address:\", @$registration_db:describe_registration(curreg)};",
            "else",
            "additional_info = {};",
            "endif",
            "$mail_agent:send_message(this, $registration_db.registrar, \"Registration request\", {(((\"Reregistration request from \" + $string_utils:nn(who)) + \" connected via \") + connection) + \":\", \"\", ((\"@register \" + who.name) + \" \") + email, (\"@new-password \" + who.name) + \" is \", \"\", \"Reason this request was forwarded:\", reason, @additional_info});",
            "endif"
          ]
        },
        {
          "name": "ctime",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "\":ctime([INT time]) => STR as the function.\";",
            "\"May be hacked by players and player-classes to reflect differences in time-zone.\";",
            "return ctime(@args);"
          ]
        },
        {
          "name": "@age",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "if ((dobjstr == \"\") || (dobj == player))",
            "dobj = player;",
            "else",
            "dobj = $string_utils:match_player(dobjstr);",
            "if (!valid(dobj))",
            "$command_utils:player_match_failed(dobj, dobjstr);",
            "return;",
            "endif",
            "endif",
            "time = dobj.first_connect_time;",
            "if (time == $maxint)",
            "duration = time() - dobj.last_disconnect_time;",
            "if (duration < 86400)",
            "notice = $string_utils:from_seconds(duration);",
            "else",
            "notice = $time_utils:english_time((duration / 86400) * 86400);",
            "endif",
            "player:notify(tostr(dobj.name, \" has never connected.  It was created \", notice, \" ago.\"));",
            "elseif (time == 0)",
            "player:notify(tostr(dobj.name, \" first connected before initial connections were being recorded.\"));",
            "else",
            "player:notify(tostr(dobj.name, \" first connected on \", ctime(time)));",
            "duration = time() - time;",
            "if (duration < 86400)",
            "notice = $string_utils:from_seconds(duration);",
            "else",
            "notice = $time_utils:english_time((duration / 86400) * 86400);",
            "endif",
            "player:notify(tostr($string_utils:pronoun_sub(\"%S %<is> \", dobj), notice, \" old.\"));",
            "endif"
          ]
        },
        {
          "name": "news",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Usage: news [contents] [articles]\";",
            "\"\";",
            "\"Common uses:\";",
            "\"news           -- display all current news, or as @mail-options decree\";",
            "\"news new       -- display articles you haven't seen yet\";",
            "\"news all       -- display all current news\";",
            "\"news contents  -- display headers of current news\";",
            "\"news <article> -- display article\";",
            "\"news archive   -- display news which has been marked as archived.\";",
            "set_task_perms(player);",
            "cur = this:get_current_message($news) || {0, 0};",
            "arch = 0;",
            "if (((!args) && (o = player:mail_option(\"news\"))) && (o != \"all\"))",
            "\"no arguments, use the player's default\";",
            "args = {o};",
            "elseif (args == {\"all\"})",
            "args = {};",
            "elseif (args == {\"archive\"})",
            "arch = 1;",
            "args = {};",
            "endif",
            "if (hdrs_only = args && (args[1] == \"contents\"))",
            "\"Do the mail contents list\";",
            "args[1..1] = {};",
            "endif",
            "if (args)",
            "if (typeof(seq = $news:_parse(args, @cur)) == STR)",
            "player:notify(seq);",
            "return;",
            "elseif (seq = $seq_utils:intersection(seq, $news.current_news))",
            "else",
            "player:notify((args == {\"new\"}) ? \"No new news.\" | \"None of those are current articles.\");",
            "return;",
            "endif",
            "elseif (arch && (seq = $news.archive_news))",
            "\"yduJ hates this coding style.  Just so you know.\";",
            "elseif (seq = $news.current_news)",
            "else",
            "player:notify(\"No news\");",
            "return;",
            "endif",
            "if (hdrs_only)",
            "$news:display_seq_headers(seq, @cur);",
            "else",
            "player:set_current_message($news, @$news:news_display_seq_full(seq));",
            "endif"
          ]
        },
        {
          "name": "@edit",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "\"Calls the verb editor on verbs, the note editor on properties, and on anything else assumes it's an object for which you want to edit the .description.\";",
            "if (!args)",
            "((player in $note_editor.active) ? $note_editor | $verb_editor):invoke(dobjstr, verb);",
            "elseif ($code_utils:parse_verbref(args[1]))",
            "if (player.programmer)",
            "$verb_editor:invoke(argstr, verb);",
            "else",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "endif",
            "else",
            "$note_editor:invoke(dobjstr, verb);",
            "endif"
          ]
        },
        {
          "name": "erase_paranoid_data",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "else",
            "$paranoid_db:erase_data(this);",
            "endif"
          ]
        },
        {
          "name": "@move-new",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";",
            "set_task_perms((caller == this) ? this | $no_one);",
            "if ((prepstr != \"to\") || (!iobjstr))",
            "player:tell(\"Usage: @move <object> to <location>\");",
            "return;",
            "endif",
            "if ((!dobjstr) || (dobjstr == \"me\"))",
            "dobj = this;",
            "else",
            "dobj = here:match_object(dobjstr);",
            "if (!valid(dobj))",
            "dobj = player:my_match_object(dobjstr);",
            "endif",
            "endif",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "iobj = this:lookup_room(iobjstr);",
            "if ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr))",
            "return;",
            "endif",
            "if (((!player.programmer) && (!$perm_utils:controls(this, dobj))) && (this != dobj))",
            "player:tell(\"You may only @move your own things.\");",
            "return;",
            "endif",
            "this:teleport(dobj, iobj);"
          ]
        },
        {
          "name": "notify_lines_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))",
            "set_task_perms(caller_perms());",
            "for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)",
            "$command_utils:suspend_if_needed(0);",
            "this:notify(tostr(line));",
            "endfor",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "_chparent",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(caller_perms());",
            "return chparent(@args);"
          ]
        },
        {
          "name": "@users",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 6,
          "code": [
            "\"Prints a count and compact list of the currently-connected players, sorted into columns.\";",
            "cp = connected_players();",
            "linelen = player:linelen() || 79;",
            "player:tell((\"There are \" + tostr(length(cp))) + \" players connected:\");",
            "dudes = $list_utils:map_prop(cp, \"name\");",
            "dudes = $list_utils:sort_suspended($login.current_lag, dudes);",
            "player:tell_lines($string_utils:columnize(dudes, 4, linelen));"
          ]
        },
        {
          "name": "@password",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "if (typeof(player.password) != STR)",
            "if (length(args) != 1)",
            "return player:notify(tostr(\"Usage:  \", verb, \" <new-password>\"));",
            "else",
            "new_password = args[1];",
            "endif",
            "elseif (length(args) != 2)",
            "player:notify(tostr(\"Usage:  \", verb, \" <old-password> <new-password>\"));",
            "return;",
            "elseif (!argon2_verify(player.password, args[1]))",
            "player:notify(\"That's not your old password.\");",
            "return;",
            "elseif (is_clear_property(player, \"password\"))",
            "player:notify(\"Your password has a `clear' property.  Please refer to a wizard for assistance in changing it.\");",
            "return;",
            "elseif (player in $wiz_utils.change_password_restricted)",
            "player:notify(\"You are not permitted to change your own password.\");",
            "return;",
            "else",
            "new_password = args[2];",
            "endif",
            "if (r = $password_verifier:reject_password(new_password, player))",
            "player:notify(r);",
            "return;",
            "endif",
            "player.password = $login:encrypt_password(new_password);",
            "player.last_password_time = time();",
            "player:notify(\"New password set.\");"
          ]
        },
        {
          "name": "recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "pass(@args);",
            "features = this.features;",
            "for x in (features)",
            "\"Have to do this, or :feature_remove thinks you're a liar and doesn't believe.\";",
            "this.features = setremove(this.features, x);",
            "if ($object_utils:has_verb(x, \"feature_remove\"))",
            "try",
            "x:feature_remove(this);",
            "except (ANY)",
            "player:tell(\"Failure in \", x, \":feature_remove for player \", $string_utils:nn(this));",
            "endtry",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "gc_gaglist",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "((caller == this) || $perm_utils:controls(caller_perms(), this)) || raise(E_PERM);",
            "if (g = this.gaglist)",
            "recycler = $recycler;",
            "for o in (g)",
            "if (!recycler:valid(o))",
            "g = setremove(g, o);",
            "endif",
            "endfor",
            "this.gaglist = g;",
            "endif"
          ]
        },
        {
          "name": "email_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(caller_perms());",
            "return this.email_address;"
          ]
        },
        {
          "name": "set_email_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(caller_perms());",
            "this.email_address = args[1];"
          ]
        },
        {
          "name": "reconfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 6,
          "code": [
            "if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != $sysobj))",
            "return E_PERM;",
            "endif",
            "return this:confunc(@args);"
          ]
        },
        {
          "name": "@owner",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 6,
          "code": [
            "if ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))",
            "return;",
            "endif",
            "player:tell($string_utils:nn(dobj), \" is owned by \", $string_utils:nn(dobj.owner), \".\");"
          ]
        },
        {
          "name": "@inline-o*ptions @editor-o*ptions",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 6,
          "code": [
            "return $edit_utils:options(@args);"
          ]
        },
        {
          "name": "@gender",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 6,
          "code": [
            "set_task_perms(valid(caller_perms()) ? caller_perms() | player);",
            "if (!args)",
            "player:notify(tostr(\"Your gender is currently \", this.gender, \".\"));",
            "player:notify($string_utils:pronoun_sub(\"Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R\"));",
            "player:notify(tostr(\"Available genders:  \", $string_utils:english_list($gender_utils.genders, \"\", \" or \")));",
            "else",
            "result = this:set_gender(args[1]);",
            "quote = (result == E_NONE) ? \"\\\"\" | \"\";",
            "player:notify(tostr(\"Gender set to \", quote, this.gender, quote, \".\"));",
            "if (typeof(result) != ERR)",
            "player:notify($string_utils:pronoun_sub(\"Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R\"));",
            "elseif (result != E_NONE)",
            "player:notify(tostr(\"Couldn't set pronouns:  \", result));",
            "else",
            "player:notify(\"Pronouns unchanged.\");",
            "endif",
            "endif"
          ]
        }
      ],
      "propnames": [
        "features",
        "previous_connection",
        "email_address",
        "last_disconnect_time",
        "help",
        "more_msg",
        "linetask",
        "linesleft",
        "linebuffer",
        "pagelen",
        "owned_objects",
        "linelen",
        "current_folder",
        "all_connect_places",
        "last_connect_place",
        "dict",
        "brief",
        "page_absent_msg",
        "page_origin_msg",
        "page_echo_msg",
        "edit_options",
        "last_connect_time",
        "ownership_quota",
        "home",
        "password",
        "gaglist",
        "paranoid",
        "display_options",
        "first_connect_time",
        "size_quota",
        "last_password_time",
        "last_connect_attempt",
        "out_of_band_session",
        "reading_input",
        "inline_editor_options"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": "",
          "owner": 2,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "*** More ***  %n lines left.  Do @more [rest|flush] for more.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            0,
            0
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": -79,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": "?",
          "owner": 2,
          "perms": 0
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%N is not currently logged in.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You sense that %n is looking for you in %l.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Your message has been sent.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "impossible password to type",
          "owner": 2,
          "perms": 0
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": {},
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic player"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "You see a player who should type '@describe me as ...'.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            132036,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "7": {
      "id": 7,
      "name": "generic exit",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "invoke",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "set_task_perms(caller_perms());",
            "this:move(player);"
          ]
        },
        {
          "name": "move",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "set_task_perms(caller_perms());",
            "what = args[1];",
            "\"if ((what.location != this.source) || (!(this in this.source.exits)))\";",
            "\"  player:tell(\\\"You can't go that way.\\\");\";",
            "\"  return;\";",
            "\"endif\";",
            "unlocked = this:is_unlocked_for(what);",
            "if (unlocked)",
            "this.dest:bless_for_entry(what);",
            "endif",
            "if (unlocked && this.dest:acceptable(what))",
            "start = what.location;",
            "if (msg = this:leave_msg(what))",
            "what:tell_lines(msg);",
            "endif",
            "what:moveto(this.dest);",
            "if (what.location != start)",
            "\"Don't print oleave messages if WHAT didn't actually go anywhere...\";",
            "this:announce_msg(start, what, (this:oleave_msg(what) || this:defaulting_oleave_msg(what)) || \"has left.\");",
            "endif",
            "if (what.location == this.dest)",
            "\"Don't print arrive messages if WHAT didn't really end up there...\";",
            "if (msg = this:arrive_msg(what))",
            "what:tell_lines(msg);",
            "endif",
            "this:announce_msg(what.location, what, this:oarrive_msg(what) || \"has arrived.\");",
            "endif",
            "else",
            "if (msg = this:nogo_msg(what))",
            "what:tell_lines(msg);",
            "else",
            "what:tell(\"You can't go that way.\");",
            "endif",
            "if (msg = this:onogo_msg(what))",
            "this:announce_msg(what.location, what, msg);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "try",
            "this.source:remove_exit(this);",
            "this.dest:remove_entrance(this);",
            "except id (ANY)",
            "endtry",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "leave_msg oleave_msg arrive_msg oarrive_msg nogo_msg onogo_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "msg = this.(verb);",
            "return msg ? $string_utils:pronoun_sub(msg, @args) | \"\";"
          ]
        },
        {
          "name": "set_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))",
            "return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_aliases",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))",
            "if (typeof(e = `this.aliases = args[1] ! ANY') == ERR)",
            "return e;",
            "else",
            "return 1;",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "announce_all_but",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "\"This is intended to be called only by exits, for announcing various oxxx messages.  First argument is room to announce in.  Second argument is as in $room:announce_all_but's first arg, who not to announce to.  Rest args are what to say.  If the final arg is a list, prepends all the other rest args to the first line and emits the lines separately.\";",
            "where = args[1];",
            "whobut = args[2];",
            "last = args[$];",
            "if (typeof(last) == LIST)",
            "where:announce_all_but(whobut, @args[3..$ - 1], last[1]);",
            "for line in (last[2..$])",
            "where:announce_all_but(whobut, line);",
            "endfor",
            "else",
            "where:announce_all_but(@args[3..$]);",
            "endif"
          ]
        },
        {
          "name": "defaulting_oleave_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "for k in ({this.name, @this.aliases})",
            "if (k in {\"east\", \"west\", \"south\", \"north\", \"northeast\", \"southeast\", \"southwest\", \"northwest\", \"out\", \"up\", \"down\", \"nw\", \"sw\", \"ne\", \"se\", \"in\"})",
            "return (\"goes \" + k) + \".\";",
            "elseif (k in {\"leave\", \"out\", \"exit\"})",
            "return \"leaves\";",
            "endif",
            "endfor",
            "if ((index(this.name, \"an \") == 1) || (index(this.name, \"a \") == 1))",
            "return (\"leaves for \" + this.name) + \".\";",
            "else",
            "return (\"leaves for the \" + this.name) + \".\";",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "examine_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "\"examine_key(examiner)\";",
            "\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";",
            "\"the default will only tell the key to a wizard or this object's owner.\";",
            "who = args[1];",
            "if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))",
            "return {tostr(this:title(), \" will only transport objects matching this key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};",
            "endif"
          ]
        },
        {
          "name": "announce_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 7,
          "code": [
            "\":announce_msg(place, what, msg)\";",
            "\"  announce msg in place (except to what). Prepend with what:title if it isn't part of the string\";",
            "msg = args[3];",
            "what = args[2];",
            "title = what:titlec();",
            "if (!$string_utils:index_delimited(msg, title))",
            "msg = tostr(title, \" \", msg);",
            "endif",
            "args[1]:announce_all_but({what}, msg);"
          ]
        }
      ],
      "propnames": [
        "obvious",
        "source",
        "dest",
        "nogo_msg",
        "onogo_msg",
        "arrive_msg",
        "oarrive_msg",
        "oleave_msg",
        "leave_msg"
      ],
      "propdefs": [
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic exit"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            10849,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "8": {
      "id": 8,
      "name": "generic container",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        5
      ],
      "children": [
        83
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "p*ut in*sert d*rop",
          "owner": 2,
          "perms": 157,
          "preps": 3,
          "object": 8,
          "code": [
            "if ((this.location != player) && (this.location != player.location))",
            "player:tell(\"You can't get at \", this.name, \".\");",
            "elseif (dobj == $nothing)",
            "player:tell(\"What do you want to put \", prepstr, \" \", this.name, \"?\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "elseif ((dobj.location != player) && (dobj.location != player.location))",
            "player:tell(\"You don't have \", dobj.name, \".\");",
            "elseif (!this.opened)",
            "player:tell(this.name, \" is closed.\");",
            "else",
            "set_task_perms(callers() ? caller_perms() | player);",
            "dobj:moveto(this);",
            "if (dobj.location == this)",
            "player:tell(this:put_msg());",
            "if (msg = this:oput_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "else",
            "player:tell(this:put_fail_msg());",
            "if (msg = this:oput_fail_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "re*move ta*ke g*et",
          "owner": 2,
          "perms": 157,
          "preps": 5,
          "object": 8,
          "code": [
            "if (!(this.location in {player, player.location}))",
            "player:tell(\"Sorry, you're too far away.\");",
            "elseif (!this.opened)",
            "player:tell(this.name, \" is not open.\");",
            "elseif (this.dark)",
            "player:tell(\"You can't see into \", this.name, \" to remove anything.\");",
            "elseif ((dobj = this:match_object(dobjstr)) == $nothing)",
            "player:tell(\"What do you want to take from \", this.name, \"?\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "elseif (!(dobj in this:contents()))",
            "player:tell(dobj.name, \" isn't in \", this.name, \".\");",
            "else",
            "set_task_perms(callers() ? caller_perms() | player);",
            "dobj:moveto(player);",
            "if (dobj.location == player)",
            "player:tell(this:remove_msg());",
            "if (msg = this:oremove_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "else",
            "dobj:moveto(this.location);",
            "if (dobj.location == this.location)",
            "player:tell(this:remove_msg());",
            "if (msg = this:oremove_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "player:tell(\"You can't pick up \", dobj.name, \", so it tumbles onto the floor.\");",
            "else",
            "player:tell(this:remove_fail_msg());",
            "if (msg = this:oremove_fail_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "look_self",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "pass();",
            "if (!this.dark)",
            "this:tell_contents();",
            "endif"
          ]
        },
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "return !is_player(args[1]);"
          ]
        },
        {
          "name": "open",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 8,
          "code": [
            "perms = (callers() && (caller != this)) ? caller_perms() | player;",
            "if (this.opened)",
            "player:tell(\"It's already open.\");",
            "\"elseif (this:is_openable_by(player))\";",
            "elseif (this:is_openable_by(perms))",
            "this:set_opened(1);",
            "player:tell(this:open_msg());",
            "if (msg = this:oopen_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "else",
            "player:tell(this:open_fail_msg());",
            "if (msg = this:oopen_fail_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@lock_for_open @lock-for-open",
          "owner": 2,
          "perms": 105,
          "preps": 0,
          "object": 8,
          "code": [
            "set_task_perms(player);",
            "key = $lock_utils:parse_keyexp(iobjstr, player);",
            "if (typeof(key) == STR)",
            "player:tell(\"That key expression is malformed:\");",
            "player:tell(\"  \", key);",
            "else",
            "try",
            "this.open_key = key;",
            "player:tell(\"Locked opening of \", this.name, \" with this key:\");",
            "player:tell(\"  \", $lock_utils:unparse_key(key));",
            "except error (ANY)",
            "player:tell(error[2], \".\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "is_openable_by",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "return (this.open_key == 0) || $lock_utils:eval_key(this.open_key, args[1]);"
          ]
        },
        {
          "name": "close",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 8,
          "code": [
            "if (!this.opened)",
            "player:tell(\"It's already closed.\");",
            "else",
            "this:set_opened(0);",
            "player:tell(this:close_msg());",
            "if (msg = this:oclose_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@unlock_for_open @unlock-for-open",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 8,
          "code": [
            "set_task_perms(player);",
            "try",
            "dobj.open_key = 0;",
            "player:tell(\"Unlocked \", dobj.name, \" for opening.\");",
            "except error (ANY)",
            "player:tell(error[2], \".\");",
            "endtry"
          ]
        },
        {
          "name": "tell_contents",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "if (this.contents)",
            "player:tell(\"Contents:\");",
            "for thing in (this:contents())",
            "player:tell(\"  \", thing:title());",
            "endfor",
            "elseif (msg = this:empty_msg())",
            "player:tell(msg);",
            "endif"
          ]
        },
        {
          "name": "set_opened",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "if (!$perm_utils:controls(caller.owner, this))",
            "return E_PERM;",
            "else",
            "this.opened = opened = !(!args[1]);",
            "this.dark = this.opaque > opened;",
            "return opened;",
            "endif"
          ]
        },
        {
          "name": "@opacity",
          "owner": 2,
          "perms": 105,
          "preps": 12,
          "object": 8,
          "code": [
            "if (!$perm_utils:controls(player, this))",
            "player:tell(\"Can't set opacity of something you don't own.\");",
            "elseif ((iobjstr != \"0\") && (!toint(iobjstr)))",
            "player:tell(\"Opacity must be an integer (0, 1, 2).\");",
            "else",
            "player:tell(\"Opacity changed:  Now \" + {\"transparent.\", \"opaque.\", \"a black hole.\"}[1 + this:set_opaque(toint(iobjstr))]);",
            "endif"
          ]
        },
        {
          "name": "set_opaque",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "if (!$perm_utils:controls(caller.owner, this))",
            "return E_PERM;",
            "elseif (typeof(number = args[1]) != INT)",
            "return E_INVARG;",
            "else",
            "number = (number < 0) ? 0 | ((number > 2) ? 2 | number);",
            "this.dark = number > this.opened;",
            "return this.opaque = number;",
            "endif"
          ]
        },
        {
          "name": "oclose_msg close_msg oopen_msg open_msg oput_fail_msg put_fail_msg oremove_fail_msg oremove_msg remove_fail_msg remove_msg oput_msg put_msg oopen_fail_msg open_fail_msg empty_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg) | \"\";"
          ]
        },
        {
          "name": "dark",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 8,
          "code": [
            "return this.(verb);"
          ]
        }
      ],
      "propnames": [
        "oclose_msg",
        "close_msg",
        "oopen_msg",
        "open_msg",
        "oput_fail_msg",
        "put_fail_msg",
        "opaque",
        "dark",
        "oremove_fail_msg",
        "oremove_msg",
        "remove_fail_msg",
        "remove_msg",
        "oput_msg",
        "put_msg",
        "oopen_fail_msg",
        "open_fail_msg",
        "empty_msg",
        "opened",
        "open_key"
      ],
      "propdefs": [
        {
          "value": "closes %d.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You close %d.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "opens %d.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You open %d.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You can't put %d in that.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 1
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "removes %d from %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You can't remove that.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You remove %d from %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "puts %d in %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You put %d in %i.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You can't open that.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "It is empty.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic container"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            14463,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "9": {
      "id": 9,
      "name": "generic note",
      "flags": 152,
      "owner": 2,
      "location": -1,
      "parents": [
        5
      ],
      "children": [
        54
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "r*ead",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 9,
          "code": [
            "if (!this:is_readable_by(valid(caller_perms()) ? caller_perms() | player))",
            "player:tell(\"Sorry, but it seems to be written in some code that you can't read.\");",
            "else",
            "this:look_self();",
            "player:tell();",
            "player:tell_lines_suspended(this:text());",
            "player:tell();",
            "player:tell(\"(You finish reading.)\");",
            "endif"
          ]
        },
        {
          "name": "er*ase",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 9,
          "code": [
            "if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))",
            "this:set_text({});",
            "player:tell(\"Note erased.\");",
            "else",
            "player:tell(\"You can't erase this note.\");",
            "endif"
          ]
        },
        {
          "name": "wr*ite",
          "owner": 2,
          "perms": 157,
          "preps": 4,
          "object": 9,
          "code": [
            "if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))",
            "this:set_text({@this.text, dobjstr});",
            "player:tell(\"Line added to note.\");",
            "else",
            "player:tell(\"You can't write on this note.\");",
            "endif"
          ]
        },
        {
          "name": "del*ete rem*ove",
          "owner": 2,
          "perms": 153,
          "preps": 5,
          "object": 9,
          "code": [
            "if (!this:is_writable_by(player))",
            "player:tell(\"You can't modify this note.\");",
            "elseif (!dobjstr)",
            "player:tell(\"You must tell me which line to delete.\");",
            "else",
            "line = toint(dobjstr);",
            "if (line < 0)",
            "line = (line + length(this.text)) + 1;",
            "endif",
            "if ((line <= 0) || (line > length(this.text)))",
            "player:tell(\"Line out of range.\");",
            "else",
            "this:set_text(listdelete(this.text, line));",
            "player:tell(\"Line deleted.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "encrypt",
          "owner": 2,
          "perms": 105,
          "preps": 0,
          "object": 9,
          "code": [
            "set_task_perms(player);",
            "key = $lock_utils:parse_keyexp(iobjstr, player);",
            "if (typeof(key) == STR)",
            "player:tell(\"That key expression is malformed:\");",
            "player:tell(\"  \", key);",
            "else",
            "try",
            "this.encryption_key = key;",
            "player:tell(\"Encrypted \", this.name, \" with this key:\");",
            "player:tell(\"  \", $lock_utils:unparse_key(key));",
            "except error (ANY)",
            "player:tell(error[2], \".\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "decrypt",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 9,
          "code": [
            "set_task_perms(player);",
            "try",
            "dobj.encryption_key = 0;",
            "player:tell(\"Decrypted \", dobj.name, \".\");",
            "except error (ANY)",
            "player:tell(error[2], \".\");",
            "endtry"
          ]
        },
        {
          "name": "text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 9,
          "code": [
            "cp = caller_perms();",
            "if ($perm_utils:controls(cp, this) || this:is_readable_by(cp))",
            "return this.text;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "is_readable_by",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 9,
          "code": [
            "key = this.encryption_key;",
            "return (key == 0) || $lock_utils:eval_key(key, args[1]);"
          ]
        },
        {
          "name": "set_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 9,
          "code": [
            "cp = caller_perms();",
            "newtext = args[1];",
            "if ($perm_utils:controls(cp, this) || this:is_writable_by(cp))",
            "if (typeof(newtext) == LIST)",
            "this.text = newtext;",
            "else",
            "return E_TYPE;",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "is_writable_by",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 9,
          "code": [
            "who = args[1];",
            "wr = this.writers;",
            "if ($perm_utils:controls(who, this))",
            "return 1;",
            "elseif (typeof(wr) == LIST)",
            "return who in wr;",
            "else",
            "return wr;",
            "endif"
          ]
        },
        {
          "name": "mailme @mailme",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 9,
          "code": [
            "\"Usage:  mailme <note>\";",
            "\"  uses $network to sends the text of this note to your REAL internet email address.\";",
            "if (!this:is_readable_by(player))",
            "return player:tell(\"Sorry, but it seems to be written in some code that you can't read.\");",
            "elseif (!(email = $wiz_utils:get_email_address(player)))",
            "return player:tell(\"Sorry, you don't have a registered email address.\");",
            "elseif (!$network.active)",
            "return player:tell(\"Sorry, internet mail is disabled.\");",
            "elseif (!(text = this:text()))",
            "return player:tell($string_utils:pronoun_sub(\"%T is empty--there wouldn't be any point to mailing it.\"));",
            "endif",
            "player:tell(\"Mailing \", this:title(), \" to \", email, \".\");",
            "player:tell(\"... \", length(text), \" lines ...\");",
            "suspend(0);",
            "$network:sendmail(email, this:titlec(), \"\", @text);"
          ]
        }
      ],
      "propnames": [
        "writers",
        "encryption_key",
        "text"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic note"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "There appears to be some writing on the note ...",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            9723,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "10": {
      "id": 10,
      "name": "Login Commands",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "?",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "clist = {};",
            "for j in ({this, @$object_utils:ancestors(this)})",
            "for i in [1..length(verbs(j))]",
            "if ((verb_args(j, i) == {\"any\", \"none\", \"any\"}) && index((info = verb_info(j, i))[2], \"x\"))",
            "vname = $string_utils:explode(info[3])[1];",
            "star = index(vname + \"*\", \"*\");",
            "clist = {@clist, $string_utils:uppercase(vname[1..star - 1]) + strsub(vname[star..$], \"*\", \"\")};",
            "endif",
            "endfor",
            "endfor",
            "notify(player, \"I don't understand that.  Valid commands at this point are\");",
            "notify(player, \"   \" + $string_utils:english_list(setremove(clist, \"?\"), \"\", \" or \"));",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "wel*come @wel*come",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "msg = this.welcome_message;",
            "version = server_version();",
            "for line in ((typeof(msg) == LIST) ? msg | {msg})",
            "if (typeof(line) == STR)",
            "notify(player, strsub(line, \"%v\", version));",
            "endif",
            "endfor",
            "this:check_player_db();",
            "this:check_for_shutdown();",
            "this:check_for_checkpoint();",
            "this:maybe_print_lag();",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "w*ho @w*ho",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "masked = $login.who_masks_wizards ? $wiz_utils:connected_wizards() | {};",
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "elseif (!args)",
            "plyrs = connected_players();",
            "if (length(plyrs) > 100)",
            "this:notify(tostr(\"You have requested a listing of \", length(plyrs), \" players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you.\"));",
            "return 0;",
            "else",
            "$ansi_utils:show_who_listing($set_utils:difference(plyrs, masked)) || this:notify(\"No one logged in.\");",
            "endif",
            "else",
            "plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);",
            "if (length(plyrs) > 100)",
            "this:notify(tostr(\"You have requested a listing of \", length(plyrs), \" players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you.\"));",
            "return 0;",
            "endif",
            "$ansi_utils:show_who_listing(plyrs, $set_utils:intersection(plyrs, masked));",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "co*nnect @co*nnect",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "\"$login:connect(player-name [, password])\";",
            "\" => 0 (for failed connections)\";",
            "\" => objnum (for successful connections)\";",
            "((caller == #0) || (caller == this)) || raise(E_PERM);",
            "\"=================================================================\";",
            "\"=== Check arguments, print usage notice if necessary\";",
            "try",
            "{name, ?password = 0} = args;",
            "name = strsub(name, \" \", \"_\");",
            "except (E_ARGS)",
            "notify(player, tostr(\"Usage:  \", verb, \" <existing-player-name> <password>\"));",
            "return 0;",
            "endtry",
            "try",
            "\"=================================================================\";",
            "\"=== Is our candidate name invalid?\";",
            "if (!valid(candidate = orig_candidate = this:_match_player(name)))",
            "raise(E_INVARG, tostr(\"`\", name, \"' matches no player name.\"));",
            "endif",
            "\"=================================================================\";",
            "\"=== Is our candidate unable to connect for generic security\";",
            "\"=== reasons (ie clear password, non-player object)?\";",
            "if (`is_clear_property(candidate, \"password\") ! E_PROPNF' || (!$object_utils:isa(candidate, $player)))",
            "server_log(tostr(\"FAILED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player), ($string_utils:connection_hostname(player) in candidate.all_connect_places) ? \"\" | \"******\"));",
            "raise(E_INVARG);",
            "endif",
            "\"=================================================================\";",
            "\"=== Check password\";",
            "if (typeof(cp = candidate.password) == STR)",
            "\"=== Candidate requires a password\";",
            "if (password)",
            "\"=== Candidate requires a password, and one was provided\";",
            "if (!argon2_verify(cp, password))",
            "\"=== Candidate requires a password, and one was provided, which was wrong\";",
            "server_log(tostr(\"FAILED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player), ($string_utils:connection_hostname(player) in candidate.all_connect_places) ? \"\" | \"******\"));",
            "raise(E_INVARG, \"Invalid password.\");",
            "else",
            "\"=== Candidate requires a password, and one was provided, which was right\";",
            "endif",
            "else",
            "\"=== Candidate requires a password, and none was provided\";",
            "set_connection_option(player, \"binary\", 1);",
            "notify(player, \"Password: \");",
            "set_connection_option(player, \"binary\", 0);",
            "set_connection_option(player, \"client-echo\", 0);",
            "this:add_interception(player, \"intercepted_password\", candidate);",
            "return 0;",
            "endif",
            "elseif (cp == 0)",
            "\"=== Candidate does not require a password\";",
            "else",
            "\"=== Candidate has a nonstandard password; something's wrong\";",
            "raise(E_INVARG);",
            "endif",
            "\"=================================================================\";",
            "\"=== Is the player locked out?\";",
            "if (this.no_connect_message && (!candidate.wizard))",
            "notify(player, this.no_connect_message);",
            "server_log(tostr(\"REJECTED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player)));",
            "return 0;",
            "endif",
            "\"=================================================================\";",
            "\"=== Check guest connections\";",
            "if ($object_utils:isa(candidate, $guest) && (!valid(candidate = candidate:defer())))",
            "if (candidate == #-2)",
            "server_log(tostr(\"GUEST DENIED: \", connection_name(player)));",
            "notify(player, \"Sorry, guest characters are not allowed from your site at the current time.\");",
            "else",
            "notify(player, \"Sorry, all of our guest characters are in use right now.\");",
            "endif",
            "return 0;",
            "endif",
            "\"=================================================================\";",
            "\"=== Check newts\";",
            "if (candidate in this.newted)",
            "if (entry = $list_utils:assoc(candidate, this.temporary_newts))",
            "if ((uptime = this:uptime_since(entry[2])) > entry[3])",
            "\"Temporary newting period is over.  Remove entry.  Oh, send mail, too.\";",
            "this.temporary_newts = setremove(this.temporary_newts, entry);",
            "this.newted = setremove(this.newted, candidate);",
            "fork (0)",
            "player = this.owner;",
            "$mail_agent:send_message(player, $newt_log, tostr(\"automatic @unnewt \", candidate.name, \" (\", candidate, \")\"), {\"message sent from $login:connect\"});",
            "endfork",
            "else",
            "notify(player, \"\");",
            "notify(player, this:temp_newt_registration_string(entry[3] - uptime));",
            "boot_player(player);",
            "return 0;",
            "endif",
            "else",
            "notify(player, \"\");",
            "notify(player, this:newt_registration_string());",
            "boot_player(player);",
            "return 0;",
            "endif",
            "endif",
            "\"=================================================================\";",
            "\"=== Connection limits based on lag\";",
            "if ((((!candidate.wizard) && (!(candidate in this.lag_exemptions))) && ((howmany = length(connected_players())) >= (max = this:max_connections()))) && (!$object_utils:connected(candidate)))",
            "notify(player, $string_utils:subst(this.connection_limit_msg, {{\"%n\", tostr(howmany)}, {\"%m\", tostr(max)}, {\"%l\", tostr(this:current_lag())}, {\"%t\", candidate.last_connect_attempt ? ctime(candidate.last_connect_attempt) | \"not recorded\"}}));",
            "candidate.last_connect_attempt = time();",
            "server_log(tostr(\"CONNECTION LIMIT EXCEEDED: \", name, \" (\", candidate, \") on \", connection_name(player)));",
            "boot_player(player);",
            "return 0;",
            "endif",
            "\"=================================================================\";",
            "\"=== Log the player on!\";",
            "if (candidate != orig_candidate)",
            "notify(player, tostr(\"Okay,... \", name, \" is in use.  Logging you in as `\", candidate.name, \"'\"));",
            "endif",
            "this:record_connection(candidate);",
            "return candidate;",
            "except (E_INVARG)",
            "notify(player, \"Either that player does not exist, or has a different password.\");",
            "return 0;",
            "endtry"
          ]
        },
        {
          "name": "cr*eate @cr*eate",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "\"... caller isn't :do_login_command()...\";",
            "elseif (!this:player_creation_enabled(player))",
            "notify(player, this:registration_string());",
            "\"... we've disabled player creation ...\";",
            "elseif (length(args) != 2)",
            "notify(player, tostr(\"Usage:  \", verb, \" <new-player-name> <new-password>\"));",
            "elseif ($player_db.frozen)",
            "notify(player, \"Sorry, can't create any new players right now.  Try again in a few minutes.\");",
            "elseif ((!(name = args[1])) || (name == \"<>\"))",
            "notify(player, \"You can't have a blank name!\");",
            "if (name)",
            "notify(player, \"Also, don't use angle brackets (<>).\");",
            "endif",
            "elseif ((name[1] == \"<\") && (name[$] == \">\"))",
            "notify(player, \"Try that again but without the angle brackets, e.g.,\");",
            "notify(player, tostr(\" \", verb, \" \", name[2..$ - 1], \" \", strsub(strsub(args[2], \"<\", \"\"), \">\", \"\")));",
            "notify(player, \"This goes for other commands as well.\");",
            "elseif (index(name, \" \"))",
            "notify(player, \"Sorry, no spaces are allowed in player names.  Use dashes or underscores.\");",
            "\"... lots of routines depend on there not being spaces in player names...\";",
            "elseif ((!$player_db:available(name)) || (this:_match_player(name) != $failed_match))",
            "notify(player, \"Sorry, that name is not available.  Please choose another.\");",
            "\"... note the :_match_player call is not strictly necessary...\";",
            "\"... it is merely there to handle the case that $player_db gets corrupted.\";",
            "elseif (!(password = args[2]))",
            "notify(player, \"You must set a password for your player.\");",
            "else",
            "new = $quota_utils:bi_create($player_class, $nothing);",
            "set_player_flag(new, 1);",
            "new.name = name;",
            "new.aliases = {name};",
            "new.programmer = $player_class.programmer;",
            "new.password = $login:encrypt_password(password);",
            "new.last_password_time = time();",
            "new.last_connect_time = $maxint;",
            "\"Last disconnect time is creation time, until they login.\";",
            "new.last_disconnect_time = time();",
            "\"make sure the owership quota isn't clear!\";",
            "$quota_utils:initialize_quota(new);",
            "this:record_connection(new);",
            "$player_db:insert(name, new);",
            "`move(new, $player_start) ! ANY';",
            "return new;",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "q*uit @q*uit",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "boot_player(player);",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "up*time @up*time",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "notify(player, tostr(\"The server has been up for \", $time_utils:english_time(time() - $server[\"last_restart_time\"]), \".\"));",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "v*ersion @v*ersion",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "notify(player, tostr(\"The MOO is currently running version \", server_version(), \" of the \", $server[\"name\"], \" server code.\"));",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "parse_command",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":parse_command(@args) => {verb, args}\";",
            "\"Given the args from #0:do_login_command,\";",
            "\"  returns the actual $login verb to call and the args to use.\";",
            "\"Commands available to not-logged-in users should be located on this object and given the verb_args \\\"any none any\\\"\";",
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "endif",
            "if (li = this:interception(player))",
            "return {@li, @args};",
            "endif",
            "if (!args)",
            "return {this.blank_command, @args};",
            "elseif ((verb = args[1]) && (!$string_utils:is_numeric(verb)))",
            "for i in ({this, @$object_utils:ancestors(this)})",
            "try",
            "if ((verb_args(i, verb) == {\"any\", \"none\", \"any\"}) && index(verb_info(i, verb)[2], \"x\"))",
            "return args;",
            "endif",
            "except (ANY)",
            "continue i;",
            "endtry",
            "endfor",
            "endif",
            "return {this.bogus_command, @args};"
          ]
        },
        {
          "name": "check_for_shutdown",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "when = $server[\"shutdown_time\"] - time();",
            "if (when >= 0)",
            "line = \"***************************************************************************\";",
            "notify(player, \"\");",
            "notify(player, \"\");",
            "notify(player, line);",
            "notify(player, line);",
            "notify(player, \"****\");",
            "notify(player, (\"****  WARNING:  The server will shut down in \" + $time_utils:english_time(when - (when % 60))) + \".\");",
            "for piece in ($generic_editor:fill_string($wiz_utils.shutdown_message, 60))",
            "notify(player, \"****            \" + piece);",
            "endfor",
            "notify(player, \"****\");",
            "notify(player, line);",
            "notify(player, line);",
            "notify(player, \"\");",
            "notify(player, \"\");",
            "endif"
          ]
        },
        {
          "name": "check_player_db",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if ($player_db.frozen)",
            "line = \"***************************************************************************\";",
            "notify(player, \"\");",
            "notify(player, line);",
            "notify(player, \"***\");",
            "for piece in ($generic_editor:fill_string(\"The character-name matcher is currently being reloaded.  This means your character name might not be recognized even though it still exists.  Don't panic.  You can either wait for the reload to finish or you can connect using your object number if you remember it (e.g., `connect #1234 yourpassword').\", 65))",
            "notify(player, \"***       \" + piece);",
            "endfor",
            "notify(player, \"***\");",
            "for piece in ($generic_editor:fill_string(\"Repeat:  Do not panic.  In particular, please do not send mail to any wizards or the registrar asking about this.  It will finish in time.  Thank you for your patience.\", 65))",
            "notify(player, \"***       \" + piece);",
            "endfor",
            "if (this:player_creation_enabled(player))",
            "notify(player, \"***       This also means that character creation is disabled.\");",
            "endif",
            "notify(player, \"***\");",
            "notify(player, line);",
            "notify(player, \"\");",
            "endif"
          ]
        },
        {
          "name": "_match_player",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":_match_player(name)\";",
            "\"This is the matching routine used by @connect.\";",
            "\"returns either a valid player corresponding to name or $failed_match.\";",
            "name = args[1];",
            "if (valid(candidate = $string_utils:literal_object(name)) && is_player(candidate))",
            "return candidate;",
            "endif",
            "\".....uncomment this to trust $player_db and have `connect' recognize aliases\";",
            "if (valid(candidate = $player_db:find_exact(name)) && is_player(candidate))",
            "return candidate;",
            "endif",
            "\".....uncomment this if $player_db gets hosed and you want by-name login\";",
            "\". for candidate in (players())\";",
            "\".   if (candidate.name == name)\";",
            "\".     return candidate; \";",
            "\".   endif \";",
            "\". endfor \";",
            "\".....\";",
            "return $failed_match;"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "(caller != $ansi_utils) && set_task_perms(caller_perms());",
            "notify(player, $ansi_utils:delete(args[1]));"
          ]
        },
        {
          "name": "tell",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"keeps bad things from happening if someone brings this object into a room and talks to it.\";",
            "return 0;"
          ]
        },
        {
          "name": "player_creation_enabled",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"Accepts a player object.  If player creation is enabled for that player object, then return true.  Otherwise, return false.\";",
            "\"Default implementation checks the player's connecting host via $login:blacklisted to decide.\";",
            "if (caller_perms().wizard)",
            "return this.create_enabled && (!this:blacklisted($string_utils:connection_hostname(args[1])));",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "newt_registration_string registration_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "return $string_utils:subst(this.(verb), {{\"%e\", this.registration_address}, {\"%%\", \"%\"}});"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if (caller_perms().wizard)",
            "this.current_lag = 0;",
            "this.lag_exemptions = {};",
            "this.max_connections = 99999;",
            "this.lag_samples = {0, 0, 0, 0, 0};",
            "this.print_lag = 0;",
            "this.last_lag_sample = 0;",
            "this.bogus_command = \"?\";",
            "this.blank_command = \"welcome\";",
            "this.create_enabled = 1;",
            "this.registration_address = \"\";",
            "this.registration_string = \"Character creation is disabled.\";",
            "this.newt_registration_string = \"Your character is temporarily hosed.\";",
            "this.welcome_message = {\"Welcome to the LambdaCore database.\", \"\", \"Type 'connect wizard' to log in.\", \"\", \"You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively.\"};",
            "this.help_message = {\"Sorry, but there's no help here yet.  Type `?' for a list of commands.\"};",
            "this.redlist = this.blacklist = this.graylist = this.spooflist = {{}, {}};",
            "this.temporary_redlist = this.temporary_blacklist = this.temporary_graylist = this.temporary_spooflist = {{}, {}};",
            "this.who_masks_wizards = 0;",
            "this.newted = this.temporary_newts = {};",
            "this.downtimes = {};",
            "this.current_numcommands = [];",
            "this.max_numcommands = 20;",
            "this.intercepted_players = this.intercepted_actions = {};",
            "this.name_lookup_players = {};",
            "if (\"monitor\" in properties(this))",
            "delete_property(this, \"monitor\");",
            "endif",
            "if (\"monitor\" in verbs(this))",
            "delete_verb(this, \"monitor\");",
            "endif",
            "if (\"special_action\" in verbs(this))",
            "set_verb_code(this, \"special_action\", {});",
            "endif",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "special_action",
          "owner": 2,
          "perms": 164,
          "preps": -1,
          "object": 10,
          "code": []
        },
        {
          "name": "blacklisted graylisted redlisted spooflisted",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":blacklisted(hostname) => is hostname on the .blacklist\";",
            "\":graylisted(hostname)  => is hostname on the .graylist\";",
            "\":redlisted(hostname)   => is hostname on the .redlist\";",
            "sitelist = this.(this:listname(verb));",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (((hostname = args[1]) in sitelist[1]) || (hostname in sitelist[2]))",
            "return 1;",
            "elseif ($site_db:domain_literal(hostname))",
            "for lit in (sitelist[1])",
            "if ((index(hostname, lit) == 1) && ((hostname + \".\")[length(lit) + 1] == \".\"))",
            "return 1;",
            "endif",
            "endfor",
            "else",
            "for dom in (sitelist[2])",
            "if (index(dom, \"*\"))",
            "\"...we have a wildcard; let :match_string deal with it...\";",
            "if ($string_utils:match_string(hostname, dom))",
            "return 1;",
            "endif",
            "else",
            "\"...tail of hostname ...\";",
            "if ((r = rindex(hostname, dom)) && (((\".\" + hostname)[r] == \".\") && (((r - 1) + length(dom)) == length(hostname))))",
            "return 1;",
            "endif",
            "endif",
            "endfor",
            "endif",
            "return this:(verb + \"_temp\")(hostname);"
          ]
        },
        {
          "name": "blacklist_add*_temp graylist_add*_temp redlist_add*_temp spooflist_add*_temp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"To add a temporary entry, only call the `temp' version.\";",
            "\"blacklist_add_temp(Site, start time, duration)\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{where, ?start, ?duration} = args;",
            "lname = this:listname(verb);",
            "which = 1 + (!$site_db:domain_literal(where));",
            "if (index(verb, \"temp\"))",
            "lname = \"temporary_\" + lname;",
            "this.(lname)[which] = setadd(this.(lname)[which], {where, start, duration});",
            "else",
            "this.(lname)[which] = setadd(this.(lname)[which], where);",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "blacklist_remove*_temp graylist_remove*_temp redlist_remove*_temp spooflist_remove*_temp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"The temp version removes from the temporary property if it exists.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "where = args[1];",
            "lname = this:listname(verb);",
            "which = 1 + (!$site_db:domain_literal(where));",
            "if (index(verb, \"temp\"))",
            "lname = \"temporary_\" + lname;",
            "if (entry = $list_utils:assoc(where, this.(lname)[which]))",
            "this.(lname)[which] = setremove(this.(lname)[which], entry);",
            "return 1;",
            "else",
            "return E_INVARG;",
            "endif",
            "elseif (where in this.(lname)[which])",
            "this.(lname)[which] = setremove(this.(lname)[which], where);",
            "return 1;",
            "else",
            "return E_INVARG;",
            "endif"
          ]
        },
        {
          "name": "listname",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "return {\"???\", \"blacklist\", \"graylist\", \"redlist\", \"spooflist\"}[1 + index(\"bgrs\", (args[1] || \"?\")[1])];"
          ]
        },
        {
          "name": "who(vanilla)",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if (caller != #0)",
            "return E_PERM;",
            "elseif (!args)",
            "$code_utils:show_who_listing(connected_players()) || this:notify(\"No one logged in.\");",
            "else",
            "plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);",
            "$code_utils:show_who_listing(plyrs);",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "record_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":record_connection(plyr) update plyr's connection information\";",
            "\"to reflect impending login.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "plyr = args[1];",
            "plyr.first_connect_time = min(time(), plyr.first_connect_time);",
            "plyr.previous_connection = {plyr.last_connect_time, $string_utils:connection_hostname(plyr.last_connect_place)};",
            "plyr.last_connect_time = time();",
            "plyr.last_connect_place = connection_name(player);",
            "chost = $string_utils:connection_hostname(player);",
            "acp = setremove(plyr.all_connect_places, chost);",
            "plyr.all_connect_places = {chost, @acp[1..min($, 15)]};",
            "if (!$object_utils:isa(plyr, $guest))",
            "$site_db:add(plyr, chost);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "sample_lag",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "lag = (time() - this.last_lag_sample) - 15;",
            "this.lag_samples = {lag, @this.lag_samples[1..3]};",
            "\"Now compute the current lag and store it in a property, instead of computing it in :current_lag, which is called a hundred times a second.\";",
            "thislag = max(0, (time() - this.last_lag_sample) - this.lag_sample_interval);",
            "if (thislag > (60 * 60))",
            "\"more than an hour, probably the lag sampler stopped\";",
            "this.current_lag = 0;",
            "else",
            "samples = this.lag_samples;",
            "sum = 0;",
            "cnt = 0;",
            "for x in (listdelete(samples, 1))",
            "sum = sum + x;",
            "cnt = cnt + 1;",
            "endfor",
            "this.current_lag = max(thislag, samples[1], samples[2], sum / cnt);",
            "endif",
            "fork (15)",
            "this:sample_lag();",
            "endfork",
            "this.last_lag_sample = time();"
          ]
        },
        {
          "name": "is_lagging",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "return this:current_lag() > this.lag_cutoff;"
          ]
        },
        {
          "name": "max_connections",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "max = this.max_connections;",
            "if (typeof(max) == LIST)",
            "if (this:is_lagging())",
            "max = max[1];",
            "else",
            "max = max[2];",
            "endif",
            "endif",
            "return max;"
          ]
        },
        {
          "name": "request_character",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"request_character(player, name, address)\";",
            "\"return true if succeeded\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{who, name, address} = args;",
            "connection = $string_utils:connection_hostname(who);",
            "if (reason = $wiz_utils:check_player_request(name, address, connection))",
            "prefix = \"\";",
            "if (reason[1] == \"-\")",
            "reason = reason[2..$];",
            "prefix = \"Please\";",
            "else",
            "prefix = \"Please try again, or, to register another way,\";",
            "endif",
            "notify(who, reason);",
            "msg = tostr(prefix, \" send mail to \", $login.registration_address, \", with the character name you want.\");",
            "for l in ($generic_editor:fill_string(msg, 70))",
            "notify(who, l);",
            "endfor",
            "return 0;",
            "endif",
            "if (lines = $no_one:eval_d(\"$local.help.(\\\"multiple-characters\\\")\")[2])",
            "notify(who, \"Remember, in general, only one character per person is allowed.\");",
            "notify(who, tostr(\"Do you already have a \", $network.moo_name, \" character? [enter `yes' or `no']\"));",
            "answer = read(who);",
            "if (answer == \"yes\")",
            "notify(who, \"Process terminated *without* creating a character.\");",
            "return 0;",
            "elseif (answer != \"no\")",
            "return notify(who, tostr(\"Please try again; when you get this question, answer `yes' or `no'. You answered `\", answer, \"'\"));",
            "endif",
            "notify(who, \"For future reference, do you want to see the full policy (from `help multiple-characters'?\");",
            "notify(who, \"[enter `yes' or `no']\");",
            "if (read(who) == \"yes\")",
            "for x in (lines)",
            "for y in ($generic_editor:fill_string(x, 70))",
            "notify(who, y);",
            "endfor",
            "endfor",
            "endif",
            "endif",
            "notify(who, tostr(\"A character named `\", name, \"' will be created.\"));",
            "notify(who, tostr(\"A random password will be generated, and e-mailed along with\"));",
            "notify(who, tostr(\" an explanatory message to: \", address));",
            "notify(who, tostr(\" [Please double-check your email address and answer `no' if it is incorrect.]\"));",
            "notify(who, \"Is this OK? [enter `yes' or `no']\");",
            "if (read(who) != \"yes\")",
            "notify(who, \"Process terminated *without* creating a character.\");",
            "return 0;",
            "endif",
            "if (!$network.active)",
            "$mail_agent:send_message(this.owner, $registration_db.registrar, \"Player request\", {\"Player request from \" + connection, \":\", \"\", ((\"@make-player \" + name) + \" \") + address});",
            "notify(who, tostr(\"Request for new character \", name, \" email address '\", address, \"' accepted.\"));",
            "notify(who, tostr(\"Please be patient until the registrar gets around to it.\"));",
            "notify(who, tostr(\"If you don't get email within a week, please send regular\"));",
            "notify(who, tostr(\"  email to: \", $login.registration_address, \".\"));",
            "elseif ($player_db.frozen)",
            "notify(who, \"Sorry, can't create any new players right now.  Try again in a few minutes.\");",
            "else",
            "new = $wiz_utils:make_player(name, address);",
            "password = new[2];",
            "new = new[1];",
            "notify(who, tostr(\"Character \", name, \" (\", new, \") created.\"));",
            "notify(who, tostr(\"Mailing password to \", address, \"; you should get the mail very soon.\"));",
            "notify(who, tostr(\"If you do not get it, please do NOT request another character.\"));",
            "notify(who, tostr(\"Instead, send regular email to \", $login.registration_address, \",\"));",
            "notify(who, tostr(\"with the name of the character you requested.\"));",
            "$mail_agent:send_message(this.owner, $new_player_log, tostr(name, \" (\", new, \")\"), {address, tostr(\" Automatically created at request of \", valid(player) ? player.name | \"unconnected player\", \" from \", connection, \".\")});",
            "$wiz_utils:send_new_player_mail(tostr(\"Someone connected from \", connection, \" at \", ctime(), \" requested a character on \", $network.moo_name, \" for email address \", address, \".\"), name, address, new, password);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "req*uest @req*uest",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "endif",
            "\"must be #0:do_login_command\";",
            "if (!this.request_enabled)",
            "for line in ($generic_editor:fill_string(this:registration_string(), 70))",
            "notify(player, line);",
            "endfor",
            "elseif ((length(args) != 3) || (args[2] != \"for\"))",
            "notify(player, tostr(\"Usage:  \", verb, \" <new-player-name> for <email-address>\"));",
            "elseif ($login:request_character(player, args[1], args[3]))",
            "boot_player(player);",
            "endif"
          ]
        },
        {
          "name": "h*elp @h*elp",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "else",
            "msg = this.help_message;",
            "for line in ((typeof(msg) == LIST) ? msg | {msg})",
            "if (typeof(line) == STR)",
            "notify(player, line);",
            "endif",
            "endfor",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "maybe_print_lag",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if ((caller == this) || (caller_perms() == player))",
            "if (this.print_lag)",
            "lag = this:current_lag();",
            "if (lag > 1)",
            "lagstr = tostr(\"approximately \", lag, \" seconds\");",
            "elseif (lag == 1)",
            "lagstr = \"approximately 1 second\";",
            "else",
            "lagstr = \"low\";",
            "endif",
            "notify(player, tostr(\"The lag is \", lagstr, \"; there \", ((l = length(connected_players())) == 1) ? \"is \" | \"are \", l, \" connected.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "current_lag",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "return this.current_lag;"
          ]
        },
        {
          "name": "maybe_limit_commands",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"This limits the number of commands that can be issued from the login prompt to prevent haywire login programs from lagging the MOO.\";",
            "\"$login.current_numcommands has the number of commands they have issued at the prompt so far.\";",
            "\"$login.max_numcommands has the maximum number of commands they may try before being booted.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "if (!(player in (keys = mapkeys(this.current_numcommands))))",
            "this.current_numcommands[player] = 1;",
            "else",
            "this.current_numcommands[player] = this.current_numcommands[player] + 1;",
            "endif",
            "\"...sweep idle connections...\";",
            "for p in (keys)",
            "if (typeof(`idle_seconds(p) ! ANY') == ERR)",
            "this.current_numcommands = mapdelete(this.current_numcommands, p);",
            "endif",
            "endfor",
            "if (this.current_numcommands[player] > this.max_numcommands)",
            "notify(player, \"Sorry, too many commands issued without connecting.\");",
            "boot_player(player);",
            "this.current_numcommands = mapdelete(this.current_numcommands, player);",
            "return 1;",
            "else",
            "return 0;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "server_started",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"Called by #0:server_started when the server restarts.\";",
            "if (caller_perms().wizard)",
            "this.lag_samples = {0, 0, 0, 0, 0};",
            "this.downtimes = {{time(), this.last_lag_sample}, @this.downtimes[1..min($, 100)]};",
            "this.intercepted_players = this.intercepted_actions = {};",
            "this.name_lookup_players = {};",
            "this.checkpoint_in_progress = 0;",
            "this.current_numcommands = [];",
            "endif"
          ]
        },
        {
          "name": "uptime_since",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"uptime_since(time): How much time the MOO has been up since `time'\";",
            "since = args[1];",
            "up = time() - since;",
            "for x in (this.downtimes)",
            "if (x[1] < since)",
            "\"downtime predates when we're asking about\";",
            "return up;",
            "endif",
            "\"since the server was down between x[2] and x[1], don't count it as uptime\";",
            "up = up - (x[1] - max(x[2], since));",
            "endfor",
            "return up;"
          ]
        },
        {
          "name": "count_bg_players",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "caller_perms().wizard || $error:raise(E_PERM);",
            "now = time();",
            "tasks = queued_tasks();",
            "sum = 0;",
            "for t in (tasks)",
            "delay = t[2] - now;",
            "interval = (delay <= 0) ? 1 | (delay * 2);",
            "\"SUM is measured in hundredths of a player for the moment...\";",
            "(delay <= 300) && (sum = sum + (2000 / interval));",
            "endfor",
            "count = sum / 100;",
            "return count;"
          ]
        },
        {
          "name": "blacklisted_temp graylisted_temp redlisted_temp spooflisted_temp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":blacklisted_temp(hostname) => is hostname on the .blacklist...\";",
            "\":graylisted_temp(hostname)  => is hostname on the .graylist...\";",
            "\":redlisted_temp(hostname)   => is hostname on the .redlist...\";",
            "\":spooflisted_temp(hostname) => is hostname on the .spooflist...\";",
            "\"\";",
            "\"... and the time limit hasn't run out.\";",
            "lname = this:listname(verb);",
            "sitelist = this.(\"temporary_\" + lname);",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (entry = $list_utils:assoc(hostname = args[1], sitelist[1]))",
            "return this:templist_expired(lname, @entry);",
            "elseif (entry = $list_utils:assoc(hostname, sitelist[2]))",
            "return this:templist_expired(lname, @entry);",
            "elseif ($site_db:domain_literal(hostname))",
            "for lit in (sitelist[1])",
            "if ((index(hostname, lit[1]) == 1) && ((hostname + \".\")[length(lit[1]) + 1] == \".\"))",
            "return this:templist_expired(lname, @lit);",
            "endif",
            "endfor",
            "else",
            "for dom in (sitelist[2])",
            "if (index(dom[1], \"*\"))",
            "\"...we have a wildcard; let :match_string deal with it...\";",
            "if ($string_utils:match_string(hostname, dom[1]))",
            "return this:templist_expired(lname, @dom);",
            "endif",
            "else",
            "\"...tail of hostname ...\";",
            "if ((r = rindex(hostname, dom[1])) && (((\".\" + hostname)[r] == \".\") && (((r - 1) + length(dom[1])) == length(hostname))))",
            "return this:templist_expired(lname, @dom);",
            "endif",
            "endif",
            "endfor",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "templist_expired",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"check to see if duration has expired on temporary_<colorlist>. Removes entry if so, returns true if still <colorlisted>\";",
            "\":(listname, hostname, start time, duration)\";",
            "{lname, hname, start, duration} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "if (this:uptime_since(start) > duration)",
            "this:(lname + \"_remove_temp\")(hname);",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "temp_newt_registration_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "return (\"Your character is unavailable for another \" + $time_utils:english_time(args[1])) + \".\";"
          ]
        },
        {
          "name": "add_interception",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "(caller == this) || raise(E_PERM);",
            "{who, verbname, @arguments} = args;",
            "(who in this.intercepted_players) && raise(E_INVARG, \"Player already has an interception set.\");",
            "this.intercepted_players = {@this.intercepted_players, who};",
            "this.intercepted_actions = {@this.intercepted_actions, {verbname, @arguments}};",
            "return 1;"
          ]
        },
        {
          "name": "delete_interception",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "(caller == this) || raise(E_PERM);",
            "{who} = args;",
            "if (loc = who in this.intercepted_players)",
            "this.intercepted_players = listdelete(this.intercepted_players, loc);",
            "this.intercepted_actions = listdelete(this.intercepted_actions, loc);",
            "return 1;",
            "else",
            "\"raise an error?  nah.\";",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "interception",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "(caller == this) || raise(E_PERM);",
            "{who} = args;",
            "return (loc = who in this.intercepted_players) ? this.intercepted_actions[loc] | 0;"
          ]
        },
        {
          "name": "intercepted_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "(caller == #0) || raise(E_PERM);",
            "this:delete_interception(player);",
            "set_connection_option(player, \"client-echo\", 1);",
            "notify(player, \"\");",
            "try",
            "{candidate, ?password = \"\"} = args;",
            "except (E_ARGS)",
            "return 0;",
            "endtry",
            "return this:connect(tostr(candidate), password);"
          ]
        },
        {
          "name": "do_out_of_band_command doobc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\"This is where oob handlers need to be put to handle oob commands issued prior to assigning a connection to a player object.  Right now it simply returns.\";",
            "return;"
          ]
        },
        {
          "name": "check_for_checkpoint",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "if (this.checkpoint_in_progress)",
            "line = \"***************************************************************************\";",
            "notify(player, \"\");",
            "notify(player, \"\");",
            "notify(player, line);",
            "notify(player, line);",
            "notify(player, \"****\");",
            "notify(player, \"****  NOTICE:  The server is very slow now.\");",
            "notify(player, \"****           The database is being saved to disk.\");",
            "notify(player, \"****\");",
            "notify(player, line);",
            "notify(player, line);",
            "notify(player, \"\");",
            "notify(player, \"\");",
            "endif"
          ]
        },
        {
          "name": "encrypt_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "{password} = args;",
            "salt = random_bytes(20);",
            "return argon2(password, salt, this.argon2[\"iterations\"], this.argon2[\"memory\"], this.argon2[\"threads\"]);"
          ]
        },
        {
          "name": "connection_name_lookup",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":connection_name_lookup(connection)\";",
            "\"Perform a threaded DNS lookup on 'connection' and record it to avoid multiple calls.\";",
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "endif",
            "{connection} = args;",
            "if (!(connection in this.name_lookup_players))",
            "this.name_lookup_players = setadd(this.name_lookup_players, connection);",
            "connection_name_lookup(connection, 1);",
            "endif"
          ]
        },
        {
          "name": "delete_name_lookup",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 10,
          "code": [
            "\":delete_name_lookup(connection)\";",
            "\"Remove a connection from the list of connections that have already have name lookups performed on.\";",
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "endif",
            "{connection} = args;",
            "this.name_lookup_players = setremove(this.name_lookup_players, connection);"
          ]
        },
        {
          "name": "mssp-request",
          "owner": 2,
          "perms": 93,
          "preps": -1,
          "object": 10,
          "code": [
            "\"Return MSSP variables using the plaintext fallback protocol.\";",
            "if ((caller != $sysobj) && (caller != this))",
            "return E_PERM;",
            "elseif (!$telnet.mssp_active)",
            "return 1;",
            "else",
            "tab = $string_utils.tab;",
            "mssp_data = $telnet:_mssp_data();",
            "notify(player, \"\");",
            "notify(player, \"MSSP-REPLY-START\");",
            "for value, key in (mssp_data)",
            "notify(player, tostr(key, tab, value));",
            "endfor",
            "notify(player, \"MSSP-REPLY-END\");",
            "return 0;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "welcome_message",
        "newt_registration_string",
        "registration_string",
        "registration_address",
        "create_enabled",
        "bogus_command",
        "blank_command",
        "graylist",
        "blacklist",
        "redlist",
        "who_masks_wizards",
        "max_player_name",
        "spooflist",
        "ignored",
        "max_connections",
        "connection_limit_msg",
        "lag_samples",
        "request_enabled",
        "help_message",
        "last_lag_sample",
        "lag_sample_interval",
        "lag_cutoff",
        "lag_exemptions",
        "newted",
        "current_numcommands",
        "max_numcommands",
        "temporary_newts",
        "downtimes",
        "print_lag",
        "current_lag",
        "temporary_blacklist",
        "temporary_redlist",
        "temporary_spooflist",
        "temporary_graylist",
        "intercepted_players",
        "intercepted_actions",
        "checkpoint_in_progress",
        "no_connect_message",
        "argon2",
        "name_lookup_players"
      ],
      "propdefs": [
        {
          "value": [
            "Welcome to the ToastCore database.",
            "",
            "Type 'connect wizard' to log in.",
            "",
            "You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Your character is temporarily hosed.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Character creation is disabled.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "?",
          "owner": 2,
          "perms": 1
        },
        {
          "value": "welcome",
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": 40,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 99999,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "*** The MOO is too busy! The current lag is %l; there are %n connected.  WAIT FIVE MINUTES BEFORE TRYING AGAIN.",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            0,
            0,
            0,
            0,
            0
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "Sorry, but there's no help here yet.  Type `?' for a list of commands."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 15,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 5,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": {},
          "owner": 2,
          "perms": 5
        },
        {
          "value": 20,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "iterations": 3,
            "memory": 4096,
            "threads": 1
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Login Commands"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "This provides everything needed by #0:do_login_command.  See `help $login' on $core_help for details.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            60702,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "11": {
      "id": 11,
      "name": "Player Last_huh Verbs",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 11,
          "code": [
            "\"{last_huh}  @<msg_name> <object> is [<text>]\";",
            "\"If <text> is given calls <object>:set_message(<msg_name>,<text>),\";",
            "\"otherwise prints the value of the specified message property\";",
            "set_task_perms(caller_perms());",
            "nargs = length(args);",
            "pos = \"is\" in args;",
            "if (pos == 1)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object> is <message>\"));",
            "return;",
            "endif",
            "dobjstr = $string_utils:from_list(args[1..pos - 1], \" \");",
            "message = $string_utils:from_list(args[pos + 1..nargs], \" \");",
            "msg_name = verb[2..$];",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "\"... oh well ...\";",
            "elseif (pos == nargs)",
            "if (E_PROPNF == (get = `dobj.(msg_name + \"_msg\") ! ANY'))",
            "player:notify(tostr(dobj.name, \" (\", dobj, \") has no \\\"\", msg_name, \"\\\" message.\"));",
            "elseif (typeof(get) == ERR)",
            "player:notify(tostr(get));",
            "elseif (!get)",
            "player:notify(\"Message is not set.\");",
            "else",
            "player:notify(tostr(\"The \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \"):\"));",
            "player:notify(tostr(get));",
            "endif",
            "else",
            "set = dobj:set_message(msg_name, message);",
            "if (set)",
            "if (typeof(set) == STR)",
            "player:notify(set);",
            "else",
            "player:notify(tostr(\"You set the \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \").\"));",
            "endif",
            "elseif (set == E_PROPNF)",
            "player:notify(tostr(dobj.name, \" (\", dobj, \") has no \\\"\", msg_name, \"\\\" message to set.\"));",
            "elseif (typeof(set) == ERR)",
            "player:notify(tostr(set));",
            "else",
            "player:notify(tostr(\"You clear the \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \").\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "give hand",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 11,
          "code": [
            "\"{last_huh}  give any to any\";",
            "\"a give \\\"verb\\\" that works for non-$things.\";",
            "set_task_perms(caller_perms());",
            "if (((verb == \"give\") && (dobjstr == \"up\")) && (!prepstr))",
            "player:tell(\"Try this instead: @quit\");",
            "elseif (dobj == $nothing)",
            "player:tell(\"What do you want to give?\");",
            "elseif (iobj == $nothing)",
            "player:tell(\"To whom/what do you want to give it?\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr) || $command_utils:object_match_failed(iobj, iobjstr))",
            "\"...lose...\";",
            "elseif (dobj.location != player)",
            "player:tell(\"You don't have that!\");",
            "elseif (iobj.location != player.location)",
            "player:tell(\"I don't see \", iobj.name, \" here.\");",
            "else",
            "dobj:moveto(iobj);",
            "if (dobj.location == iobj)",
            "player:tell(\"You give \", dobj:title(), \" to \", iobj.name, \".\");",
            "iobj:tell(player.name, \" gives you \", dobj:title(), \".\");",
            "else",
            "player:tell(\"Either that doesn't want to be given away or \", iobj.name, \" doesn't want it.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "get take",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 11,
          "code": [
            "\"{last_huh}  get/take any\";",
            "\"a take \\\"verb\\\" that works for non-$things.\";",
            "set_task_perms(caller_perms());",
            "if (dobj == $nothing)",
            "player:tell(verb, \" what?\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "\"...lose...\";",
            "elseif (dobj.location == player)",
            "player:tell(\"You already have that!\");",
            "elseif (dobj.location != player.location)",
            "player:tell(\"I don't see that here.\");",
            "else",
            "dobj:moveto(player);",
            "if (dobj.location == player)",
            "player:tell(\"Taken.\");",
            "player.location:announce(player.name, \" takes \", dobj.name, \".\");",
            "else",
            "player:tell(\"You can't pick that up.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "drop throw",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 11,
          "code": [
            "\"{last_huh}  drop/throw any\";",
            "\"a drop \\\"verb\\\" that works for non-$things.\";",
            "set_task_perms(caller_perms());",
            "if (dobj == $nothing)",
            "player:tell(verb, \" what?\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "\"...lose...\";",
            "elseif (dobj.location != player)",
            "player:tell(\"You don't have that.\");",
            "elseif (!player.location:acceptable(dobj))",
            "player:tell(\"You can't drop that here.\");",
            "else",
            "dobj:moveto(player.location);",
            "if (dobj.location == player.location)",
            "player:tell_lines((verb[1] == \"d\") ? \"Dropped.\" | \"Thrown.\");",
            "player.location:announce(player.name, (verb[1] == \"d\") ? \" dropped \" | \" threw away \", dobj.name, \".\");",
            "else",
            "player:tell_lines(\"You can't seem to drop that here.\");",
            "endif",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Player Last_huh Verbs"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "A repository of last-resort player verbs to be called by $player:last_huh",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            6454,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "12": {
      "id": 12,
      "name": "Guest Log",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "enter",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 12,
          "code": [
            "\":enter(who,islogin,time,site)\";",
            "\"adds an entry to the connection log for a given guest (caller).\";",
            "if ($object_utils:isa(caller, $guest))",
            "$guest_log.connections = {{caller, @args}, @$guest_log.connections[1..min($guest_log.max_entries, $)]};",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "last",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 12,
          "code": [
            "\":last([n,[guest_list]])\";",
            "\"print list of the last n entries in the guest log\";",
            "\" (use n=0 if you want all entries)\";",
            "\" optional second arg limits listing to the specified guest(s)\";",
            "set_task_perms(caller_perms());",
            "{?howmany = 0, ?which = 0} = args;",
            "howmany = min(howmany || $maxint, length($guest_log.connections));",
            "if (!caller_perms().wizard)",
            "player:notify(\"Sorry.\");",
            "else",
            "current = {};",
            "listing = {};",
            "last = 0;",
            "for c in ($guest_log.connections[1..howmany])",
            "if (which && (!(c[1] in which)))",
            "elseif (c[2])",
            "\"...login...\";",
            "if (a = $list_utils:assoc(c[1], current))",
            "listing[a[2]][3] = c[3];",
            "current = setremove(current, a);",
            "else",
            "listing = {@listing, {c[1], c[4], c[3], $object_utils:connected(c[1]) ? -idle_seconds(c[1]) | 1}};",
            "last = last + 1;",
            "endif",
            "else",
            "\"...logout...\";",
            "listing = {@listing, {c[1], c[4], 0, c[3]}};",
            "last = last + 1;",
            "if (i = $list_utils:iassoc(c[1], current))",
            "current[i][2] = last;",
            "else",
            "current = {@current, {c[1], last}};",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(2);",
            "endfor",
            "su = $string_utils;",
            "player:notify(su:left(su:left(su:left(\"Guest\", 20) + \"Connected\", 36) + \"Idle/Disconn.\", 52) + \"From\");",
            "player:notify(su:left(su:left(su:left(\"-----\", 20) + \"---------\", 36) + \"-------------\", 52) + \"----\");",
            "for l in (listing)",
            "on = l[3] ? (ct = ctime(l[3]))[1..3] + ct[9..19] | \"earlier\";",
            "off = (l[4] > 0) ? (ct = ctime(l[4]))[1..3] + ct[9..19] | (\"  \" + $string_utils:from_seconds(-l[4]));",
            "player:notify(su:left(su:left(su:right(tostr(strsub(l[1].name, \"uest\", \".\"), \" (\", l[1], \")  \"), -20) + on, 36) + off, 52) + l[2]);",
            "$command_utils:suspend_if_needed(2);",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 12,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.connections = {};",
            "endif"
          ]
        },
        {
          "name": "find",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 12,
          "code": [
            "\":find(guest_id,time)\";",
            "\" => site name of guest logged in at that time\";",
            "\" => 0 if not logged in\";",
            "\" => E_NACC if this is earlier than the earliest guest recorded\";",
            "set_task_perms(caller_perms());",
            "{who, when} = args;",
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "else",
            "found = (who in connected_players()) ? $string_utils:connection_hostname(who.last_connect_place) | 0;",
            "for c in ($guest_log.connections)",
            "if (c[3] < when)",
            "return found;",
            "elseif (c[1] != who)",
            "\"... different guest...\";",
            "elseif (c[2])",
            "\"...login...\";",
            "if (c[3] == when)",
            "return found;",
            "endif",
            "found = 0;",
            "else",
            "\"...logout...\";",
            "found = c[4];",
            "endif",
            "endfor",
            "return E_NACC;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "connections",
        "max_entries"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": 511,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Guest Log"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            5510,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "13": {
      "id": 13,
      "name": "Generic BigList Utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "length",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":length(tree) => number of leaves in tree.\";",
            "return args[1] ? args[1][2] | 0;"
          ]
        },
        {
          "name": "find_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":find_nth(tree,n) => nth leaf of tree.  Assumes n in [1..tree[2]]\";",
            "return this:_find_nth(caller, @args);"
          ]
        },
        {
          "name": "find_ord",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_find_ord(tree,n,comp) \";",
            "\" => index of rightmost leaf for which :(comp)(n,:_ord(leaf)) is false.\";",
            "\"returns 0 if true for all leaves.\";",
            "return args[1] ? this:_find_ord(caller, @args) | 0;"
          ]
        },
        {
          "name": "set_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":set_nth(tree,n,value) => tree\";",
            "\"modifies tree so that nth leaf == value\";",
            "if (((n = args[2]) < 1) || ((!(tree = args[1])) || (tree[2] < n)))",
            "return E_RANGE;",
            "else",
            "this:_set_nth(caller, @args);",
            "return (n != 1) ? tree | listset(tree, caller:_ord(args[3]), 3);",
            "endif"
          ]
        },
        {
          "name": "kill",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":kill(tree[,leafverb]) deletes tree and _kills all of the nodes that it uses.\";",
            "\"if leafverb is given, caller:leafverb is called on all leaves in tree.\";",
            "if (tree = args[1])",
            "lverb = {@args, \"\"}[2];",
            "this:_skill(caller, (typeof(tree) == LIST) ? tree[1] | tree, lverb);",
            "endif",
            "\"... otherwise nothing to do...\";"
          ]
        },
        {
          "name": "insert_after insert_before",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":insert_after(tree,subtree,n)\";",
            "\":insert_before(tree,subtree,n)\";",
            "\"  inserts subtree after (before) the nth leaf of tree,\";",
            "\"  returning the resulting tree.\";",
            "subtree = args[2];",
            "if (tree = args[1])",
            "if (subtree)",
            "where = args[3] - (verb == \"insert_before\");",
            "if (where <= 0)",
            "return this:_merge(caller, subtree, tree);",
            "elseif (where >= tree[2])",
            "return this:_merge(caller, tree, subtree);",
            "else",
            "s = this:_split(caller, caller:_get(tree[1])[1], where, tree);",
            "return this:_merge(caller, this:_merge(caller, s[1], subtree), s[2]);",
            "endif",
            "else",
            "return tree;",
            "endif",
            "else",
            "return subtree;",
            "endif"
          ]
        },
        {
          "name": "extract_range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":extract_range(tree,first,last) => {newtree,extraction}\";",
            "return this:_extract(caller, @args);"
          ]
        },
        {
          "name": "delete_range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":delete_range(tree,first,last[,leafkill]) => newtree\";",
            "extract = this:_extract(caller, @args);",
            "if (die = extract[2])",
            "this:_skill(caller, die[1], {@args, \"\"}[4]);",
            "endif",
            "return extract[1];"
          ]
        },
        {
          "name": "keep_range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":keep_range(tree,first,last[,leafkill]) => range\";",
            "extract = this:_extract(caller, @args);",
            "if (die = extract[1])",
            "this:_skill(caller, die[1], {@args, \"\"}[4]);",
            "endif",
            "return extract[2];"
          ]
        },
        {
          "name": "insert_last",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":insert_last(tree,insert) => newtree\";",
            "\"insert a new leaf to be inserted at the righthand end of the tree\";",
            "tree = args[1];",
            "insert = args[2];",
            "if (!tree)",
            "return {caller:_make(0, {insert}), 1, caller:_ord(insert)};",
            "endif",
            "hgt = caller:_get(tree[1]);",
            "rspine = {{tree, plen = length(kids = hgt[2])}};",
            "for i in [1..hgt[1]]",
            "parent = kids[plen];",
            "kids = caller:_get(parent[1])[2];",
            "plen = length(kids);",
            "rspine = {{parent, plen}, @rspine};",
            "endfor",
            "iord = caller:_ord(insert);",
            "for h in [1..length(rspine)]",
            "\"... tree is the plen'th (rightmost) child of parent...\";",
            "if (rspine[h][2] < this.maxfanout)",
            "parent = rspine[h][1];",
            "hgp = caller:_get(parent[1]);",
            "caller:_put(parent[1], @listset(hgp, {@hgp[2], insert}, 2));",
            "for p in (rspine[h + 1..length(rspine)])",
            "rkid = listset(parent, parent[2] + 1, 2);",
            "parent = p[1];",
            "hgp = caller:_get(parent[1]);",
            "caller:_put(parent[1], @listset(hgp, listset(hgp[2], rkid, p[2]), 2));",
            "endfor",
            "return listset(tree, tree[2] + 1, 2);",
            "endif",
            "insert = {caller:_make(h - 1, {insert}), 1, iord};",
            "endfor",
            "return {caller:_make(length(rspine), {tree, insert}), tree[2] + 1, tree[3]};"
          ]
        },
        {
          "name": "start",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":start(tree,first,last) => {list of leaf nodes, @handle}\";",
            "\"handle is of the form {{node,next,size}...}\";",
            "if (tree = args[1])",
            "before = max(0, args[2] - 1);",
            "howmany = min(args[3], tree[2]) - before;",
            "if (howmany <= 0)",
            "return {};",
            "else",
            "spine = {};",
            "for h in [1..caller:_get(tree[1])[1]]",
            "ik = this:_listfind_nth(kids = caller:_get(tree[1])[2], before);",
            "newh = kids[ik[1]][2] - ik[2];",
            "if (newh < howmany)",
            "spine = {{tree[1], ik[1] + 1, howmany - newh}, @spine};",
            "howmany = newh;",
            "endif",
            "tree = kids[ik[1]];",
            "before = ik[2];",
            "endfor",
            "return {caller:_get(tree[1])[2][before + 1..before + howmany], @spine};",
            "endif",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "next",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":next(@handle) => {list of more leaf nodes, @newhandle}\";",
            "if (args)",
            "spine = listdelete(args, 1);",
            "node = args[1][1];",
            "n = args[1][2];",
            "size = args[1][3];",
            "for h in [1..caller:_get(node)[1]]",
            "nnode = caller:_get(node)[2][n];",
            "if (size > nnode[2])",
            "spine = {{node, n + 1, size - nnode[2]}, @spine};",
            "size = nnode[2];",
            "endif",
            "n = 1;",
            "node = nnode[1];",
            "endfor",
            "test = caller:_get(node);",
            "return {test[2][n..size], @spine};",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "_find_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_find_nth(home,tree,n) => nth leaf of tree.\";",
            "\"...Assumes n in [1..tree[2]]\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, tree, n} = args;",
            "if ((p = home:_get(tree[1]))[1])",
            "for k in (p[2])",
            "if (n > k[2])",
            "n = n - k[2];",
            "else",
            "return this:_find_nth(home, k, n);",
            "endif",
            "endfor",
            "return E_RANGE;",
            "else",
            "return p[2][n];",
            "endif"
          ]
        },
        {
          "name": "_find_ord",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_find_ord(home,tree,n,less_than) \";",
            "\" => index of rightmost leaf for which :(less_than)(n,:_ord(leaf)) is false.\";",
            "\"returns 0 if true for all leaves.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, tree, n, less_than} = args;",
            "if ((p = home:_get(tree[1]))[1])",
            "sz = tree[2];",
            "for i in [-length(p[2])..-1]",
            "k = p[2][-i];",
            "sz = sz - k[2];",
            "if (!this:_call(home, less_than, n, k[3]))",
            "return sz + this:_find_ord(home, k, n, less_than);",
            "endif",
            "endfor",
            "return 0;",
            "else",
            "for i in [1..r = length(p[2])]",
            "if (this:_call(home, less_than, n, home:_ord(p[2][i])))",
            "return i - 1;",
            "endif",
            "endfor",
            "return r;",
            "endif"
          ]
        },
        {
          "name": "_set_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_set_nth(home,tree,n,value) => tree[n] = value\";",
            "\"Assumes n in [1..tree[2]]\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, tree, n, value} = args;",
            "if ((p = home:_get(tree[1]))[1])",
            "ik = this:_listfind_nth(p[2], n - 1);",
            "this:_set_nth(home, p[2][ik[1]], ik[2] + 1, value);",
            "if (!ik[2])",
            "p[2][ik[1]][3] = home:_ord(value);",
            "home:_put(tree[1], @p);",
            "endif",
            "else",
            "p[2][n] = value;",
            "home:_put(tree[1], @p);",
            "endif"
          ]
        },
        {
          "name": "_skill",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_skill(home,node,kill_leaf)\";",
            "\"home:_kill's node and all descendants, home:(kill_leaf)'s all leaves\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, node, kill_leaf} = args;",
            "try",
            "{height, subtrees} = home:_get(node) || {0, {}};",
            "except (E_PROPNF)",
            "return;",
            "endtry",
            "if (height)",
            "for kid in (subtrees)",
            "this:_skill(home, kid[1], kill_leaf);",
            "endfor",
            "elseif (kill_leaf)",
            "for kid in (subtrees)",
            "this:_call(home, kill_leaf, kid);",
            "endfor",
            "endif",
            "home:_kill(node);"
          ]
        },
        {
          "name": "_extract",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_extract(home,tree,first,last) => {newtree,extraction}\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "home = args[1];",
            "if (!(tree = args[2]))",
            "return {{}, {}};",
            "endif",
            "before = max(0, args[3] - 1);",
            "end = min(tree[2], args[4]);",
            "if ((end <= 0) || (before >= end))",
            "return {tree, {}};",
            "endif",
            "height = home:_get(tree[1])[1];",
            "if (end < tree[2])",
            "r = this:_split(home, height, end, tree);",
            "if (before)",
            "l = this:_split(home, height, before, r[1]);",
            "extract = l[2];",
            "newtree = this:_merge(home, l[1], r[2]);",
            "else",
            "extract = r[1];",
            "newtree = r[2];",
            "endif",
            "elseif (before)",
            "l = this:_split(home, height, before, tree);",
            "extract = l[2];",
            "newtree = l[1];",
            "else",
            "return {{}, tree};",
            "endif",
            "return {this:_scrunch(home, newtree), this:_scrunch(home, extract)};"
          ]
        },
        {
          "name": "_merge",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\"_merge(home,ltree,rtree) => newtree\";",
            "\"assumes ltree and rtree to be nonempty.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, lnode, rnode} = args;",
            "lh = home:_get(lnode[1])[1];",
            "rh = home:_get(rnode[1])[1];",
            "if (lh > rh)",
            "return this:_rmerge(home, lnode, rnode);",
            "endif",
            "for h in [lh + 1..rh]",
            "lnode[1] = home:_make(h, {lnode});",
            "endfor",
            "m = this:_smerge(home, rh, lnode, rnode);",
            "return (length(m) <= 1) ? m[1] | {home:_make(rh + 1, m), m[1][2] + m[2][2], m[1][3]};"
          ]
        },
        {
          "name": "_smerge",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\"_smerge(home, height, ltree, rtree) =>{ltree[,rtree]}\";",
            "\"assumes ltree and rtree are at the given height.\";",
            "\"merges the trees if the combined number of children is <= maxfanout\";",
            "\"otherwise returns two trees where ltree is guaranteed minfanout children and rtree is guaranteed the minimum of minfanout and however many children it started with.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, height, ltree, rtree} = args;",
            "llen = length(lkids = home:_get(ltree[1])[2]);",
            "rlen = length(rkids = home:_get(rtree[1])[2]);",
            "if (height)",
            "m = this:_smerge(home, height - 1, lkids[llen], rkids[1]);",
            "mlen = length(mkids = {@listdelete(lkids, llen), @m, @listdelete(rkids, 1)});",
            "if (mlen <= this.maxfanout)",
            "home:_put(ltree[1], height, mkids);",
            "home:_kill(rtree[1]);",
            "ltree[2] = ltree[2] + rtree[2];",
            "return {ltree};",
            "else",
            "S = max(llen - 1, (mlen + 1) / 2);",
            "home:_put(ltree[1], height, mkids[1..S]);",
            "home:_put(rtree[1], height, mkids[S + 1..$]);",
            "xfer = -lkids[llen][2];",
            "for k in (mkids[llen..S])",
            "xfer = xfer + k[2];",
            "endfor",
            "ltree[2] = ltree[2] + xfer;",
            "rtree[2] = rtree[2] - xfer;",
            "rtree[3] = mkids[S + 1][3];",
            "return {ltree, rtree};",
            "endif",
            "elseif ((llen * 2) >= this.maxfanout)",
            "return {ltree, rtree};",
            "elseif (this.maxfanout < (llen + rlen))",
            "T = ((rlen - llen) + 1) / 2;",
            "home:_put(ltree[1], 0, {@lkids, @rkids[1..T]});",
            "home:_put(rtree[1], 0, rkids[T + 1..rlen]);",
            "ltree[2] = ltree[2] + T;",
            "rtree[2] = rtree[2] - T;",
            "rtree[3] = home:_ord(rkids[T + 1]);",
            "return {ltree, rtree};",
            "else",
            "home:_put(ltree[1], 0, {@lkids, @rkids});",
            "home:_kill(rtree[1]);",
            "ltree[2] = ltree[2] + rtree[2];",
            "return {ltree};",
            "endif"
          ]
        },
        {
          "name": "_split",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\"_split(home, height,lmax,ltree[,@rtrees]}) => {ltree,[mtree,]@rtrees}\";",
            "\"ltree is split after the lmax'th leaf, the righthand portion grafted onto the leftmost of the rtrees, if possible.  Otherwise we create a new tree mtree, stealing from rtrees[1] if necessary.\";",
            "\"Assumes 1<=lmax<ltree[2]\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, height, lmax, ltree, @rtrees} = args;",
            "llen = length(lkids = home:_get(ltree[1])[2]);",
            "rlen = length(rkids = rtrees ? home:_get(rtrees[1][1])[2] | {});",
            "if (height)",
            "ik = this:_listfind_nth(lkids, lmax);",
            "if (ik[2])",
            "llast = ik[1];",
            "m = this:_split(home, height - 1, ik[2], lkids[llast], @lkids[llast + 1..llen], @rkids);",
            "lkids[llast] = m[1];",
            "mkids = listdelete(m, 1);",
            "else",
            "llast = ik[1] - 1;",
            "mkids = {@lkids[ik[1]..llen], @rkids};",
            "endif",
            "home:_put(ltree[1], height, lkids[1..llast]);",
            "mlen = length(mkids);",
            "if ((((mlen - rlen) * 2) >= this.maxfanout) || (!rtrees))",
            "\"...residue left over from splitting ltree can stand by itself...\";",
            "return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen - rlen]), ltree[2] - lmax, mkids[1][3]}, @rtrees};",
            "elseif (mlen <= this.maxfanout)",
            "\"...residue left over from splitting ltree fits in rtrees[1]...\";",
            "home:_put(rtrees[1][1], height, mkids);",
            "rtrees[1][2] = (ltree[2] - lmax) + rtrees[1][2];",
            "rtrees[1][3] = mkids[1][3];",
            "return {listset(ltree, lmax, 2), @rtrees};",
            "else",
            "\"...need to steal from rtrees[1]...\";",
            "if (llast < llen)",
            "msize = ltree[2] - lmax;",
            "R = (mlen - rlen) + 1;",
            "else",
            "msize = 0;",
            "R = 1;",
            "endif",
            "for k in (mkids[R..mlen / 2])",
            "msize = msize + k[2];",
            "endfor",
            "home:_put(rtrees[1][1], height, mkids[(mlen / 2) + 1..mlen]);",
            "rtrees[1][2] = (rtrees[1][2] + ltree[2]) - (lmax + msize);",
            "rtrees[1][3] = mkids[(mlen / 2) + 1][3];",
            "return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen / 2]), msize, mkids[1][3]}, @rtrees};",
            "endif",
            "else",
            "home:_put(ltree[1], 0, lkids[1..lmax]);",
            "if ((((llen - lmax) * 2) >= this.maxfanout) || (!rtrees))",
            "\"...residue left over from splitting ltree can stand by itself...\";",
            "return {listset(ltree, lmax, 2), {home:_make(0, lkids[lmax + 1..llen]), llen - lmax, home:_ord(lkids[lmax + 1])}, @rtrees};",
            "elseif ((mlen = (rlen + llen) - lmax) <= this.maxfanout)",
            "\"...residue left over from splitting ltree fits in rtrees[1]...\";",
            "home:_put(rtrees[1][1], 0, {@lkids[lmax + 1..llen], @rkids});",
            "rtrees[1][2] = mlen;",
            "rtrees[1][3] = home:_ord(lkids[lmax + 1]);",
            "return {listset(ltree, lmax, 2), @rtrees};",
            "else",
            "\"...need to steal from rtrees[1]...\";",
            "home:_put(rtrees[1][1], 0, rkids[(R = ((rlen - llen) + lmax) / 2) + 1..rlen]);",
            "rtrees[1][2] = (mlen + 1) / 2;",
            "rtrees[1][3] = home:_ord(rkids[R + 1]);",
            "return {listset(ltree, lmax, 2), {home:_make(0, {@lkids[lmax + 1..llen], @rkids[1..R]}), mlen / 2, home:_ord(lkids[lmax + 1])}, @rtrees};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "_rmerge",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_rmerge(home, tree, insertree) => newtree \";",
            "\"(newtree is tree with insertree appended to the right)\";",
            "\"insertree is assumed to be of height < tree\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{home, tree, insert} = args;",
            "if (!tree)",
            "return insert;",
            "elseif (!insert)",
            "return tree;",
            "endif",
            "iheight = home:_get(insert[1])[1];",
            "rspine = {};",
            "for i in [iheight + 1..home:_get(tree[1])[1]]",
            "kids = home:_get(tree[1])[2];",
            "tlen = length(kids);",
            "rspine = {{tree, tlen}, @rspine};",
            "tree = kids[tlen];",
            "endfor",
            "isize = insert[2];",
            "m = this:_smerge(home, iheight, tree, insert);",
            "for h in [1..length(rspine)]",
            "plen = rspine[h][2];",
            "parent = rspine[h][1];",
            "hgp = home:_get(parent[1]);",
            "if (((length(m) - 1) + plen) > this.maxfanout)",
            "home:_put(parent[1], @listset(hgp, listset(hgp[2], m[1], plen), 2));",
            "parent[2] = (parent[2] + isize) - m[2][2];",
            "m = {parent, listset(m[2], home:_make(h + iheight, {m[2]}), 1)};",
            "else",
            "home:_put(parent[1], @listset(hgp, {@hgp[2][1..plen - 1], @m}, 2));",
            "for p in (rspine[h + 1..length(rspine)])",
            "parent[2] = parent[2] + isize;",
            "tree = parent;",
            "parent = p[1];",
            "hgp = home:_get(parent[1]);",
            "home:_put(parent[1], @listset(hgp, listset(hgp[2], tree, p[2]), 2));",
            "endfor",
            "return listset(parent, parent[2] + isize, 2);",
            "endif",
            "endfor",
            "return {home:_make((length(rspine) + iheight) + 1, m), m[1][2] + m[2][2], m[1][3]};"
          ]
        },
        {
          "name": "_scrunch",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_scrunch(home,tree) => newtree\";",
            "\"decapitates single-child nodes from the top of the tree, returns new root.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "if (tree = args[2])",
            "home = args[1];",
            "while ((n = home:_get(tree[1]))[1] && (length(n[2]) == 1))",
            "home:_kill(tree[1]);",
            "tree = n[2][1];",
            "endwhile",
            "endif",
            "return tree;"
          ]
        },
        {
          "name": "_listfind_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\"_listfind_nth(nodelist,key) => {i,k} where i is the smallest i such that the sum of the first i elements of intlist is > key, and k==key - sum(first i-1 elements).\";",
            "\"1 <= i <= length(intlist)+1\";",
            "{lst, key} = args;",
            "for i in [1..length(lst)]",
            "key = key - lst[i][2];",
            "if (0 > key)",
            "return {i, key + lst[i][2]};",
            "endif",
            "endfor",
            "return {length(lst) + 1, key};"
          ]
        },
        {
          "name": "_insertfirst",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "debug",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "return $perm_utils:controls(caller_perms(), this) ? this:(args[1])(@listdelete(args, 1)) | E_PERM;"
          ]
        },
        {
          "name": "_call",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 13,
          "code": [
            "\":_call(home,verb,@vargs) calls home:verb(@vargs) with $no_one's perms\";",
            "set_task_perms($no_one);",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "{home, vb, @vargs} = args;",
            "return home:(vb)(@vargs);"
          ]
        }
      ],
      "propnames": [
        "about",
        "maxfanout"
      ],
      "propdefs": [
        {
          "value": [
            "Implementation notes",
            "--------------------",
            "Each biglist is actually a tree (a kind of B-tree, actually).",
            "The routines above pass around handles of the form",
            "",
            "    {root_node, size, leftmost_ord}",
            "",
            "where root_node is the (string) name of a property that holds the root of the tree, size is the number of leaves in the tree, and leftmost_ord is the :_ord value of the leftmost element of the list (i.e., the leftmost leaf).",
            "Each node property has a value of the form ",
            "",
            "    {height,list of subtrees}.",
            "",
            "where the each of the subtrees is itself a 3-element list as above unless",
            "the height is 0, in which case the subtrees are actually biglist elements of the arbitrary form determined by the home object.",
            "At every level, each node except the rightmost has between this.maxfanout/2 and this.maxfanout subtrees; the rightmost is allowed to have as few as 1 subtree."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 7,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Generic BigList Utilities",
            "----------------------------",
            "This is a package for maintaining huge persistent (sorted) lists in a format that is less likely to spam the server (which runs into a certain amount of trouble dealing with long ordinary lists --- btw we use `biglist' to refer to the huge data structure we're about to describe and `list' to refer to ordinary MOO lists {...}).  The biglist in question lives on a particular object, to which we will refer in the discussion below as the `home' object, and its various elements appear as leaves of a tree whose nodes are kept in properties of the home object.  It should be noted that the home object does not need to be (and in fact should *not* be) a descendant of this one; this object merely provides utilities for manipulating the properties on the home object that are used in a particular biglist manipulation.  ",
            "",
            "All of the utilities below refer to `caller' to locate the home object.  Thus verbs to manipulate a given biglist must be located on or inherited by its home object itself.  The home object needs to define the following verbs",
            "",
            "  :_make(@args)     => new property on home object with value args",
            "  :_kill(prop)      delete a given property that was created by :_make",
            "  :_get(prop)       => home.prop",
            "  :_put(prop,@args) set home.prop = args",
            "  :_ord(element)    given something that is of the form of a biglist element",
            "                    return the corresponding ordinal (for sorting purposes).",
            "                    If you never intend to use :find_ord, then this can be a ",
            "                    routine that always returns 0 or some other random value.",
            "",
            "See #5546 (Generic Biglist Resident) or $big_mail_recipient",
            "for examples.",
            "",
            "Those of the following routines that take a biglist argument are expecting",
            "either {} (empty biglist) or some biglist returned by one of the other routines",
            "",
            "  :length(biglist)          => length(biglist) (i.e., number of elements)",
            "  :find_nth(biglist,n)      => biglist[n]",
            "  :find_ord(biglist,k,comp) => n where n is",
            "     the largest such that home:(comp)(k,home:_ord(biglist[n])) is false, or",
            "     the smallest such that home:(comp)(k,home:_ord(biglist[n+1])) is true.",
            "     Always returns a value between 0 and length(biglist) inclusive.",
            "     This assumes biglist to be sorted in order of increasing :_ord values ",
            "     with respect to home:(comp)().",
            "     Standard situation is :_ord returns a number and comp is a < verb.",
            "",
            "  :start(biglist,s,e)  => {biglist[s..?],@handle} or {}",
            "  :next(@handle)       => {biglist[?+1..??],@newhandle} or {}",
            "     These two are used for iterating over a range of elements of a biglist",
            "     The canonical incantation for doing",
            "        for elt in (biglist[first..last])",
            "          ...",
            "        endfor",
            "     is",
            "        handle = :start(biglist,first,last);",
            "        while(handle)",
            "          for elt in (handle[1])",
            "            ...",
            "          endfor",
            "          handle = :next(@listdelete(handle,1));",
            "        endwhile",
            "",
            "The following all destructively modify their biglist argument(s) L (and M).",
            "",
            "  :set_nth(L,n,value)  =>  L[n] = value",
            "     replaces the indicated element",
            "",
            "  :insert_before(L,M,n) => {@L[1..n-1],@M,@L[n..length(L)]}",
            "  :insert_after (L,M,n) => {@L[1..n],  @M,@L[n+1..length(L)]}",
            "     takes two distinct biglists, inserts one into the other at the given point",
            "     returns the resulting consolidated biglist",
            "",
            "  :extract_range(L,m,n) => {{@L[1..m-1],@L[n+1..]}, L[m..n]} ",
            "     breaks the given biglist into two distinct biglists.",
            "",
            "  :delete_range(L,m,n[,leafkiller]) => {@L[1..m-1],@L[n+1..]}",
            "  :keep_range  (L,m,n[,leafkiller]) => L[m..n]",
            "     like extract_range only we destroy what we don't want.",
            "",
            "  :insertlast(L,value)  => {@L,value}",
            "     inserts a new element at the end of biglist.  ",
            "     If find_ord is to continue to work properly, it is assumed that the ",
            "     home:_ord(elt) is greater (comp-wise) than all of the :_ord values",
            "     of elements currently in the biglist.",
            "",
            "  :kill(L[,leafkiller]) ",
            "     destroys all nodes used by biglist.  ",
            "     Calls home:leafkiller on each element."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "ghblu",
            "biglist_utils"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "This is the Generic BigList Utilities utility package.  See `help $biglist' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            30986,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "14": {
      "id": 14,
      "name": "Generic Large-Capacity Mail Recipient",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        45
      ],
      "children": [
        17
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "_genprop",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "gp = this._genprop;",
            "ngp = \"\";",
            "for i in [1..length(gp)]",
            "if (gp[i] != \"z\")",
            "ngp = (ngp + \"bcdefghijklmnopqrstuvwxyz\"[index(\"abcdefghijklmnopqrstuvwxy\", gp[i])]) + gp[i + 1..length(gp)];",
            "return \" \" + (this._genprop = ngp);",
            "endif",
            "ngp = ngp + \"a\";",
            "endfor",
            "return \" \" + (this._genprop = ngp + \"a\");"
          ]
        },
        {
          "name": "_make",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":_make(...) => new node with value {...}\";",
            "if (!(caller in {this._mgr, this}))",
            "return E_PERM;",
            "endif",
            "prop = this:_genprop();",
            "`add_property(this, prop, args, {this.mowner, \"\"}) ! ANY';",
            "return prop;"
          ]
        },
        {
          "name": "_kill",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":_kill(node) destroys the given node.\";",
            "if (!(caller in {this, this._mgr}))",
            "return E_PERM;",
            "endif",
            "`delete_property(this, args[1]) ! ANY';"
          ]
        },
        {
          "name": "_get",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return (caller == this._mgr) ? `this.(args[1]) ! ANY' | E_PERM;"
          ]
        },
        {
          "name": "_put",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;"
          ]
        },
        {
          "name": "_ord",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[1][2..3];"
          ]
        },
        {
          "name": "_makemsg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":_makemsg(ord,msg) => leafnode for msg\";",
            "\"msg = $mail_agent:__convert_new(@args[2])\";",
            "msg = args[2];",
            "if (caller != this)",
            "return E_PERM;",
            "elseif (h = \"\" in msg)",
            "return {this:_make(@msg[h + 1..$]), args[1], @msg[1..h - 1]};",
            "else",
            "return {0, args[1], @msg};",
            "endif"
          ]
        },
        {
          "name": "_killmsg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (caller != this._mgr)",
            "return E_PERM;",
            "elseif (node = args[1][1])",
            "this:_kill(node);",
            "endif"
          ]
        },
        {
          "name": "_message_num",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[2];"
          ]
        },
        {
          "name": "_message_date",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[3];"
          ]
        },
        {
          "name": "_message_hdr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[3..$];"
          ]
        },
        {
          "name": "_message_text",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if ((caller == this) || this:is_readable_by(caller_perms()))",
            "\"perms check added HTC 16 Feb 1999\";",
            "return {@args[3..$], @args[1] ? {\"\", @this.(args[1])} | {}};",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "_lt_msgnum",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[1] < args[2][1];"
          ]
        },
        {
          "name": "_lt_msgdate",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return args[1] < args[2][2];"
          ]
        },
        {
          "name": "receive_batch",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:is_writable_by(caller_perms()))",
            "return E_PERM;",
            "else",
            "new = this:new_message_num();",
            "msgtree = this.messages;",
            "for m in (args)",
            "msgtree = this._mgr:insert_last(msgtree, this:_makemsg(new, m[2]));",
            "new = new + 1;",
            "if ($command_utils:running_out_of_time())",
            "this.messages = msgtree;",
            "player:tell(\"... \", new);",
            "suspend(0);",
            "msgtree = this.messages;",
            "new = this:new_message_num();",
            "endif",
            "endfor",
            "this.messages = msgtree;",
            "this.last_used_time = time();",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "receive_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:is_writable_by(caller_perms()))",
            "return E_PERM;",
            "else",
            "this.messages = this._mgr:insert_last(this.messages, msg = this:_makemsg(new = this:new_message_num(), args[1]));",
            "this.last_msg_date = this:_message_date(@msg);",
            "this.last_used_time = time();",
            "return new;",
            "endif"
          ]
        },
        {
          "name": "messages_in_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (typeof(seq = args[1]) != LIST)",
            "x = this._mgr:find_nth(this.messages, seq);",
            "return {this:_message_num(@x), this:_message_text(@x)};",
            "else",
            "msgs = {};",
            "while (seq)",
            "handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);",
            "while (handle)",
            "for x in (handle[1])",
            "msgs = {@msgs, {this:_message_num(@x), this:_message_text(@x)}};",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "seq = seq[3..$];",
            "endwhile",
            "return msgs;",
            "endif"
          ]
        },
        {
          "name": "display_seq_headers",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":display_seq_headers(msg_seq[,cur[,last_read_date]])\";",
            "\"This is the default header display routine.\";",
            "\"Prints a list of headers of messages on this to player.  msg_seq is the handle returned by this:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "getmsg = this.summary_uses_body ? \"_message_text\" | \"_message_hdr\";",
            "{seq, ?cur = 0, ?last_old = $maxint} = args;",
            "keep_seq = {@$seq_utils:contract(this:kept_msg_seq(), $seq_utils:complement(seq, 1, this:length_all_msgs())), $maxint};",
            "k = 1;",
            "mcount = 0;",
            "width = player:linelen();",
            "while (seq)",
            "handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);",
            "while (handle)",
            "for x in (handle[1])",
            "$command_utils:suspend_if_needed(0);",
            "if (keep_seq[k] <= (mcount = mcount + 1))",
            "k = k + 1;",
            "endif",
            "annot = (x[3] > last_old) ? \"+\" | ((k % 2) ? \" \" | \"=\");",
            "line = tostr($string_utils:right(x[2], 5, (cur == x[2]) ? \">\" | \" \"), \":\", annot, \" \", this:msg_summary_line(@this:(getmsg)(@x)));",
            "player:tell(line[1..min(width, $)]);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "seq = seq[3..$];",
            "endwhile",
            "player:tell(\"-----+\");"
          ]
        },
        {
          "name": "display_seq_full",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":display_seq_full(msg_seq[,preamble]) => {cur}\";",
            "\"This is the default message display routine.\";",
            "\"Prints the indicated messages on folder to player.  msg_seq is the handle returned by folder:parse_message_seq(...).  Returns the number of the final message in the sequence (to be the new current message number).\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{seq, ?preamble = \"\"} = args;",
            "cur = date = 0;",
            "while (seq)",
            "handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);",
            "while (handle)",
            "for x in (handle[1])",
            "cur = this:_message_num(@x);",
            "date = this:_message_date(@x);",
            "player:display_message(preamble ? strsub(preamble, \"%d\", tostr(cur)) | {}, this:msg_full_text(@this:_message_text(@x)));",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "seq = seq[3..$];",
            "endwhile",
            "return {cur, date};"
          ]
        },
        {
          "name": "list_rmm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "len = 0;",
            "getmsg = this.summary_uses_body ? \"_message_text\" | \"_message_hdr\";",
            "going = this.messages_going;",
            "if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))",
            "kept = {@going[1], $maxint};",
            "going = going[2];",
            "else",
            "kept = {$maxint};",
            "endif",
            "k = 1;",
            "mcount = 0;",
            "for s in (going)",
            "if (kept[k] <= (mcount = mcount + s[1]))",
            "k = k + 1;",
            "endif",
            "len = len + s[2][2];",
            "handle = this._mgr:start(s[2], 1, s[2][2]);",
            "while (handle)",
            "for x in (handle[1])",
            "if (kept[k] <= (mcount = mcount + 1))",
            "k = k + 1;",
            "endif",
            "player:tell($string_utils:right(this:_message_num(@x), 4), (k % 2) ? \":  \" | \":= \", this:msg_summary_line(@this:(getmsg)(@x)));",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "if (len)",
            "player:tell(\"----+\");",
            "endif",
            "return len;"
          ]
        },
        {
          "name": "undo_rmm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "msgtree = this.messages;",
            "seq = {};",
            "last = 0;",
            "\"there are two possible formats here:\";",
            "\"OLD: {{n,msgs},{n,msgs},...}\";",
            "\"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}\";",
            "going = this.messages_going;",
            "if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))",
            "kept = going[1];",
            "going = going[2];",
            "else",
            "kept = {};",
            "endif",
            "for s in (going)",
            "msgtree = this._mgr:insert_after(msgtree, s[2], last + s[1]);",
            "seq = {@seq, (last + s[1]) + 1, (last = (last + s[1]) + s[2][2]) + 1};",
            "endfor",
            "this.messages = msgtree;",
            "this.messages_going = {};",
            "this.messages_kept = $seq_utils:union(kept, $seq_utils:expand(this.messages_kept, seq));",
            "this:_fix_last_msg_date();",
            "return seq;"
          ]
        },
        {
          "name": "expunge_rmm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "len = 0;",
            "going = this.messages_going;",
            "if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))",
            "going = going[2];",
            "endif",
            "for s in (going)",
            "len = len + s[2][2];",
            "this._mgr:kill(s[2], \"_killmsg\");",
            "endfor",
            "this.messages_going = {};",
            "return len;"
          ]
        },
        {
          "name": "rm_message_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "seq = args[1];",
            "if (!(this:ok_write(caller, caller_perms()) || (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))))",
            "return E_PERM;",
            "endif",
            "msgtree = this.messages;",
            "save = nums = {};",
            "onext = 1;",
            "rmmed = 0;",
            "for i in [1..length(seq) / 2]",
            "if ($command_utils:suspend_if_needed(0))",
            "player:tell(\"... rmm \", onext);",
            "suspend(0);",
            "endif",
            "start = seq[(2 * i) - 1];",
            "next = seq[2 * i];",
            "{msgtree, zmsgs} = this._mgr:extract_range(msgtree, start - rmmed, (next - 1) - rmmed);",
            "save = {@save, {start - onext, zmsgs}};",
            "nums = {@nums, this:_message_num(@this._mgr:find_nth(zmsgs, 1)), this:_message_num(@this._mgr:find_nth(zmsgs, zmsgs[2])) + 1};",
            "onext = next;",
            "rmmed = (rmmed + next) - start;",
            "endfor",
            "tmg = this.messages_going;",
            "save_kept = $seq_utils:intersection(this.messages_kept, seq);",
            "this.messages_kept = $seq_utils:contract(this.messages_kept, seq);",
            "this.messages_going = save_kept ? {save_kept, save} | save;",
            "fork (0)",
            "for s in (tmg)",
            "this._mgr:kill(s[2], \"_killmsg\");",
            "endfor",
            "endfork",
            "this.messages = msgtree;",
            "this:_fix_last_msg_date();",
            "return $seq_utils:tostr(nums);"
          ]
        },
        {
          "name": "renumber",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":renumber([cur]) renumbers caller.messages, doing a suspend() if necessary.\";",
            "\"  => {number of messages,new cur}.\";",
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{?cur = 0} = args;",
            "this:expunge_rmm();",
            "\"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...\";",
            "if (!(msgtree = this.messages))",
            "return {0, 0};",
            "endif",
            "if (cur)",
            "cur = this._mgr:find_ord(msgtree, cur - 1, \"_lt_msgnum\") + 1;",
            "endif",
            "while (1)",
            "\"...find first out-of-sequence message...\";",
            "n = 1;",
            "subtree = msgtree;",
            "if (msgtree[3][1] == 1)",
            "while ((node = this.(subtree[1]))[1])",
            "\"...subtree[3][1]==n...\";",
            "kids = node[2];",
            "n = n + subtree[2];",
            "i = length(kids);",
            "while ((n = n - kids[i][2]) != kids[i][3][1])",
            "i = i - 1;",
            "endwhile",
            "subtree = kids[i];",
            "endwhile",
            "leaves = node[2];",
            "n = ((firstn = n) + length(leaves)) - 1;",
            "while (n != leaves[(n - firstn) + 1][2])",
            "n = n - 1;",
            "endwhile",
            "n = n + 1;",
            "endif",
            "\"... n == first out-of-sequence ...\";",
            "\"...renumber as many messages as we have time for...\";",
            "while ((n <= msgtree[2]) && (!$command_utils:running_out_of_time()))",
            "msg = this._mgr:find_nth(msgtree, n);",
            "msgtree = this._mgr:set_nth(msgtree, n, listset(msg, n, 2));",
            "n = n + 1;",
            "endwhile",
            "this.messages = msgtree;",
            "if (n > msgtree[2])",
            "return {n - 1, cur};",
            "endif",
            "player:tell(\"...(renumbering to \", n - 1, \")\");",
            "suspend(0);",
            "\"...start over... may have received new mail, rmm'ed stuff, etc...\";",
            "\"...so who knows what's there now?...\";",
            "if (this.messages_going)",
            "player:tell(\"Renumber aborted.\");",
            "return;",
            "endif",
            "msgtree = this.messages;",
            "endwhile"
          ]
        },
        {
          "name": "length_all_msgs",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return this:ok(caller, caller_perms()) ? this.messages ? this.messages[2] | 0 | E_PERM;"
          ]
        },
        {
          "name": "length_num_le",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], \"_lt_msgnum\") | E_PERM;"
          ]
        },
        {
          "name": "length_date_le",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], \"_lt_msgdate\") | E_PERM;"
          ]
        },
        {
          "name": "exists_num_eq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return this:ok(caller, caller_perms()) ? (i = this._mgr:find_ord(this.messages, args[1], \"_lt_msgnum\")) && ((this:_message_num(@this._mgr:find_nth(this.messages, i)) == args[1]) && i) | E_PERM;"
          ]
        },
        {
          "name": "new_message_num",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (this:ok(caller, caller_perms()))",
            "new = (msgtree = this.messages) ? this:_message_num(@this._mgr:find_nth(msgtree, msgtree[2])) + 1 | 1;",
            "if (rmsgs = this.messages_going)",
            "lbrm = rmsgs[$][2];",
            "return max(new, this:_message_num(@this._mgr:find_nth(lbrm, lbrm[2])) + 1);",
            "else",
            "return new;",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "from_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":from_msg_seq(object or list)\";",
            "\" => msg_seq of messages from any of these senders\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{plist, ?mask = {1, this.messages[2] + 1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "fseq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "fromline = msg[4];",
            "for f in ($mail_agent:parse_address_field(fromline))",
            "if (f in plist)",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "endfor",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%from_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":%from_msg_seq(string or list of strings)\";",
            "\" => msg_seq of messages with one of these strings in the from line\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{nlist, ?mask = {1, this.messages[2] + 1}} = args;",
            "if (typeof(nlist) != LIST)",
            "nlist = {nlist};",
            "endif",
            "fseq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "fromline = \" \" + msg[4];",
            "for n in (nlist)",
            "if (index(fromline, n))",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "endfor",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "to_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":to_msg_seq(object or list) => msg_seq of messages to those people\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{plist, ?mask = {1, this.messages[2] + 1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "seq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "toline = msg[5];",
            "for r in ($mail_agent:parse_address_field(toline))",
            "if (r in plist)",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "endfor",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%to_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":%to_msg_seq(string or list of strings)\";",
            "\" => msg_seq of messages containing one of strings in the to line\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{nlist, ?mask = {1, this.messages[2] + 1}} = args;",
            "if (typeof(nlist) != LIST)",
            "nlist = {nlist};",
            "endif",
            "seq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "toline = \" \" + msg[5];",
            "for n in (nlist)",
            "if (index(toline, n))",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "endfor",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "subject_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{target, ?mask = {1, this.messages[2] + 1}} = args;",
            "seq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "if (((subject = msg[6]) != \" \") && index(subject, target))",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return seq || ((\"%f %<has> no messages with subjects containing `\" + target) + \"'\");"
          ]
        },
        {
          "name": "body_msg_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":body_msg_seq(target) => msg_seq of messages with target in the body\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!this.messages)",
            "return {};",
            "endif",
            "{target, ?mask = {1, this.messages[2] + 1}} = args;",
            "seq = {};",
            "for m in [1..length(mask) / 2]",
            "handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);",
            "while (handle)",
            "for msg in (handle[1])",
            "if ((msg[1] && (body = this.(msg[1]))) && index(tostr(@body), target))",
            "seq = $seq_utils:add(seq, i, i);",
            "\"Above saves ticks. Munges the whole message into one string and indexes it. Old code follows.\";",
            "\"l = length(body);\";",
            "\"while (!index(body[l], target) && (l = l - 1))\";",
            "\"$command_utils:suspend_if_needed(0);\";",
            "\"endwhile\";",
            "\"if (l)\";",
            "\"seq = $seq_utils:add(seq, i, i);\";",
            "\"endif\";",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "handle = this._mgr:next(@listdelete(handle, 1));",
            "endwhile",
            "endfor",
            "return seq || tostr(\"%f %<has> no messages containing `\", target, \"' in the body.\");"
          ]
        },
        {
          "name": "date_sort",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "return E_VERBNF;"
          ]
        },
        {
          "name": "_fix_last_msg_date",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "msgtree = this.messages;",
            "this.last_msg_date = (msgtree && this:_message_hdr(@this._mgr:find_nth(msgtree, msgtree[2]))[1]) || 0;"
          ]
        },
        {
          "name": "__fix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{?doit = 0} = args;",
            "msgtree = this.messages;",
            "for n in [1..msgtree[2]]",
            "msg = this._mgr:find_nth(msgtree, n);",
            "msg = {@msg[1..2], @$mail_agent:__convert_new(@msg[3..$])};",
            "if (doit)",
            "msgtree = this._mgr:set_nth(msgtree, n, msg);",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "suspend(0);",
            "if (this.messages != msgtree)",
            "player:notify(\"urk.  someone played with this folder.\");",
            "return 0;",
            "endif",
            "endif",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (caller_perms().wizard)",
            "this._mgr = $biglist;",
            "this.mowner = $mail_recipient.owner;",
            "for p in (properties(this))",
            "$command_utils:suspend_if_needed(0);",
            "if (p && (p[1] == \" \"))",
            "delete_property(this, p);",
            "endif",
            "endfor",
            "this.messages = this.messages_going = {};",
            "this:_fix_last_msg_date();",
            "this._genprop = \"\";",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "length_date_gt",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "if (this:ok(caller, caller_perms()))",
            "date = args[1];",
            "return (this.last_msg_date <= date) ? 0 | (this.messages[2] - this._mgr:find_ord(this.messages, args[1], \"_lt_msgdate\"));",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "_repair",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 14,
          "code": [
            "c = callers();",
            "if ((caller != this) && (!((((length(c) > 1) && (c[1][1] == $list_utils)) && (c[1][2] == \"map_arg\")) && (c[2][1] == this))))",
            "raise(E_PERM);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "biglist = this;",
            "propname = args[1];",
            "if (!propname)",
            "bestlevel = -1;",
            "best = {};",
            "for prop in (properties(biglist))",
            "$command_utils:suspend_if_needed(0);",
            "if (index(prop, \" \") == 1)",
            "val = biglist.(prop);",
            "if (typeof(val[1]) == INT)",
            "if (bestlevel < val[1])",
            "bestlevel = val[1];",
            "best = {prop};",
            "elseif (bestlevel == val[1])",
            "best = {@best, prop};",
            "endif",
            "endif",
            "endif",
            "endfor",
            "if (!best)",
            "player:notify(\"Can't find a root.\");",
            "raise(E_INVARG);",
            "elseif (length(best) == 1)",
            "propname = best[1];",
            "else",
            "propname = best[1];",
            "val = biglist.(propname);",
            "for prop in (best[2..$])",
            "$command_utils:suspend_if_needed(0);",
            "val[2] = {@val[2], @biglist.(prop)[2]};",
            "endfor",
            "biglist.(propname) = val;",
            "\"Now that the new value is safely stored, delete old values.\";",
            "for prop in (best[2..$])",
            "$command_utils:suspend_if_needed(0);",
            "player:notify(tostr(\"Removing property \", toliteral(prop), \".  Its value, \", toliteral(biglist.(prop)), \", has been merged with property \", toliteral(propname), \".\"));",
            "delete_property(biglist, prop);",
            "endfor",
            "endif",
            "maxlevel = biglist.(propname)[1];",
            "player:notify(tostr(\"Maximum level is \", maxlevel, \".\"));",
            "items = $list_utils:make(maxlevel, {});",
            "\"Arrgh.  Even after finding the root, some nodes might be detached!\";",
            "player:notify(\"Checking for orphans...\");",
            "for prop in (properties(biglist))",
            "$command_utils:suspend_if_needed(0);",
            "if (prop && (prop[1] == \" \"))",
            "val = biglist.(prop);",
            "if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level < maxlevel))",
            "items[level + 1] = {@items[level + 1], prop};",
            "endif",
            "endif",
            "endfor",
            "for prop in (properties(biglist))",
            "$command_utils:suspend_if_needed(0);",
            "if (prop && (prop[1] == \" \"))",
            "val = biglist.(prop);",
            "if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level > 0))",
            "for item in (val[2])",
            "items[level] = setremove(items[level], item[1]);",
            "endfor",
            "endif",
            "endif",
            "endfor",
            "player:notify(tostr(\"Orphans: \", toliteral(items)));",
            "backbone_prop = propname;",
            "level = maxlevel;",
            "while (level)",
            "backbone = biglist.(backbone_prop);",
            "lastkid = backbone_prop;",
            "for prop in (props = items[level])",
            "backbone[2] = {@backbone[2], {lastkid = prop, 0, {0, 0}}};",
            "endfor",
            "player:notify(tostr(\"Attaching \", nn = length(props), \" propert\", (nn == 1) ? \"y\" | \"ies\", \" to property \", toliteral(backbone_prop), \"...\"));",
            "biglist.(backbone_prop) = backbone;",
            "backbone_prop = lastkid;",
            "level = level - 1;",
            "endwhile",
            "player:notify(tostr(\"Orphans repatriated.\"));",
            "endif",
            "toplevel = \"(top level)\";",
            "context = args[2] || toplevel;",
            "\"This stuff is just paranoia in case something unexpected is in the data structure.  Normally there should be no blowouts here. --Minnie\";",
            "if (typeof(propname) != STR)",
            "player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- bad property name.\"));",
            "raise(E_INVARG);",
            "endif",
            "val = biglist.(propname);",
            "if (typeof(val) != LIST)",
            "player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- contents invalid.\"));",
            "raise(E_INVARG);",
            "endif",
            "if (typeof(level = val[1]) != INT)",
            "player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- contents invalid (bad first argument).\"));",
            "raise(E_INVARG);",
            "endif",
            "\"This is where the real work starts. --Minnie\";",
            "\"First check that the properties referred to really exist.  This must be done for all levels.\";",
            "for item in (val[2])",
            "try",
            "biglist.(item[1]);",
            "except (E_PROPNF)",
            "player:notify(tostr(\"Item \", toliteral(item), \" is invalid in property \", toliteral(propname), \".  It is being removed.\"));",
            "val[2] = setremove(val[2], item);",
            "continue item;",
            "endtry",
            "endfor",
            "\"Next, only for upper levels, check that the message count for inferior levels is correct, but only after recursing into those levels and making repairs.\";",
            "if (level > 0)",
            "new = $list_utils:map_arg(this, verb, $list_utils:slice(val[2]), propname);",
            "if (val[2] != new)",
            "player:notify(tostr(\"Changing \", toliteral(val[2]), \" to \", toliteral(new), \".\"));",
            "val[2] = new;",
            "endif",
            "\"Now that everything is correct, count size of inferiors.\";",
            "endif",
            "\"Bravely stuff the result back into place.\";",
            "biglist.(propname) = val;",
            "\"The result will be of the form:                               \";",
            "\"  {propname, inferior_msgcount, {first_msgnum, first_time}}  \";",
            "if (level == 0)",
            "\"Count the messages for message count.\";",
            "\"Use first message number and time for first_msgnum and first_time.\";",
            "result = {propname, length(val[2]), val[2][1][2..3]};",
            "else",
            "\"Use message count that is sum of inferior counts.\";",
            "\"Just propagate first node's first_msgnum and first_time upward literally.\";",
            "n = 0;",
            "for subnode in (val[2])",
            "n = n + subnode[2];",
            "endfor",
            "result = {propname, n, val[2][1][3]};",
            "endif",
            "if (context == toplevel)",
            "if (result != biglist.messages)",
            "biglist.messages = result;",
            "player:notify(tostr(\"Property \", biglist, \".messages updated.\"));",
            "endif",
            "player:tell(biglist.messages[2], \" messages repaired in \", $mail_agent:name(biglist), \".\");",
            "endif",
            "return result;",
            "\"Last modified Thu Feb 15 23:13:44 1996 MST by Minnie (#123).\";"
          ]
        },
        {
          "name": "repair",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 14,
          "code": [
            "\"Syntax: repair <biglist>\";",
            "\"\";",
            "\"This tool makes a last-resort attempt to repair broken biglists (ones whose data structures are out of alignment due to an error such as \\\"out of ticks\\\" during some update operation leaving the b-tree in an inconsistent state).  This tool comes with no warranty of any kind.  You should only use it when you have no other choice, and you should make an attempt to @dump or fully copy or otherwise checkpoint your object before attempting to repair it so that you can recover from any failures this might produce.  This operation is NOT undoable.\";",
            "if (!$perm_utils:controls(player, this))",
            "player:tell(\"You do not control that.\");",
            "elseif (!$command_utils:yes_or_no(\"This tool can be used to repair some (but maybe not all) situations involving generic biglists that have had an error (usually \\\"out of ticks\\\") during an update operation and were left inconsistent.  Is this list really and truly broken in such a way?\"))",
            "player:tell(\"No action taken.  PLEASE don't use this except in extreme cases.\");",
            "elseif (!$command_utils:yes_or_no(\"Have you made a best effort to @dump or otherwise save the contents in case this make things worse?\"))",
            "player:tell(\"No action taken.  PLEASE do any saving you can before proceeding.\");",
            "elseif (!$command_utils:yes_or_no(\"This tool comes with no warranty of any kind.  Is this really your last resort and are you prepared to accept the consequences of utter failure?  There is no undoing the actions this takes.  Do you understand and accept the risks?\"))",
            "player:tell(\"No action taken.  I'm not taking any responsibility for this failing.  It's gotta be your choice.\");",
            "else",
            "player:tell(\"OK!  Going ahead with repair attempts...\");",
            "this:_repair();",
            "player:tell(\"All done.  If this worked, you can thank Mickey.  If not, remember the promises you made above about accepting responsibility for failure.\");",
            "endif",
            "\"Last modified Fri Feb 16 08:36:27 1996 MST by Minnie (#123).\";"
          ]
        },
        {
          "name": "restore_from",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "\":restore_from(OLD_MAIL_RECIPIENT, LOST_STRING)\";",
            "\"This clears all biglist properties from this object, then\";",
            "\"scans the properties of OLD_MAIL_RECIPIENT, which must be a descendant\";",
            "\"of $big_mail_recipient, looking for those corresponding to mail messages,\";",
            "\"and then rebuilds the message tree entirely from scratch.\";",
            "\"\";",
            "\"No attempt is made to preserve the original tree structure.\";",
            "\"The live/deleted state of any given message is lost;\";",
            "\"all messages, including formerly rmm-ed ones, are restored to .messages\";",
            "\"\";",
            "\"In the (unlikely) event that message-body properties have been lost, the\";",
            "\"affected messages are given a one-line body consisting of LOST_STRING\";",
            "\"\";",
            "{old, ?lost_body = \"###BODY-LOST###\"} = args;",
            "if (!($perm_utils:controls(caller_perms(), this) && $perm_utils:controls(caller_perms(), old)))",
            "raise(E_PERM);",
            "elseif (!$object_utils:isa(old, $big_mail_recipient))",
            "raise(E_TYPE, \"First argument must be a $big_mail_recipient.\");",
            "elseif (typeof(lost_body) != STR)",
            "raise(E_TYPE, \"Second argument, if given, must be a string.\");",
            "endif",
            "mgr = this._mgr;",
            "\"...\";",
            "\"... destroy everything...\";",
            "for p in (properties(this))",
            "delete_property(this, p);",
            "endfor",
            "this.messages = this.messages_going = {};",
            "\"...\";",
            "\"... look at all properties...\";",
            "msgcount = lostcount = 0;",
            "for p in (properties(old))",
            "if (index(p, \" \") == 1)",
            "pvalue = old.(p);",
            "\"... ignore everything except level-0 nodes...\";",
            "if (pvalue[1..min(1, $)] == {0})",
            "for msg in (pvalue[2])",
            "if ((ticks_left() < 6000) || (seconds_left() < 2))",
            "player:tell(\"...\", msgcount, \" copied.\");",
            "suspend(0);",
            "endif",
            "try",
            "body = old.(msg[1]);",
            "except e (E_PROPNF)",
            "body = {lost_body};",
            "lostcount = lostcount + 1;",
            "endtry",
            "msg[1] = this:_make(@body);",
            "msgtree = mgr:insert_last(this.messages, msg);",
            "msgcount = msgcount + 1;",
            "n = mgr:find_ord(msgtree, this:_message_num(@msg), \"_lt_msgnum\");",
            "if (n < msgcount)",
            "{msgtree, singleton} = mgr:extract_range(msgtree, msgcount, msgcount);",
            "msgtree = mgr:insert_after(msgtree, singleton, n);",
            "endif",
            "this.messages = msgtree;",
            "endfor",
            "endif",
            "endif",
            "endfor",
            "player:tell(msgcount, \" messages installed on \", this.name, \"(\", this, \")\");",
            "if (lostcount)",
            "player:tell(lostcount, \" messages have missing bodies (indicated by \", toliteral(lost_body), \").\");",
            "else",
            "player:tell(\"No message bodies were missing.\");",
            "endif"
          ]
        },
        {
          "name": "set_message_body_by_index",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 14,
          "code": [
            "{i, body} = args;",
            "if (!this:ok_write(caller, caller_perms()))",
            "\"... maybe someday let people edit messages they've sent?\";",
            "\"... && !(this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args))) ???\";",
            "return E_PERM;",
            "endif",
            "{bodyprop, @rest} = this._mgr:find_nth(this.messages, i);",
            "if (!body)",
            "if (bodyprop)",
            "this:_kill(bodyprop);",
            "this._mgr:set_nth(this.messages, i, {0, @rest});",
            "endif",
            "elseif (bodyprop)",
            "if (typeof(body) != LIST)",
            "raise(E_TYPE);",
            "endif",
            "this.(bodyprop) = body;",
            "else",
            "bodyprop = this:_make(@body);",
            "this._mgr:set_nth(this.messages, i, {bodyprop, @rest});",
            "endif"
          ]
        }
      ],
      "propnames": [
        "summary_uses_body",
        "_mgr",
        "mowner",
        "_genprop"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 13,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 36,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "",
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Large-Capacity Mail Recipient"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Generic Large Capacity Mail Recipient",
            "-------------------------------------",
            "Since any modifications to large lists entail copying the entire list over, operations on ordinary mail recipients having large numbers of messages, that actually change the content of .messages will take inordinately long.  Thus we have this version which makes use of the $biglist package, scattering the messages onto numerous properties so that write operations involving only a few messages will not require recopying of the entire list.",
            "",
            "In nearly all respects it behaves as the ordinary Mail Recipient, except that it is faster for certain kinds of operations.",
            "",
            "Certain unimplemented verbs, like :date_sort(), and :messages() currently return E_VERBNF.",
            "",
            "To convert an existing $mail_recipient-child (call it #MR) into a $big_mail_recipient-child the basic procedure is",
            "",
            "    ;;something.foo= #MR:messages();",
            "    @rmm 1-$ from #MR",
            "    @unrmm expunge",
            "    @chparent #MR to $big_mail_recipient",
            "    ;#MR:receive_batch(@something.foo);",
            "",
            "Reconstructing Damaged Big Mail Recipients",
            "------------------------------------------",
            "On rare occasions, the tree structure created by $biglist can be corrupted (this can happen on lists sufficiently large that a list-modification operation (e.g., @rmm, @renumber) runs out of ticks/seconds).  In the vast majority of such cases, your messages are all still there; it's simply that the tree we use for finding/searching them is messed up.",
            "",
            "To recover messages from a damaged big mail recipient (#DBMR)",
            " --- read to the end before you start typing any commands ---",
            "",
            "create a fresh $big_mail_recipient (#NEWBMR) and then do the following:",
            "",
            "   ;#NEWBMR:restore_from(#DBMR)",
            "",
            "When this finishes, #NEWBMR will contain all of the mail messages we were able to find.  (note that this will include messages that you had deleted from #DBMR but not expunged).  #NEWMBR should thenceforth be useable in place of #DBMR, however if #DBMR contains custom verbs and non-clear properties, these will also need to be copied over.",
            "",
            "Alternatively, one may do",
            "",
            "   @copyobject #DBMR to #TEMPBMR",
            "   ;#DBMR:restore_from(#TEMPBMR)",
            "",
            "to rebuild #DBMR in place.  This, however, will take about twice as long.",
            "",
            "oooooooooooooooooooooooooooooooo",
            "WARNING!!! WARNING!!! WARNING!!!",
            "oooooooooooooooooooooooooooooooo",
            "",
            "Calling #OBJ:restore_from(...) COMPLETELY AND IRREVOCABLY REMOVES ALL MESSAGES from the object that it is run on (#OBJ); you MUST be sure to EITHER have made a copy of #OBJ OR be doing the restore to a DIFFERENT object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            53798,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "15": {
      "id": 15,
      "name": "Limbo",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [
        98,
        2
      ],
      "verbs": [
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 15,
          "code": [
            "what = args[1];",
            "return is_player(what) && (!(what in connected_players()));"
          ]
        },
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 15,
          "code": [
            "(caller == #0) || raise(E_PERM);",
            "{who} = args;",
            "\"this:eject(who)\";",
            "if (!$recycler:valid(home = who.home))",
            "clear_property(who, \"home\");",
            "home = who.home;",
            "if (!$recycler:valid(home))",
            "home = who.home = $player_start;",
            "endif",
            "endif",
            "\"Modified 08-22-98 by TheCat to foil people who manually set their home to places they shouldn't.\";",
            "if ((!home:acceptable(who)) || (!home:accept_for_abode(who)))",
            "home = $player_start;",
            "endif",
            "try",
            "move(who, home);",
            "except (ANY)",
            "move(who, $player_start);",
            "endtry",
            "who.location:announce_all_but({who}, who.name, \" has connected.\");"
          ]
        },
        {
          "name": "who_location_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 15,
          "code": [
            "return $player_start:who_location_msg(@args);"
          ]
        },
        {
          "name": "moveto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 15,
          "code": [
            "\"Don't go anywhere.\";"
          ]
        },
        {
          "name": "eject",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 15,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this))",
            "if ((what = args[1]).wizard && (what.location == this))",
            "move(what, what.home);",
            "else",
            "return pass(@args);",
            "endif",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "The Body Bag"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            3784,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "16": {
      "id": 16,
      "name": "Registration Database",
      "flags": 0,
      "owner": 36,
      "location": -1,
      "parents": [
        37
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find* _only* _every*",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;"
          ]
        },
        {
          "name": "add",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "\":add(player,email[,comment])\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{who, email, @comment} = args;",
            "l = this:find_exact(email);",
            "if (l == $failed_match)",
            "this:insert(email, {{who, @comment}});",
            "elseif (i = $list_utils:iassoc(who, l))",
            "this:insert(email, listset(l, {who, @comment}, i));",
            "else",
            "this:insert(email, {@l, {who, @comment}});",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this:clearall();",
            "this.registrar = #2;",
            "this:prune_reset();",
            "endif"
          ]
        },
        {
          "name": "suspicious_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "\"suspicious(address [,who])\";",
            "\"Determine whether an address appears to be another player in disguise.\";",
            "\"returns a list of similar addresses.\";",
            "\"If second argument given, then if all similar addresses are held by that\";",
            "\"person, let it pass---they're just switching departments at the same school\";",
            "\"or something.\";",
            "\"\";",
            "\"at the moment,\";",
            "\"  foo@bar.baz.bing.boo\";",
            "\"is considered 'similar' to anything matching\";",
            "\"  foo@*.bing.boo\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{address, ?allowed = #-1} = args;",
            "{userid, site} = $network:parse_address(address);",
            "exact = (!site) && this:find_exact(address);",
            "if (!site)",
            "site = $network.site;",
            "endif",
            "site = $network:local_domain(site);",
            "sitelen = length(site);",
            "others = this:find_all_keys(userid + \"@\");",
            "for other in (others)",
            "if (other[max(1, ($ - sitelen) + 1)..$] != site)",
            "others = setremove(others, other);",
            "endif",
            "endfor",
            "if (exact)",
            "others = listinsert(others, address);",
            "endif",
            "for x in (others)",
            "allzapped = 1;",
            "for y in (this:find_exact(x))",
            "if ((((length(y) == 2) && ((y[2] == \"zapped due to inactivity\") || (y[2] == \"toaded due to inactivity\"))) || (y[1] == allowed)) || (($object_utils:has_property($local, \"second_char_registry\") && (typeof(them = $local.second_char_registry:other_chars(y[1])) == LIST)) && (allowed in them)))",
            "\"let them change to the address if it is them, or if it is a registered char of theirs.\";",
            "\"Hrm. Need typeof==LIST check because returns E_INVARG for shared characters. bleah Ho_Yan 5/8/95\";",
            "else",
            "allzapped = 0;",
            "endif",
            "endfor",
            "if (allzapped)",
            "others = setremove(others, x);",
            "endif",
            "endfor",
            "return others;"
          ]
        },
        {
          "name": "suspicious_userid",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "\"suspicious_userid(userid)\";",
            "\"Return yes if userid is root or postmaster or something like that.\";",
            "if ($object_utils:has_property(#0, \"local\") && $object_utils:has_property($local, \"suspicious_userids\"))",
            "extra = $local.suspicious_userids;",
            "else",
            "extra = {};",
            "endif",
            "return ((((args[1] in {@$network.suspicious_userids, @extra}) || match(args[1], \"^guest\")) || match(args[1], \"^help\")) || index(args[1], \"-owner\")) || index(args[1], \"owner-\");",
            "\"Thinking about ruling out hyphenated names, on the grounds that they're probably mailing lists.\";"
          ]
        },
        {
          "name": "describe_registration",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "\"Returns a list of strings describing the registration data for an email address.  Args[1] should be the result of this:find.\";",
            "set_task_perms(caller_perms());",
            "result = {};",
            "for x in (args[1])",
            "name = (valid(x[1]) && is_player(x[1])) ? x[1].name | \"<recycled>\";",
            "email = (valid(x[1]) && is_player(x[1])) ? $wiz_utils:get_email_address(x[1]) | \"<???>\";",
            "result = {@result, tostr(\"  \", name, \" (\", x[1], \") current email: \", email, (length(x) > 1) ? (\" [\" + x[2]) + \"]\" | \"\")};",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "prune",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "\"Carefully loop through the db and delete items associated with reaped objects.  If that results in no objects remaining for a username, delete that username.\";",
            "\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";",
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "this.prune_task = task_id();",
            "probe = this.prune_progress;",
            "while (probe < this.prune_stop)",
            "for username in (this:find_all_keys(probe))",
            "items = this:find_exact(username);",
            "orig = items;",
            "for y in (items)",
            "{who, @whys} = y;",
            "if ((!valid(who)) || (!is_player(who)))",
            "nuke = 1;",
            "for why in (whys)",
            "if (((why && (why != \"zapped due to inactivity\")) && (why != \"toaded due to inactivity\")) && (why != \"Additional email address\"))",
            "nuke = 0;",
            "endif",
            "endfor",
            "if (nuke)",
            "items = setremove(items, y);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (!items)",
            "this:delete(username);",
            "this.total_pruned_people = this.total_pruned_people + 1;",
            "elseif (items != orig)",
            "this:insert(username, items);",
            "this.total_pruned_characters = (this.total_pruned_characters + length(orig)) - length(items);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "probe = $string_utils:incr_alpha(probe, this.alphabet);",
            "this.prune_progress = probe;",
            "if ($command_utils:running_out_of_time())",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endif",
            "endwhile",
            "player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"
          ]
        },
        {
          "name": "report_prune_progress",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "player:tell(\"Prune is up to \", toliteral(this.prune_progress), \".\");",
            "mine = 0;",
            "alphalen = length(this.alphabet);",
            "if (typeof(this.prune_progress) == STR)",
            "total = (alphalen * alphalen) * alphalen;",
            "for x in [1..3]",
            "mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;",
            "endfor",
            "else",
            "total = 256 * 256;",
            "mine = (this.prune_progress[1] * 256) + this.prune_progress[2];",
            "endif",
            "percent = (100.0 * tofloat(mine)) / tofloat(total);",
            "player:tell(\"We have processed \", mine, \" entries out of \", total, \", or \", toint(percent), \".\", toint(10.0 * percent) % 10, \"%.\");",
            "player:tell(\"There were \", this.total_pruned_characters, \" individual list entries removed, and \", this.total_pruned_people, \" whole email addresses removed.\");",
            "if ($code_utils:task_valid(this.prune_task))",
            "player:tell(\"Prune task is \", this.prune_task, \".  Stacktrace:\");",
            "for x in (task_stack(this.prune_task, 1))",
            "if (valid(x[4]))",
            "player:tell(x[4], \":\", x[2], \" [\", x[1], \"]  \", x[3].name, \"  (\", x[6], \")\");",
            "endif",
            "endfor",
            "else",
            "player:tell(\"The recorded task_id is no longer valid.\");",
            "endif"
          ]
        },
        {
          "name": "prune_reset",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 16,
          "code": [
            "this:report_prune_progress();",
            "player:tell(\"Resetting...\");",
            "this.prune_progress = \"aaa\";",
            "this.prune_stop = \"zzz\";",
            "this.total_pruned_people = 0;",
            "this.total_pruned_characters = 0;",
            "this.prune_task = 0;"
          ]
        },
        {
          "name": "search",
          "owner": 2,
          "perms": 109,
          "preps": 11,
          "object": 16,
          "code": [
            "who = caller_perms();",
            "if (((who != #-1) && (!((who == player) || (caller == this)))) || (!(who.wizard || (who in $local.registrar_pet_core.members))))",
            "raise(E_PERM);",
            "endif",
            "total = 0;",
            "player:tell(\"Searching...\");",
            "for k in ($registration_db:find_all_keys(\"\"))",
            "$command_utils:suspend_if_needed(0);",
            "line = (k + \" \") + toliteral($registration_db:find_exact(k));",
            "if (index(line, iobjstr))",
            "player:tell(line);",
            "total = total + 1;",
            "endif",
            "endfor",
            "player:tell(\"Search over.  \", total, \" matches found.\");"
          ]
        }
      ],
      "propnames": [
        "registrar",
        "prune_progress",
        "prune_stop",
        "total_pruned_people",
        "total_pruned_characters",
        "prune_task",
        "alphabet"
      ],
      "propdefs": [
        {
          "value": 2,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "aaa",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "zzz",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "abcdefghijklmnopqrstuvwxy0123456789_.@+z",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "",
            [],
            []
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Registration Database"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            13392,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "17": {
      "id": 17,
      "name": "Player-Creation-Log",
      "flags": 0,
      "owner": 2,
      "location": 46,
      "parents": [
        14
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "display_seq_headers",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 17,
          "code": [
            "\":display_seq_headers(msg_seq[,cur])\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "player:tell(\"       WHEN    BY        WHO                 EMAIL-ADDRESS\");",
            "pass(@args);"
          ]
        },
        {
          "name": "msg_summary_line",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 17,
          "code": [
            "when = ctime(args[1])[5..10];",
            "from = args[2];",
            "by = $string_utils:left(from[1..index(from, \" (\") - 1], -9);",
            "subject = args[4];",
            "who = subject[1..(open = index(subject, \" (\")) - 1];",
            "if ((close = rindex(subject, \")\")) > open)",
            "who = who[1..min(9, $)] + subject[open..close];",
            "endif",
            "who = $string_utils:left(who, 18);",
            "line = args[(\"\" in args) + 1];",
            "email = line[1..index(line + \" \", \" \") - 1];",
            "if (!index(email, \"@\"))",
            "email = \"??\";",
            "endif",
            "return tostr(when, \"  \", by, \" \", who, \"  \", email);"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 17,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_notify = {player};",
            "player:set_current_message(this, 0, 0, 1);",
            "this.moderated = {this};",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "is_usable_by",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 17,
          "code": [
            "\"Copied from Generic Mail Recipient (#6419):is_usable_by by Rog (#4292) Tue Mar  2 10:02:32 1993 PST\";",
            "return (!this.moderated) || ((this:is_writable_by(who = args[1]) || (who in this.moderated)) || who.wizard);"
          ]
        },
        {
          "name": "expire_old_messages",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 17,
          "code": [
            "\"Stop breaking the expire task completely with out of seconds/ticks.\";",
            "if (this:ok_write(caller, caller_perms()))",
            "fork (0)",
            "pass(@args);",
            "endfork",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [
        " a",
        " b"
      ],
      "propdefs": [
        {
          "value": [
            "none"
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [
            0,
            [
              [
                " a",
                1,
                1541028130,
                "Wizard (#2)",
                "*Player-Creation-Log (#17)",
                "Anti-Wizard (#98)"
              ]
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 13,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 36,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "b",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            [
              0,
              [
                " b",
                1,
                [
                  1,
                  1541028130
                ]
              ]
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [
            17
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1541028130,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Player-Creation-Log",
            "PCL"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "Log of player creations.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            5701,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "18": {
      "id": 18,
      "name": "Verb Help DB",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find_topics",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 18,
          "code": [
            "if ($code_utils:parse_verbref(what = args[1]))",
            "\"... hey wow, I found it!...\";",
            "return {what};",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "get_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 18,
          "code": [
            "\"Help facility for verbs that people have bothered to document.  If the argument is a verb specification, this retrieves the code and prints any documentation lines that might be at the beginning.  Returns true if the arg can actually be interpreted as a verb specification, whether or not it is a correct one.\";",
            "set_task_perms(caller_perms());",
            "if (!(spec = $code_utils:parse_verbref(args[1])))",
            "return 0;",
            "elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))",
            "return 1;",
            "elseif (!(hv = $object_utils:has_verb(object, spec[2])))",
            "return \"That object does not define that verb.\";",
            "elseif (typeof(verbdoc = $code_utils:verb_documentation(object = hv[1], spec[2])) == ERR)",
            "return tostr(verbdoc);",
            "elseif (typeof(info = `verb_info(object, spec[2]) ! ANY') == ERR)",
            "return tostr(info);",
            "else",
            "objverb = tostr(object.name, \"(\", object, \"):\", strsub(info[3], \" \", \"/\"));",
            "if (verbdoc)",
            "return {tostr(\"Information about \", objverb), \"----\", @verbdoc};",
            "else",
            "return tostr(\"No information about \", objverb);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "dump_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 18,
          "code": [
            "set_task_perms(caller_perms());",
            "if (!(spec = $code_utils:parse_verbref(args[1])))",
            "return E_INVARG;",
            "elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))",
            "return E_INVARG;",
            "elseif (!(hv = $object_utils:has_verb(object, spec[2])))",
            "return E_VERBNF;",
            "elseif (typeof(vd = $code_utils:verb_documentation(hv[1], spec[2])) != LIST)",
            "return vd;",
            "else",
            "return {tostr(\";$code_utils:set_verb_documentation(\", $code_utils:corify_object(hv[1]), \",\", $string_utils:print(spec[2]), \",$command_utils:read_lines())\"), @$command_utils:dump_lines(vd)};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "help_msg"
      ],
      "propdefs": [
        {
          "value": [
            "This is not a help database in the same way that children of $generic_help are. This object does the work when someone calls help in this way:",
            "",
            "    help <object>:<verb>",
            "",
            "It parses out the object and verb reference, pulls out the comments at the beginning of the verb, and returns them to the help system for nice display.",
            "",
            "    :find_topics(string)",
            "       tries to pull out an object:verb reference from string",
            "       returns {string} if successful",
            "       returns {} if not",
            "",
            "    :get_topic(string)",
            "       tries to pull out an object:verb reference from string (returns 0 if",
            "          it fails to do so)",
            "       tries to match the object",
            "       checks the object to see if the verb exists",
            "       pulls out the initial comments from the verb if they exist",
            "       returns a meaningful list of strings to be displayed to the player",
            "",
            "    :dump_topic(string)",
            "       does the same as :get_topic above, but returns the verb documentation",
            "          in dump form.",
            "----"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "verbhelp",
            "vh"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "A `help database' that knows about all of the documented verbs.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            5412,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "19": {
      "id": 19,
      "name": "Core Utility Help",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find_topics",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 19,
          "code": [
            "if (!args)",
            "l = {};",
            "for p in (properties(#0))",
            "if ((p[max(1, $ - 5)..$] == \"_utils\") && `#0.(p):help_msg() ! ANY')",
            "l = {@l, \"$\" + p};",
            "endif",
            "endfor",
            "return {@pass(@args), @l};",
            "elseif (ts = pass(@args))",
            "return ts;",
            "elseif ((what = args[1])[1] != \"$\")",
            "return {};",
            "elseif (ts = pass(\"$generic_\" + what[2..$]))",
            "return ts;",
            "elseif ((r = rindex(w = strsub(what[2..$], \"-\", \"_\"), \"_utils\")) && ((r == (length(w) - 5)) && (`valid(#0.(w)) ! ANY' && `#0.(w):help_msg() ! ANY')))",
            "return {what};",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "get_topic",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 19,
          "code": [
            "topic = args[1];",
            "if ((topic == ((\"$\" + topic[2..$ - 5]) + \"utils\")) && (valid(#0.(w = strsub(topic[2..$], \"-\", \"_\"))) && (uhelp = #0.(w):description())))",
            "return {tostr(\"General information on $\", w, \":\"), \"----\", @(typeof(uhelp) == STR) ? {uhelp} | uhelp};",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "dump_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 19,
          "code": [
            "if ((E_PROPNF != (text = pass(@args))) || ((args[1][1] != \"$\") || ((!((uprop = args[1][2..$]) in properties(#0))) || (typeof(uobj = #0.(uprop)) != OBJ))))",
            "return text;",
            "else",
            "udesc = uobj.description;",
            "return {tostr(\";;$\", uprop, \".description = $command_utils:read_lines()\"), @$command_utils:dump_lines((typeof(udesc) == LIST) ? udesc | {udesc})};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "$login",
        "$container",
        "$mail_agent",
        "MR-subscribing",
        "MR-naming",
        "MR-access",
        "$mail_recipient",
        "receiving-mail",
        "mail-format",
        "mail-resolve",
        "sending-mail",
        "mail-system",
        "$player_db",
        "core-index",
        "object-matching",
        "$no_one",
        "$exit",
        "$room",
        "$help",
        "$generic_db",
        "$generic_editor",
        "$generic_help",
        "$generic_options",
        "MR-sequences",
        "MR-reading",
        "MR-writing",
        "MR-searching",
        "$housekeeper",
        "$recycler",
        "$error",
        "$biglist",
        "$guest_log",
        "mail-resolution",
        "$news",
        "matching",
        "MR-expiration",
        "mail-expiration",
        "$big_mail_recipient",
        "init_for_core",
        "include_for_core",
        "proxy_for_core",
        "$core_objects",
        "make-core-database"
      ],
      "propdefs": [
        {
          "value": [
            "$login",
            "------",
            "This object manages command parsing for unconnected players and governs the initiation of an actual connection.  There are verbs pertaining to registration, controlling player creation, and doing site-locks (see `help blacklist' on $wiz_help).",
            "",
            "COMMANDS FOR UNCONNECTED PLAYERS",
            "",
            "Recall that for each line that an unconnected player types, the server parses that line into words (the same way normal commands are parsed into a list of words that is then assigned to `args') and then #0:do_login_command is called.",
            "",
            "  :parse_command (@args) => {verb, @args}",
            "    given the sequence of arguments that were fed to #0:do_login_command",
            "    this returns the name of a verb on $login to be called together with a ",
            "    list of arguments to be passed to it.",
            "",
            "By default this just returns args iff args[1] names an actual verb on $login that is +x and has args {\"any\",\"none\",\"any\"}.  Otherwise, it returns one of",
            "",
            "  .blank_command   -- verb to call if command line is empty",
            "  .bogus_command   -- verb to call if command line otherwise unintelligible",
            "",
            "In both cases :parse_command returns a verbname followed by the entire args list passed to it (including the would-be verb at the beginning if any).",
            "",
            "Currently the following verbs are available to non-connected players",
            "",
            "  h*elp @h*elp       -- print .welcome_message",
            "  ?                  -- print a short list of available commands",
            "  w*ho @w*ho         -- print a list of logged in players (excluding wizards)",
            "  co*nnect @co*nnect -- connect to an existing player",
            "  cr*eate @cr*eate   -- create a new player",
            "  up*time @up*time   -- tell how long the server has been running",
            "  version @version   -- tell which version of the server is running",
            "  q*uit @q*uit       -- logoff",
            "",
            "Adding a new command is fairly straightforward; just create a verb on $login, making sure a previous verb doesn't already match the name you want to give it.  Then give it args of \"any\" \"none \"any\" and make sure it is +x.  Such a verb should begin with `if (caller != #0) return E_PERM; ...' so as to prevent anyone other from a not-logged-in player from making use of it.",
            "",
            "CUSTOMIZATIONS",
            "",
            "  .welcome_message ",
            "    -- the message for \"help\" to print.",
            "  .create_enabled ",
            "    == 0 => @create prints .registration_string if one tries to use it",
            "    == 1 => anyone from a non-blacklisted site (see `help blacklist')",
            "            may use @create to make a new player",
            "",
            "  .registration_address",
            "    -- an email address for character creation requests",
            "  .registration_string  ",
            "    -- string to print to players to give them information about how to get ",
            "       a character created for them, .registration_address is substituted ",
            "       for %e, % for %%",
            "  .newt_registration_string",
            "    -- string to print to @newted players (see `help @newt').",
            "       same substitutions as for .registration_string.",
            "",
            "  .max_connections",
            "    -- integer representing the maximum connected players permitted on this moo.",
            "  .connection_limit_msg",
            "    -- string printed out when this is reached.",
            "  .lag_exemptions",
            "    -- list of non-wizard players who may login anyway.",
            "",
            "  .argon2",
            "    -- parameters for hashing passwords. See HELP ARGON2() for information on the",
            "       options available. ",
            "",
            "Other verbs",
            "   :registration_string()      => .registration_string with substitutions",
            "   :newt_registration_string() => .newt_registration_string with substitutions",
            "   :player_creation_enabled(connection) ",
            "       decides whether someone on connection should be allowed to create ",
            "       a player.  If you decide this shouldn't depend strictly on the blacklist",
            "       and on the value of .create_enabled, here's where the extra code can go.",
            "   :check_for_shutdown()",
            "       prints a warning message to append to the login banner in the event ",
            "       that the server will be going down soon.",
            "   :check_player_db()",
            "       prints a warning message to append to the login banner in the event ",
            "       that $player_db is being reloaded to warn players that their character",
            "       names might not be recognized.",
            "",
            "SITE LOCKS",
            "see `help blacklist'",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The Generic Container (for programmers)",
            "",
            "In addition to the command verbs described under `help containers'",
            "and the _msg properties described in `help container-messages',",
            "the following verbs and properties are available for use within programs",
            "",
            ".opened == TRUE iff the container is open",
            ".dark   == TRUE iff the contents of the container may be seen",
            ".opaque -- describes the correlation between .open and .dark",
            "   == 0  container is always !dark",
            "   == 1  container is dark iff it is closed",
            "   == 2  container is always dark              ",
            "",
            ":set_opaque(newvalue)   ",
            "  changes the .opaque value for the container",
            "  => newvalue or E_PERM or E_INVARG",
            "",
            ":set_opened(newvalue)   ",
            "  opens/closes the container (updates .open and .dark) according to newvalue",
            "  => newvalue or E_PERM",
            "",
            ":is_openable_by(player) ",
            " what the :open command uses to test whether the player should be able to open",
            " the container.  By default this refers to .open_key  (set by",
            " @(un)lock_for_open), but the object owner is free to customize this.",
            "",
            "N.B.:  There is no way to directly set .dark; .dark can be changed only by ",
            "changing one of .opaque or .opened.  Use :set_opaque(0) and :set_opaque(2)",
            "to have .dark change independently of the value of .opened."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "$mail_agent",
            "",
            "This object contains a two distinct sets of routines:",
            "",
            "  1.  utilities for performing basic mailsystem functions, e.g.,",
            "      matching on recipient names, resolving mail forwarding, ",
            "      formatting messages, sending messages",
            "",
            "Recipient Matching",
            "",
            "match           - match on a $mail_recipient",
            "match_recipient - match on either a $mail_recipient or a player",
            "match_failed    - print angry messages to the user for $failed/ambiguous_match",
            "",
            "look_self  - provides a list of available $mail_recipients",
            "check_names",
            "touch",
            "accept",
            "",
            "Message Format",
            "",
            "make_message        - produces a message in the canonical transmission format",
            "name                - single recipient     => string for address field",
            "name_list           - list of recipients   => string for address field",
            "parse_address_field - address field string => object list",
            "",
            "Sending Messages",
            "",
            "send_message  - advertised message sending routine.",
            "raw_send      - raw message sending routine ",
            "                (only called by $mail_editor:send and this:send_message)",
            "resolve_addr  - converts a given list recipients into a list of actual ",
            "                recipients and objects to be notified.",
            "sends_to      - Does X forward (transitively) to Y",
            "",
            "Mail Options",
            "",
            "option         ",
            "option_verbose",
            "",
            "  2.  canonical versions of mail_recipient verbs",
            "",
            "Ideally, the verbs to perform operations on a given mail recipient would be located on the recipient itself, except for the fact that these verbs also need to be located on players, which for various reasons, shouldn't be children of $mail_recipient.  Multiple inheritance would solve our problems, but we don't have it yet.  Ergo, both $mail_recipient and $player refer to the following verbs here:",
            "",
            "display_seq_full     print entire text of messages  (@read)",
            "display_seq_headers  print headers of messages      (@mail)",
            "rm_message_seq       remove messages                (@rmm)",
            "undo_rmm             undo last rm_message_seq       (@unrmm)",
            "expunge_rmm          flush removed messages         (@unrmm expunge)",
            "list_rmm             list removed messages          (@unrmm list)",
            "renumber             renumber messages              (@renumber)",
            "msg_summary_line     msg header => display_seq_headers/list_rmm summary line",
            "",
            "parse_message_seq    command line msg sequence spec => message sequence",
            "new_message_num      => message number of next new message",
            "length_all_msgs      => number of messages (total)",
            "length_num_le        => number of messages numbered <= some number",
            "length_date_le       => number of messages dated <= some date",
            "exists_num_eq        => true iff there exists a messsage with the given number",
            "from_msg_seq         => message sequence of msgs from given sender(s)",
            "to_msg_seq           => message sequence of msgs to given recipient(s)",
            "subject_msg_seq      => message sequence of msgs with subjects containing text",
            "body_msg_seq         => message sequence of msgs with bodies containing text",
            "messages_in_seq      => list of {message number, message} pairs",
            "",
            "messages             == :messages_in_seq(1,:length_all_msgs()+1)   (obsolete)",
            "",
            "The $mail_agent versions of these verbs are set_task_perms(caller_perms()) and perform their operations on caller, which in turn is assumed to have done any necessary security checks."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Subscribing to Mail Recipients",
            "------------------------------",
            "There are two notions of being \"subscribed\" to a mailing list/recipient.",
            "",
            "(1) Hard subscribed == being on the recipient's .mail_forward list so that mail sent to this list is forwarded to one's own .messages as well (see `help mail-forwarding').",
            "",
            "(2) Soft subscribed == keeping track of a current message for this recipient and (optionally) being on the recipient's .mail_notify list.",
            "",
            "",
            "Each player has a .current_message property that contains, for each recipient the player cares to keep track of, a current message number and a last read date.",
            "",
            "player:current_message(rcpt)                 (somewhat obsolete)",
            " => player's current message number for rcpt ",
            "",
            "player:get_current_message(rcpt) ",
            " => player's {current message number for rcpt, last-read-date for rcpt}",
            "",
            "player:make_current_message(rcpt)",
            " => adds a current_message entry for rcpt  (NOOP if rcpt == player)",
            "",
            "player:set_current_message(rcpt,n|E_NONE,[,date])",
            " => sets player's current message number for rcpt to n iff n!=E_NONE",
            "    updates the last-read-date for rcpt to date iff date > last-read-date",
            "",
            "player:kill_current_message(rcpt)",
            " => removes current-message info for rcpt  (NOOP if rcpt == player)",
            "",
            "",
            "On $mail_recipient, .mail_forward and .mail_notify are -c so one needs to use the following verbs to actually modify them.",
            "",
            "    :add_forward(@new_recipients)",
            "    :delete_forward(@recpients)",
            "    :add_notify(@new_notifiees)",
            "    :delete_notify(@notifiees)",
            "",
            "A recipient's owner is, of course, allowed to make arbitrary changes to .mail_forward and .mail_notify.  However, the default versions of these verbs also allow any player to add him/herself to a recipient's .mail_forward or .mail_notify if the recipient is readable (see `help MR-access') by him/her.",
            "",
            "Likewise any player may use the :delete* verbs to delete him/herself from any .mail_forward/.mail_notify list, regardless of his actual access to the list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "One may always refer to a list by its object number.  In order to refer to it by name, it must be contained in $mail_agent, which holds all mailing lists, i.e., those that you want others to be able to refer to by name.",
            "",
            "The .aliases field holds the names by which one may refer to the list, but only those names not containing spaces actually count for anything.  As with certain other types of objects (e.g., players), set_aliases() needs to be called in order to change the .aliases field.",
            "",
            "$mail_agent:match(name) ",
            "    is the canonical way to obtain the objectid of a mailing list ",
            "    given the name (\"*\" is assumed; an initial \"*\" will be dropped).",
            "",
            "$mail_agent:match_recipient(name) ",
            "    is the canonical way to obtain the objectid of a list or player",
            "    matching the given name.  An initial \"*\" indicates that this is ",
            "    supposed to be a list.",
            "",
            "$mail_agent:match_failed(objid,name) ",
            "    is the mail_recipient counterpart to $command_utils:object_match_failed"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Controlling Access to Mail Recipients",
            "-------------------------------------",
            ":is_writable_by(one) - one may alter/add/remove saved messages",
            ":is_readable_by(one) - one may read messages.",
            ":is_usable_by(one)   - one may send to this list",
            "",
            "By default, these verbs refer to the following properties:",
            "",
            "writers   - list of players other from the owner who can do anything",
            "readers   - if == 1, indicates a public mailing list.",
            "            list of additional readers (by default anyone who receives mail ",
            "            sent to the list can read the saved messages).",
            "moderated - if false, indicates a normal mail recipient everyone can send to.",
            "            otherwise this should be a list of approved senders.",
            "",
            "Terminology:",
            "  A mailing list is \"public\" if everyone can read it.",
            "  A mailing list is \"moderated\" if not everyone can send to it.",
            "",
            "Note that while being able to write to a recipient implies being able to read from it or send to it, neither of read-ability or send-ability implies the other.",
            "",
            "It is highly recommended that if you are creating custom mail recipients with variable reader/sender lists, i.e., you find you need to write your own :is_readable/usable/writabe_by verbs, you are best off if such verbs are of the form",
            "",
            "  return pass(@args) || << your_test(args[1]) >>",
            "",
            "and have .writers == .readers == {} and .moderated == 1.  This will ensure",
            " (1) wizards having write access",
            "     --- necessary in order for :receive_message to work",
            " (2) writers being able to read and send (the converse being a ludicrous ",
            "     situation), ",
            " (3) persons on the mail_forward list of someone with reader access will also",
            "     have read access (convenient)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Generic Mail Recipient",
            "----------------------",
            "A \"mail recipient\" is, by definition, an object that can be sent mail.",
            "Mail recipients must either be players or descendants of $mail_recipient.",
            "",
            "One source of confusion is that the terms \"mail recipient\", \"mail folder\", \"mailing list\", and \"mail collection\" really all refer to the same kind of object.  It so happens that $mail_recipient serve several distinct functions and we tend to use whatever term happens to best match the application under discussion, e.g., it's a \"mailing list\" if we're playing with its .mail_forward property but it's also a \"mail folder\" if we're examining the messages that have been saved in it.",
            "",
            "Note that, by default, a freshly created recipient is accessibly only by you.  If you wish to make a publically accessible recipient, set .readers=1.  Furthermore, if you want to allow a message on your recipient to be removed by its sender without your intervention, set .rmm_own_msgs=1.  Finally, in order for other players to be able to refer to your recipient by name, the object must reside in $mail_agent.  $mail_agent will not accept the object unless it has an actual description and a name distinct from all other mail recipient names/aliases.",
            "",
            "Topics:",
            "",
            "  MR-access       -- controlling read, write and send access to a recipient",
            "  MR-naming       -- naming conventions and how to match on recipient names",
            "  MR-sequences    -- message sequence arguments to $mail_recipient verbs",
            "  MR-reading      -- reading messages/headers on recipients",
            "  MR-searching    -- searching message lists for patterns in certain fields",
            "  MR-writing      -- removing and renumbering messages",
            "  MR-subscribing  -- updating .mail_forward, .mail_notify ",
            "                       and the story of .current_message",
            "  MR-expiration   -- expiring and netmailing messages from recipients"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Receiving Mail",
            "--------------",
            "By definition a recipient \"receives\" a mail message when its :receive_message verb is called with that message as an argument.",
            "",
            ":new_message_num()",
            "=> number that will be assigned to the next incoming message.",
            "By default this returns the maximum of the message numbers appearing in ",
            "messages or .messages_going, incremented by 1.  If the recipient is a player",
            "then the value returned will be 1 higher if it conflicts with the player's ",
            "current message number for him/herself.",
            "",
            ":receive_message(msg,sender)",
            "By default this first calls this:new_message_num to obtain a message number to assign to the incoming message and then appends {num,msg} to this.messages.  ",
            "`sender', the original sender, is supplied in case one wants different ",
            "action depending on who is sending the message (e.g., mail-gagging).",
            "The return value should be an error or string if :receive_message is considered to have failed in some way.  Otherwise, a number should be returned --- this number is given to any :notify_mail routines that are called and is expected to either be 0 or the number assigned to the incoming message.",
            "",
            "Note that :receive_message can do arbitrary things, including resending the same message to a new destination.  Hacking :receive_message to resend messages is different from using .mail_forward in the following respects",
            "  (1) the resent message is considered to be a distinct message having this ",
            "      object as its \"author\" --- i.e., the From: line will necessarily be ",
            "      different.",
            "  (2) since this \"forwarding\" is invisible to the mailsystem, ",
            "      there is no protection against loops and multiple copies.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Mail Transmission Format",
            "------------------------",
            "There is a standard message format used for transmitting messages.  This is the format that $mail_editor:make_message produces, and that :receive_message verbs on players and $mail_recipients expect to see.  The (currently experimental) @refile and @copym commands also use this format to transfer messages.",
            "",
            "This *transmission* format is distinct from the *storage* format, though, for convenience this same format is often used as well for storing messages in player collections and ordinary $mail_recipient children though, in general, there is no requirement that this be the case.",
            "",
            "A transmitted message is a list in the following form",
            "",
            "   date (number),",
            "     the time() value at the time the message was sent.",
            "   from (string),",
            "     the sending object (address list form)",
            "     if this is not a player, an additional header will indicate the ",
            "     current ownership of the object.",
            "   to  (string),",
            "     recipients (address list form) which can either be players ",
            "     or $mail_recipient descendents.",
            "   subject (string),",
            "     subject of the message, or \" \" if there is no subject,",
            "  @additional optional headers (list of strings),",
            "     each header has the form \"<header-name>: text\" where <header-name>: ",
            "     is padded out to a width of 10 columns for the convenience of ",
            "     :display_message.  Currently \"Reply-to: <address list>\" is the only ",
            "     additional header in use,",
            "   \"\",",
            "  @body of message (list of strings)",
            "",
            "Note that the from, to and subject lines do *not* include a header name like \"From:\", \"To:\", or \"Subject:\".  The @'s indicate that the lists in question get spliced in (as usual), thus the entire message is a list whose first element is a number and the rest are strings.",
            "",
            "The address lists that appear in the from and to lines is a string in the form a sequence of object ids, each enclosed in parentheses and preceded by optional text, e.g.,",
            "",
            "  \"*Core-DB-Issues (#8175), Rog (#4292), and Haakon (#2)\"",
            "",
            "The text is intended to give the current name of each object for the benefit of human readers, but is actually ignored by all header parsing routines.  The convention is that the text is either a player name or a * followed by a mailing list name."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Resolving Mail Forwarding & Notification",
            "----------------------------------------",
            "For each recipient of a given mail message, the following two verbs are called to determine where the message should actually go and who should be notified about it:",
            "",
            ":mail_forward([from])",
            "    should return either",
            "     . a list of objects (either players or $mail_recipients)",
            "         to which mail for this recipient will be redirected.",
            "     . a string error message to be printed to the player sending the message.",
            "         If this recipient is one of the original destinations (i.e., not the",
            "         result of a previous forwarding), no mail is actually sent.",
            "",
            "    If :mail_forward returns a nonempty list, the recipient itself will *not*",
            "    actually receive the mail message unless it is included in the list.",
            "    #-1 is allowed to be on the list; it is ignored but does make the list ",
            "    nonempty.  Thus, having :mail_forward() return {#-1} is the canonical way",
            "    to have arriving mail disappear without being kept or forwarded.",
            "",
            ":mail_notify([from]) ",
            "    should return a list of objects that are to be told about any mail sent ",
            "    to this recipient (whether or not the recipient actually receives it).",
            "    Said objects must have a :notify_mail verb, but other from that, there ",
            "    is no restriction on what these can be.",
            "",
            "    object:notify_mail is called with the arguments ",
            "    (sender,recipients,msgnumbers) where ",
            "      recipients  == list of recipients including object in .mail_notify",
            "      msgsnumbers == corresponding list of :receive_message return values",
            "                 (or 0 if :receive_message is not actually called, which",
            "                  will be the case if the recipient forwards without keeping)",
            "",
            "When called as part of a mail send, the `from' argument is the immediate predecessor on the forwarding chain.  The default versions of these verbs return the values of .mail_forward and .mail_notify respectively (pronoun_subbing if the value is a string), unless this is a moderated mailing list and `from' is an unapproved sender (see `help MR-access') in which case the following verbs are called instead:",
            "",
            ":moderator_forward(from) ",
            "    what :mail_forward should return for mail coming from unapproved senders",
            "    This returns .moderator_forward (pronoun_subbed if a string) by default.",
            "",
            ":moderator_notify(from)",
            "    what :mail_notify should return for mail coming from unapproved senders",
            "    This returns .moderator_notify (pronoun_subbed if a string) by default.",
            "",
            "Since the :mail_forward verbs only see the previous sender in the forwarding chain, if, e.g, B is moderated but A can send to B (i.e., B:mail_forward(A) returns an actual list), then any mail sent to A goes to B even if the original sender isn't normally allowed to send to B directly.",
            "",
            "These verbs should all allow `from' to be omitted in which case they should return as if `from' were a generic approved sender (e.g., wizard).",
            "",
            "It should rarely be necessary to actually modify any of :*_forward/*_notify verbs, since one has a fair amount of control over their behavior via the following properties",
            "",
            "  .mail_forward",
            "  .mail_notify",
            "  .moderated          (see `help MR-access')",
            "  .moderator_forward",
            "  .moderator_notify"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Sending Mail",
            "------------",
            "$mail_agent:send_message(from,recipients,headers,body)",
            "  from:        sender of the message ",
            "               (this must be you or something you own; otherwise => E_PERM)",
            "  recipients:  object or list of objects (must all be players or ",
            "               $mail_recipient descendants)",
            "  headers:     either a string (contents of the Subject: line) ",
            "               or a list {subject,replytos} replytos is a list ",
            "               of objects designated to receive replies.",
            "               Use {\"\",replytos} to have a Reply-to: without a Subject:",
            "",
            "This is the canonical way to send a mail message from a program.",
            "This calls $mail_agent:make_message to format the arguments into an actual message (see `help mail-format') and then $mail_agent:raw_send to do the actual sending which goes as follows:",
            "",
            "  (1) Call :mail_forward on all recipients add any new recipients thus obtained to final recipient list, keep calling mail:forward on the new recipients until we obtain no additional recipients.  If one of the initial recipients is invalid, is not a player or $mail_recipient, or has its mail_forward return a string error, then we print the error message and abort at this point with no mail being sent.  If one of the later recipients bombs similarly, error messages are printed, but in this case mail still goes out to the other recipients.",
            "",
            "  (2) Call :mail_notify on all recipients encountered in stage (1) to get a list of objects to notify.",
            "",
            "  (3) All final recipients receive the message (see `help receive-mail')",
            "  (4) All notifications are delivered (using :notify_mail())",
            "",
            "We return {0, @failed_recipients} if we bombed out at step 1.",
            "Otherwise return {1, @actual_rcpts} indicating what mail was sent."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Mail System",
            "-----------",
            "The following topics describe the guts of the LambdaCore mail system",
            "",
            "sending-mail     -- how to send mail from a program; what happens.",
            "mail-forwarding  -- how to do mail forwarding/notification (the simple version)",
            "mail-resolve     -- how mail forwarding/notification works, in gory detail",
            "receiving-mail   -- what :receive_message should do",
            "mail-format      -- format of transmitted messages",
            "mail-command-parsing   (TODO) -- routines for parsing mail commands",
            "",
            "$mail_recipient  -- generic non-player mail recipient",
            "$mail_agent      -- mail utility object"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "Database of Players",
            "-------------------",
            "This is an instance of the Generic Database ($generic_db) that",
            "holds the {name/alias,#objectid} pairs for every ",
            "name and alias of every player in the MOO.",
            "",
            "Verbs supplied include",
            "",
            "  :find(string)        => player or $ambiguous_match or $failed_match",
            "  :find_exact(string)  => player or $failed_match (does not do partial matches)",
            "  :find_all(string)    => list of all matching players",
            "",
            "  :insert(string,player) ",
            "       records that string is now a name or alias of player",
            "  :delete(string) ",
            "       removes string from the db",
            "  :available(string)",
            "       returns 1 if string is available as a player name or alias,",
            "       an object if string is in use, or 0 if string is otherwise unavailable.",
            "  :load()",
            "       resets the db, inserting all current player names and aliases.",
            "",
            "The internal representation and all of the above verbs (except :load() and",
            ":available()) are as described for $generic_db.",
            "",
            "It should be noted that for any application that involves resolving a player name from a command line, you should be using $string_utils:match_player() rather than $player_db:find(), since the former will deal correctly with other ways of referring to players apart from their names and aliases (e.g., literal object numbers, \"me\", \"$no_one\"...).",
            "",
            ":load() needs to be done periodically as it is possible for the player db ",
            "to get out of synch with reality.  In particular, there is currently no way",
            "to block someone writing his own player :recycle() verb that neglects to ",
            "remove his names from the player db.",
            "",
            "While a :load() is in progress the .frozen property is set to 1 to indicate that any results of :find*() are not to be trusted."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Core Utility Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "Which :match...() Verb Do I Call?",
            "---------------------------------",
            "There are many situations where one wishes to obtain an object from a room or a player's .contents whose name/aliases matches a particular string.  There are four main verbs available for this and it is important to understand the distinctions between them and how they are supposed to be used.",
            "",
            "(*)  LOC:match(\"X\")",
            "     -- what you get looking for something that is inside LOC and named \"X\".",
            "        By default, this looks through LOC.contents to find a unique object ",
            "        having a name or alias that has \"X\" as a prefix.",
            "",
            "Essentially, you can think of :match as a contents-matching verb, though, e.g., for rooms you also get matches on exits as well.",
            "",
            "(*)  LOC:match_object(\"X\", YOU)           [YOU defaults to player]",
            "(*)  YOU:my_match_object(\"X\", LOC)        [LOC defaults to player.location]",
            "     -- what YOU get being located at LOC and looking for something named \"X\".",
            "        By default these both return $string_utils:match_object(\"X\",LOC,YOU)",
            "",
            "(*)  $string_utils:match_object(\"X\", LOC, YOU) ",
            "   -- what you *would* get *if* YOU were a typical player, YOU were inside LOC,",
            "      YOU were looking for something named \"X\", *and* LOC were a typical place.",
            "",
            "In other words, $string_utils:match_object describes the :match_object() algorithm for \"typical places\" and the :my_match_object for \"typical players\":",
            "",
            "    (1)  check for \"X\" being one of \"\", \"me\", \"here\", \"$something\", or \"#n\"",
            "    (2)  try YOU:match(\"X\") i.e., something in your inventory (maybe)",
            "    (3)  try LOC:match(\"X\") i.e., some object in the room (maybe)",
            "",
            "The distinction between these location:match_object and player:my_match_object has to do with whether the player or the location should determine what the matching algorithm is.  Which one you should use depends on the command that you are writing.  If you are writing a command with a virtual-reality flavor, then you should be respecting the room owner's idea of which objects you can \"see\" and thus the command should be calling the location's :match_object verb.  If you are writing a building/programming command where it is appropriate for the player to determine the matching algorithm  --- whether because the current location is irrelevant, not to be trusted, or both --- then the player's :my_match_object verb should be called.",
            "",
            "Examples:",
            "",
            "  `look diamond in box'",
            "      calls box:match(\"diamond\").  This is a match on the contents of box.",
            "",
            "  `take ball', ",
            "      calls player.location:match_object(\"ball\")",
            "      to determine which \"ball\" to take.  Note that if the room is dark, ",
            "      we might not be able to find any \"ball\".",
            "",
            "  `@program widget:foo', ",
            "      calls player:my_match_object(\"widget\") to get the player's own idea",
            "      of what \"widget\" should be.  Note that if I were carrying something ",
            "      named \"widget\" and expecting to be programming a :foo() verb on it,",
            "      it would be potentially disastrous should the room where I am decide",
            "      for me to be programming something else (not even necessarily ",
            "      called \"widget\").",
            "",
            "Object Matching Failures",
            "------------------------",
            "As with other matching routines, one gets back ",
            "",
            "  $failed_match in the case of no matching object",
            "  $ambiguous_match in the case of more than one matching object",
            "  $nothing in the case of a blank string argument",
            "",
            "or an object-id.  In these first 3 cases, one usually wants to translate these nonresults to the player; this is what $command_utils:object_match_failed.  The standard idiom to mimic what the builtin parser does, say, with the direct object is",
            "",
            "  dobj = foo:match_???(dobjstr);",
            "  if($command_utils:object_match_failed(dobj, dobjstr))",
            "    \"...give up.  nothing to do.   error message has already printed...\";",
            "  else",
            "    \"...dobj is something useful.  Continue...\";",
            "    ...",
            "  endif"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "$no_one",
            "-------",
            "... is a powerless player.  He owns no objects, not even himself; nor does he own any verbs.  He is, however, a programmer and thus may use eval().  In fact his sole purpose is to evaluate questionable code.  `questionable' could be in either or both of the following senses ",
            "",
            "(1) Its origin is sufficiently uncertain so that there is no obvious way of deciding whose permissions it should run under.",
            "(2) The code itself is potentially malicious, i.e., to the extent that one does not want to be evaluating it using one's own permissions.",
            "",
            "set_task_perms($no_one);  is thus the canonical idiom in wizard code for rendering anything that follows mostly harmless.  For use by ordinary programmers, we have:",
            "",
            "    $no_one:eval(string)",
            "",
            "which attempts to evaluate an arbitrary string using $no_one's permissions.",
            "string is either an expression or \";\" followed by one or more statements, of which the final semicolon may be omitted.  return values are what eval() would return (either {1,value} or {0,@error_messages}).",
            "",
            "Similarly, we have",
            "",
            "    $no_one:eval_d(string)",
            "",
            "which attempts to evaluate the specified string, but does it without the debug flag turned on (so that, for example, you'll get an error as opposed to terminating by traceback).",
            "",
            "And, as a helpful utility for calling verbs whose behavior may be unpredictable, there is",
            "",
            "    $no_one:call_verb(object, verb name, args)",
            "",
            "which calls the specified verb with $no_one's permissions."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Exits",
            "-----",
            "An exit can be renamed by either the owner of the exit or the owner of its source.",
            "",
            "The standard verbs that are called in exit movement are:",
            "",
            ":move(object)  - moves the object via this exit",
            ":invoke()      - equivalent to :move(player)",
            "",
            "When an exit is invoked on a particular object (via exit:move(object)), the following occurs.",
            "",
            "(1) The exit may be locked against the object, in which case we print the ",
            "   nogo messages and quit.",
            "",
            "(2) (room=exit.dest):bless_for_entry(object) is called.  Assuming that exit is recognized by room as being a legitimate entrance (i.e., is in room.entrances), this will enable room:accept(object) to return true.",
            "",
            "(3) object:moveto(room) is called and the various messages (see `help exit-messages') are :announced/:told.  Note that this, in accordance with the way the builtin move() (and hence the default :moveto()) works, we get a call to room:accept(object) which checks for the room itself being locked against the object, and otherwise returns true if the blessing in the previous step worked.  The move is performed, here:exitfunc(object) and room:enterfunc(object) are called.  In particular, room:enterfunc clears the blessing bestowed in (2) now that it is no longer needed.",
            "",
            "In general, the move may fail, in which case we :announce the (o)nogo_msgs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The Generic Room ($room)",
            "----------------",
            "",
            "(1)  Announcements",
            "",
            ":announce         (@text)         => broadcasts to all except player",
            ":announce_all     (@text)         => broadcasts to all",
            ":announce_all_but (objects,@text) => broadcasts to all except those in objects",
            "",
            "say, emote",
            "",
            "",
            "(2)  Command recovery",
            "",
            ":huh            (verb,args) - server hook: last chance to make sense of verb",
            ":here_huh       (verb,args) - room's last attempt to parse something",
            ":here_explain_syntax (this,verb,args) - attempts to explain usage of verb",
            "",
            "",
            "(3)  Residency",
            "",
            "free_home  - true => @sethome allows anyone to set his .home to be here",
            "residents  - objects on this list may teleport in and/or set their homes here.",
            "",
            ":accept_for_abode(player) ",
            "            => true iff player should be allowed to set .home to this room.",
            "",
            "@resident*s",
            "",
            "",
            "(4)  Looking",
            "",
            "dark  - true => contents are not visible",
            "ctype - 0..3 for four different styles of .contents lists",
            "",
            ":match         (string)        => exit or object in room's .contents",
            ":tell_contents (objects,ctype) - format objects according to ctype, tell player",
            "",
            "l*ook",
            "",
            "",
            "(5)  Entrance and exit.",
            "",
            ":accept (object) - Called by move() and :moveto() before an object enters a room, if false is returned, movement is prevented.  Protocol permits this verb to make noise (though this is discouraged) as this is the only place the room will learn the object's original location.",
            "",
            ":acceptable (object) - Called by verbs which wish to check whether movement will be possible.  Protocol prohibits this verb from making noise and requires it to return the same value as :accept would for the same arguments.",
            "",
            ":is_unlocked_for (object) - interface with the @lock protocol.  Returns true or false depending on the state of locks for the object with the room.  Other things may prevent entrance even if this returns true.  Protocol prohibits this verb from making noise. ",
            "",
            ":enterfunc (object) - called after entrance has succeeded.  Noise is fine.",
            "",
            ":exitfunc (object) - called after an object has successfully left.  Noisemaking is fine.",
            "",
            "(6)  Topology and Movement via Exits",
            "",
            "See `help $exit' for an explanation of how the generic $exit works.",
            "",
            "free_entry     - true  => `teleporting' in is allowed",
            "                  false => only residents may teleport in",
            "exits          - list of invokable exits leading from this room",
            "entrances      - list of recognized exits leading to this room",
            "blessed_object - object currently entering via an exit",
            "blessed_task   - task_id for entering object",
            "",
            ":match_exit      (string) => exit whose name matches string",
            ":bless_for_entry (object) - set up room to accept object arriving from entrance",
            ":add_exit        (exit)",
            ":add_entrance    (exit)",
            ":remove_exit     (exit)",
            ":remove_entrance (exit)",
            "",
            "e/east/w/west/s/south/n/north/ne/northeast/nw/northwest/se/southeast/sw/southwest/u/up/d/down, go, @add-exit, @add-entrance, @remove-exit, @remove-entrance, @exits, @entrances ",
            "",
            "",
            "(7)  Ejection",
            "",
            "victim_ejection_msg/oejection_msg/ejection_msg",
            ":*_msg()  messages",
            "",
            "@eject",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "$generic_help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Generic Database",
            "----------------",
            "This holds a collection of {string key, datum} pairs, where datum can be anything.  At most one datum may be associated with any given string.  Data may be anything (lists, strings, numbers, objectids).  If you like, you can think of this as an array indexed by strings.",
            "Verbs supplied include",
            "",
            "  :find(string)          => datum, $ambiguous_match or $failed_match",
            "  :find_key(string)      => full string key,  $ambiguous_match or $failed_match",
            "  :find_exact(string)    => datum or $failed_match (no partial matches)",
            "  :find_all(string)      => list of all data corresponding to matching strings",
            "  :find_all_keys(string) => list of all matching strings",
            "",
            "  :insert(string,datum)  ",
            "       if the string is already present in the db, ",
            "       changes the associated datum and returns {old_datum};",
            "       otherwise enters a new {string,datum} pair and return 0.",
            "  :delete(string)",
            "       if there is a datum associated with string, ",
            "       remove this association and return {datum}; otherwise return 0.",
            "  :delete2(string,datum)",
            "       if the given datum is associated with string, ",
            "       removes that association and return {datum}, ",
            "       if some other datum is associated with string, just return {other datum}",
            "       otherwise return 0.",
            "  :clearall([4|3])",
            "       removes all associations from the database.",
            "       optional argument changes the type of the database ",
            "       (4 is normal, 3 is a kludge for when the data are simply boolean flags",
            "        i.e., this is a set of strings rather than a string-indexed array;",
            "        more on this below)",
            "",
            "  count [entries|chars] in this",
            "        provide some vague statistics about how big this thing is.",
            "",
            "N.B.  As entries get made, properties belonging to $generic_db.owner will be created on the db object itself.  These properties will be created having flags as specified by .node_perms, which by default is \"r\", but can be changed to \"\" should you want to ensure that randoms don't have access to the raw information.",
            "",
            "Implementation notes",
            " - - - - - - - - - -",
            "The representation is as a `trie', a tree in which each internal node corresponds to a prefix shared by two or more strings in the db.",
            "Each internal node is kept in a property named \" \"+<prefix>, where <prefix> is a prefix shared by all strings in the subtree under this node.",
            "The property value is a 4 element list",
            "",
            "this.(\" \"+<prefix>)[1] = <common>",
            "   maximal continuation shared by all strings beginning with prefix",
            "   i.e., all these names actually begin with <prefix>+<common>",
            "",
            "this.(\" \"+<prefix>)[2] = <continuations>",
            "   string of all characters <c> that can follow <prefix>+<common> for which",
            "   there is more than one string in the db beginning with <prefix>+<common>+<c>",
            "",
            "this.(\" \"+<prefix>)[3] = <exact_matches>",
            "   list of all strings in this subtree for which ",
            "   the character (or lack thereof) following the <prefix>+<common> substring ",
            "   suffices to determine the string.",
            "",
            "this.(\" \"+<prefix>)[4] = <data>",
            "   list of data corresponding to the strings in [3].",
            "",
            "Child nodes are       this.(\" \"+<prefix>+<common>+<c>) ",
            "       for all <c> in this.(\" \"+<prefix>)[2].",
            "The root node is this.(\" \").",
            "If, e.g., there are 2 or more strings in the db beginning with a, ",
            "there will be a node this.(\" a\").  ",
            "If all of these strings actually begin with \"ani\", then this.(\" a\")[1]==\"ni\".",
            "The db consisting of the 5 correspondences",
            "",
            "  {\"animal\", #1}",
            "  {\"anime\",  #2}",
            "  {\"anil\",   #3}",
            "  {\"anile\",  #4}",
            "  {\"banal\",  #5}",
            "",
            "would be represented",
            "",
            "this.(\" \")    =={\"\",  \"a\",  {\"banal\"},         {#5}}",
            "this.(\" a\")   =={\"ni\",\"lm\", {},                {}}",
            "this.(\" anim\")=={\"\",  \"\",   {\"animal\",\"anime\"},{#1,#2}}",
            "this.(\" anil\")=={\"\",  \"\",   {\"anil\",\"anile\"},  {#3,#4}}",
            "",
            "In some cases one may merely wish to hold a collection of strings without trying to associate a particular datum with each string.  One may then instead set up a db without the fourth field on each of the properties.  In this case the datum is taken to be the found string itself and that is what gets returned by :find*() in the event of a successful search.   :find and :find_key are then equivalent as are :find_all and :find_all_keys.  To setup the db this way, do a :clearall(3).  :clearall(4) reverts to the above described type of db with a separately kept datum.  Note that you can't change the type without emptying the db.  3 and 4 are currently the only db types allowed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The Generic Editor enables a player to edit a list of strings.  While one might contrive to use it directly, it is rather intended as a parent for some actual editor.  It supplies the following commands:",
            "",
            "say         <text>                      w*hat       ",
            "emote       <text>                      abort       ",
            "lis*t       [<range>] [nonum]           q*uit,done,pause ",
            "ins*ert     [<ins>] [\"<text>]           ",
            "n*ext,p*rev [n] [\"<text>]               ",
            "del*ete     [<range>]                   ",
            "f*ind       /<str>[/[c][<range>]]       ",
            "s*ubst      /<str1>/<str2>[/[g][c][<range>]]",
            "m*ove,c*opy [<range>] to <ins>          ",
            "join*l      [<range>]                   ",
            "fill        [<range>] [@<col>]          ",
            "",
            "$editor_help.(cmdname) descrbes cmdname",
            "$editor_help.insert    descrbes insertion points (<ins>)",
            "$editor_help.ranges    descrbes range specifications (<range>)",
            "",
            "You'll notice that nowhere does it say how to load in a given list of strings or how and where one may save said list away when one is done editing.  These commands are supplied by the child editor object.  The generic editor contains only the code for editing lines, though it defines additional functions for use by the children:",
            "",
            "  :loaded(player)",
            "     returns the index (player in this.active) iff text has been loaded",
            "     from somewhere, otherwise returns 0.",
            "",
            "     Note that, by default, there is a difference between ",
            "",
            "        having nothing loaded                (:text(who)==0) and ",
            "        having loaded something with no text (:text(who)=={}).",
            "",
            "     If you don't care about this distinction in a particular case,",
            "     just do (player in this.active) instead of this:loaded(player).  ",
            "     If you don't want your editor to make this distinction at all, do",
            "",
            "        @stateprop texts={} for <youreditor>",
            "",
            "     which changes the initial value of :text() to {} ",
            "",
            "In all functions below, 'who' is the index returned by :loaded(player) ",
            "",
            "BTW, be careful about using 'player' in non-user (i.e., +x this-none-this) verbs --- much better to have the user verb get the index with :loaded() and then pass that around.  ",
            "",
            "Also be careful about suspend() and verbs that call suspend().  In particular, the player's index in the .active list can change during the suspend interval, so you must be sure to obtain the index (e.g., using :loaded()) again after the suspend() returns.",
            "",
            "For your non-user verbs, we have",
            "",
            "  :ok(who)",
            "     returns E_PERM if the caller is not an editor verb and E_RANGE",
            "     if 'who' does not point to a valid session.",
            "",
            "which should take care of the more egregious security holes (but maybe not the less egregious ones).  For getting and loading text, we have",
            "",
            "  :text(who)    ",
            "     the current text string list or 0 if nothing loaded yet.",
            "  :load(who,text)",
            "     loads the given list of strings as the text to be edited.",
            "     this also resets the 'changed' flag and pushes the insertion ",
            "     point to the end.",
            "",
            "and various flags and properties (all of the set_* routines return E_PERM when not called from an editor verb, E_RANGE if who is out of bounds, E_INVARG if something is wrong with the 2nd arg, or the new value, which may not necessarily be the same as the 2nd arg (e.g., set_insertion(..,37) on a 5 line text buffer returns 6).",
            "",
            "  :changed(who)",
            "     has the text been altered since the last save/load?",
            "     (the child editor gets to define what \"save\" means).",
            "  :set_changed(who,value)",
            "     Any child editor command that is considered to save the text should do a ",
            "     :set_changed(who,0).  ",
            "     Note that if the changed flag is 0, the session will be flushed when ",
            "     the player leaves the editor, so you may also want certain commands to",
            "     do set_changed(who,1)...",
            "",
            "  :origin(who)",
            "     room where the player came from.  ",
            "  :set_origin(who,room)",
            "     can be used to change the room the player will return to when finished",
            "     editing.  Since origin gets set even in cases where the player teleports",
            "     into the editor you probably won't usually need to do this.",
            "",
            "  :insertion(who)",
            "     current insertion point.",
            "  :set_insertion(who,linenumber)",
            "     linenumber needs to be a positive integer and will get ",
            "",
            "  :readable(who)",
            "     whether the current editing session has been made globally readable.",
            "  :set_readable(who,boolean)",
            "     change the readability of the current editing session.",
            "     This is used by the publish/perish verbs.",
            "",
            "We also provide",
            "",
            "  :invoke(...)",
            "      If the player has a previous unsaved (i.e., :changed()!=0)",
            "      session, we return to it, moving the player to the editor.  ",
            "      If the player is already in the editor, this has no effect other",
            "      than to print a few nasty messages.  In any case a :changed()",
            "      session must be aborted or set_changed(,0) before anything else ",
            "      can be started",
            "",
            "      Otherwise, we pass the arguments (which are assumed to be the",
            "      result of some munging of the command line) to :parse_invoke(),",
            "      move the player to the editor and load whatever parse_invoke()",
            "      specified.  The only interpretation the generic editor makes on",
            "      the arguments is that if the boolean value of the first is true,",
            "      this indicates that the player wanted to load something as",
            "      opposed to resume a previous session.  Usually a command calling",
            "      :invoke will have a true (i.e., nonzero number, nonempty list or",
            "      string) first arg iff the command line is nonempty, in which case ",
            "      'args' works fine for this purpose.",
            "",
            "      If the command parses sucessfully (:parse_invoke() returns a list),",
            "      we move the player to the editor if necessary and then call ",
            "      :init_session() to set things up.",
            "",
            "The child editor is assumed to provide",
            "",
            "  :parse_invoke(...)",
            "     given :invoke()'s arguments, determines what the player wants to edit.",
            "     It either returns 0 and reports syntax errors to player,",
            "     or it returns some list that :init_session() will understand.",
            "",
            "  :init_session(who,@spec)",
            "     where spec is something that was returned by :parse_invoke().",
            "     Loads the text and sets the stateprops (below) to indicate that ",
            "     we are working on whatever it is we're suppose to be working on.",
            "",
            "  :working_on(who)   ",
            "     returns a string X as in \"You are working on X.\"",
            "     This is called by the 'w*hat' command, among other things.",
            "",
            "Child editors may have their own properties giving state information for the various editing sessions.  The value of each such property will be a list giving a value for each player in the editor.  For each such property, you should, once the editor object has been created, initialize the property to {} and do one of",
            "",
            "    @stateprop <propname>                 for <editor>",
            "    @stateprop <propname>=<default-value> for <editor>",
            "               (0 is the default <default-value>)",
            "",
            "Henceforth, adding and deleting new editing sessions will amend the list held by the given property.  The value of the property for a given session can be obtained via this.<propname>[player in this.active] and can be changed with a corresponding listset() call.  The usual idiom for an editor command is",
            "",
            "   if(!(who=this:loaded(player)))",
            "     player:tell(nothing_loaded_msg());",
            "   else",
            "      ... various references to  this.<propname>[who] ...",
            "   endif",
            "",
            "To remove such a property from the list of such state properties:",
            "",
            "    @rmstateprop <propname> from <editor>",
            "",
            "Note that you can only do this with properties defined on the child editor itself.  ",
            "",
            "Sometimes you may wish to @stateprop a new property on an editor where active editing sessions exist.  @stateprop will fail if the property in question does not hold a list of the correct length (== length(editor.active); one value for each editing session).  You need to either give the @flush command to clear out all sessions and boot all players currently in the editor or somehow manually initialize the property to a list of appropriate values and pray that nobody enters/exits the editor between the property initialization and the @stateprop command --- this problem can be avoided by doing an eval() that does all of the initializations (beware of suspends()) and calls :set_stateprops directly.",
            "",
            "Incidentally, the @flush command may be used at any time to clean out the editor or to remove all sessions older than a given date.",
            "",
            "There are also numerous _msg properties that may be customized",
            "",
            "    @depart          announced at the origin when :invoke() is called. ",
            "    @return          announced at the origin the player is returned there.",
            "    @nothing_loaded  printed when user attempts editing ",
            "                     before anything has been loaded.",
            "    @no_text         response to 'list' when :text()=={}",
            "    @no_change       printed by 'what' when :changed()==0",
            "    @change          printed by 'what' when :changed()==1",
            "    @no_littering    printed upon leaving the editor with :changed()==1.",
            "    @previous_session  printed by :invoke() when player tries to start a ",
            "                     new session without aborting or saving the old one",
            "",
            "The general procedure for creating a child editor:",
            "",
            ". @create $generic_editor named <editor>",
            "",
            ". define additional <editor> verbs/properties",
            "    At the very least you need 'edit' and 'save' commands.",
            "    Usually you can get away with just having 'edit' call :invoke();",
            "    Presumably, you'll need at least a command to load text from somewhere",
            "    as well as a command to save it back out.",
            "",
            ". define a verb (somewhere) to invoke the editor ",
            "    This could be just a one-liner that calls <editor>:invoke(args,verb).",
            "    Either that or",
            "      .  you have to set up an exit somewhere whose destination is <editor>",
            "      .  you have to advertise the object number so that people can ",
            "         teleport to it.",
            "  ",
            ". @stateprop x for <editor>",
            "",
            ". if you want the 'abort' command to boot the player from the editor do",
            "    <editor>.exit_on_abort = 1;",
            "",
            ". set <editor>.commands to be the list of additional commands defined",
            "    by <editor>.  ",
            "    Each element of the list is itself a list of the form {name,args}.",
            "  set <editor>.commands2 to be the list of commands that should appear",
            "    in the `look' listing, and should be a list of strings appearing ",
            "    as names in .commands on either <editor> or some editor ancestor.",
            "  look at $verb_editor or $note_editor for an example.",
            "",
            ". If you want to have help text for new verbs you define, create a child of ",
            "    $generic_help and add properties to this object for each of the topics ",
            "    that you want to provide help text.",
            "    Finally, set <editor>.help = {this object} so that the help system",
            "    knows to consult this object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The Help System",
            "---------------",
            "When a player types help, the following list of objects is consulted for .help properties:  the player itself, all ancestors of player up to and including $player, and, if the current location is a room, the current location together with all ancestors of the current location back to and including $room.  Each help property should have as value either an object or a list of objects (otherwise we just ignore it).  These objects are then strung together as a list of `help databases' to be searched in order for the requested topic.",
            "",
            "A help database (in the sense of anything that is usable by $player:help()) is any object having the following three verbs:",
            "",
            "  :find_topics([string])",
            "     where string is a supposed help topic, returns a list of strings,",
            "     i.e., actual help topics that this db knows about, or some boolean ",
            "     false value in the event that this db is clueless...",
            "     If no arguments are given, this should return a list of all topics",
            "     in the db",
            "",
            "  :get_topic(string)",
            "     given one of the strings returned by :find_topics this either",
            "     returns a list of strings (text to be spewed to the player) or",
            "     returns 1 to indicate that it has already taken care of printing",
            "     information to the player.",
            "",
            "  :dump_topic(string)",
            "     like get_topic, but instead returns the raw text of a help topic",
            "     as a (download/upload) script",
            "",
            "In short if :find_topic reports that a particular db knows about a given topic",
            "it returns the full topic name, so that :get_topic may be called on it later.",
            ":dump_topic is used by maintainers (see $wiz:@gethelp) to edit help topics.",
            "",
            "$generic_help and $help",
            "-----------------------",
            "The Generic Help Database, $generic_help, is the parent class of a particular kind of help database of which $help is an instance.  On help databases of this type, every help topic has a corresponding property, interpreted as follows:",
            "",
            "  this.(topic) = string             ",
            "      one-line help text.",
            "",
            "  this.(topic) = {\"*<verb>*\",@args}",
            "      call this:<verb>(args,dblist) to get text where dblist is the list of ",
            "      help objects that would have been consulted had the topic not been found ",
            "      on this object.",
            "",
            "  this.(topic) = other list of strings ",
            "      multi-line help text",
            "",
            "For the {\"*<verb>*\",...} form, the current verbs available are",
            "",
            "  {\"*forward*\", topic, @rest}   ",
            "     - get help text for topic and then append the lines of `rest'.  ",
            "       rest may, in turn, begin with a \"*<verb>*\"...",
            "",
            "  {\"*pass*\", topic, @rest}   ",
            "     - get help text for topic from the first help database after this one",
            "       that actually has help text for topic, and then append lines of `rest'.",
            "       As with \"*forward*\" rest may, in turn, begin with a \"*<verb>*\"...",
            "",
            "  {\"*subst*\", @lines} ",
            "     - All occurences of %[exp] in lines are replaced with the value of exp",
            "         which is assumed to evaluate to a string.  ",
            "       All lines beginning with %;exp are replaced with the value of exp ",
            "         which is assumed to evaluate to a list of strings.",
            "       Evaluation is done using $no_one's permissions so exp in either case",
            "       can only refer to public information.",
            "",
            "  {\"*index*\", title}",
            "     - returns a list of all topics in this database, arranged in columns.",
            "       title is used as a heading for this index.",
            "",
            "       In order for your help database to appear in the list presented",
            "       by 'help index', your db object must be set to +r.",
            "",
            "  {\"*objectdoc*\", object}",
            "     - gets the documentation for the given object (i.e., object:help_msg())",
            "       N.B. as with all other *verb* arguments, object must be a string.",
            "",
            "  {\"*verbdoc*\", object, verbname}",
            "     - gets the documentation for the named verb on the given object",
            "       (i.e., any strings at the beginning of said verbcode)",
            "",
            "Individual help dbs are free to define additional verbs that may be used in this context.  $help itself defines the following additional such verbs:",
            "",
            "  {\"*index_list*\"}",
            "     - returns a list of all index topics in all databases in the search list.",
            "       An index topic is one whose actual text is {\"*index*\", something}.",
            "       When creating a help db, you should be sure to make an index topic.",
            "",
            "  {\"*full_index*\"}",
            "     - prints indices for all help databases in the search list.",
            "",
            "It should be noted (once again) that help databases need not be children of $generic_help, so long as they have :find_topics/:get_topic/:dump_topic working as specified above."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Generic Option Package",
            "----------------------",
            "It occasionally happens that one has a command or set of commands for which one wishes to provide several options/flags that a player can set to customize the command's behavior for him/herself.  Making each option a separate property is a bit expensive, especially when the option in question is merely a boolean flag that gets set to false in most cases.  This package provides an alternative, as well as providing a uniform set of commands for setting these flags/options and checking that the values given are of appropriate types.",
            "",
            "Instead of needing several properties, only one is required to store a list containing values for all of the options.  An \"option package\" (pkg, below) is then an object of this class, which provides routines for manipulating such lists.",
            "",
            "The set of option names is divided into a set of \"real\" options, those whose names will actually appear in a given list, and \"extras\" which are either synonyms for or represent combinations of real options.",
            "",
            " pkg:add_name(name)      adds name to .names  (remove it from .extras if there)",
            " pkg:add_name(name,1)    adds name to .extras (remove it from .names if there)",
            "    => 1 - ok, 0 - already added, E_INVARG - illegal name, E_PERM",
            "",
            " pkg:remove_name(name)   remove name from either .names or .extras",
            "    => 1 - ok, 0 - not present, E_PERM",
            "",
            "For setting or retrieving values we have",
            "",
            " pkg:get(options,name) ",
            "    => value (or 0 if name isn't a real option)",
            " pkg:set(options,name,value)",
            "    => revised options (or string error message if something goes wrong)",
            "",
            "By default, a given option can only be a boolean flag, having one of the values 0 (absent from the list), or 1 (present in the list).  :set translates 0/\"\"/{} to 0 and any other non-object value to 1.",
            "",
            "One may however designate a wider range of possible values for an option \"foo\" by either installing one of",
            "",
            "  pkg.type_foo",
            "    -- list of allowed types, ",
            "       e.g., {NUM,STR}   => must be a number or a string",
            "       e.g., {OBJ,{OBJ}} => must be an object or a list of objects",
            "    for anything fancier use:",
            "",
            "  pkg:check_foo(value)",
            "    => string error message or {value munged as desired}",
            "",
            "In general, the only restriction on option values is that 0 is the only false value; setting an option to \"\" or {} sets it to 0.  Every option defaults to 0, and no matter what you install as .type_foo or :check_foo(), 0 will always be a legal value for option \"foo\".",
            "",
            "When presented with an option that is in .extras, :set will typecheck the value as described, however, then :actual(name, value) will be called to obtain a list of {name-of-real-option, value} pairs indicating which combination of real options should be set.",
            "",
            "Other verbs",
            "  pkg:parse(args,...)",
            "    parses the command line arguments of a @whatever_option command",
            "    => {optionname, value}  if the player wants to set an option",
            "    => {optionname}         if the player wants to view an option",
            "    => string error message  otherwise",
            "",
            "  one may install pkg:parse_foo to parse arguments for option \"foo\" ",
            "    !foo     => {\"foo\",0}  (:parse_foo not called)",
            "    foo=     => {\"foo\",0}  (:parse_foo not called)",
            "    -foo     => {\"foo\",0}  (:parse_foo not called)",
            "    +foo     => pkg:parse_foo(\"foo\",1)",
            "    foo=word => pkg:parse_foo(\"foo\",\"word\")",
            "    foo word1 word2    => pkg:parse_foo(\"foo\",{\"word1\",\"word2\"})",
            "    foo is word1 word2 => pkg:parse_foo(\"foo\",{\"word1\",\"word2\"})",
            "",
            " pkg:show(options,name|list of names)",
            "    => list of strings describing the current value of the named option(s).",
            "       calls     pkg:show_foo(options,list of names) or",
            "       refers to pkg.show_foo",
            "       to describe option \"foo\"",
            "",
            "(see sources for details...  at some point I'll finish writing this... --Rog)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Message Sequences",
            "-----------------",
            "A \"message sequence\" is a handle by which one may refer to a particular subset of a mail recipient's (player or $mail_recipient-descendant) saved messages.  Routines like rcpt:display_seq_headers or rcpt:display_seq_full need to be supplied with message-sequence arguments to deterimine which headers or full-messages to display.",
            "",
            "Message sequences can in turn be obtained from routines like rcpt:parse_message_seq, which takes a command-line description of a message sequence on that particular recipient and returns the corresponding message sequence handle.",
            "",
            "The actual form of a message sequence (though you shouldn't actually need to make use of this) is that of a set of integers in the format used by $seq_utils (see `help $seq_utils').  It should however be noted that these integers are *not* themselves message numbers, but rather indices into the list of saved messages.  For example, if a particular recipient holds 5 messages numbered 1,3,5,7,9.  Then the message sequence handle representing messages 3,5,7 collectively, would be {2,5} which is $seq_utils-ese for the range 2..4, namely the second, third and fourth messages saved on that recipient.",
            "",
            "The following verbs are available for obtaining indices to use in message sequences",
            "",
            "  :length_all_msgs()    => total number of messages, or equivalently,",
            "                        => index of last message",
            "  :length_num_le(n)     => number of messages numbered <= n, or equivalently,",
            "                        => index of highest numbered message <= n",
            "  :exists_num_eq(n)     => 0 unless there exists a message numbered n in which",
            "                           case we return the index of that message.",
            "  :length_date_le(date) => number of messages dated <= date, or equivalently,",
            "                        => index of most recent message dated <= date",
            "",
            "  :length_date_gt(date) => number of messages dated > date",
            "",
            "Note that r:length_date_gt(date) == r:length_all_msgs()-r:length_date_le(date).",
            "The only reason :length_date_gt is provided as a separate routine is in order ",
            "to do quick checks for the existence of new mail (as @rn needs to do)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Read verbs",
            "----------",
            "The following verbs may be used to extract headers/messages from readable mail recipients/players;",
            "",
            ":display_seq_headers (message sequence, current message number, last_read_date)",
            "  Does a @mail listing of the given message sequence.  If current message",
            "  number is given and the sequence includes it, we mark it with a `>'.",
            "  Likewise if the sequence includes any new messages (i.e., dated after ",
            "  last_read_date), these are also indicated as such.",
            "",
            "display_seq_full (message sequence, preamble)",
            "  Does a @read listing of the given message sequence.  Each message is preceded",
            "  by preamble.",
            "  => {new current message number, new last_read_date}",
            "",
            ":messages_in_seq (index)",
            "  => {n, msg}",
            ":messages_in_seq (message sequence)",
            "  => {{n_1,msg_1},{n_2,msg_2},...}",
            "  where the n_i are message numbers and the msg_i are messages in transmission",
            "  format (see `help mail-format')",
            "",
            ":list_rmm ()",
            "  Does an `@unrmm list' listing of messages in .messages_going"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Write verbs",
            "-----------",
            "The following verbs can be used to manipulate writable mail recipients/players:",
            "",
            ":rm_message_seq (message sequence)",
            "  Does an @rmmail.  Messages in message sequence are removed from this ",
            "  recipient's saved .messages and written to .messages_going.",
            "",
            ":undo_rmm ()",
            "  Does an @unrmm.  Messages in .messages_going are copied back to .messages.",
            "",
            ":expunge_rmm ()",
            "  Does an @unrmm expunge.  Blows away .messages_going.",
            "",
            ":renumber ()",
            "  Does a @renumber.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Search verbs",
            "------------",
            "The following verbs can be used on a readable mail-recipient/player to search for messages with fields matching a given pattern.",
            "",
            "from_msg_seq (objectid or list [,mask])",
            "  => message sequence: messages from (one of) the given objectid(s)",
            "",
            "%from_msg_seq (string or list [,mask])",
            "  => message sequence: messages with (one of) the given string(s)",
            "     in the From: line",
            "",
            "to_msg_seq (objectid or list [,mask])",
            "  => message sequence: messages to (one of) the given objectid(s)",
            "",
            "%to_msg_seq (string or list [,mask])",
            "  => message sequence: messages with (one of) the given string(s)",
            "     in the To: line",
            "",
            "subject_msg_seq (string [,mask])",
            "  => message sequence: messages with given string occurring in Subject:",
            "",
            "body_msg_seq (string [,mask])",
            "  => message sequence: messages with given string occurring in body of message",
            "",
            "In all cases `mask' is a message sequence which one may supply to limit the range of the search.  One way of looking at it is that the message sequence to be returned is first intersected with mask."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The housekeeper is an object that can help keep other objects where they belong.  New MOOs may want to add their own user interface for the housekeeper; here is some information that may be helpful.",
            "",
            "To indicate what objects should be cleaned:",
            "",
            "  :add_cleanup(object[, requestor[, where]])",
            "    Ask the housekeeper to clean 'object' for 'requestor' to 'where'.",
            "    Requestor defaults to 'player'.",
            "    Where defaults to object.location.",
            "",
            "  :remove_cleanup(what[, requestor])",
            "    Remove 'what' from the cleanup list at 'requestor's request.",
            "    Will remove it only if 'requestor' made the original request and owns",
            "    the object or the destination.",
            "",
            "To actually get the housekeeper to clean stuff up:",
            "",
            "  :cleanup([insist])",
            "    Clean up player's objects.  Argument is 'up' or 'up!' for manually",
            "    requested cleanups.  'up!' means to clean things even if it's against",
            "    the housekeeper's better judgement.",
            "",
            "  :replace(object[, insist])",
            "    Clean up the indicated object.  'insist' is as in :cleanup.",
            "",
            "  :continuous()",
            "    Starts the housekeeper cleaning continuously, killing any previous",
            "    continuous task.  This should be called only when starting up a new MOO,",
            "    or if something has gone wrong, as normally it will just keep going",
            "    without any help.",
            "",
            "  :litterbug()",
            "    Clean up all the places in housekeeper.public_places by getting rid of",
            "    all contents not in their .residents lists.  This is called by",
            "    :continuous, so it doesn't need to be called directly.",
            "",
            "To find out what's being cleaned to where for whom:",
            "",
            "  :cleanup_list([whom])",
            "    Show 'player' the personal cleanup list for 'whom', or the housekeeper's",
            "    complete list if no argument is given.",
            "",
            "  :clean_status()",
            "    Show 'player' a brief summary of eir personal cleanup list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "$recycler",
            "=========",
            "",
            "Rather than having the server built-in recycle() and create() functions handle the creation and destruction of objects, a recycling center has been created to simulate these actions by  changing objects that would have been recycled into children of $garbage (The Generic Garbage Object) and making them owned by Hacker, and then when they're needed again, to avoid a raw create() command, those objects are given to whoever's asking for them.",
            "",
            "Most Useful Verbs",
            "-----------------",
            "",
            "$recycler:_recycle( object )",
            "  This will effectively recycle an object. (As a point of fact, it changes ownership of the object to Hacker and makes the object a child of $garbage.)  It handles .ownership_quota and .owned_objects properly.  Generally, use this instead of a recycle() in your verbs.",
            "",
            "$recycler:_create( parent object [ , new owner object ] )",
            "  This effectively creates an object (with the specified parent, if possible, and with the specified owner, if possible; these are the same restrictions as on the server create() builtin).  This is what should generally be used instead of create() in your programming.",
            "",
            "$recycler:valid ( object )",
            "  This is a variant of the server built-in valid() except that it handles the $garbage objects as well.  It returns a 1 if the object specified -is- valid and is -not- a $garbage object.",
            "",
            "Other Notes",
            "-----------",
            "",
            "request <object> from <recycler>",
            "  This is not an internal verb (it's !x).  It is, however, a command-line verb that can be used to request a specific object from the recycler.  It's also useful for the creation of objects like a Magic Number Repository.  When the object is removed from the recycler, the .announce_removal_msg is announced to the room if it's set (it's piped through $string_utils for pronoun substitution).",
            "",
            "show-history <recycler>",
            "  This is a wizardly verb which allows wizards to check the `history list' of the recycler. The history maintains the latest ($recycler.nhist) entries.",
            "",
            "$recycler.orphans",
            "  This maintains a list of objects for which the recreation process got mangled. It ought to be checked every once in a while to see what's up."
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "$error",
            "======",
            "",
            "The Error Generator, $error, may be used to automatically generate errors. This is particularly useful if you are working in a !d verb but have occasion to -want- to crash with traceback. To raise a specific error, use $error:raise(error type) -- for example, $error:raise(E_PERM) will produce traceback resulting from a Permission Denied error.",
            "",
            "Random notes about $error:",
            "",
            "+ The complete list of errors is stored in $error.names.",
            "+ The seemingly useless :accept() verb on $error is so that $error:E_RECMOVE and $error:E_NACC will be guaranteed success (success meaning, of course, a termination by traceback).",
            "+ There is, unfortunately, no way to raise the error E_NONE."
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "Generic BigList Utilities",
            "----------------------------",
            "$biglist is a collection of routines for maintaining huge persistent (sorted) lists in a format that is less likely to spam the server (which runs into a certain amount of trouble dealing with long ordinary lists --- btw we use `biglist' to refer to the huge data structure we're about to describe and `list' to refer to ordinary MOO lists {...}).  The biglist in question lives on a particular object, to which we will refer in the discussion below as the `home' object, and its various elements appear as leaves of a tree whose nodes are kept in properties of the home object.  It should be noted that the home object does not need to be (and in fact should *not* be) a descendant of $biglist one; $biglist merely provides utilities for manipulating the properties on the home object that are used in a particular biglist manipulation.  ",
            "",
            "All of the utilities below refer to `caller' to locate the home object.  Thus verbs to manipulate a given biglist must be located on or inherited by its home object itself.  The home object needs to define the following verbs",
            "",
            "  :_make(@args)     => new property on home object with value args",
            "  :_kill(prop)      delete a given property that was created by :_make",
            "  :_get(prop)       => home.prop",
            "  :_put(prop,@args) set home.prop = args",
            "  :_ord(element)    given something that is of the form of a biglist element",
            "                    return the corresponding ordinal (for sorting purposes).",
            "                    If you never intend to use :find_ord, then this can be a ",
            "                    routine that always returns 0 or some other random value.",
            "",
            "See $generic_biglist_home or $big_mail_recipient for examples.",
            "",
            "Those of the following routines that take a biglist argument are expecting",
            "either {} (empty biglist) or some biglist returned by one of the other routines",
            "",
            "  :length(biglist)          => length(biglist) (i.e., number of elements)",
            "  :find_nth(biglist,n)      => biglist[n]",
            "  :find_ord(biglist,k,comp) => n where n is",
            "     the largest such that home:(comp)(k,home:_ord(biglist[n])) is false, or",
            "     the smallest such that home:(comp)(k,home:_ord(biglist[n+1])) is true.",
            "     Always returns a value between 0 and length(biglist) inclusive.",
            "     This assumes biglist to be sorted in order of increasing :_ord values ",
            "     with respect to home:(comp)().",
            "     Standard situation is :_ord returns a number and comp is a < verb.",
            "",
            "  :start(biglist,s,e)  => {biglist[s..?],@handle} or {}",
            "  :next(@handle)       => {biglist[?+1..??],@newhandle} or {}",
            "     These two are used for iterating over a range of elements of a biglist",
            "     The canonical incantation for doing",
            "        for elt in (biglist[first..last])",
            "          ...",
            "        endfor",
            "     is",
            "        handle = :start(biglist,first,last);",
            "        while(handle)",
            "          for elt in (handle[1])",
            "            ...",
            "          endfor",
            "          handle = :next(@listdelete(handle,1));",
            "        endwhile",
            "",
            "The following all destructively modify their biglist argument(s) L (and M).",
            "",
            "  :set_nth(L,n,value)  =>  L[n] = value",
            "     replaces the indicated element",
            "",
            "  :insert_before(L,M,n) => {@L[1..n-1],@M,@L[n..length(L)]}",
            "  :insert_after (L,M,n) => {@L[1..n],  @M,@L[n+1..length(L)]}",
            "     takes two distinct biglists, inserts one into the other at the given point",
            "     returns the resulting consolidated biglist",
            "",
            "  :extract_range(L,m,n) => {{@L[1..m-1],@L[n+1..]}, L[m..n]} ",
            "     breaks the given biglist into two distinct biglists.",
            "",
            "  :delete_range(L,m,n[,leafkiller]) => {@L[1..m-1],@L[n+1..]}",
            "  :keep_range  (L,m,n[,leafkiller]) => L[m..n]",
            "     like extract_range only we destroy what we don't want.",
            "",
            "  :insertlast(L,value)  => {@L,value}",
            "     inserts a new element at the end of biglist.  ",
            "     If find_ord is to continue to work properly, it is assumed that the ",
            "     home:_ord(elt) is greater (comp-wise) than all of the :_ord values",
            "     of elements currently in the biglist.",
            "",
            "  :kill(L[,leafkiller]) ",
            "     destroys all nodes used by biglist.  ",
            "     Calls home:leafkiller on each element."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "$guest_log",
            "",
            "records guest connect/disconnect events.",
            "",
            ".max_events  -- maximum number of connect/disconnect events kept",
            ".connections -- actual list of events, the most recent ones first",
            "    each element is of the form",
            "      {object, is_connect, time, site}",
            "    object is the particular guest that (dis)connected",
            "    is_connect 1 or 0 according as this is a connect or not.",
            "",
            ":find(who,when)",
            "  => site name of WHO at the particular time",
            "     (or 0 if WHO was not logged in then)",
            "",
            ":last(n) ",
            "  prints a listing of the last n events"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "mail-resolve"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "$news",
            "-----",
            "This object is a mail_recipient like any other (see `help $mail_recipient').  One may send messages to it and use the usual recipient manipulation commands (@mail, @read, @rmm,...).  ",
            "",
            "Selected messages on this recipient are ordered in reverse date order (i.e., most recent first) and concatenated to produce the \"news\" that is printed in response to the player `news' command.  Each news item is thus a distinct message.  The default $player:confunc checks to see if any new messages have been selected for inclusion in the \"news\" since the player last read the news.",
            "",
            "The property $news.current_news holds the message sequence of messages currently considered as comprising \"the news\".  The following commands are used to change .current_news:",
            "",
            "  @addnews <message-seq> to %[$news]",
            "  @rmnews <message-seq> from %[$news]",
            "  @setnews %[$news] to <message-seq>",
            "",
            "@addnews includes the specified messages, @rmnews excludes the specified messages, and @setnews changes .current_news to be the given message sequence.  Note that these ONLY change whether a given message is marked as being \"in the news\" and do not actually add or remove messages from the mail recipient $news.",
            "",
            "The procedure for adding a news article is",
            "",
            "  Send a mail message to %[$mail_agent:name($news)]",
            "  @addnews last to %[$news]",
            "    This marks the message as belonging to the current newspaper.",
            "    This also announces to any player who have not yet read this message ",
            "    that there is a new version of the newspaper.",
            "",
            "The preferred method for updating a news items is to send a new version of the item, @rmnews the old version and @addnews the new one.",
            "",
            "The following ordinary mail commands behave differently",
            "  @rmm   removes any reference to message from .current_news ",
            "         in addition to removing the message itself from .messages",
            "  @unrmm completely undoes the effect of the previous @rmm; ",
            "         this includes restoring .current_news.",
            "",
            "By default, the newspaper is moderated, however there is the possibility of unmoderating it (see `help MR-access'), letting arbitrary players send mail to it; administrators could then @addnews those items deemed worthy."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "object-matching"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The mail messages stored in mail recipients may be removed automatically by a weekly expiration task. New core owners who wish to turn this feature on and cut down on the db space used by mail recipients (Remember, players are mail recipients too) should start this task:",
            "",
            "    $wiz_utils:expire_mail_weekly",
            "",
            "When this task runs, it searches through all mail recipients and checks their .expire_period property. This property contains a time, in seconds, that messages should expire after. If this property is set to 0, then no expiration will take place from that recipient. The task, then, will compile a list of messages that are older than the expire period (e.g., if the property is set to 30 days, messages older than 30 days from the current date will expire). The default expiration period for mail recipients is 30 days.",
            "",
            "Normally, when the mail messages are expired from the recipient they are deleted. However, the owner of the recipient may elect to have the messages mailed to an email address prior to their erasure. There are two methods for doing this, one for players and one for children of $mail_recipient.",
            "",
            "Players:",
            "",
            "  Players may completely turn off mail expiration by setting the mail option `expire' off. If it is on, then $mail_agent.player_expire_time is the expire period used for mail on players. ",
            "  If a player has a registered email address, he may simply turn the mail option `no_auto_forward' off in order to have the expired messages sent to his email address before they are deleted. (The reversed logic saves on db space). See `help mail-options' and `help @registerme'.",
            "",
            "Mail Recipients:",
            "",
            "  The command to set the expiration period of a mail recipient is:",
            "",
            "    @set_expire <recipient> to <time>",
            "",
            "The <time> specified can be in english format (30 days, 60 days, etc.). If left off (the owner types `@set_expire <recipient> to'), the command will print out the current expiration information for that recipient. A list owner may set the expiration period up to a maximum of 180 days.",
            "",
            "  Similar to players, the owner of a mail recipient may have the mail sent to either his registered email address or to any other address he specifies before it expires. To prevent unsolicited email from going to a random address, confirmation must be made before the owner may set the address to something other than his registered address.",
            "",
            "  The command is:",
            "",
            "    @register <recipient> to <address>",
            "",
            "If the owner leaves off the <address>, the current registered address (if any) and expiration period will be returned. Again, if the address specified is the player's registered address, nothing more need be done. If it is not, then an email message will be sent to that address containing a password. Presumably, the owner can retrieve that password and then log back into the MOO and type:",
            "",
            "   @validate <recipient> with <password>",
            "",
            "which will enable the mail forwarding before expiration."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "MR-expiration"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Generic Large Capacity Mail Recipient",
            "-------------------------------------",
            "Since any modifications to large lists entail copying the entire list over, operations on ordinary mail recipients having large numbers of messages, that actually change the content of .messages will take inordinately long.  Thus we have this version which makes use of the $biglist package, scattering the messages onto numerous properties so that write operations involving only a few messages will not require recopying of the entire list.",
            "",
            "In nearly all respects it behaves as the ordinary Mail Recipient, except that it is faster for certain kinds of operations.",
            "",
            "Certain unimplemented verbs, like :date_sort(), and :messages() currently return E_VERBNF.",
            "",
            "To convert an existing $mail_recipient-child (call it #MR) into a $big_mail_recipient-child the basic procedure is",
            "",
            "    ;;something.foo= #MR:messages();",
            "    @rmm 1-$ from #MR",
            "    @unrmm expunge",
            "    @chparent #MR to $big_mail_recipient",
            "    ;#MR:receive_batch(@something.foo);",
            "",
            "Reconstructing Damaged Big Mail Recipients",
            "------------------------------------------",
            "On rare occasions, the tree structure created by $biglist can be corrupted (this can happen on lists sufficiently large that a list-modification operation (e.g., @rmm, @renumber) runs out of ticks/seconds).  In the vast majority of such cases, your messages are all still there; it's simply that the tree we use for finding/searching them is messed up.",
            "",
            "To recover messages from a damaged big mail recipient (#DBMR)",
            " --- read to the end before you start typing any commands ---",
            "",
            "create a fresh $big_mail_recipient (#NEWBMR) and then do the following:",
            "",
            "   ;#NEWBMR:restore_from(#DBMR)",
            "",
            "When this finishes, #NEWBMR will contain all of the mail messages we were able to find.  (note that this will include messages that you had deleted from #DBMR but not expunged).  #NEWMBR should thenceforth be useable in place of #DBMR, however if #DBMR contains custom verbs and non-clear properties, these will also need to be copied over.",
            "",
            "Alternatively, one may do",
            "",
            "   @copyobject #DBMR to #TEMPBMR",
            "   ;#DBMR:restore_from(#TEMPBMR)",
            "",
            "to rebuild #DBMR in place.  This, however, will take about twice as long.",
            "",
            "oooooooooooooooooooooooooooooooo",
            "WARNING!!! WARNING!!! WARNING!!!",
            "oooooooooooooooooooooooooooooooo",
            "",
            "Calling #OBJ:restore_from(...) COMPLETELY AND IRREVOCABLY REMOVES ALL MESSAGES from the object that it is run on (#OBJ); you MUST be sure to EITHER have made a copy of #OBJ OR be doing the restore to a DIFFERENT object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "OBJECT:init_for_core([CORE_VARIANT_SPEC])",
            "",
            "This verb is called in the final stage of core extraction (see $wiz:make-core-database), which occurs after all non-core objects have been recycled, the remaining ones have been renumbered and moved to #-1.  This verbcall then performs any final cleanups to establish the initial state of the object and is (pretty much) the last thing to happen to the object before the new core database is saved.",
            "",
            "What exactly goes in an :init_for_core verb varies hugely.  Some considerations:",
            "",
            "(1)  The :init_for_core verbs are invoked from the top down, i.e., a given object's :init_for_core call verb precedes that of any of its children.  Thus, when a given object's init_for_core() runs, you can safely assume that its entire ancestor chain has already been initialized in this way, and likewise that NONE of the descendants have been initialized yet.",
            "",
            "(2)  For non-ancestral objects, all bets are off --- with a few exceptions, you should not assume that they will be in working order, i.e., only invoke verbs that you know aren't being changed, and don't mess with their properties.   Or if you must, make sure whatever you do works in BOTH the case where the other object's init_for_core has already run AND the case where it has not.",
            "",
            "(3)  The object's own properties, where they contain references to other objects, will be GARBAGE; renumber() does not update object values within properties or lists.  That's your job (i.e., you qua author of :init_for_core).",
            "",
            "(4)  The root object's :init_for_core will copy code from any verb whose name ends in \"(core)\" to the corresponding verbname obtained by dropping that suffix.  So, for example, if you find yourself writing 'set_verb_code(this, \"verbname\", {...})', you should instead create a (non-executable) \"verbname(core)\" verb, so as to have the verbcode in a place where you can edit it in a more readable form.  This means...",
            "",
            "  (4a)  For non-root objects, it is very important that pass(@args) be called.",
            "        And yes the @args need to be there, too, since while the ",
            "        CORE_VARIANT_SPEC argument is currently unspecified and ignored",
            "        by all existing init_for_core verbs, it is intended to mean",
            "        mean something someday.",
            "",
            "  (4b)  A given object's init_for_core will be applied to every descendant.",
            "        Bracket the parts that only apply to the object itself with ",
            "",
            "\t   if ($code_utils:verb_location() == this)",
            "\t     ... ",
            "\t   endif",
            "",
            "(5) Oddly enough, init_for_core verbs by default become part of the core database.  You can arrange for them to remove themselves, but in the cases where they're performing generic sorts of initializations that are likely to be applicable to other MOOs, it's best to leave them in place.  This is for the sake of other MOO admins who may, after some amount of their own development, want to (re)extract their own cores.  While they will most likely be modifying the various init_for_core verbs as needed, if they do NOT make such modifications then (ideally) a core extraction should produce the same core they started with.",
            "",
            "Thus,",
            "",
            "   (5a) init_for_core should be IDEMPOTENT; i.e., running it a second time on the",
            "        same object should achieve the same result.  So, e.g., rather than",
            "",
            "          player.current_message = {@player.current_message, {this, 0, 0}};",
            "",
            "        which will create a duplicate entry the second time around, do",
            "",
            "          player:set_current_message(this, 0, 0, 1);",
            "",
            "   (5b) init_for_core should not depend on any non-core verbs/properties.  ",
            "        In particular, if your init_for_core deletes a LambdaMOO-specific ",
            "        verb/property and you don't arrange to delete the init_for_core as well,",
            "        then you should bracket that call (e.g., with `... ! E_PROPNF,E_VERBNF')",
            "        so that it will work elsewhere even after said verb/property is long gone.",
            "",
            "   (5c) if your init_for_core has a large amount of LambdaMOO-specific material, ",
            "        consider splitting the verb into ",
            "",
            "        (*) an :init_for_core that eliminates the LambdaMOO-specific material,",
            "            and ",
            "",
            "        (*) an :init_for_core(core) that accomplishes the generic initialization",
            "            (and will be copied into place by $root_object:init_for_core so that",
            "            ONLY the generic stuff escapes to the outside world.).  ",
            "",
            "        You can arrange for BOTH verbs to be called as follows:",
            "",
            "\t#foo:init_for_core",
            "\tif (caller_perms().wizard)",
            "\t  pass(@args);  // copies :init_for_core(core) to this",
            "",
            "\t  if ($code_utils:verb_location() == this)",
            "\t     // wipe LambdaMOO-specific properties/verbs from this object",
            "\t     ...",
            "\t     // call init_for_core(core) code",
            "\t     this:init_for_core()",
            "\t  endif",
            "\tendif",
            "",
            "        though again, this depends on the various parent verbs being idempotent",
            "        since in this case they will be invoked twice."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "$core_objects"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "$core_objects"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "    $core_objects           ([CORE_VARIANT_SPEC])         => object list",
            "    OBJECT:proxy_for_core   ([CORE_VARIANT_SPEC, IN_MCD]) => object",
            "    OBJECT:include_for_core ([CORE_VARIANT_SPEC])         => property list",
            "",
            "$core_objects() returns a list of those objects currently considered to be part of the core database.  ",
            "See help 'make-core-database' for a description of the overall core database extraction process.",
            "",
            "The list of core objects is determined by a traversal of properties starting with #0.sysobj (normally == #0).",
            "",
            "If a given property being traversed is not object-valued or the object id is invalid we are done with that property.",
            "",
            "Otherwise the property's value is a valid object and we call its 'proxy_for_core' verb, if one exists.  Any such verb is expected to return an object id which will then be used to update this property and any others encountered in the traversal that likewise were pointing to the same object.  If the verb does not exist we use the original property value (i.e., exactly as if the verbcode had been \"return this;\").",
            "",
            "If the object thus obtained is valid, we add it to the list of core objects.",
            "",
            "For each object added, we call its 'include_for_core' verb if one exists.  Any such verb is expected to return a list of properties on that object, which are then recursively traversed as above.  If the verb does not exist, no additional properties are traversed (i.e., exactly as if the verb had returned an empty list).",
            "",
            "The traversal ends when there are no further properties to visit.",
            "",
            "The CORE_VARIANT_SPEC argument is reserved for future use.  For now, the value provided to $core_objects() is passed straight through to the various hook verbs (proxy/include) and otherwise ignored.",
            "",
            "Note that the verb '$core_objects()' can be called at any time to see the full list of objects to be included in the core as per the above algorithm.",
            "",
            "Note that proxy_for_core is only called once for any given object during the traversal.  The IN_MCD parameter will be true for calls coming from within an actual run of make-core-database and false in all other invocations of $core_objects().  Thus, provided IN_MCD is true, it is safe for proxy_for_core to create an object to return."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  make-core-database",
            "",
            "!!! NOTE:",
            "!!! ",
            "!!! This is, by design, an extraordinarily destructive command, ",
            "!!! one NOT INTENDED to be run in the live instance of your MOO.",
            "!!! ",
            "!!! While there are various safeguards to keep it from being run in",
            "!!! situations where it looks like this might be the live instance of",
            "!!! the MOO (e.g., >1 player connected), there are limits on how",
            "!!! idiot-proof we can be.",
            "!!!",
            "!!! You have been warned.",
            "",
            "The correct use of this command is in a separate process.  ",
            "That is, once you have identified a database/checkpoint file from which you wish to extract a core, you",
            "",
            "(*) Run a LOCAL moo process reading from that database file,",
            "    ",
            "(*) Connect as $owner (usually $owner == #2).",
            "",
            "(*) Invoke ($wiz:)make-core-database",
            "",
            "Here \"LOCAL\" means you have open_network_connection() disabled (so that, e.g., spurious registration email doesn't go out) and you either run the moo on a port that is not accessible from the outside world or use one of the single-user/local configurations of the server (e.g., NETWORK_PROTOCOL = NP_SINGLE or -a 127.0.0.1 on the command line) so that no one else can connect while you're destroying the world (and perhaps mess with what eventually gets saved).",
            "",
            "Once you type 'make-core-database', the actual extraction process then goes as follows:",
            "",
            "(1) A particular set of objects, the \"core objects\" as determined by,",
            "    oddly enough, $core_objects(), is identified.  ",
            "    ",
            "    See 'help $core_objects' for details on the algorithm used.",
            "    ",
            "(2) Any core object and any property/verb thereon that has a non-core owner",
            "    is chowned either to the (assumed wizardly) player or $hacker ",
            "    according as the item in question is wizard-owned.",
            "",
            "(3) All non-core objects are mercilessly recycled.",
            "",
            "(4) Core objects are renumbered and max_object is reset,",
            "    so as to produce a contiguous array [#0..max_object()] of objects.",
            "",
            "(5) All objects are moved to #-1.",
            "",
            "(6) OBJECT:init_for_core is called on all objects having such verbs.",
            "    The sequence of calls is unspecified except in that an object ",
            "    is initialized prior to any of its children.",
            "    ",
            "    See 'help init_for_core' for more on what these verbs should look like.",
            "",
            "(7) The byte-quota statistics are redone",
            "",
            "(8) The moo is shut down and the database is saved."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "core-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Core Utility Help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Help database for LambdaCore utility objects and generics.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            121534,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "20": {
      "id": 20,
      "name": "string utilities",
      "flags": 24,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "space(noansi)",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.\";",
            "{n, ?fill = \" \"} = args;",
            "if (typeof(n) == STR)",
            "n = length(n);",
            "endif",
            "if (n > 1000)",
            "\"Prevent someone from crashing the moo with $string_utils:space($maxint)\";",
            "return E_INVARG;",
            "endif",
            "if (\" \" != fill)",
            "fill = fill + fill;",
            "fill = fill + fill;",
            "fill = fill + fill;",
            "elseif ((n = abs(n)) < 70)",
            "return \"                                                                      \"[1..n];",
            "else",
            "fill = \"                                                                      \";",
            "endif",
            "m = (n - 1) / length(fill);",
            "while (m)",
            "fill = fill + fill;",
            "m = m / 2;",
            "endwhile",
            "return (n > 0) ? fill[1..n] | fill[($ + 1) + n..$];"
          ]
        },
        {
          "name": "left(noansi)",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:left(string,width[,filler])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";",
            "\"\";",
            "\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";",
            "{text, len, ?fill = \" \"} = args;",
            "abslen = abs(len);",
            "out = tostr(text);",
            "if (length(out) < abslen)",
            "return out + this:space(length(out) - abslen, fill);",
            "else",
            "return (len > 0) ? out | out[1..abslen];",
            "endif"
          ]
        },
        {
          "name": "right(noansi)",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:right(string,width[,filler])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width> from the right.\";",
            "\"\";",
            "\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";",
            "{text, len, ?fill = \" \"} = args;",
            "abslen = abs(len);",
            "out = tostr(text);",
            "if ((lenout = length(out)) < abslen)",
            "return this:space(abslen - lenout, fill) + out;",
            "else",
            "return (len > 0) ? out | out[($ - abslen) + 1..$];",
            "endif"
          ]
        },
        {
          "name": "centre center",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:center(string,width[,lfiller[,rfiller]])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";",
            "\"\";",
            "\"The <lfiller> is optional and defaults to \\\" \\\"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.\";",
            "{text, len, ?lfill = \" \", ?rfill = lfill} = args;",
            "out = tostr(text);",
            "abslen = abs(len);",
            "if (length(out) < abslen)",
            "return (this:space((abslen - length(out)) / 2, lfill) + out) + this:space(((abslen - length(out)) + 1) / -2, rfill);",
            "else",
            "return (len > 0) ? out | out[1..abslen];",
            "endif"
          ]
        },
        {
          "name": "columnize columnise",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.\";",
            "{items, n, ?width = 79} = args;",
            "height = ((length(items) + n) - 1) / n;",
            "items = {@items, @$list_utils:make((height * n) - length(items), \"\")};",
            "colwidths = {};",
            "for col in [1..n - 1]",
            "colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));",
            "endfor",
            "result = {};",
            "for row in [1..height]",
            "line = tostr(items[row]);",
            "for col in [1..n - 1]",
            "line = tostr(this:left(line, colwidths[col]), \" \", items[row + (col * height)]);",
            "endfor",
            "result = listappend(result, line[1..min($, width)]);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "from_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:from_list(list [, separator])\";",
            "\"Return a string being the concatenation of the string representations of the elements of LIST, each pair separated by the string SEPARATOR, which defaults to the empty string.\";",
            "{thelist, ?separator = \"\"} = args;",
            "if (separator == \"\")",
            "return tostr(@thelist);",
            "elseif (thelist)",
            "result = tostr(thelist[1]);",
            "for elt in (listdelete(thelist, 1))",
            "result = tostr(result, separator, elt);",
            "endfor",
            "return result;",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "english_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Prints the argument (must be a list) as an english list, e.g. {1, 2, 3} is printed as \\\"1, 2, and 3\\\", and {1, 2} is printed as \\\"1 and 2\\\".\";",
            "\"Optional arguments are treated as follows:\";",
            "\"  Second argument is the string to use when the empty list is given.  The default is \\\"nothing\\\".\";",
            "\"  Third argument is the string to use in place of \\\" and \\\".  A typical application might be to use \\\" or \\\" instead.\";",
            "\"  Fourth argument is the string to use instead of a comma (and space).  Gary_Severn's deranged mind actually came up with an application for this.  You can ask him.\";",
            "\"  Fifth argument is a string to use after the penultimate element before the \\\" and \\\".  The default is to have a comma without a space.\";",
            "{things, ?nothingstr = \"nothing\", ?andstr = \" and \", ?commastr = \", \", ?finalcommastr = \",\"} = args;",
            "nthings = length(things);",
            "if (nthings == 0)",
            "return nothingstr;",
            "elseif (nthings == 1)",
            "return tostr(things[1]);",
            "elseif (nthings == 2)",
            "return tostr(things[1], andstr, things[2]);",
            "else",
            "ret = \"\";",
            "for k in [1..nthings - 1]",
            "if (k == (nthings - 1))",
            "commastr = finalcommastr;",
            "endif",
            "ret = tostr(ret, things[k], commastr);",
            "endfor",
            "return tostr(ret, andstr, things[nthings]);",
            "endif"
          ]
        },
        {
          "name": "names_of",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Return a string of the names and object numbers of the objects in a list.\";",
            "line = \"\";",
            "for item in (args[1])",
            "if ((typeof(item) == OBJ) && valid(item))",
            "line = (((line + item.name) + \"(\") + tostr(item)) + \")   \";",
            "endif",
            "endfor",
            "return $string_utils:trimr(line);"
          ]
        },
        {
          "name": "from_seconds",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":from_seconds(number of seconds) => returns a string containing the rough increment of days, or hours if less than a day, or minutes if less than an hour, or lastly in seconds.\";",
            "\":from_seconds(86400) => \\\"a day\\\"\";",
            "\":from_seconds(7200)  => \\\"two hours\\\"\";",
            "minute = 60;",
            "hour = 60 * minute;",
            "day = 24 * hour;",
            "secs = args[1];",
            "if (secs > day)",
            "count = secs / day;",
            "unit = \"day\";",
            "article = \"a\";",
            "elseif (secs > hour)",
            "count = secs / hour;",
            "unit = \"hour\";",
            "article = \"an\";",
            "elseif (secs > minute)",
            "count = secs / minute;",
            "unit = \"minute\";",
            "article = \"a\";",
            "else",
            "count = secs;",
            "unit = \"second\";",
            "article = \"a\";",
            "endif",
            "if (count == 1)",
            "time = tostr(article, \" \", unit);",
            "else",
            "time = tostr(count, \" \", unit, \"s\");",
            "endif",
            "return time;"
          ]
        },
        {
          "name": "trim",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":trim (string [, space]) -- remove leading and trailing spaces\";",
            "\"\";",
            "\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all leading and trailing copies of that character removed.  For example, $string_utils:trim(\\\"***foo***\\\", \\\"*\\\") => \\\"foo\\\".\";",
            "{string, ?space = \" \"} = args;",
            "m = match(string, tostr(\"[^\", space, \"]%(.*[^\", space, \"]%)?%|$\"));",
            "return string[m[1]..m[2]];"
          ]
        },
        {
          "name": "triml",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":triml(string [, space]) -- remove leading spaces\";",
            "\"\";",
            "\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all leading copies of that character removed.  For example, $string_utils:triml(\\\"***foo***\\\", \\\"*\\\") => \\\"foo***\\\".\";",
            "{string, ?what = \" \"} = args;",
            "m = match(string, tostr(\"[^\", what, \"]%|$\"));",
            "return string[m[1]..$];"
          ]
        },
        {
          "name": "trimr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":trimr(string [, space]) -- remove trailing spaces\";",
            "\"\";",
            "\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all trailing copies of that character removed.  For example, $string_utils:trimr(\\\"***foo***\\\", \\\"*\\\") => \\\"***foo\\\".\";",
            "{string, ?what = \" \"} = args;",
            "return string[1..rmatch(string, tostr(\"[^\", what, \"]%|^\"))[2]];"
          ]
        },
        {
          "name": "strip_chars",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":strip_chars(string,chars) => string with chars removed\";",
            "{subject, stripped} = args;",
            "for i in [1..length(stripped)]",
            "subject = strsub(subject, stripped[i], \"\");",
            "endfor",
            "return subject;"
          ]
        },
        {
          "name": "strip_all_but",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":strip_all_but(string,keep) => string with chars not in `keep' removed.\";",
            "\"`keep' is used in match() so if it includes ], ^, or -,\";",
            "\"] should be first, ^ should be other from first, and - should be last.\";",
            "string = args[1];",
            "wanted = (\"[\" + args[2]) + \"]+\";",
            "output = \"\";",
            "while (m = match(string, wanted))",
            "output = output + string[m[1]..m[2]];",
            "string = string[m[2] + 1..$];",
            "endwhile",
            "return output;"
          ]
        },
        {
          "name": "uppercase lowercase",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"lowercase(string) -- returns a lowercase version of the string.\";",
            "\"uppercase(string) -- returns the uppercase version of the string.\";",
            "string = args[1];",
            "from = caps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";",
            "to = lower = \"abcdefghijklmnopqrstuvwxyz\";",
            "if (verb == \"uppercase\")",
            "from = lower;",
            "to = caps;",
            "endif",
            "for i in [1..26]",
            "string = strsub(string, from[i], to[i], 1);",
            "endfor",
            "return string;"
          ]
        },
        {
          "name": "capitalize capitalise",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"capitalizes its argument.\";",
            "if ((string = args[1]) && (i = index(\"abcdefghijklmnopqrstuvwxyz\", string[1], 1)))",
            "string[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[i];",
            "endif",
            "return string;"
          ]
        },
        {
          "name": "literal_object",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Matches args[1] against literal objects: #xxxxx, $variables, *mailing-lists, and username.  Returns the object if successful, $failed_match else.\";",
            "string = args[1];",
            "if (!string)",
            "return $nothing;",
            "elseif ((string[1] == \"#\") && (E_TYPE != (object = $code_utils:toobj(string))))",
            "return object;",
            "elseif (string[1] == \"~\")",
            "return this:match_player(string[2..$], #0);",
            "elseif ((string[1] == \"*\") && (length(string) > 1))",
            "return $mail_agent:match_recipient(string);",
            "elseif (string[1] == \"$\")",
            "string[1..1] = \"\";",
            "object = #0;",
            "while (pn = string[1..(dot = index(string, \".\")) ? dot - 1 | $])",
            "if ((!$object_utils:has_property(object, pn)) || (typeof(object = object.(pn)) != OBJ))",
            "\"Try to match a map now.\";",
            "object = $code_utils:parse_sysobj_map(args[1]);",
            "if (object == E_PROPNF)",
            "return $failed_match;",
            "else",
            "break;",
            "endif",
            "endif",
            "string = string[length(pn) + 2..$];",
            "endwhile",
            "if ((object == #0) || (typeof(object) == ERR))",
            "return $failed_match;",
            "else",
            "return object;",
            "endif",
            "else",
            "return $failed_match;",
            "endif"
          ]
        },
        {
          "name": "match",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:match(string [, obj-list, prop-name]*)\";",
            "\"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.\";",
            "\"The argument string is matched against all of the strings in the property values.\";",
            "\"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.\";",
            "\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.\";",
            "\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";",
            "subject = args[1];",
            "if (subject == \"\")",
            "return $nothing;",
            "endif",
            "no_exact_match = no_partial_match = 1;",
            "for i in [1..length(args) / 2]",
            "prop_name = args[(2 * i) + 1];",
            "for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})",
            "if (valid(object))",
            "if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)",
            "str_list = {str_list};",
            "endif",
            "if (subject in str_list)",
            "if (no_exact_match)",
            "no_exact_match = object;",
            "elseif (no_exact_match != object)",
            "return $ambiguous_match;",
            "endif",
            "else",
            "for string in (str_list)",
            "if (index(string, subject) != 1)",
            "elseif (no_partial_match)",
            "no_partial_match = object;",
            "elseif (no_partial_match != object)",
            "no_partial_match = $ambiguous_match;",
            "endif",
            "endfor",
            "endif",
            "endif",
            "endfor",
            "endfor",
            "return no_exact_match && (no_partial_match && $failed_match);"
          ]
        },
        {
          "name": "match_str*ing",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"* wildcard matching. Returns a list of what the *s actually matched. Won't cath every match, if there are several ways to parse it.\";",
            "\"Example: $string_utils:match_string(\\\"Jack waves to Jill\\\",\\\"* waves to *\\\") returns {\\\"Jack\\\", \\\"Jill\\\"}\";",
            "\"Optional arguments: numbers are interpreted as case-sensitivity, strings as alternative wildcards.\";",
            "{what, targ, @rest} = args;",
            "wild = \"*\";",
            "case = ret = {};",
            "what = what + \"&^%$\";",
            "targ = targ + \"&^%$\";",
            "for y in (rest)",
            "if (typeof(y) == STR)",
            "wild = y;",
            "elseif (typeof(y) == INT)",
            "case = {y};",
            "endif",
            "endfor",
            "while (targ != \"\")",
            "if (z = index(targ, wild))",
            "part = targ[1..z - 1];",
            "else",
            "z = length(targ);",
            "part = targ;",
            "endif",
            "n = (part == \"\") ? 1 | index(what, part, @case);",
            "if (n)",
            "ret = listappend(ret, what[1..n - 1]);",
            "what = what[(z + n) - 1..$];",
            "targ = targ[z + 1..$];",
            "else",
            "return 0;",
            "endif",
            "endwhile",
            "if (ret == {})",
            "return what == \"\";",
            "elseif (ret == {\"\"})",
            "return 1;",
            "elseif (ret[1] == \"\")",
            "return ret[2..$];",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "match_object",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":match_object(string,location[,someone])\";",
            "\"Returns the object matching the given string for someone, on the assumption that s/he is in the given location.  `someone' defaults to player.\";",
            "\"This first tries :literal_object(string), \\\"me\\\"=>someone,\\\"here\\\"=>location, then player:match(string) and finally location:match(string) if location is valid.\";",
            "\"This is the default algorithm for use by room :match_object() and player :my_match_object() verbs.  Player verbs that are calling this directly should probably be calling :my_match_object instead.\";",
            "{string, here, ?who = player} = args;",
            "if ($failed_match != (object = this:literal_object(string)))",
            "return object;",
            "elseif (string == \"me\")",
            "return who;",
            "elseif (string == \"here\")",
            "return here;",
            "elseif ((valid(pobject = who:match(string)) && (string in {@pobject.aliases, pobject.name})) || (!valid(here)))",
            "\"...exact match in player or room is bogus...\";",
            "return pobject;",
            "elseif ((valid(hobject = here:match(string)) && (string in {@hobject.aliases, hobject.name})) || (pobject == $failed_match))",
            "\"...exact match in room or match in player failed completely...\";",
            "return hobject;",
            "else",
            "return pobject;",
            "endif"
          ]
        },
        {
          "name": "match_player",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"match_player(name,name,...)      => {obj,obj,...}\";",
            "\"match_player(name[,meobj])       => obj\";",
            "\"match_player({name,...}[,meobj]) => {obj,...}\";",
            "\"objs returned are either players, $failed_match, $ambiguous_match, or $nothing in the case of an empty string.\";",
            "\"meobj (what to return for instances of `me') defaults to player; if given and isn't actually a player, `me' => $failed_match\";",
            "retstr = 0;",
            "me = player;",
            "if ((length(args) < 2) || (typeof(me = args[2]) == OBJ))",
            "me = (valid(me) && is_player(me)) ? me | $failed_match;",
            "if (typeof(args[1]) == STR)",
            "strings = {args[1]};",
            "retstr = 1;",
            "\"return a string, not a list\";",
            "else",
            "strings = args[1];",
            "endif",
            "else",
            "strings = args;",
            "me = player;",
            "endif",
            "found = {};",
            "for astr in (strings)",
            "if (!astr)",
            "aobj = $nothing;",
            "elseif (astr == \"me\")",
            "aobj = me;",
            "elseif (valid(aobj = $string_utils:literal_object(astr)) && is_player(aobj))",
            "\"astr is a valid literal object number of some player, so we are done.\";",
            "else",
            "aobj = $player_db:find(astr);",
            "endif",
            "found = {@found, aobj};",
            "endfor",
            "return retstr ? found[1] | found;"
          ]
        },
        {
          "name": "match_player_or_object",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Accepts any number of strings, attempts to match those strings first against objects in the room, and if no objects by those names exist, matches against player names (and \\\"#xxxx\\\" style strings regardless of location).  Returns a list of valid objects so found.\";",
            "\"Unlike $string_utils:match_player, does not include in the list the failed and ambiguous matches; instead has built-in error messages for such objects.  This should probably be improved.  Volunteers?\";",
            "if (!args)",
            "return;",
            "endif",
            "unknowns = {};",
            "objs = {};",
            "\"We have to do something icky here.  Parallel walk the victims and args lists.  When it's a valid object, then it's a player.  If it's an invalid object, try to get an object match from the room.  If *that* fails, complain.\";",
            "for i in [1..length(args)]",
            "if (valid(o = player.location:match_object(args[i])))",
            "objs = {@objs, o};",
            "else",
            "unknowns = {@unknowns, args[i]};",
            "endif",
            "endfor",
            "victims = $string_utils:match_player(unknowns);",
            "for i in [1..length(victims)]",
            "if (!valid(victims[i]))",
            "player:tell(\"Could not find \", unknowns[i], \" as either an object or a player.\");",
            "else",
            "objs = {@objs, victims[i]};",
            "endif",
            "endfor",
            "return objs;"
          ]
        },
        {
          "name": "find_prefix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"find_prefix(prefix, string-list) => list index of something starting with prefix, or 0 or $ambiguous_match.\";",
            "{subject, choices} = args;",
            "answer = 0;",
            "for i in [1..length(choices)]",
            "if (index(choices[i], subject) == 1)",
            "if (answer == 0)",
            "answer = i;",
            "else",
            "answer = $ambiguous_match;",
            "endif",
            "endif",
            "endfor",
            "return answer;"
          ]
        },
        {
          "name": "index_d*elimited",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"index_delimited(string,target[,case_matters]) is just like the corresponding call to the builtin index() but instead only matches on occurences of target delimited by word boundaries (i.e., not preceded or followed by an alphanumeric)\";",
            "args[2] = (\"%(%W%|^%)\" + $string_utils:regexp_quote(args[2])) + \"%(%W%|$%)\";",
            "return (m = match(@args)) ? m[3][1][2] + 1 | 0;"
          ]
        },
        {
          "name": "is_integer is_numeric",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Usage:  is_numeric(string)\";",
            "\"        is_integer(string)\";",
            "\"Is string numeric (composed of one or more digits possibly preceded by a minus sign)? This won't catch floating points.\";",
            "\"Return true or false\";",
            "return match(args[1], \"^ *[-+]?[0-9]+ *$\") ? 1 | 0;"
          ]
        },
        {
          "name": "ordinal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":short_ordinal(1) => \\\"1st\\\",:short_ordinal(2) => \\\"2nd\\\",etc...\";",
            "string = tostr(n = args[1]);",
            "n = abs(n) % 100;",
            "if (((n / 10) != 1) && ((n % 10) in {1, 2, 3}))",
            "return string + {\"st\", \"nd\", \"rd\"}[n % 10];",
            "else",
            "return string + \"th\";",
            "endif"
          ]
        },
        {
          "name": "group_number",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:group_number(INT n [, sep_char])\";",
            "\"$string_utils:group_number(FLOAT n, [INT precision [, scientific [, sep_char]]])\";",
            "\"\";",
            "\"Converts N to a string, inserting commas (or copies of SEP_CHAR, if given) every three digits, counting from the right.  For example, $string_utils:group_number(1234567890) returns the string \\\"1,234,567,890\\\".\";",
            "\"For floats, the arguements precision (defaulting to 4 in this verb) and scientific are the same as given in floatstr().\";",
            "if (typeof(args[1]) == INT)",
            "{n, ?comma = \",\"} = args;",
            "result = \"\";",
            "sign = (n < 0) ? \"-\" | \"\";",
            "n = tostr(abs(n));",
            "elseif (typeof(args[1]) == FLOAT)",
            "{n, ?prec = 4, ?scien = 0, ?comma = \",\"} = args;",
            "sign = (n < 0.0) ? \"-\" | \"\";",
            "n = floatstr(abs(n), prec, scien);",
            "i = index(n, \".\");",
            "result = n[i..$];",
            "n = n[1..i - 1];",
            "else",
            "return E_INVARG;",
            "endif",
            "while ((len = length(n)) > 3)",
            "result = (comma + n[len - 2..len]) + result;",
            "n = n[1..len - 3];",
            "endwhile",
            "return (sign + n) + result;",
            "\"Code contributed by SunRay\";"
          ]
        },
        {
          "name": "english_number",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:english_number(n) -- convert the integer N into English\";",
            "\"\";",
            "\"Produces a string containing the English phrase naming the given integer.  For example, $string_utils:english_number(-1234) returns the string `negative one thousand two hundred thirty-four'.\";",
            "numb = toint(args[1]);",
            "if (numb == 0)",
            "return \"zero\";",
            "endif",
            "labels = {\"\", \" thousand\", \" million\", \" billion\"};",
            "numstr = \"\";",
            "mod = abs(numb);",
            "for n in [1..4]",
            "div = mod % 1000;",
            "if (div)",
            "hun = div / 100;",
            "ten = div % 100;",
            "outstr = this:english_tens(ten) + labels[n];",
            "if (hun)",
            "outstr = ((this:english_ones(hun) + \" hundred\") + (ten ? \" \" | \"\")) + outstr;",
            "endif",
            "if (numstr)",
            "numstr = (outstr + \" \") + numstr;",
            "else",
            "numstr = outstr;",
            "endif",
            "endif",
            "mod = mod / 1000;",
            "endfor",
            "return ((numb < 0) ? \"negative \" | \"\") + numstr;"
          ]
        },
        {
          "name": "english_ordinal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:english_ordinal(n) -- convert the integer N into an english ordinal (1 => \\\"first\\\", etc...)\";",
            "numb = toint(args[1]);",
            "if (numb == 0)",
            "return \"zeroth\";",
            "elseif (numb % 100)",
            "hundreds = (abs(numb) > 100) ? this:english_number((numb / 100) * 100) + \" \" | ((numb < 0) ? \"negative \" | \"\");",
            "numb = abs(numb) % 100;",
            "specials = {1, 2, 3, 5, 8, 9, 12, 20, 30, 40, 50, 60, 70, 80, 90};",
            "ordinals = {\"first\", \"second\", \"third\", \"fifth\", \"eighth\", \"ninth\", \"twelfth\", \"twentieth\", \"thirtieth\", \"fortieth\", \"fiftieth\", \"sixtieth\", \"seventieth\", \"eightieth\", \"ninetieth\"};",
            "if (i = numb in specials)",
            "return hundreds + ordinals[i];",
            "elseif ((numb > 20) && (i = (numb % 10) in specials))",
            "return ((hundreds + this:english_tens((numb / 10) * 10)) + \"-\") + ordinals[i];",
            "else",
            "return (hundreds + this:english_number(numb)) + \"th\";",
            "endif",
            "else",
            "return this:english_number(numb) + \"th\";",
            "endif"
          ]
        },
        {
          "name": "english_ones",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "numb = args[1];",
            "ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};",
            "return ones[numb + 1];"
          ]
        },
        {
          "name": "english_tens",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "numb = args[1];",
            "teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};",
            "others = {\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};",
            "if (numb < 10)",
            "return this:english_ones(numb);",
            "elseif (numb < 20)",
            "return teens[numb - 9];",
            "else",
            "return (others[(numb / 10) - 1] + ((numb % 10) ? \"-\" | \"\")) + this:english_ones(numb % 10);",
            "endif"
          ]
        },
        {
          "name": "subst*itute",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])\";",
            "\"  => returns string with all instances of the strings redex<n> replaced respectively by the strings repl<n>.  If the optional argument `case' is given and nonzero, the search for instances of redex<n> is case sensitive.\";",
            "\"  Substitutions are done in parallel, i.e., instances of redex<n> that appear in any of the replacement strings are ignored.  In the event that two redexes overlap, whichever is leftmost in `string' takes precedence.  For two redexes beginning at the same position, the longer one takes precedence.\";",
            "\"\";",
            "\"subst(\\\"hoahooaho\\\",{{\\\"ho\\\",\\\"XhooX\\\"},{\\\"hoo\\\",\\\"mama\\\"}}) => \\\"XhooXamamaaXhooX\\\"\";",
            "\"subst(\\\"Cc: banana\\\",{{\\\"a\\\",\\\"b\\\"},{\\\"b\\\",\\\"c\\\"},{\\\"c\\\",\\\"a\\\"}},1) => \\\"Ca: cbnbnb\\\"\";",
            "{ostr, subs, ?case = 0} = args;",
            "if (typeof(ostr) != STR)",
            "return ostr;",
            "endif",
            "len = length(ostr);",
            "\" - - - find the first instance of each substitution - -\";",
            "indices = {};",
            "substs = {};",
            "for s in (subs)",
            "if (i = index(ostr, s[1], case))",
            "fi = $list_utils:find_insert(indices, i = i - len) - 1;",
            "while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))",
            "\"...give preference to longer redexes...\";",
            "fi = fi - 1;",
            "endwhile",
            "indices = listappend(indices, i, fi);",
            "substs = listappend(substs, s, fi);",
            "endif",
            "endfor",
            "\"- - - - - perform substitutions - \";",
            "nstr = \"\";",
            "while (substs)",
            "ind = len + indices[1];",
            "sub = substs[1];",
            "indices = listdelete(indices, 1);",
            "substs = listdelete(substs, 1);",
            "if (ind > 0)",
            "nstr = (nstr + ostr[1..ind - 1]) + sub[2];",
            "ostr = ostr[ind + length(sub[1])..len];",
            "len = length(ostr);",
            "endif",
            "if (next = index(ostr, sub[1], case))",
            "fi = $list_utils:find_insert(indices, next = next - len) - 1;",
            "while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))",
            "\"...give preference to longer redexes...\";",
            "fi = fi - 1;",
            "endwhile",
            "indices = listappend(indices, next, fi);",
            "substs = listappend(substs, sub, fi);",
            "endif",
            "endwhile",
            "return nstr + ostr;"
          ]
        },
        {
          "name": "substitute_d*elimited",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 20,
          "code": [
            "\"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])\";",
            "\"Just like :substitute() but it uses index_delimited() instead of index()\";",
            "{ostr, subs, ?case = 0} = args;",
            "if (typeof(ostr) != STR)",
            "return ostr;",
            "endif",
            "len = length(ostr);",
            "\" - - - find the first instance of each substitution - -\";",
            "indices = {};",
            "substs = {};",
            "for s in (subs)",
            "if (i = this:index_delimited(ostr, s[1], case))",
            "fi = $list_utils:find_insert(indices, i = i - len) - 1;",
            "while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))",
            "\"...give preference to longer redexes...\";",
            "fi = fi - 1;",
            "endwhile",
            "indices = listappend(indices, i, fi);",
            "substs = listappend(substs, s, fi);",
            "endif",
            "endfor",
            "\"- - - - - perform substitutions - \";",
            "nstr = \"\";",
            "while (substs)",
            "ind = len + indices[1];",
            "sub = substs[1];",
            "indices = listdelete(indices, 1);",
            "substs = listdelete(substs, 1);",
            "if (ind > 0)",
            "nstr = (nstr + ostr[1..ind - 1]) + sub[2];",
            "ostr = ostr[ind + length(sub[1])..len];",
            "len = length(ostr);",
            "endif",
            "if (next = this:index_delimited(ostr, sub[1], case))",
            "fi = $list_utils:find_insert(indices, next = next - len) - 1;",
            "while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))",
            "\"...give preference to longer redexes...\";",
            "fi = fi - 1;",
            "endwhile",
            "indices = listappend(indices, next, fi);",
            "substs = listappend(substs, sub, fi);",
            "endif",
            "endwhile",
            "return nstr + ostr;"
          ]
        },
        {
          "name": "_cap_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"cap_property(what,prop[,ucase]) returns what.(prop) but capitalized if either ucase is true or the prop name specified is capitalized.\";",
            "\"If prop is blank, returns what:title().\";",
            "\"If prop is bogus or otherwise irretrievable, returns the error.\";",
            "\"If capitalization is indicated, we return what.(prop+\\\"c\\\") if that exists, else we capitalize what.(prop) in the usual fashion.  There is a special exception for is_player(what)&&prop==\\\"name\\\" where we just return what.name if no .namec is provided --- ie., a player's .name is never capitalized in the usual fashion.\";",
            "\"If args[1] is a list, calls itself on each element of the list and returns $string_utils:english_list(those results).\";",
            "{what, prop, ?ucase = 0} = args;",
            "set_task_perms(caller_perms());",
            "if (typeof(what) == LIST)",
            "result = {};",
            "for who in (what)",
            "result = {@result, this:_cap_property(who, prop, ucase)};",
            "endfor",
            "return $string_utils:english_list(result);",
            "endif",
            "ucase = (prop && (strcmp(prop, \"a\") < 0)) || ucase;",
            "if (!prop)",
            "return valid(what) ? ucase ? what:titlec() | what:title() | ((ucase ? \"N\" | \"n\") + \"othing\");",
            "elseif ((!ucase) || (typeof(s = `what.(prop + \"c\") ! ANY') == ERR))",
            "if (prop == \"name\")",
            "s = valid(what) ? what.name | \"nothing\";",
            "ucase = ucase && (!is_player(what));",
            "else",
            "s = `$object_utils:has_property(what, prop) ? what.(prop) | $player.(prop) ! ANY';",
            "endif",
            "if (ucase && (s && ((typeof(s) == STR) && (((z = index(this.alphabet, s[1], 1)) < 27) && (z > 0)))))",
            "s[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[z];",
            "endif",
            "endif",
            "return (typeof(s) == ERR) ? s | tostr(s);"
          ]
        },
        {
          "name": "pronoun_sub",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Pronoun (and other things) substitution. See 'help pronouns' for details.\";",
            "\"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location[,dobj[,iobj]]]]])\";",
            "\"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.\";",
            "\"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, <thing>, location and %\";",
            "\"<thing> defaults to caller; <location> defaults to who.location\";",
            "\"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.\";",
            "\" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number\";",
            "\"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..\";",
            "\"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.\";",
            "\"%<d:foo> -> whatever <dobj> does when normal people foo.\";",
            "{string, ?who = player, ?thing = caller, ?where = $nothing, ?dobject = dobj, ?iobject = iobj} = args;",
            "where = valid(where) ? where | (valid(who) ? who.location | where);",
            "set_task_perms($no_one);",
            "if (typeof(string) == LIST)",
            "plines = {};",
            "for line in (string)",
            "plines = {@plines, this:(verb)(line, who, thing, where)};",
            "endfor",
            "return plines;",
            "endif",
            "old = tostr(string);",
            "new = \"\";",
            "objspec = \"nditl\";",
            "objects = {who, dobject, iobject, thing, where};",
            "prnspec = \"sopqrSOPQR\";",
            "prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};",
            "oldlen = length(old);",
            "while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))",
            "s = old[k = prcnt + 1];",
            "if ((s == \"<\") && (gt = index(old[k + 2..$], \">\")))",
            "\"handling %<verb> \";",
            "gt = (gt + k) + 1;",
            "vb = old[k + 1..gt - 1];",
            "vbs = who;",
            "if ((length(vb) > 2) && (vb[2] == \":\"))",
            "\" %<d:verb>\";",
            "vbs = objects[index(objspec, vb[1]) || 1];",
            "vb = vb[3..$];",
            "endif",
            "vb = $object_utils:has_callable_verb(vbs, \"verb_sub\") ? vbs:verb_sub(vb) | $gender_utils:get_conj(vb, vbs);",
            "new = (new + old[1..prcnt - 1]) + vb;",
            "k = gt;",
            "else",
            "cp_args = {};",
            "if (brace = index(\"([\", s))",
            "if (!(w = index(old[k + 1..oldlen], \")]\"[brace])))",
            "return new + old;",
            "else",
            "p = old[prcnt + 2..(k = k + w) - 1];",
            "if (brace == 1)",
            "\"%(property)\";",
            "cp_args = {who, p};",
            "elseif (p[1] == \"#\")",
            "\"%[#n] => object number\";",
            "s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");",
            "elseif (!(o = index(objspec, p[1])))",
            "s = (\"[\" + p) + \"]\";",
            "else",
            "\" %[dproperty] \";",
            "cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};",
            "endif",
            "endif",
            "elseif (o = index(objspec, s))",
            "cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};",
            "elseif (w = index(prnspec, s, 1))",
            "cp_args = {who, prprops[w]};",
            "elseif (s == \"#\")",
            "s = tostr(who);",
            "elseif (s != \"%\")",
            "s = \"%\" + s;",
            "endif",
            "new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));",
            "endif",
            "old = old[k + 1..oldlen];",
            "oldlen = oldlen - k;",
            "endwhile",
            "return new + old;"
          ]
        },
        {
          "name": "pronoun_sub_secure",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:pronoun_sub_secure(string[,who[,thing[,location]]], default)\";",
            "\"Do pronoun_sub on string with the arguments given (see help\";",
            "\"string_utils:pronoun_sub for more information).  Return pronoun_subbed\";",
            "\"<default> if the subbed string does not contain <who>.name (<who>\";",
            "\"defaults to player).\";",
            "who = (length(args) > 2) ? args[2] | player;",
            "default = args[$];",
            "result = this:pronoun_sub(@args[1..$ - 1]);",
            "return this:index_delimited(result, who.name) ? result | this:pronoun_sub(@{default, @args[2..$ - 1]});"
          ]
        },
        {
          "name": "pronoun_quote",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\" pronoun_quote(string) => quoted_string\";",
            "\" pronoun_quote(list of strings) => list of quoted_strings\";",
            "\" pronoun_quote(list of {key,string} pairs) => list of {key,quoted_string} pairs\";",
            "\"\";",
            "\"Here `quoted' means quoted in the sense of $string_utils:pronoun_sub, i.e., given a string X, the corresponding `quoted' string Y is such that pronoun_sub(Y) => X.  For example, pronoun_quote(\\\"--%Spam%--\\\") => \\\"--%%Spam%%--\\\".  This is for including literal text into a string that will eventually be pronoun_sub'ed, i.e., including it in such a way that the pronoun_sub will not expand anything in the included text.\";",
            "\"\";",
            "\"The 3rd form above (with {key,string} pairs) is for use with $string_utils:substitute().  If you have your own set of substitutions to be done in parallel with the pronoun substitutions, do\";",
            "\"\";",
            "\"  msg=$string_utils:substitute(msg,$string_utils:pronoun_quote(your_substs));\";",
            "\"  msg=$string_utils:pronoun_sub(msg);\";",
            "if (typeof(what = args[1]) == STR)",
            "return strsub(what, \"%\", \"%%\");",
            "else",
            "ret = {};",
            "for w in (what)",
            "if (typeof(w) == LIST)",
            "ret = listappend(ret, listset(w, strsub(w[2], \"%\", \"%%\"), 2));",
            "else",
            "ret = listappend(ret, strsub(w, \"%\", \"%%\"));",
            "endif",
            "endfor",
            "return ret;",
            "endif"
          ]
        },
        {
          "name": "alt_pronoun_sub",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Pronoun (and other things) substitution. See 'help pronouns' for details.\";",
            "\"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location]]])\";",
            "\"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.\";",
            "\"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, this, <who>.location and %\";",
            "\"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.\";",
            "\" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number\";",
            "\"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..\";",
            "\"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.\";",
            "\"%<d:foo> -> whatever <dobj> does when normal people foo.\";",
            "set_task_perms($no_one);",
            "{string, ?who = player, ?thing = caller, ?where = $nothing} = args;",
            "where = valid(who) ? who.location | where;",
            "if (typeof(string) == LIST)",
            "plines = {};",
            "for line in (string)",
            "plines = {@plines, this:(verb)(line, who, thing, where)};",
            "endfor",
            "return plines;",
            "endif",
            "old = tostr(string);",
            "new = \"\";",
            "objspec = \"nditl\";",
            "objects = {who, dobj, iobj, thing, where};",
            "prnspec = \"sopqrSOPQR\";",
            "prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};",
            "oldlen = length(old);",
            "while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))",
            "s = old[k = prcnt + 1];",
            "if ((s == \"<\") && (gt = index(old[k + 2..$], \">\")))",
            "\"handling %<verb> \";",
            "gt = (gt + k) + 1;",
            "vb = old[k + 1..gt - 1];",
            "vbs = who;",
            "if ((length(vb) > 2) && (vb[2] == \":\"))",
            "\" %<d:verb>\";",
            "vbs = objects[index(objspec, vb[1]) || 1];",
            "vb = vb[3..$];",
            "endif",
            "vb = $object_utils:has_verb(vbs, \"verb_sub\") ? vbs:verb_sub(vb) | this:(verb)(vb, vbs);",
            "new = (new + old[1..prcnt - 1]) + vb;",
            "k = gt;",
            "else",
            "cp_args = {};",
            "if (brace = index(\"([\", s))",
            "if (!(w = index(old[k + 1..oldlen], \")]\"[brace])))",
            "return new + old;",
            "else",
            "p = old[prcnt + 2..(k = k + w) - 1];",
            "if (brace == 1)",
            "\"%(property)\";",
            "cp_args = {who, p};",
            "elseif (p[1] == \"#\")",
            "\"%[#n] => object number\";",
            "s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");",
            "elseif (!(o = index(objspec, p[1])))",
            "s = (\"[\" + p) + \"]\";",
            "else",
            "\" %[dproperty] \";",
            "cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};",
            "endif",
            "endif",
            "elseif (o = index(objspec, s))",
            "cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};",
            "elseif (w = index(prnspec, s, 1))",
            "cp_args = {who, prprops[w]};",
            "elseif (s == \"#\")",
            "s = tostr(who);",
            "elseif (s != \"%\")",
            "s = \"%\" + s;",
            "endif",
            "new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));",
            "endif",
            "old = old[k + 1..oldlen];",
            "oldlen = oldlen - k;",
            "endwhile",
            "return new + old;"
          ]
        },
        {
          "name": "explode",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:explode(subject [, break])\";",
            "\"Return a list of those substrings of subject separated by runs of break[1].\";",
            "\"break defaults to space.\";",
            "return explode(@args);"
          ]
        },
        {
          "name": "words",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"This breaks up the argument string into words, the resulting list being obtained exactly the way the command line parser obtains `args' from `argstr'.\";",
            "rest = args[1];",
            "\"...trim leading blanks...\";",
            "if (0)",
            "rest[1..match(rest, \"^ *\")[2]] = \"\";",
            "endif",
            "rest = $string_utils:triml(rest);",
            "if (!rest)",
            "return {};",
            "endif",
            "quote = 0;",
            "toklist = {};",
            "token = \"\";",
            "pattern = \" +%|\\\\.?%|\\\"\";",
            "while (m = match(rest, pattern))",
            "\"... find the next occurence of a special character, either\";",
            "\"... a block of spaces, a quote or a backslash escape sequence...\";",
            "char = rest[m[1]];",
            "token = token + rest[1..m[1] - 1];",
            "if (char == \" \")",
            "toklist = {@toklist, token};",
            "token = \"\";",
            "elseif (char == \"\\\"\")",
            "\"... beginning or end of quoted string...\";",
            "\"... within a quoted string spaces aren't special...\";",
            "pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";",
            "elseif (m[1] < m[2])",
            "\"... char has to be a backslash...\";",
            "\"... include next char literally if there is one\";",
            "token = token + rest[m[2]];",
            "endif",
            "rest[1..m[2]] = \"\";",
            "endwhile",
            "return (rest || (char != \" \")) ? {@toklist, token + rest} | toklist;"
          ]
        },
        {
          "name": "word_start",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"This breaks up the argument string into words, returning a list of indices into argstr corresponding to the starting points of each of the arguments.\";",
            "rest = args[1];",
            "\"... find first nonspace...\";",
            "wstart = match(rest, \"[^ ]%|$\")[1];",
            "wbefore = wstart - 1;",
            "rest[1..wbefore] = \"\";",
            "if (!rest)",
            "return {};",
            "endif",
            "quote = 0;",
            "wslist = {};",
            "pattern = \" +%|\\\\.?%|\\\"\";",
            "while (m = match(rest, pattern))",
            "\"... find the next occurence of a special character, either\";",
            "\"... a block of spaces, a quote or a backslash escape sequence...\";",
            "char = rest[m[1]];",
            "if (char == \" \")",
            "wslist = {@wslist, {wstart, (wbefore + m[1]) - 1}};",
            "wstart = (wbefore + m[2]) + 1;",
            "elseif (char == \"\\\"\")",
            "\"... beginning or end of quoted string...\";",
            "\"... within a quoted string spaces aren't special...\";",
            "pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";",
            "endif",
            "rest[1..m[2]] = \"\";",
            "wbefore = wbefore + m[2];",
            "endwhile",
            "return (rest || (char != \" \")) ? {@wslist, {wstart, wbefore + length(rest)}} | wslist;"
          ]
        },
        {
          "name": "to_value",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).\";",
            "\"Returns {1,value} or {0,error_message} according as the attempt was successful or not.\";",
            "string = this:triml(args[1]);",
            "if ((string[1] == \"[\") || (string[$] == \"]\"))",
            "result = this:_tomap((string[1] == \"[\") ? string[2..$] | string);",
            "if (typeof(result[2]) != MAP)",
            "return {0, result[2]};",
            "else",
            "return {1, result[2]};",
            "endif",
            "else",
            "result = this:_tolist(string = args[1] + \"}\");",
            "if (result[1] && (result[1] != $string_utils:space(result[1])))",
            "return {0, tostr(\"after char \", length(string) - result[1], \":  \", result[2])};",
            "elseif (typeof(result[1]) == INT)",
            "return {0, \"missing } or \\\"\"};",
            "elseif (length(result[2]) > 1)",
            "return {0, \"comma unexpected.\"};",
            "elseif (result[2])",
            "return {1, (typeof(result[2]) == LIST) ? result[2][1] | result[2]};",
            "else",
            "return {0, \"missing expression\"};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "prefix_to_value",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":prefix_to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).\";",
            "\"Returns {rest-of-string,value} or {0,error_message} according as the attempt was successful or not.\";",
            "alen = length(args[1]);",
            "slen = length(string = this:triml(args[1]));",
            "if (!string)",
            "return {0, \"empty string\"};",
            "elseif (w = index(\"{[\\\"\", string[1]))",
            "result = this:({\"_tolist\", \"_tomap\", \"_unquote\"}[w])(string[2..slen]);",
            "if (typeof(result[1]) != INT)",
            "return result;",
            "elseif (result[1] == 0)",
            "return {0, \"missing } or \\\"\"};",
            "else",
            "return {0, result[2], (alen - result[1]) + 1};",
            "endif",
            "else",
            "thing = string[1..tlen = index(string + \" \", \" \") - 1];",
            "if (typeof(s = this:_toscalar(thing)) != STR)",
            "return {string[tlen + 1..slen], s};",
            "else",
            "return {0, s, (alen - slen) + 1};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "_tolist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"_tolist(string) --- auxiliary for :to_value()\";",
            "rest = this:triml(args[1]);",
            "vlist = {};",
            "if (!rest)",
            "return {0, {}};",
            "elseif (rest[1] == \"}\")",
            "return {rest[2..$], {}};",
            "endif",
            "while (1)",
            "rlen = length(rest);",
            "if (w = index(\"{\\\"\", rest[1]))",
            "result = this:({\"_tolist\", \"_unquote\"}[w])(rest[2..rlen]);",
            "if (typeof(result[1]) == INT)",
            "return result;",
            "endif",
            "vlist = {@vlist, result[2]};",
            "rest = result[1];",
            "else",
            "thing = rest[1..tlen = min(index(rest + \",\", \",\"), index(rest + \"}\", \"}\")) - 1];",
            "if (typeof(s = this:_toscalar(thing)) == STR)",
            "return {rlen, s};",
            "endif",
            "vlist = {@vlist, s};",
            "rest = rest[tlen + 1..rlen];",
            "endif",
            "if (!rest)",
            "return {0, vlist};",
            "elseif (rest[1] == \"}\")",
            "return {rest[2..$], vlist};",
            "elseif (rest[1] == \",\")",
            "rest = this:triml(rest[2..$]);",
            "else",
            "return {length(rest), \", or } expected\"};",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "_unquote",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"_unquote(string)   (auxiliary for :to_value())\";",
            "\"reads string as if it were preceded by a quote, reading up to the closing quote if any, then returns the corresponding unquoted string.\";",
            "\" => {0, string unquoted}  if there is no closing quote\";",
            "\" => {original string beyond closing quote, string unquoted}  otherwise\";",
            "rest = args[1];",
            "result = \"\";",
            "while (m = match(rest, \"\\\\.?%|\\\"\"))",
            "\"Find the next special character\";",
            "if (rest[pos = m[1]] == \"\\\"\")",
            "return {rest[pos + 1..$], result + rest[1..pos - 1]};",
            "endif",
            "result = (result + rest[1..pos - 1]) + rest[pos + 1..m[2]];",
            "rest = rest[m[2] + 1..$];",
            "endwhile",
            "return {0, result + rest};"
          ]
        },
        {
          "name": "_toscalar",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":_toscalar(string)  --- auxiliary for :tovalue\";",
            "\" => value if string represents a number, object or error\";",
            "\" => string error message otherwise\";",
            "thing = args[1];",
            "if (!thing)",
            "return \"missing value\";",
            "elseif (match(thing, \"^#?[-+]?[0-9]+ *$\"))",
            "return (thing[1] == \"#\") ? toobj(thing) | toint(thing);",
            "elseif (match(thing, \"^[-+]?%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)? *$\"))",
            "\"matches 2. .2 3.2 3.2e3 .2e-3 3.e3\";",
            "return `tofloat(thing) ! E_INVARG => tostr(\"Bad floating point value: \", thing)';",
            "elseif (match(thing, \"^[-+]?[0-9]+e[-+]?[0-9]+ *$\"))",
            "\"matches 345e4. No decimal, but has an e so still a float\";",
            "return `tofloat(thing) ! E_INVARG => tostr(\"Bad floating point value: \", thing)';",
            "elseif (thing == \"true\")",
            "return true;",
            "elseif (thing == \"false\")",
            "return false;",
            "elseif (thing[1] == \"E\")",
            "return (e = $code_utils:toerr(thing)) ? tostr(\"unknown error code `\", thing, \"'\") | e;",
            "elseif (thing[1] == \"#\")",
            "return tostr(\"bogus objectid `\", thing, \"'\");",
            "else",
            "return tostr(\"`\", thing[1], \"' unexpected\");",
            "endif"
          ]
        },
        {
          "name": "parse_command",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":parse_command(cmd_line[,player])\";",
            "\" => {verb, {dobj, dobjstr}, {prep, prepstr}, {iobj, iobjstr}, {args, argstr},\";",
            "\"     {dobjset, prepset, iobjset}}\";",
            "\"This mimics the action of the builtin parser, returning what the values of the builtin variables `verb', `dobj', `dobjstr', `prepstr', `iobj', `iobjstr', `args', and `argstr' would be if `player' had typed `cmd_line'.  \";",
            "\"`prep' is the shortened version of the preposition found.\";",
            "\"\";",
            "\"`dobjset' and `iobjset' are subsets of {\\\"any\\\",\\\"none\\\"} and are used to determine possible matching verbs, i.e., the matching verb must either be on `dobj' and have verb_args[1]==\\\"this\\\" or else it has verb_args[1] in `dobjset'; likewise for `iobjset' and verb_args[3]; similarly we must have verb_args[2] in `prepset'.\";",
            "{c, ?who = player} = args;",
            "y = $string_utils:words(c);",
            "if (y == {})",
            "return {};",
            "endif",
            "vrb = y[1];",
            "y = y[2..$];",
            "as = (y == {}) ? \"\" | c[length(vrb) + 2..$];",
            "n = 1;",
            "while ((!(gp = $code_utils:get_prep(@y[n..$]))[1]) && (n < length(y)))",
            "n = n + 1;",
            "endwhile",
            "\"....\";",
            "really = player;",
            "player = who;",
            "loc = who.location;",
            "if (ps = gp[1])",
            "ds = $string_utils:from_list(y[1..n - 1], \" \");",
            "is = $string_utils:from_list(listdelete(gp, 1), \" \");",
            "io = valid(loc) ? loc:match_object(is) | $string_utils:match_object(is, loc);",
            "else",
            "ds = $string_utils:from_list(y, \" \");",
            "is = \"\";",
            "io = $nothing;",
            "endif",
            "do = valid(loc) ? loc:match_object(ds) | $string_utils:match_object(ds, loc);",
            "player = really;",
            "\"....\";",
            "dset = {\"any\", @(ds == \"\") ? {\"none\"} | {}};",
            "\"\\\"this\\\" must be handled manually.\";",
            "pset = {\"any\", @ps ? {$code_utils:full_prep(ps)} | {\"none\"}};",
            "iset = {\"any\", @(is == \"\") ? {\"none\"} | {}};",
            "return {vrb, {do, ds}, {$code_utils:short_prep(ps), ps}, {io, is}, {y, as}, {dset, pset, iset}};"
          ]
        },
        {
          "name": "from_value",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])\";",
            "\"Print the given value into a string.\";",
            "{value, ?quote_strings = 0, ?list_depth = 1} = args;",
            "if (typeof(value) == LIST)",
            "if (value)",
            "if (list_depth)",
            "result = \"{\" + this:from_value(value[1], quote_strings, list_depth - 1);",
            "for v in (listdelete(value, 1))",
            "result = tostr(result, \", \", this:from_value(v, quote_strings, list_depth - 1));",
            "endfor",
            "return result + \"}\";",
            "else",
            "return \"{...}\";",
            "endif",
            "else",
            "return \"{}\";",
            "endif",
            "elseif (quote_strings)",
            "if (typeof(value) == STR)",
            "result = \"\\\"\";",
            "while (q = index(value, \"\\\"\") || index(value, \"\\\\\"))",
            "if (value[q] == \"\\\"\")",
            "q = min(q, index(value + \"\\\\\", \"\\\\\"));",
            "endif",
            "result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];",
            "value = value[q + 1..$];",
            "endwhile",
            "return (result + value) + \"\\\"\";",
            "elseif (typeof(value) == ERR)",
            "return $code_utils:error_name(value);",
            "else",
            "return tostr(value);",
            "endif",
            "else",
            "return tostr(value);",
            "endif"
          ]
        },
        {
          "name": "print print_suspended",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:print(value)\";",
            "\"Print the given value into a string. == from_value(value,1,-1)\";",
            "return toliteral(args[1]);"
          ]
        },
        {
          "name": "reverse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":reverse(string) => \\\"gnirts\\\"\";",
            "\"An example: :reverse(\\\"This is a test.\\\") => \\\".tset a si sihT\\\"\";",
            "string = args[1];",
            "if ((len = length(string)) > 50)",
            "return this:reverse(string[($ / 2) + 1..$]) + this:reverse(string[1..$ / 2]);",
            "endif",
            "index = len;",
            "result = \"\";",
            "while (index > 0)",
            "result = result + string[index];",
            "index = index - 1;",
            "endwhile",
            "return result;"
          ]
        },
        {
          "name": "char_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":char_list(string) => string as a list of characters.\";",
            "\"   e.g., :char_list(\\\"abad\\\") => {\\\"a\\\",\\\"b\\\",\\\"a\\\",\\\"d\\\"}\";",
            "if (30 < (len = length(string = args[1])))",
            "return {@this:char_list(string[1..$ / 2]), @this:char_list(string[($ / 2) + 1..$])};",
            "else",
            "l = {};",
            "for c in [1..len]",
            "l = {@l, string[c]};",
            "endfor",
            "return l;",
            "endif"
          ]
        },
        {
          "name": "regexp_quote",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":regexp_quote(string)\";",
            "\" => string with all of the regular expression special characters quoted with %\";",
            "string = args[1];",
            "quoted = \"\";",
            "while (m = rmatch(string, \"[][$^.*+?%].*\"))",
            "quoted = (\"%\" + string[m[1]..m[2]]) + quoted;",
            "string = string[1..m[1] - 1];",
            "endwhile",
            "return string + quoted;"
          ]
        },
        {
          "name": "connection_hostname",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Return the host string for an object or extract it from a legacy connection_name() string. Assumes you are using bsd_network style connection names.\";",
            "(caller != #0) && set_task_perms(caller_perms());",
            "{lookup} = args;",
            "if (typeof(lookup) == OBJ)",
            "return `connection_name(lookup) ! E_INVARG => \"\"';",
            "elseif (typeof(lookup) == STR)",
            "\"Make the assumption here that connection_name() has been passed in from legacy code and contains just the host string.\";",
            "return (m = `match(lookup, \"^.* %(from%|to%) %([^, ]+%)\") ! ANY') ? substitute(\"%2\", m) | lookup;",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "from_value_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])\";",
            "\"Print the given value into a string.\";",
            "\"This verb suspends as necessary for large values.\";",
            "set_task_perms(caller_perms());",
            "{value, ?quote_strings = 0, ?list_depth = 1} = args;",
            "if (typeof(value) == LIST)",
            "if (value)",
            "if (list_depth)",
            "result = \"{\" + this:from_value(value[1], quote_strings, list_depth - 1);",
            "for v in (listdelete(value, 1))",
            "$command_utils:suspend_if_needed(0);",
            "result = tostr(result, \", \", this:from_value(v, quote_strings, list_depth - 1));",
            "endfor",
            "return result + \"}\";",
            "else",
            "return \"{...}\";",
            "endif",
            "else",
            "return \"{}\";",
            "endif",
            "elseif (quote_strings)",
            "if (typeof(value) == STR)",
            "result = \"\\\"\";",
            "while (q = index(value, \"\\\"\") || index(value, \"\\\\\"))",
            "$command_utils:suspend_if_needed(0);",
            "if (value[q] == \"\\\"\")",
            "q = min(q, index(value + \"\\\\\", \"\\\\\"));",
            "endif",
            "result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];",
            "value = value[q + 1..$];",
            "endwhile",
            "return (result + value) + \"\\\"\";",
            "elseif (typeof(value) == ERR)",
            "return $code_utils:error_name(value);",
            "else",
            "return tostr(value);",
            "endif",
            "else",
            "return tostr(value);",
            "endif"
          ]
        },
        {
          "name": "end_expression",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":end_expression(string[,stop_at])\";",
            "\"  assumes string starts with an expression; returns the index of the last char in expression or 0 if string appears not to be an expression.  Expression ends at any character from stop_at which occurs at top level.\";",
            "{string, ?stop_at = \" \"} = args;",
            "gone = 0;",
            "paren_stack = \"\";",
            "inquote = 0;",
            "search = top_level_search = (\"[][{}()\\\"\" + strsub(stop_at, \"]\", \"\")) + \"]\";",
            "paren_search = \"[][{}()\\\"]\";",
            "while (m = match(string, search))",
            "char = string[m[1]];",
            "string[1..m[2]] = \"\";",
            "gone = gone + m[2];",
            "if (char == \"\\\"\")",
            "\"...skip over quoted string...\";",
            "char = \"\\\\\";",
            "while (char == \"\\\\\")",
            "if (!(m = match(string, \"%(\\\\.?%|\\\"%)\")))",
            "return 0;",
            "endif",
            "char = string[m[1]];",
            "string[1..m[2]] = \"\";",
            "gone = gone + m[2];",
            "endwhile",
            "elseif (index(\"([{\", char))",
            "\"... push parenthesis...\";",
            "paren_stack[1..0] = char;",
            "search = paren_search;",
            "elseif (i = index(\")]}\", char))",
            "if (paren_stack && (\"([{\"[i] == paren_stack[1]))",
            "\"... pop parenthesis...\";",
            "paren_stack[1..1] = \"\";",
            "search = paren_stack ? paren_search | top_level_search;",
            "else",
            "\"...parenthesis mismatch...\";",
            "return 0;",
            "endif",
            "else",
            "\"... stop character ...\";",
            "return gone - 1;",
            "endif",
            "endwhile",
            "return (!paren_stack) && (gone + length(string));"
          ]
        },
        {
          "name": "first_word",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":first_word(string) => {first word, rest of string} or {}\";",
            "rest = args[1];",
            "\"...trim leading blanks...\";",
            "rest[1..match(rest, \"^ *\")[2]] = \"\";",
            "if (!rest)",
            "return {};",
            "endif",
            "quote = 0;",
            "token = \"\";",
            "pattern = \" +%|\\\\.?%|\\\"\";",
            "while (m = match(rest, pattern))",
            "\"... find the next occurence of a special character, either\";",
            "\"... a block of spaces, a quote or a backslash escape sequence...\";",
            "char = rest[m[1]];",
            "token = token + rest[1..m[1] - 1];",
            "if (char == \" \")",
            "rest[1..m[2]] = \"\";",
            "return {token, rest};",
            "elseif (char == \"\\\"\")",
            "\"... beginning or end of quoted string...\";",
            "\"... within a quoted string spaces aren't special...\";",
            "pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";",
            "elseif (m[1] < m[2])",
            "\"... char has to be a backslash...\";",
            "\"... include next char literally if there is one\";",
            "token = token + rest[m[2]];",
            "endif",
            "rest[1..m[2]] = \"\";",
            "endwhile",
            "return {token + rest, \"\"};"
          ]
        },
        {
          "name": "common",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":common(first,second) => length of longest common prefix\";",
            "{first, second} = args;",
            "r = min(length(first), length(second));",
            "l = 1;",
            "while (r >= l)",
            "h = (r + l) / 2;",
            "if (first[l..h] == second[l..h])",
            "l = h + 1;",
            "else",
            "r = h - 1;",
            "endif",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "title_list*c list_title*c",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"wr_utils:title_list/title_listc(<obj-list>[, @<args>)\";",
            "\"Creates an english list out of the titles of the objects in <obj-list>.  Optional <args> are passed on to $string_utils:english_list.\";",
            "\"title_listc uses :titlec() for the first item.\";",
            "titles = $list_utils:map_verb(args[1], \"title\");",
            "if (verb[length(verb)] == \"c\")",
            "if (titles)",
            "titles[1] = args[1][1]:titlec();",
            "elseif (length(args) > 1)",
            "args[2] = $string_utils:capitalize(args[2]);",
            "else",
            "args = listappend(args, \"Nothing\");",
            "endif",
            "endif",
            "return $string_utils:english_list(titles, @args[2..$]);"
          ]
        },
        {
          "name": "name_and_number nn name_and_number_list nn_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"name_and_number(object [,sepr] [,english_list_args]) => \\\"ObjectName (#object)\\\"\";",
            "\"Return name and number for OBJECT.  Second argument is optional separator (for those who want no space, use \\\"\\\").  If OBJECT is a list of objects, this maps the above function over the list and then passes it to $string_utils:english_list.\";",
            "\"The third through nth arguments to nn_list corresponds to the second through nth arguments to English_list, and are passed along untouched.\";",
            "{objs, ?sepr = \" \", @eng_args} = args;",
            "if (typeof(objs) != LIST)",
            "objs = {objs};",
            "endif",
            "name_list = {};",
            "for what in (objs)",
            "name = valid(what) ? what.name | {\"<invalid>\", \"$nothing\", \"$ambiguous_match\", \"$failed_match\"}[1 + (what in {#-1, #-2, #-3})];",
            "name = tostr(name, sepr, \"(\", what, \")\");",
            "name_list = {@name_list, name};",
            "endfor",
            "return this:english_list(name_list, @eng_args);"
          ]
        },
        {
          "name": "columnize_suspended columnise_suspended",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"columnize_suspended (interval, items, n [, width]) - Turn a one-column list of items into an n-column list, suspending for `interval' seconds as necessary. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize_suspended(0, {1, 2, 3, 4, 5, 6, 7}, 3));'.\";",
            "{interval, items, n, ?width = 79} = args;",
            "height = ((length(items) + n) - 1) / n;",
            "items = {@items, @$list_utils:make((height * n) - length(items), \"\")};",
            "colwidths = {};",
            "for col in [1..n - 1]",
            "colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));",
            "endfor",
            "result = {};",
            "for row in [1..height]",
            "line = tostr(items[row]);",
            "for col in [1..n - 1]",
            "$command_utils:suspend_if_needed(interval);",
            "line = tostr(this:left(line, colwidths[col]), \" \", items[row + (col * height)]);",
            "endfor",
            "result = listappend(result, line[1..min($, width)]);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "a_or_an",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":a_or_an(<noun>) => \\\"a\\\" or \\\"an\\\"\";",
            "\"To accomodate personal variation (e.g., \\\"an historical book\\\"), a player can override this by having a personal a_or_an verb.  If that verb returns 0 instead of a string, the standard algorithm is used.\";",
            "noun = args[1];",
            "if ($object_utils:has_verb(player, \"a_or_an\") && ((custom_result = player:a_or_an(noun)) != 0))",
            "return custom_result;",
            "endif",
            "if (noun in this.use_article_a)",
            "return \"a\";",
            "endif",
            "if (noun in this.use_article_an)",
            "return \"an\";",
            "endif",
            "a_or_an = \"a\";",
            "if (noun != \"\")",
            "if (index(\"aeiou\", noun[1]))",
            "a_or_an = \"an\";",
            "\"unicycle, unimplemented, union, united, unimpressed, unique\";",
            "if ((((noun[1] == \"u\") && (length(noun) > 2)) && (noun[2] == \"n\")) && ((index(\"aeiou\", noun[3]) == 0) || (((noun[3] == \"i\") && (length(noun) > 3)) && (index(\"aeioubcghqwyz\", noun[4]) || ((length(noun) > 4) && index(\"eiy\", noun[5]))))))",
            "a_or_an = \"a\";",
            "endif",
            "endif",
            "endif",
            "return a_or_an;",
            "\"Ported by Mickey with minor tweaks from a Moo far far away.\";",
            "\"Last modified Sun Aug  1 22:53:07 1993 EDT by BabyBriar (#2).\";"
          ]
        },
        {
          "name": "index_all",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"index_all(string,target) -- returns list of positions of target in string.\";",
            "\"Usage: $string_utils:index_all(<string,pattern>)\";",
            "\"       $string_utils:index_all(\\\"aaabacadae\\\",\\\"a\\\")\";",
            "{line, pattern} = args;",
            "if ((typeof(line) != STR) || (typeof(pattern) != STR))",
            "return E_TYPE;",
            "else",
            "where = {};",
            "place = -1;",
            "next = 0;",
            "while ((place = index(line[next + 1..$], pattern)) != 0)",
            "where = {@where, place + next};",
            "next = ((place + next) + length(pattern)) - 1;",
            "endwhile",
            "return where;",
            "endif"
          ]
        },
        {
          "name": "match_stringlist match_string_list",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Copied from Puff (#1449):match_stringlist Tue Oct 19 08:18:13 1993 PDT\";",
            "\"$string_utils:match_stringlist(string, {list of strings})\";",
            "\"The list of strings should be just that, a list of strings.  The first string is matched against the list of strings.\";",
            "\"If it exactly matches exactly one of them, the index of the match is returned. If it exactly matches more than one of them, $ambiguous_match is returned.\";",
            "\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of one of the strings.\";",
            "\"Again, if exactly one match is found, the index of that string is returned, and if more than one match is found, $ambiguous match is returned.\";",
            "\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";",
            "{subject, stringlist} = args;",
            "if ((subject == \"\") || (length(stringlist) < 1))",
            "return $nothing;",
            "endif",
            "matches = {};",
            "\"First check for exact matches.\";",
            "for i in [1..length(stringlist)]",
            "if (subject == stringlist[i])",
            "matches = {@matches, i};",
            "endif",
            "endfor",
            "\"Now return a match, or $ambiguous, or check for partial matches.\";",
            "if (length(matches) == 1)",
            "return matches[1];",
            "elseif (length(matches) > 1)",
            "return $ambiguous_match;",
            "elseif (length(matches) == 0)",
            "\"Checking for partial matches is almost identical to checking for exact matches, but we use index(list[i], target) instead of list[i] == target to see if they match.\";",
            "for i in [1..length(stringlist)]",
            "if (index(stringlist[i], subject) == 1)",
            "matches = {@matches, i};",
            "endif",
            "endfor",
            "if (length(matches) == 1)",
            "return matches[1];",
            "elseif (length(matches) > 1)",
            "return $ambiguous_match;",
            "elseif (length(matches) == 0)",
            "return $failed_match;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "from_ASCII",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"This converts a ASCII character code in the range [32..126] into the ASCII character with that code, represented as a one-character string.\";",
            "\"\";",
            "\"Example:   $string_utils:from_ASCII(65) => \\\"A\\\"\";",
            "code = args[1];",
            "return this.ascii[code - 31];"
          ]
        },
        {
          "name": "to_ASCII",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Convert a one-character string into the ASCII character code for that character.\";",
            "\"\";",
            "\"Example:  $string_utils:to_ASCII(\\\"A\\\") => 65\";",
            "return (index(this.ascii, args[1], 1) || raise(E_INVARG)) + 31;"
          ]
        },
        {
          "name": "abbreviated_value",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Copied from Mickey (#52413):abbreviated_value Fri Sep  9 08:52:41 1994 PDT\";",
            "\":abbreviated_value(value,max_reslen,max_lstlev,max_lstlen,max_strlen,max_toklen)\";",
            "\"\";",
            "\"Gets the printed representation of value, subject to these parameters:\";",
            "\" max_reslen = Maximum desired result string length.\";",
            "\" max_lstlev = Maximum list level to show.\";",
            "\" max_lstlen = Maximum list length to show.\";",
            "\" max_strlen = Maximum string length to show.\";",
            "\" max_toklen = Maximum token length (e.g., numbers and errors) to show.\";",
            "\"\";",
            "\"A best attempt is made to get the exact target size, but in some cases the result is not exact.\";",
            "{value, ?max_reslen = $maxint, ?max_lstlev = $maxint, ?max_lstlen = $maxint, ?max_strlen = $maxint, ?max_toklen = $maxint} = args;",
            "return this:_abbreviated_value(value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen);",
            "\"Originally written by Mickey.\";"
          ]
        },
        {
          "name": "_abbreviated_value",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Copied from Mickey (#52413):_abbreviated_value Fri Sep  9 08:52:44 1994 PDT\";",
            "\"Internal to :abbreviated_value.  Do not call this directly.\";",
            "{value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen} = args;",
            "if ((type = typeof(value)) == LIST)",
            "if (!value)",
            "return \"{}\";",
            "elseif (max_lstlev == 0)",
            "return \"{...}\";",
            "else",
            "n = length(value);",
            "result = \"{\";",
            "r = max_reslen - 2;",
            "i = 1;",
            "eltstr = \"\";",
            "while (((i <= n) && (i <= max_lstlen)) && (r > (x = (i == 1) ? 0 | 2)))",
            "eltlen = length(eltstr = this:(verb)(value[i], r, max_lstlev - 1, max_lstlen, max_strlen, max_toklen));",
            "lastpos = 1;",
            "if (r >= (eltlen + x))",
            "comma = (i == 1) ? \"\" | \", \";",
            "result = tostr(result, comma);",
            "if (r > 4)",
            "lastpos = length(result);",
            "endif",
            "result = tostr(result, eltstr);",
            "r = (r - eltlen) - x;",
            "elseif (i == 1)",
            "return \"{...}\";",
            "elseif (r > 4)",
            "return tostr(result, \", ...}\");",
            "else",
            "return tostr(result[1..lastpos], \"...}\");",
            "endif",
            "i = i + 1;",
            "endwhile",
            "if (i <= n)",
            "if (i == 1)",
            "return \"{...}\";",
            "elseif (r > 4)",
            "return tostr(result, \", ...}\");",
            "else",
            "return tostr(result[1..lastpos], \"...}\");",
            "endif",
            "else",
            "return tostr(result, \"}\");",
            "endif",
            "endif",
            "elseif (type == STR)",
            "result = \"\\\"\";",
            "while ((q = index(value, \"\\\"\")) ? q = min(q, index(value, \"\\\\\")) | (q = index(value, \"\\\\\")))",
            "result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];",
            "value = value[q + 1..$];",
            "endwhile",
            "result = result + value;",
            "if ((length(result) + 1) > (z = max(min(max_reslen, max(max_strlen, max_strlen + 2)), 6)))",
            "z = z - 5;",
            "k = 0;",
            "while ((k < z) && (result[z - k] == \"\\\\\"))",
            "k = k + 1;",
            "endwhile",
            "return tostr(result[1..z - (k % 2)], \"\\\"+...\");",
            "else",
            "return tostr(result, \"\\\"\");",
            "endif",
            "else",
            "v = (type == ERR) ? $code_utils:error_name(value) | tostr(value);",
            "len = max(4, min(max_reslen, max_toklen));",
            "return (length(v) > len) ? v[1..len - 3] + \"...\" | v;",
            "endif",
            "\"Originally written by Mickey.\";"
          ]
        },
        {
          "name": "match_suspended",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"$string_utils:match_suspended(string [, obj-list, prop-name]*)\";",
            "\"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.\";",
            "\"The argument string is matched against all of the strings in the property values.\";",
            "\"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.\";",
            "\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.\";",
            "\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";",
            "\"This verb will suspend as needed, and should be used if obj-list is very large.\";",
            "subject = args[1];",
            "if (subject == \"\")",
            "return $nothing;",
            "endif",
            "no_exact_match = no_partial_match = 1;",
            "for i in [1..length(args) / 2]",
            "prop_name = args[(2 * i) + 1];",
            "for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})",
            "if (valid(object))",
            "if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)",
            "str_list = {str_list};",
            "endif",
            "if (subject in str_list)",
            "if (no_exact_match)",
            "no_exact_match = object;",
            "elseif (no_exact_match != object)",
            "return $ambiguous_match;",
            "endif",
            "else",
            "for string in (str_list)",
            "if (index(string, subject) != 1)",
            "elseif (no_partial_match)",
            "no_partial_match = object;",
            "elseif (no_partial_match != object)",
            "no_partial_match = $ambiguous_match;",
            "endif",
            "endfor",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(5);",
            "endfor",
            "endfor",
            "return no_exact_match && (no_partial_match && $failed_match);"
          ]
        },
        {
          "name": "incr_alpha",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"args[1] is a string.  'increments' the string by one. E.g., aaa => aab, aaz => aba.  empty string => a, zzz => aaaa.\";",
            "\"args[2] is optional alphabet to use instead of $string_utils.alphabet.\";",
            "{s, ?alphabet = this.alphabet} = args;",
            "index = length(s);",
            "if (!s)",
            "return alphabet[1];",
            "elseif (s[$] == alphabet[$])",
            "return this:incr_alpha(s[1..index - 1], alphabet) + alphabet[1];",
            "else",
            "t = index(alphabet, s[index]);",
            "return s[1..index - 1] + alphabet[t + 1];",
            "endif"
          ]
        },
        {
          "name": "is_float",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Usage:  is_float(string)\";",
            "\"Is string composed of one or more digits possibly preceded by a minus sign either followed by a decimal or by an exponent?\";",
            "\"Return true or false\";",
            "return match(args[1], \"^ *[-+]?%(%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)?%)%|%([0-9]+e[-+]?[0-9]+%) *$\");"
          ]
        },
        {
          "name": "inside_quotes",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 20,
          "code": [
            "\"Copied from Moo_tilities (#332):inside_quotes by Mooshie (#106469) Tue Dec 23 10:26:49 1997 PST\";",
            "\"Usage: inside_quotes(STR)\";",
            "\"Is the  end of the given string `inside' a doublequote?\";",
            "\"Called from $code_utils:substitute.\";",
            "{string} = args;",
            "quoted = 0;",
            "while (i = index(string, \"\\\"\"))",
            "if ((!quoted) || (string[i - 1] != \"\\\\\"))",
            "quoted = !quoted;",
            "endif",
            "string = string[i + 1..$];",
            "endwhile",
            "return quoted;"
          ]
        },
        {
          "name": "strip_all_but_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":strip_all_but_seq(string, keep) => chars in string not in exact sequence of keep removed.\";",
            "\":strip_all_but() works similarly, only it does not concern itself with the sequence, just the specified chars.\";",
            "string = args[1];",
            "wanted = args[2];",
            "output = \"\";",
            "while (m = match(string, wanted))",
            "output = output + string[m[1]..m[2]];",
            "string = string[m[2] + 1..length(string)];",
            "endwhile",
            "return output;"
          ]
        },
        {
          "name": "redirect_ansi left right center centre columnize columnise space",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 20,
          "code": [
            "\"...redirects verbs to $ansi_utils...\";",
            "if (verb == \"redirect_ansi\")",
            "elseif (valid(au = $ansi_utils))",
            "return au:(verb)(@args);",
            "else",
            "return this:(verb + \"(noansi)\")(@args);",
            "endif"
          ]
        },
        {
          "name": "_tomap",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"_tomap(string) -- auxiliary for :to_value()\";",
            "\"Last modified 11/28/18 11:48 p.m. by Sinistral (#2) on ChatMUD\";",
            "rest = this:triml(args[1]);",
            "vhash = [];",
            "if (!rest)",
            "return {0, []};",
            "elseif (rest[1] == \"]\")",
            "return {rest[2..$], []};",
            "endif",
            "while (1)",
            "rlen = length(rest);",
            "key = 0;",
            "if (rest[1] == \"\\\"\")",
            "result = this:_unquote(rest[2..rlen]);",
            "if (typeof(result[1] == INT))",
            "return result;",
            "endif",
            "key = result[2];",
            "rest = result[1];",
            "if (!rest)",
            "return {0, \"\"};",
            "endif",
            "key_end = index(rest, \"->\");",
            "if (!key_end)",
            "return {rlen, \"missing arrow '->' in hash entry definition\"};",
            "endif",
            "rest = rest[key_end + 2..$];",
            "elseif (w = index(\"{[\", rest[1]))",
            "return {rlen, \"hash key cannot be list or hash\"};",
            "else",
            "key_end = index(rest, \"->\");",
            "if (!key_end)",
            "return {rlen, \"missing arrow '->' in hash entry definition\"};",
            "endif",
            "thing = rest[1..key_end - 1];",
            "if (typeof(s = this:_toscalar(thing)) == STR)",
            "return {rlen, s};",
            "endif",
            "key = s;",
            "rest = rest[key_end + 2..rlen];",
            "endif",
            "val = 0;",
            "rest = this:triml(rest);",
            "rlen = length(rest);",
            "if (w = index(\"{[\\\"\", rest[1]))",
            "result = this:({\"_tolist\", \"_tomap\", \"_unquote\"}[w])(rest[2..rlen]);",
            "if (typeof(result[1] == INT))",
            "return result;",
            "endif",
            "val = result[2];",
            "rest = result[1];",
            "else",
            "val = rest[1..vlen = min(index(rest + \",\", \",\"), index(rest + \"]\", \"]\")) - 1];",
            "if (typeof(s = this:_toscalar(val)) == STR)",
            "return {rlen, s};",
            "endif",
            "val = s;",
            "rest = rest[vlen + 1..rlen];",
            "endif",
            "vhash[key] = val;",
            "rest = this:triml(rest);",
            "if (!rest)",
            "return {0, vhash};",
            "elseif (rest[1] == \"]\")",
            "return {rest[2..$], vhash};",
            "elseif (rest[1] == \",\")",
            "rest = this:triml(rest[2..$]);",
            "else",
            "return {length(rest), \", or ] expected\"};",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "autofit fit_to_screen",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":fit_to_screen({elements}, ?padding = 2, ?underline = 0, ?separator = \\\" \\\") => Returns a columnized display that is adapted to the linelength of the viewers screen.\";",
            "\"If underline is set to 1, the first list is assumed to be a list of column headings and the code will insert an appropriate amount of dashes for you. e.g. {ur, mom, lawlz} will add {--, ---, -----}\";",
            "\"If separator is set to a character, it will be passed to :neat. e.g. those things that use lots of periods instead of spaces\";",
            "\"Verb Created by Lisdude@Toastsoft, 10/13/15\";",
            "{elements, ?padding = 2, ?underline = 0, ?separator = \" \"} = args;",
            "ansi_utils = $ansi_utils;",
            "command_utils = $command_utils;",
            "if (underline)",
            "lines = {};",
            "for x in (elements[1])",
            "lines = {@lines, ansi_utils:space(length(x), \"-\")};",
            "endfor",
            "elements = listinsert(elements, lines, 2);",
            "endif",
            "max = $list_utils:make(length(elements[1]));",
            "for x in (elements)",
            "command_utils:suspend_if_needed(0);",
            "for y in [1..length(x)]",
            "if ((len = ansi_utils:length(x[y])) > max[y])",
            "max[y] = len;",
            "endif",
            "endfor",
            "endfor",
            "\"Add padding.\";",
            "for x in [1..length(max)]",
            "max[x] = max[x] + padding;",
            "endfor",
            "ret = {};",
            "max = this:adjust_column_lengths(max);",
            "for x in (elements)",
            "command_utils:suspend_if_needed(0);",
            "neat = {};",
            "for y in [1..length(x)]",
            "neat = {@neat, {x[y], max[y], separator}};",
            "endfor",
            "ret = {@ret, this:neat(@neat)};",
            "endfor",
            "return ret;"
          ]
        },
        {
          "name": "adjust_column_lengths",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\":adjust_column_lengths({lengths}) => Takes a list of numbers that are assumed to be column lengths. Then, if the sum\";",
            "\"                                       of those lengths exceeds the player's linelength, beginning systematically lowering\";",
            "\"                                      individual columns until we fit on their screen.\";",
            "{ret, ?increment = 5, ?player = player} = args;",
            "variable_picker = 0;",
            "len = length(ret);",
            "iterations = 0;",
            "linelen = player:linelen();",
            "while (1)",
            "$sin(0);",
            "iterations = iterations + 1;",
            "if (iterations >= 500000)",
            "break;",
            "endif",
            "sum = 0;",
            "for x in (ret)",
            "sum = sum + x;",
            "endfor",
            "if (sum <= linelen)",
            "return ret;",
            "else",
            "variable_picker = variable_picker + 1;",
            "if (variable_picker > len)",
            "variable_picker = len;",
            "endif",
            "if ((ret[variable_picker] - increment) <= 4)",
            "continue;",
            "endif",
            "endif",
            "ret[variable_picker] = ret[variable_picker] - increment;",
            "endwhile",
            "return ret;"
          ]
        },
        {
          "name": "neat",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"{string, length, [seperator]}\";",
            "AU = $ansi_utils;",
            "ret = \"\";",
            "for x in (args)",
            "NUM = toint(x[2]);",
            "x[1] = tostr(x[1]);",
            "ret = tostr(ret, tostr(AU:left((AU:length(x[1]) >= NUM) ? AU:cutoff(x[1], 1, NUM - 1) | x[1], NUM, (length(x) == 3) ? x[3] | \" \")));",
            "$sin(0);",
            "endfor",
            "return ret;"
          ]
        },
        {
          "name": "capitalize_each",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "\"This will capitalize each word in a string.\";",
            "\"Add words to the ignore list if you want them to be left lowercase.\";",
            "{string, ?ignore_words = {}, ?always_capitalize_first = 1} = args;",
            "words = $string_utils:words(string);",
            "for x in [1..length(words)]",
            "if ((!(words[x] in ignore_words)) || ((x == 1) && always_capitalize_first))",
            "words[x] = $string_utils:capitalize(words[x]);",
            "endif",
            "endfor",
            "return $string_utils:from_list(words, \" \");"
          ]
        },
        {
          "name": "strip_binary",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 20,
          "code": [
            "{decode} = args;",
            "decoded = \"\";",
            "for x in (decode_binary(decode))",
            "if (typeof(x) == STR)",
            "decoded = decoded + x;",
            "endif",
            "endfor",
            "return decoded;"
          ]
        }
      ],
      "propnames": [
        "digits",
        "ascii",
        "alphabet",
        "use_article_a",
        "use_article_an",
        "tab"
      ],
      "propdefs": [
        {
          "value": "0123456789",
          "owner": 2,
          "perms": 5
        },
        {
          "value": " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "abcdefghijklmnopqrstuvwxyz",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "unit",
            "unix",
            "one",
            "once",
            "utility"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "\t",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "For a complete description of a given verb, do `help $string_utils:verbname'",
            "",
            "    Conversion routines:",
            "",
            ":from_list    (list [,sep])                          => \"foo1foo2foo3\"",
            ":english_list (str-list[,none-str[,and-str[, sep]]]) => \"foo1, foo2, and foo3\"",
            ":title_list*c (obj-list[,none-str[,and-str[, sep]]]) => \"foo1, foo2, and foo3\"",
            "                                                  or => \"Foo1, foo2, and foo3\"",
            ":from_value   (value [,quoteflag [,maxlistdepth]])   => \"{foo1, foo2, foo3}\"",
            ":print        (value)                                => value in string",
            ":abbreviated_value (value, options)                  => short value in string",
            "",
            ":to_value       (string)     => {success?, value or error message}",
            ":prefix_to_value(string)     => {rest of string, value} or {0, error message}",
            "",
            ":english_number(42)          => \"forty-two\"",
            ":english_ordinal(42)         => \"forty-second\"",
            ":ordinal(42)                 => \"42nd\"",
            ":group_number(42135 [,sep])  => \"42,135\"",
            ":from_ASCII(65)              => \"A\"",
            ":to_ASCII(\"A\")               => 65",
            ":from_seconds(number)        => string of rough time passed in large increments",
            "",
            ":name_and_number(obj [,sep]) => \"ObjectName (#obj)\"",
            ":name_and_number_list({obj1,obj2} [,sep])",
            "                             => \"ObjectName1 (#obj1) and ObjectName2 (#obj2)\"",
            ":nn is an alias for :name_and_number.",
            ":nn_list is an alias for :name_and_number_list.",
            "",
            "    Type checking:",
            "",
            ":is_integer   (string) => return true if string is composed entirely of digits",
            ":is_float     (string) => return true if string holds just a floating point",
            "",
            "    Parsing:",
            "",
            ":explode (string,char) -- string => list of words delimited by char",
            ":words   (string)      -- string => list of words (as with command line parser)",
            ":word_start (string)   -- string => list of start-end pairs.",
            ":first_word (string)   -- string => list {first word, rest of string} or {}",
            ":char_list  (string)   -- string => list of characters in string",
            "",
            ":parse_command (cmd_line [,player] => mimics action of builtin parser",
            "",
            "    Matching:",
            "",
            ":find_prefix  (prefix, string-list)=>list index of element starting with prefix",
            ":index_delimited(string,target[,case]) =>index of delimited string occurrence",
            ":index_all    (string, target string)          => list of all matched positions",
            ":common       (first string, second string)  => length of longest common prefix",
            ":match        (string, [obj-list, prop-name]+) => matching object",
            ":match_player (string-list[,me-object])        => list of matching players",
            ":match_object (string, location)               => default object match...",
            ":match_player_or_object (string, location) => object then player matching",
            ":literal_object (string)                       => match against #xxx, $foo",
            ":match_stringlist (string, targets)            => match against static strings",
            ":match_string (string, wildcard target,options)=> match against a wildcard",
            "",
            "    Pretty printing:",
            "",
            ":space         (n/string[,filler])     => n spaces",
            ":left          (string,width[,filler]) => left justified string in field ",
            ":right         (string,width[,filler]) => right justified string in field",
            ":center/re     (string,width[,lfiller[,rfiller]]) => centered string in field",
            ":columnize/se  (list,n[,width])        => list of strings in n columns",
            "",
            "    Substitutions",
            "",
            ":substitute (string,subst_list [,case])   -- general substitutions.",
            ":substitute_delimited (string,subst_list [,case])",
            "                                          -- like subst, but uses index_delim",
            ":pronoun_sub (string/list[,who[,thing[,location]]])",
            "                                          -- pronoun substitutions.",
            ":pronoun_sub_secure (string[,who[,thing[,location]]],default)",
            "                                          -- substitute and check for names.",
            ":pronoun_quote (string/list/subst_list)   -- quoting for pronoun substitutions.",
            "",
            "    Miscellaneous string munging:",
            "",
            ":trim         (string)       => string with outside whitespace removed.",
            ":triml        (string)       => string with leading whitespace removed.",
            ":trimr        (string)       => string with trailing whitespace removed.",
            ":strip_chars  (string,chars) => string with all chars in `chars' removed.",
            ":strip_all_but(string,chars) => string with all chars not in `chars' removed.",
            ":capitalize/se(string)       => string with first letter capitalized.",
            ":uppercase/lowercase(string) => string with all letters upper or lowercase.",
            ":names_of     (list of OBJ)  => string with names and object numbers of items.",
            ":a_or_an      (word)         => \"a\" or \"an\" as appropriate for that word.",
            ":reverse      (string)       => \"gnirts\"",
            ":incr_alpha   (string)       => \"increments\" the string alphabetically",
            "",
            "    A useful property:",
            "",
            ".alphabet                    => \"abcdefghijklmnopqrstuvwxyz\"",
            "",
            "Suspended versions (with _suspended at end of name) for",
            "     :print     :from_value     :columnize/se      :match"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "string",
            "utils"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the string utilities utility package.  See `help $string_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            109381,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "21": {
      "id": 21,
      "name": "building utilities",
      "flags": 24,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "make_exit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\"make_exit(spec, source, dest[, use-$recycler-pool [, kind]])\";",
            "\"\";",
            "\"Uses $recycler by default; supplying fourth arg as 0 suppresses this.\";",
            "\"Optional 5th arg gives a parent for the object to be created\";",
            "\"(i.e., distinct from $exit)\";",
            "\"Returns the object number as a list if successful, 0 if not.\";",
            "set_task_perms(caller_perms());",
            "{spec, source, dest, ?use_recycler, ?exit_kind = $exit} = args;",
            "exit = player:_create(exit_kind);",
            "if (typeof(exit) == ERR)",
            "player:notify(tostr(\"Cannot create new exit as a child of \", $string_utils:nn(exit_kind), \": \", exit, \".  See `help @build-options' for information on how to specify the kind of exit this command tries to create.\"));",
            "return;",
            "endif",
            "for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))",
            "exit.(f) = 1;",
            "endfor",
            "$building_utils:set_names(exit, spec);",
            "exit.source = source;",
            "exit.dest = dest;",
            "source_ok = source:add_exit(exit);",
            "dest_ok = dest:add_entrance(exit);",
            "move(exit, $nothing);",
            "via = $string_utils:from_value(setadd(exit.aliases, exit.name), 1);",
            "if (source_ok)",
            "player:tell(\"Exit from \", source.name, \" (\", source, \") to \", dest.name, \" (\", dest, \") via \", via, \" created with id \", exit, \".\");",
            "if (!dest_ok)",
            "player:tell(\"However, I couldn't add \", exit, \" as a legal entrance to \", dest.name, \".  You may have to get its owner, \", dest.owner.name, \" to add it for you.\");",
            "endif",
            "return {exit};",
            "elseif (dest_ok)",
            "player:tell(\"Exit to \", dest.name, \" (\", dest, \") via \", via, \" created with id \", exit, \".  However, I couldn't add \", exit, \" as a legal exit from \", source.name, \".  Get its owner, \", source.owner.name, \" to add it for you.\");",
            "return {exit};",
            "else",
            "player:_recycle(exit);",
            "player:tell(\"I couldn't add a new exit as EITHER a legal exit from \", source.name, \" OR as a legal entrance to \", dest.name, \".  Get their owners, \", source.owner.name, \" and \", dest.owner.name, \", respectively, to add it for you.\");",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "set_names",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\"$building_utils:set_names(object, spec)\";",
            "set_task_perms(caller_perms());",
            "object = args[1];",
            "names = this:parse_names(args[2]);",
            "name = names[1] || object.name;",
            "return object:set_name(name) && object:set_aliases(names[2]);"
          ]
        },
        {
          "name": "recreate",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\":recreate(object,newparent) -- effectively recycle and recreate the specified object as a child of parent.  Returns true if successful.\";",
            "\"In any circumstance, either object OR newparent has to be a valid object.\";",
            "\"If object is valid and newparent is invalid, object is effectively just recycled.\";",
            "\"If object is invalid and newparent is valid, an attempt will be made to recreate the invalid object as newparent.\";",
            "{object, parent} = args;",
            "who = caller_perms();",
            "if (who.wizard)",
            "\"no problemo\";",
            "elseif ((valid(object) && (who != object.owner)) || (valid(parent) && ((who != parent.owner) && (!parent.f))))",
            "return E_PERM;",
            "endif",
            "\"No need to worry about orphans or contents, as recycle() will handle all of that for us.\";",
            "set_task_perms(who);",
            "if (valid(object))",
            "recycle(object);",
            "endif",
            "if (!valid(parent))",
            "\"We're done here. All we wanted to do was recycle with who's permissions.\";",
            "return 1;",
            "else",
            "recreate(object, parent, who);",
            "object.name = \"\";",
            "object.r = 0;",
            "object.f = 0;",
            "object.w = 0;",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "parse_names",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\"$building_utils:parse_names(spec)\";",
            "\"Return {name, {alias, alias, ...}} from name,alias,alias or name:alias,alias\";",
            "spec = args[1];",
            "if (!(colon = index(spec, \":\")))",
            "aliases = $string_utils:explode(spec, \",\");",
            "if (!aliases)",
            "aliases = {spec};",
            "endif",
            "name = aliases[1];",
            "else",
            "aliases = $string_utils:explode(spec[colon + 1..$], \",\");",
            "name = spec[1..colon - 1];",
            "endif",
            "return {name, $list_utils:map_arg($string_utils, \"trim\", aliases)};"
          ]
        },
        {
          "name": "audit_object_category",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "if (is_player(what = args[1]))",
            "return \"P\";",
            "endif",
            "while (valid(what))",
            "if (i = what in this.classes)",
            "return this.class_string[i];",
            "endif",
            "what = parent(what);",
            "endwhile",
            "return \" \";"
          ]
        },
        {
          "name": "object_audit_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\":object_audit_string(object [,prospectus-style])\";",
            "{o, ?prospectus = 0} = args;",
            "olen = length(tostr(max_object()));",
            "if (!$recycler:valid(o))",
            "return tostr(prospectus ? \"          \" | \"\", $quota_utils.byte_based ? \"    \" | \"\", $string_utils:right(o, olen), \" Invalid Object!\");",
            "endif",
            "if (prospectus)",
            "kids = 0;",
            "for k in (children(o))",
            "$command_utils:suspend_if_needed(0);",
            "if (k.owner != o.owner)",
            "kids = 2;",
            "break k;",
            "elseif (kids == 0)",
            "kids = 1;",
            "endif",
            "endfor",
            "\"The verbs() call below might fail, but that's OK\";",
            "\"Well, actually it won't cuz we seem to be a wizard.  Since you can get the number of verbs information from @verbs anyway, it seems kind of pointless to hide it here.\";",
            "v = verbs(o);",
            "if (v)",
            "vstr = tostr(\"[\", $string_utils:right(length(v), 3), \"] \");",
            "else",
            "vstr = \"      \";",
            "endif",
            "if (o.r && o.f)",
            "r = \"f\";",
            "elseif (o.r)",
            "r = \"r\";",
            "elseif (o.f)",
            "r = \"F\";",
            "else",
            "r = \" \";",
            "endif",
            "vstr = tostr(\" kK\"[kids + 1], r, $building_utils:audit_object_category(o), vstr);",
            "else",
            "vstr = \"\";",
            "endif",
            "if ($quota_utils.byte_based)",
            "vstr = tostr(this:size_string(`o.object_size[1] ! ANY => 0'), \" \", vstr);",
            "name_field_len = 26;",
            "else",
            "name_field_len = 30;",
            "endif",
            "if (valid(o.location))",
            "loc = ((((o.location.owner == o.owner) ? \" \" | \"*\") + \"[\") + o.location.name) + \"]\";",
            "elseif (typeof(o) == ANON)",
            "loc = \" \";",
            "elseif ($object_utils:has_property(o, \"dest\") && $object_utils:has_property(o, \"source\"))",
            "if (typeof(o.source) != OBJ)",
            "source = \" <non-object> \";",
            "elseif (!valid(o.source))",
            "source = \"<invalid>\";",
            "else",
            "source = o.source.name;",
            "if (o.source.owner != o.owner)",
            "source = \"*\" + source;",
            "endif",
            "endif",
            "if (typeof(o.dest) != OBJ)",
            "destin = \" <non-object> \";",
            "elseif (!valid(o.dest))",
            "destin = \"<invalid>\";",
            "else",
            "destin = o.dest.name;",
            "if (o.dest.owner != o.owner)",
            "destin = \"*\" + destin;",
            "endif",
            "endif",
            "srclen = min(length(source), 19);",
            "destlen = min(length(destin), 19);",
            "loc = ((\" \" + source[1..srclen]) + \"->\") + destin[1..destlen];",
            "elseif ($object_utils:isa(o, $room))",
            "loc = \"\";",
            "try",
            "for x in (o.entrances)",
            "if (((((typeof(x) == OBJ) && valid(x)) && (x.owner != o.owner)) && $object_utils:has_property(x, \"dest\")) && (x.dest == o))",
            "loc = ((loc + (loc ? \", \" | \"\")) + \"<-*\") + x.name;",
            "endif",
            "endfor",
            "except (ANY)",
            "if ($perm_utils:controls(player, o))",
            "loc = \" BROKEN PROPERTY: .entrances\";",
            "endif",
            "endtry",
            "else",
            "loc = \" [Nowhere]\";",
            "endif",
            "if (length(loc) > 41)",
            "loc = loc[1..37] + \"..]\";",
            "endif",
            "namelen = min(length(o.name), name_field_len - 1);",
            "return tostr(vstr, $string_utils:right(o, olen), \" \", $string_utils:left(o.name[1..namelen], name_field_len), loc);"
          ]
        },
        {
          "name": "do_audit do_prospectus",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\":do_audit(who, start, end, match)\";",
            "\"audit who, with objects from start to end that match 'match'\";",
            "\":do_prospectus(...)\";",
            "\"same, but with verb counts\";",
            "{who, start, end, match} = args;",
            "pros = verb == \"do_prospectus\";",
            "\"the set_task_perms is to make the task owned by the player. There are no other security aspects\";",
            "set_task_perms(caller_perms());",
            "if ((((((start == 0) && (end == toint(max_object()))) && (!match)) && (typeof(who.owned_objects) == LIST)) && (length(who.owned_objects) > 100)) && (!$command_utils:yes_or_no(tostr(who.name, \" has \", length(who.owned_objects), \" objects.  This will be a very long list.  Do you wish to proceed?\"))))",
            "v = pros ? \"@prospectus\" | \"@audit\";",
            "return player:tell(v, \" aborted.  Usage:  \", v, \" [player] [from <start>] [to <end>] [for <match>]\");",
            "endif",
            "player:tell(tostr(\"Objects owned by \", who.name, \" (from #\", start, \" to #\", end, match ? \" matching \" + match | \"\", \")\", \":\"));",
            "count = bytes = 0;",
            "if (typeof(who.owned_objects) == LIST)",
            "for o in (who.owned_objects)",
            "$command_utils:suspend_if_needed(0);",
            "if (!player:is_listening())",
            "return;",
            "endif",
            "if ((typeof(o) == ANON) || ((toint(o) >= start) && (toint(o) <= end)))",
            "didit = this:do_audit_item(o, match, pros);",
            "count = count + didit;",
            "if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, \"object_size\"))",
            "bytes = bytes + o.object_size[1];",
            "endif",
            "endif",
            "endfor",
            "else",
            "for i in [start..end]",
            "$command_utils:suspend_if_needed(0);",
            "o = toobj(i);",
            "if ($recycler:valid(o) && (o.owner == who))",
            "didit = this:do_audit_item(o, match, pros);",
            "count = count + didit;",
            "if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, \"object_size\"))",
            "bytes = bytes + o.object_size[1];",
            "endif",
            "endif",
            "endfor",
            "endif",
            "player:tell($string_utils:left(tostr(\"-- \", count, \" object\", (count == 1) ? \".\" | \"s.\", $quota_utils.byte_based ? tostr(\"  Total bytes: \", $string_utils:group_number(bytes), \".\") | \"\"), player:linelen() - 1, \"-\"));"
          ]
        },
        {
          "name": "do_audit_item",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\":do_audit_item(object, match-name-string, prospectus-flag)\";",
            "{o, match, pros} = args;",
            "found = match ? 0 | 1;",
            "names = `{o.name, @o.aliases} ! ANY => {o.name}';",
            "\"Above to get rid of screwed up aliases\";",
            "while (names && (!found))",
            "if (index(names[1], match) == 1)",
            "found = 1;",
            "endif",
            "names = listdelete(names, 1);",
            "endwhile",
            "if (found)",
            "\"From Dred---don't wrap long lines.\";",
            "line = $building_utils:object_audit_string(o, pros);",
            "player:tell(line[1..min($, player:linelen())]);",
            "return 1;",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "size_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "\"Copied from Roebare (#109000):size_string at Sat Nov 26 18:41:12 2005 PST\";",
            "size = args[1];",
            "if (typeof(size) != INT)",
            "return E_INVARG;",
            "endif",
            "if (`!player:build_option(\"audit_float\") ! ANY')",
            "\"...use integers to determine a four-char string...\";",
            "factor = 1000;",
            "threshold = {{1000, \"B\"}, {1000000, \"K\"}, {1000000000, \"M\"}};",
            "if (!size)",
            "return \" ???\";",
            "elseif ((size < 0) || (size > threshold[$][1]))",
            "if ((size < 0) || (size > $maxint))",
            "return \" >2G\";",
            "else",
            "\"...floats still required to factor over $maxint...\";",
            "return tostr($string_utils:right(floatstr(tofloat(size) / 1000000000.0, 0), 3), \"G\");",
            "endif",
            "elseif ((size < threshold[1][1]) && `!player:build_option(\"audit_bytes\") ! ANY')",
            "return \" <1K\";",
            "endif",
            "for entry in ($list_utils:slice(threshold, 1))",
            "$command_utils:suspend_if_needed(0);",
            "i = $list_utils:iassoc(entry, threshold);",
            "if (size == entry)",
            "size = \"1\";",
            "try",
            "unit = threshold[i + 1][2];",
            "except error (E_RANGE)",
            "unit = \"G\";",
            "endtry",
            "break;",
            "elseif (size < entry)",
            "size = tostr(size / (entry / factor));",
            "unit = threshold[i][2];",
            "break;",
            "endif",
            "endfor",
            "return tostr($string_utils:right(size, 3), unit);",
            "else",
            "\"...use floats to determine a six-char string...\";",
            "size = tofloat(size);",
            "factor = 1024.0;",
            "\"...be precise, `((1024.00 * 1024.00) * 1024.00) * 1024.00'...\";",
            "threshold = {{1048576.0, \"K\"}, {1073741824.0, \"M\"}, {1099511627776.0, \"G\"}};",
            "if (!size)",
            "return \"   ???\";",
            "elseif ((size < 0.0) || (size > threshold[$][1]))",
            "\"...special handling for bad conversions & big numbers...\";",
            "if ((size < 0.0) || (size > tofloat($maxint)))",
            "return \"   >2G\";",
            "else",
            "return tostr($string_utils:right(floatstr(size / 1000000000.0, 1), 3), \"G\");",
            "endif",
            "endif",
            "for entry in ($list_utils:slice(threshold, 1))",
            "$command_utils:suspend_if_needed(0);",
            "i = $list_utils:iassoc(entry, threshold);",
            "if (size == entry)",
            "size = \"1\";",
            "try",
            "unit = threshold[i + 1][2];",
            "except error (E_RANGE)",
            "\"...in another decade, maybe...\";",
            "unit = \"T\";",
            "endtry",
            "break;",
            "elseif (size < entry)",
            "size = floatstr(size / (entry / factor), 1);",
            "unit = threshold[i][2];",
            "break;",
            "endif",
            "endfor",
            "return tostr($string_utils:right(size, 5), unit);",
            "endif",
            "\"Rewritten by Roebare (#109000), 051119-26\";",
            "\"With inspiration from Miral (#107983) and assistance from Diopter (#98842)\";",
            "\"Byte & float display optional, per Nosredna (#2487), 051120-24\";"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 21,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.classes = {$player, $room, $exit, $note, $container, $thing, $feature, $mail_recipient, $generic_help, $generic_db, $generic_utils, $generic_options};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "classes",
        "class_string"
      ],
      "propdefs": [
        {
          "value": [
            6,
            3,
            7,
            9,
            8,
            5,
            74,
            45,
            30,
            37,
            78,
            68
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "p",
            "R",
            "E",
            "N",
            "C",
            "T",
            "F",
            "M",
            "H",
            "D",
            "U",
            "O"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "Verbs useful for building.  For a complete description of a given verb, do `help $building_utils:verbname'.",
            "",
            "make_exit(spec,source,dest[,don't-really-create]) => a new exit",
            "          spec is an exit-spec as described in `help @dig'",
            "",
            "set_names(object, spec) - sets name and aliases for an object",
            "parse_names(spec) => list of {name, aliases}",
            "          in both of these, spec is of the form",
            "            <name>[[,:]<alias>,<alias>,...]",
            "          (as described in `help @rename')",
            "",
            "recreate(object, newparent) - effectively recycle and recreate object",
            "          as a child of newparent"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "building",
            "utils"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the building utilities utility package.  See `help $building_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            19173,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "22": {
      "id": 22,
      "name": "Programmer Help",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "errors",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 22,
          "code": [
            "text = args[1];",
            "for i in [1..length($code_utils.error_list)]",
            "text = {@text, tostr(\"    \", $string_utils:left($code_utils.error_names[i], 15), $code_utils.error_list[i])};",
            "endfor",
            "return text;"
          ]
        },
        {
          "name": "prepositions",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 22,
          "code": [
            "text = args[1];",
            "for p in ($code_utils:prepositions())",
            "text = {@text, tostr($string_utils:space(4), p)};",
            "endfor",
            "return text;"
          ]
        }
      ],
      "propnames": [
        "@check-property",
        "@check-chparent",
        "@egrep",
        "regular-expressions",
        "@show",
        "@grep",
        "prog-index",
        "help",
        "prepositions",
        ";",
        "utilities",
        "truth",
        "tasks",
        "statements",
        "programming",
        "precedence",
        "language",
        "functions",
        "expressions",
        "eval",
        "errors",
        "@verb",
        "@setenv",
        "@rmverb",
        "@rmproperty",
        "@prospectus",
        "@property",
        "@program",
        "@list",
        "@kill",
        "@kids",
        "@forked",
        "@display",
        "@dbsize",
        "@copy",
        "@chparent",
        "@chmod",
        "@args",
        ".program",
        "@clearproperty",
        "@disown",
        "@disinherit",
        "@displayoptions",
        "@display-options",
        "@add-feature",
        "@remove-feature",
        "features",
        "examine",
        "mail",
        "#",
        "@programmer-options",
        "@programmeroptions",
        "@progoptions",
        "@prog-options",
        "options",
        "utils",
        "@killquiet",
        "scattering",
        ".flush",
        "@rmverb#",
        "@list#",
        "@program#",
        "@args#",
        "@chmod#",
        "@rename#",
        "@addalias#",
        "@add-alias#",
        "@rmalias#",
        "@rm-alias#",
        "checkpoint-programming",
        "@grepall",
        "@egrepall",
        "@properties",
        "@props"
      ],
      "propdefs": [
        {
          "value": [
            "*forward*",
            "@check-chparent"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @check-property <object>.<propname>",
            "         @check-chparent <object> to <newparent>",
            "         ",
            "You cannot add a new property to an object if an ancestor or a descendant already defines a property with the same name.  @check-property will give you the list of all descendants of <object> that that define .<propname>.  ",
            "",
            "Likewise you cannot chparent an object to a new parent if the new parent has a property that is also defined on the object or some descendant.  Use @check-chparent to find out all instances of conflicting properties that would interfere with @chparent in this manner.",
            "",
            "Note that @check-property requires either that you own the object or that it be writeable, the same conditions that need to hold if you are to create new properties on the object.  Similarly, @check-chparent requires that you own the object and that the new parent is either fertile or likewise owned by you.",
            "",
            "For objects with large numbers of descendants, these commands can be time-consuming."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Regular expression matching allows you to test whether a string fits into a specific syntactic shape.  You can also search a string for a substring that fits a pattern.  See also the built-in function match()/rmatch().",
            "",
            "A regular expression describes a set of strings.  The simplest case is one that describes a particular string; for example, the string `foo' when regarded as a regular expression matches `foo' and nothing else.  Nontrivial regular expressions use certain special constructs so that they can match more than one string.  For example, the regular expression `foo%|bar' matches either the string `foo' or the string `bar'; the regular expression `c[ad]*r' matches any of the strings `cr', `car', `cdr', `caar', `cadddar' and all other such strings with any number of `a''s and `d''s.",
            "",
            "Regular expressions have a syntax in which a few characters are special constructs and the rest are \"ordinary\".  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are `$', `^', `.', `*', `+', `?', `[', `]' and `%'.  Any other character appearing in a regular expression is ordinary, unless a `%' precedes it.",
            "",
            "For example, `f' is not a special character, so it is ordinary, and therefore `f' is a regular expression that matches the string `f' and no other string.  (It does *not*, for example, match the string `ff'.)  Likewise, `o' is a regular expression that matches only `o'.",
            "",
            "Any two regular expressions A and B can be concatenated.  The result is a regular expression which matches a string if A matches some amount of the beginning of that string and B matches the rest of the string.",
            "",
            "As a simple example, we can concatenate the regular expressions `f' and `o' to get the regular expression `fo', which matches only the string `fo'.  Still trivial.",
            "",
            "The following are the characters and character sequences that have special meaning within regular expressions.  Any character not mentioned here is not special; it stands for exactly itself for the purposes of searching and matching.",
            "",
            "`.'  is a special character that matches any single character.  Using",
            "     concatenation, we can make regular expressions like `a.b', which matches",
            "     any three-character string that begins with `a' and ends with `b'.",
            "",
            "`*'  is not a construct by itself; it is a suffix that means that the preceding",
            "     regular expression is to be repeated as many times as possible.  In `fo*',",
            "     the `*' applies to the `o', so `fo*' matches `f' followed by any number of",
            "     `o''s.",
            "",
            "     The case of zero `o''s is allowed: `fo*' does match `f'.",
            "",
            "     `*' always applies to the *smallest* possible preceding expression.  Thus,",
            "     `fo*' has a repeating `o', not a repeating `fo'.",
            "",
            "     The matcher processes a `*' construct by matching, immediately, as many",
            "     repetitions as can be found.  Then it continues with the rest of the",
            "     pattern.  If that fails, it backtracks, discarding some of the matches of",
            "     the `*''d construct in case that makes it possible to match the rest of",
            "     the pattern.  For example, matching `c[ad]*ar' against the string",
            "     `caddaar', the `[ad]*' first matches `addaa', but this does not allow the",
            "     next `a' in the pattern to match.  So the last of the matches of `[ad]' is",
            "     undone and the following `a' is tried again.  Now it succeeds.",
            "",
            "`+'  is like `*' except that at least one match for the preceding pattern is",
            "     required for `+'.  Thus, `c[ad]+r' does not match `cr' but does match",
            "     anything else that `c[ad]*r' would match.",
            "",
            "`?'  is like `*' except that it allows either zero or one match for the",
            "     preceding pattern.  Thus, `c[ad]?r' matches `cr' or `car' or `cdr', and",
            "     nothing else.",
            "",
            "`[ ... ]'",
            "     `[' begins a \"character set\", which is terminated by a `]'.  In the",
            "     simplest case, the characters between the two brackets form the set.",
            "     Thus, `[ad]' matches either `a' or `d', and `[ad]*' matches any string of",
            "     `a''s and `d''s (including the empty string), from which it follows that",
            "     `c[ad]*r' matches `car', etc.",
            "",
            "     Character ranges can also be included in a character set, by writing two",
            "     characters with a `-' between them.  Thus, `[a-z]' matches any lower-case",
            "     letter.  Ranges may be intermixed freely with individual characters, as in",
            "     `[a-z$%.]', which matches any lower case letter or `$', `%' or period.",
            "",
            "     Note that the usual special characters are not special any more inside a",
            "     character set.  A completely different set of special characters exists",
            "     inside character sets: `]', `-' and `^'.",
            "",
            "     To include a `]' in a character set, you must make it the first character.",
            "     For example, `[]a]' matches `]' or `a'.  To include a `-', you must use it",
            "     in a context where it cannot possibly indicate a range: that is, as the",
            "     first character, or immediately after a range.",
            "",
            "`[^ ... ]'",
            "     `[^' begins a \"complement character set\", which matches any character",
            "     except the ones specified.  Thus, `[^a-z0-9A-Z]' matches all characters",
            "     *except* letters and digits.",
            "",
            "     `^' is not special in a character set unless it is the first character.",
            "     The character following the `^' is treated as if it were first (it may be",
            "     a `-' or a `]').",
            "",
            "`^'  is a special character that matches the empty string -- but only if at the",
            "     beginning of the string being matched.  Otherwise it fails to match",
            "     anything.  Thus, `^foo' matches a `foo' which occurs at the beginning of",
            "     the string.",
            "",
            "`$'  is similar to `^' but matches only at the *end* of the string.  Thus,",
            "     `xx*$' matches a string of one or more `x''s at the end of the string.",
            "",
            "`%'  has two functions: it quotes the above special characters (including `%'),",
            "     and it introduces additional special constructs.",
            "",
            "     Because `%' quotes special characters, `%$' is a regular expression that",
            "     matches only `$', and `%[' is a regular expression that matches only `[',",
            "     and so on.",
            "",
            "     For the most part, `%' followed by any character matches only that",
            "     character.  However, there are several exceptions: characters that, when",
            "     preceded by `%', are special constructs.  Such characters are always",
            "     ordinary when encountered on their own.",
            "",
            "     No new special characters will ever be defined.  All extensions to the",
            "     regular expression syntax are made by defining new two-character",
            "     constructs that begin with `%'.",
            "",
            "`%|' specifies an alternative.  Two regular expressions A and B with `%|' in",
            "     between form an expression that matches anything that either A or B will",
            "     match.",
            "",
            "     Thus, `foo%|bar' matches either `foo' or `bar' but no other string.",
            "",
            "     `%|' applies to the largest possible surrounding expressions.  Only a",
            "     surrounding `%( ... %)' grouping can limit the grouping power of `%|'.",
            "",
            "     Full backtracking capability exists for when multiple `%|''s are used.",
            "",
            "`%( ... %)'",
            "     is a grouping construct that serves three purposes:",
            "",
            "       1. To enclose a set of `%|' alternatives for other operations.  Thus,",
            "          `%(foo%|bar%)x' matches either `foox' or `barx'.",
            "",
            "       2. To enclose a complicated expression for a following `*', `+', or `?'",
            "          to operate on.  Thus, `ba%(na%)*' matches `bananana', etc., with any",
            "          number of `na''s, including none.",
            "",
            "       3. To mark a matched substring for future reference.",
            "",
            "     This last application is not a consequence of the idea of a parenthetical",
            "     grouping; it is a separate feature that happens to be assigned as a second",
            "     meaning to the same `%( ... %)' construct because there is no conflict in",
            "     practice between the two meanings.  Here is an explanation of this",
            "     feature:",
            "",
            "`%DIGIT'",
            "     After the end of a `%( ... %)' construct, the matcher remembers the",
            "     beginning and end of the text matched by that construct.  Then, later on",
            "     in the regular expression, you can use `%' followed by DIGIT to mean",
            "     \"match the same text matched by the DIGIT'th `%( ... %)' construct in the",
            "     pattern.\"  The `%( ... %)' constructs are numbered in the order that their",
            "     `%(''s appear in the pattern.",
            "",
            "     The strings matching the first nine `%( ... %)' constructs appearing in a",
            "     regular expression are assigned numbers 1 through 9 in order of their",
            "     beginnings.  `%1' through `%9' may be used to refer to the text matched by",
            "     the corresponding `%( ... %)' construct.",
            "",
            "     For example, `%(.*%)%1' matches any string that is composed of two",
            "     identical halves.  The `%(.*%)' matches the first half, which may be",
            "     anything, but the `%1' that follows must match the same exact text.",
            "",
            "`%b' matches the empty string, but only if it is at the beginning or end of a",
            "     word.  Thus, `%bfoo%b' matches any occurrence of `foo' as a separate word.",
            "     `%bball%(s%|%)%b' matches `ball' or `balls' as a separate word.",
            "",
            "     For the purposes of this construct and the five that follow, a word is",
            "     defined to be a sequence of letters and/or digits.",
            "",
            "`%B' matches the empty string, provided it is *not* at the beginning or end of",
            "     a word.",
            "",
            "`%<' matches the empty string, but only if it is at the beginning of a word.",
            "",
            "`%>' matches the empty string, but only if it is at the end of a word.",
            "",
            "`%w' matches any word-constituent character (i.e., any letter or digit).",
            "",
            "`%W' matches any character that is not a word constituent."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @show <object>",
            "         @show <object>.<prop-name>",
            "         @show <object>:<verb-name>",
            "",
            "Displays quite detailed information about an object, property or verb, including its name, owner, permission bits, etc.  The information displayed for an object can be quite long.",
            "",
            "See also @display, which displays different information and is controlled differently."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @grep     <string> in <object>|{<objectlist>}",
            "         @egrep    <regexp> in <object>|{<objectlist>}",
            "         @grepall  <string> in <object>|{<objectlist>}",
            "         @egrepall <regexp> in <object>|{<objectlist>}",
            "",
            "@grep (@grepall) searches the given object(s) for verbs whose verbcode contains the given string as a substring of one of its lines.  ",
            "@egrep (@egrepall) searches the given object(s) for verbs whose verbcode contains a substring matching the given regular expression (see `help regular-expressions').",
            "",
            "@grep and @egrep print just the first matching line in each verb found.",
            "@grepall and @egrepall printed every matching line.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Programmer Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "help",
            "",
            "For programmers, the help system provides the following additional forms:",
            "",
            "  help object:verbname   -- prints any documentation strings that are present",
            "                            at the beginning of the program for that verb.",
            "  help $<whatever>_utils -- prints general information about one of the ",
            "                            $..._utils objects (e.g., $string_utils, ",
            "                            $list_utils, etc...), which are all libraries ",
            "                            of generally used verbs.",
            "  help builtin()         -- prints documentation from the programmers manual",
            "                            about the named primitive, for example length()",
            "",
            "For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*prepositions*",
            "The complete list of prepositions recognized by the command-line parser:",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "eval"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The core database has a number of objects serving as libraries of useful verbs.",
            "More detailed information can be obtained for (some of) these, via `help $whatever_utils'",
            "",
            "$building_utils -- ",
            "$code_utils     -- parsing and manipulating verb code",
            "$command_utils  -- reporting matching errors to the player",
            "$gender_utils   -- managing gendered objects",
            "$list_utils     -- list manipulation",
            "$set_utils      -- set manipulation",
            "$lock_utils     -- key expression manipulation",
            "$match_utils    -- ",
            "$object_utils   -- object information ",
            "                  (inheritance/location hierarchy, verb/property lists)",
            "$perm_utils     -- permissions",
            "$string_utils   -- string manipulation",
            "$time_utils     -- time (numeric and verbal) manipulation",
            "$trig_utils     -- trigonometric and other numerical utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Several kinds of statements, expressions, and functions in the MOO programming language use a notion that some MOO values are 'true' and others 'false'.",
            "",
            "The only values that are considered true are non-zero numbers, non-empty strings, and non-empty lists.",
            "",
            "All other values (i.e., 0, \"\", {}, objects, and errors) are considered false."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "A task is an execution of a MOO program.  There are five ways for tasks to be created in LambdaMOO:",
            "   + Every time a player types a command, a task is created to execute that command; we call these 'command tasks'.",
            "   + Whenever a player connects or disconnects from the MOO, the server starts a task to do whatever processing is necessary, such as printing out 'Munchkin has connected' to all of the players in the same room; these are called 'server tasks'.",
            "   + The FORK statement in the programming language creates a task whose execution is delayed for at least some given number of seconds; these are 'forked tasks'.",
            "   + The suspend() function suspends the execution of the current task.  A snapshot is taken of whole state of the execution, and the execution will be resumed later.  These are called `suspended tasks'.",
            "   + The read() function also suspends the execution of the current task, in this case waiting for the player to type a line of input.  When the line is received, the task resumes with the read() function returning the input line as result.  These are called `reading tasks'.",
            "",
            "The last three kinds of tasks above are collectively known as `queued tasks' or `waiting tasks', since they may not run immediately.",
            "",
            "To prevent a maliciously- or incorrectly-written MOO program from running forever and monopolizing the server, limits are placed on the running time of every task. One limit is on the length of time that tasks are allowed to run: queued tasks are given %[tostr(typeof(bgs = $server_options.bg_seconds) == ERR ? 3 | bgs)], and all other tasks, %[tostr(typeof(fgs = $server_options.fg_seconds) == ERR ? 5 | fgs)] seconds to run, after which they will - if they don't suspend() or end first - raise a 'Task ran out of seconds' traceback and die. But there is a second limit which is on the number of operations a task may execute.",
            "",
            "The server counts down 'ticks' as any task executes.  Roughly speaking, it counts one tick for every expression evaluation (other than variables and literals), one for every `if', `fork' or `return' statement, and one for every iteration of a loop.  If the count gets all the way down to zero, a 'Task ran out of ticks' traceback is raised and the task is immediately and unceremoniously aborted.  Queued tasks begin with %[$string_utils:group_number(typeof(bgt = $server_options.bg_ticks) == ERR ? 10000 | bgt)], and all other tasks with %[$string_utils:group_number(typeof(fgt = $server_options.fg_ticks) == ERR ? 30000 | fgt)] ticks.",
            "",
            "Because queued tasks may exist for long periods of time before they begin execution, there are commands to list the ones that you own and to kill them before they execute.  These commands are covered in the following help topics:",
            "",
            "@forked -- listing the forked tasks that you own",
            "@kill -- killing a particular forked task"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The following kinds of statements exist in the MOO programming language:",
            "",
            "        ;",
            "The null statement does nothing.",
            "",
            "        expression ;",
            "The expression statement evaluates the expression and then discards the value.",
            "",
            "        IF ( expression ) statements ENDIF",
            "        IF ( expression ) statements ELSE statements ENDIF",
            "        IF ( expression )",
            "          statements",
            "        ELSEIF ( expression )",
            "          statements",
            "        ...",
            "        ELSE",
            "          statements",
            "        ENDIF",
            "The conditional statement evaluates each expression in turn and executes the statements associated with the first one to return a true value; the ELSE statements are executed if none of the expressions returns a true value.  There can be any number of ELSEIF clauses and the ELSE part is optional.  See 'help truth' for the definition of 'true value'.",
            "",
            "        FOR name IN ( expression ) statements ENDFOR",
            "The list iteration statement first evaluates the expression, which must return a list.  It then executes the statements once for each element of that list, each time with the named variable having the value of the corresponding list element.",
            "",
            "        FOR name IN [ expression .. expression ] statements ENDFOR",
            "The numeric iteration statement first evaluates the two expressions, both of which must return numbers; call those numbers N1 and N2, respectively.  The statements are then executed once for each integer I such that N1 <= I <= N2, in increasing order; each time, the named variable has the corresponding value of I.",
            "",
            "        WHILE ( expression ) statements ENDWHILE",
            "        WHILE name ( expression ) statements ENDWHILE",
            "The indefinite iteration statement repeatedly evaluates the expression and, each time it returns a true value, executes the statements.  The loop stops the first time that the expression returns a false value.  The definitions of 'true' and 'false' values is in 'help truth'.",
            "",
            "        BREAK ;",
            "        BREAK name ;",
            "Each `break' statement indicates a specific surrounding loop; if <name> is not given, the statement refers to the innermost one. If it is given, <name> must be the name appearing right after the `for' or `while' keyword of the desired enclosing loop. When the `break' statement is executed, the indicated loop is immediately terminated and executing continues just as if the loop had completed its iterations normally.",
            "",
            "        CONTINUE ;",
            "        CONTINUE name ;",
            "Allows you to terminate just the current iteration of a loop, making it immediately go on to the next one if any. ",
            "",
            "        RETURN ;",
            "        RETURN expression ;",
            "The return statement evaluates the expression, if any, and returns the resulting value (or 0 if there is no expression) to the verb that called the current one.  Execution of the current verb is immediately terminated.",
            "",
            "        TRY",
            "          statements-0 ;",
            "        EXCEPT variable-1 (codes-1)",
            "          statements-1 ;",
            "        EXCEPT variable-2 (codes-2)",
            "          statements-2 ;",
            "        ... (up to 255)",
            "        ENDTRY",
            "Each of the `statements-x' may be any number or combination of MOO statements and function calls. Each of the `codes-x' may be either the keyword `ANY' or else a comma-separated list of expressions that yield error codes. If the execution of `statements-0' raises an error listed in the `codes-x', then the statements associated in that EXCEPT clause where the code was listed are executed. When this occurs, `variable-x' is assigned this information about the error being raised:  {<error code>, <error message>, <value>, <traceback>}. If the error raised is not listed in any EXCEPT clause (which means the `ANY' keyword was not used), then the error continues to be raised. ",
            "",
            "        TRY",
            "          statements-0 ;",
            "        FINALLY",
            "          statements-last ;",
            "        ENDTRY",
            "In this construct, `statements-0' are executed. Then, whether an error was raised by their execution or not, `statements-last' are executed. If `statements-0' transfers control somewhere else, that transfer is interrupted so that `statements-last' can be run. If `statements-last' transfers control, then that overrides the first transfer. (Transfers include raising an error, returning from this verb, terminating the current iteration of a surrounding loop). `Statements-last' will always be executed, providing a good place for necessary cleanup code that will run even if `statements-0' doesn't simply run normally to completion.",
            "",
            "        FORK ( expression ) statements ENDFORK",
            "        FORK name ( expression ) statements ENDFORK",
            "The fork statement first executes the expression, which must return a number; call that number N.  It then creates a new MOO task that will, after at least N seconds, execute the statements.  When the new task begins, all variables will have the values they had at the time the FORK statement was executed.  The task executing the FORK statement immediately continues execution.  If a variable name is given after the FORK keyword, then it is assigned the 'queue ID' of the newly-created task.  The value of this variable is visible both to the task executing the fork statement and to the statements in the newly-created task.  See 'help tasks' for more information about forked tasks."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.  Help is available on the following topics concerning programming in MOO:",
            "",
            "language -- a brief reference for the syntax and semantics of the MOO language",
            "tasks -- a brief description of MOO tasks and their resource limits",
            "",
            "@property -- adding a property to an object",
            "@rmproperty -- removing a property from an object",
            "",
            "@verb   -- adding a verb to an object",
            "@rmverb -- removing a verb from an object",
            "@args   -- changing the syntax of a verb",
            "@copy   -- copying a verb from one object to another",
            "",
            ".program/@program -- entering the program for a verb",
            "@list -- printing a listing of the program for a verb",
            "@edit -- editing verb code",
            "",
            "@show     -- looking at all the details of an object, a property, or a verb",
            "@parents  -- listing the ancestors of an object",
            "@kids     -- listing the children of an object",
            "@contents -- listing the contents of an object",
            "@chmod    -- changing the permissions on an object, a property, or a verb",
            "@chparent -- changing the parent of an object",
            "@rename   -- changing the name of a verb or object",
            "",
            "eval -- executing MOO statements and expressions without writing a verb"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The table below gives the relative precedence of all of the MOO operators; operators on higher lines in the table have higher precedence and those on the same line have identical precedence:",
            "",
            "        !       - (without a left operand)",
            "        ^",
            "        *       /       %",
            "        +       -",
            "        ==      !=      <       <=      >       >=      in",
            "        &&      ||",
            "        ... ? ... | ... (the conditional expression)",
            "        =",
            "",
            "Thus, the horrendous expression",
            "",
            "        x = a < b && c > d + e * f ? w in y | - q - r",
            "",
            "would be grouped as follows:",
            "",
            "        x = (((a < b) && (c > (d + (e * f)))) ? (w in y) | ((- q) - r))"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The MOO programming language is described in excruciating detail in the LambdaMOO Programmer's Manual, available for download at http://lambda.moo.mud.org/pub/MOO/html/ProgrammersManual_toc.html.  The online help consists of a few quick reference guides here in the help system under the following topics:",
            "",
            "statements -- the syntax and semantics of the various kinds of MOO statements",
            "expressions -- the same for the various kinds of MOO expressions",
            "functions -- a list of the primitive functions available to MOO programs"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "There are many, many built-in functions available to MOO programmers.  The following list gives a brief summary of the arguments and purpose of each function; for more information, see the LambdaMOO Programmer's Manual.  ",
            "",
            "pass(arg, ...)   -- calling a verb defined on this object's parent",
            "",
            "time()           -- current time in seconds since midnight GMT, 1 Jan 70",
            "ctime([time])    -- time (or current time) converted to a human-readable string",
            "",
            "eval(string)     -- parsing and executing strings as MOO code",
            "",
            "typeof(value)      -- determining the data type of a value",
            " tostr(value, ...) -- converting any set of values into a string",
            " toint(value)      -- converting any non-list value into an integer",
            " tonum(value)      -- converting any non-list value into an integer (obsolete)",
            " tofloat(value)    -- converting any non-list value into a floating-point",
            " toobj(value)      -- converting any non-list value into an object",
            " toliteral(value)  -- converting any value into a literal string",
            "length(value)      -- returns the length of a string or list",
            "",
            "equal(val1, val2)          -- is val1 indistinguishable from val2",
            "min(n1, n2, ...)           -- minimum of n1,n2,...",
            "max(n1, n2, ...)           -- maximum of n1,n2,...",
            "abs(n)                     -- absolute value of n",
            "sin(n), cos(n), tan(n)     -- sine, cosine, tangent of n",
            "asin(n), acos(n), atan(n)  -- arc-sine, arc-cosine, arc-tangent of n",
            "sinh(n), cosh(n), tanh(n)  -- hyperbolic sine, cosine, tangent of n",
            "exp(n)                     -- `e' raised to the power of n",
            "log(n), log10(n)           -- natural or base 10 logarithm of n (n > 0)",
            "sqrt(n)                    -- square root of n, rounded down",
            "random(n)                  -- random integer between 1 and n inclusive",
            "floatstr(float, precision, sci) -- format a floating-point into string",
            "ceil(f)          -- smallest integer > float f as a floating-point",
            "floor(f)         -- largest integer < float f as floating-point",
            "trunc(f)         -- truncate f at the decimal point, as floating-point",
            "",
            "index(str1, str2 [, case-matters])  -- index of first str2 in str1",
            "rindex(str1, str2 [, case-matters]) -- index of last  str2 in str1",
            "strcmp(str1, str2) -- case-sensitive string comparison",
            "strsub(subject, what, with [, case-matters]) -- substitution in a string",
            "match(str1, str2 [, case-matters])  -- match first regular expr str2 in str1",
            "rmatch(str1, str2 [, case-matters]) -- match last regular expr str2 in str1",
            "substitute(template, subs)          -- perform substitutions on template",
            "",
            "decode_binary(bin-string [, fully]) -- convert from a binary string",
            "encode_binary(arg, ...)             -- convert to a binary string",
            "      crypt(string [, salt])        -- one-way string encryption",
            "string_hash(text)                 -- MD5 cryptographically secure hash of text",
            "binary_hash(bin-string)           -- same but for a binary string",
            " value_hash(value)                -- string_hash(toliteral(value))",
            "",
            " is_member(value, list)           -- is exact value (case sensitive) in list",
            "listappend(list, value [, index]) -- adding an element at the end of a list",
            "listinsert(list, value [, index]) -- adding an element at the head of a list",
            "   listset(list, value, index)    -- updating a list at some index",
            "listdelete(list, index)           -- removing an element from a list",
            "    setadd(list, element) -- adding an element to a set represented as a list",
            " setremove(list, element) -- removing an element from such a set",
            "",
            "   valid(object)             -- testing whether an object exists",
            "  create(parent [, owner(*)])-- creating a new MOO object",
            " recycle(object)             -- destroying a MOO object",
            "    move(object, where)      -- altering the object-containment hierarchy",
            "chparent(object, new-parent) -- altering the object-inheritance hierarchy",
            "  parent(object)             -- object's parent   in the inheritance hierarchy",
            "children(object)             -- object's children in the inheritance hierarchy",
            "max_object()       -- the highest-numbered object in the MOO",
            "renumber(obj)      -- changes an object's number to lowest available one (*)",
            "reset_max_object() -- resets max_object() to the largest valid object (*)",
            "",
            "     properties(object) -- a list of the properties defined on an object",
            "   add_property(object, prop-name, value, info) -- add a new property",
            "delete_property(object, prop-name)              -- remove a property",
            "    property_info(object, prop-name)       -- {owner, perms} info on a property",
            "set_property_info(object, prop-name, info) -- setting same",
            "is_clear_property(object, prop-name) -- find out if a property is \"clear\"",
            "   clear_property(object, prop-name) -- make a property \"clear\"",
            "",
            "      verbs(object) -- a list of the verbs defined on an object",
            "   add_verb(object, info, args)  -- add a verb to an object",
            "delete_verb(object, verb-name)   -- remove a verb from an object",
            "    verb_info(object, verb-name) -- {owner, perms, names} info for a verb defn.",
            "    verb_args(object, verb-name) -- {dobj, prep, iobj} argument info for a verb",
            "    verb_code(object, verb-name [, fully-paren [, indent]]) -- program listing",
            "set_verb_info(object, verb-name, {owner, perms, names})",
            "set_verb_args(object, verb-name, {dobj, prep, iobj})   ",
            "set_verb_code(object, verb-name, {line, line, ...})",
            "disassemble(object, verb-desc)   -- listing of server's internal `compile' ",
            "",
            "        is_player(object) -- testing whether or not object is a player",
            "          players()       -- a list of all players, active or not",
            "connected_players()       -- a list of all currently-connected players",
            "     idle_seconds(player) -- seconds since given player typed anything",
            "connected_seconds(player) -- seconds given player has been logged in",
            "    boot_player(player)        -- disconnect player from the MOO immediately(*)",
            "set_player_flag(player, value) -- set/clear player bit; boot player if clear(*)",
            "connection_name(player)   -- a server-assigned name for player's connection",
            "",
            "open_network_connection(@args) -- open a connection to another network site (*)",
            "notify(player, string)    -- sending text to a player's terminal",
            "read()                    -- reading a line of input from the player (*)",
            "buffered_output_length([player])      -- how much output pending",
            "force_input(player, str [, at-front]) -- put str in player's output queue",
            "flush_input(player [, show-messages]) -- clear a player's output queue",
            "output_delimiters(player) -- return {prefix,suffix} set by PREFIX/SUFFIX cmds",
            "set_connection_option(player, option, value) -- set I/O options for player",
            "   connection_options(player) -- list current I/O options for player",
            "    connection_option(player, option) -- return setting of option for player",
            "",
            "   listen(conn, point [, print-messages]) -- create server listening point (*)",
            "u nlisten(canon) -- close the server listening point described by canon (*)",
            "listeners() -- list of all listening points",
            "",
            "        raise(code [, message [, value]]) -- raise code just like an error",
            "call_function(func-name, arg, ...)        -- call func-name",
            "function_info([name])   -- descriptions of available built-in functions",
            "",
            "caller_perms()         -- the player whose permissions your caller was using",
            "set_task_perms(player) -- changing permissions of the running task (*)",
            "callers()      -- list of {obj, verb, owner, vloc, player}: this task's stack",
            "suspend([secs])  -- suspending the current task for a number of seconds",
            "resume(task [, value]) -- resume the given task with value returned",
            "seconds_left() -- number of seconds left in the current task",
            "ticks_left()   -- number of ticks   left in the current task",
            "task_id()      -- a random number representing the currently-running task",
            "queue_info([player]) -- who has tasks, or how many player has",
            "queued_tasks() -- list of {id,start,0,20000,owner,obj,verb,line,this}",
            "kill_task(id)  -- delete one of your tasks from the queue",
            "task_stack(task-id [, include-line-numbers]) -- info about suspended task",
            "",
            "server_log(string) -- add a comment to the server log file",
            "server_version() -- a string of three numbers \"major.minor.release\"",
            "memory_usage()   -- {{blocksize, nused, nfree}, ...}, the server's memory stats",
            "shutdown(msg)    -- print msg and kill the server (*)",
            "dump_database()  -- what it says (*)",
            "db_disk_size()   -- size in bytes of recent full database",
            "",
            " value_bytes(value)  -- memory required to store value",
            "object_bytes(object) -- memory required to store object",
            "",
            "(*) => as you might have expected, these usually require wizard permissions."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The following kinds of expressions exist in the MOO programming language:",
            "",
            "        number",
            "        # integer",
            "        # - integer",
            "        \"character string\"",
            "        error-name",
            "Literal expressions return the obvious values: numbers (floating-point or integers), object numbers, strings, and errors.",
            "",
            "        { expression , expression , ... , expression }",
            "The list-construction expression evaluates the each of the expressions in turn and returns a list whose elements are the results of those expressions.  Any of the expressions may be prefixed with an at-sign ('@'); in this case, that expression must return a list and, rather than that list becoming an element of the final list, its elements are spliced into the final list.",
            "",
            "        name",
            "Variable expressions return the current value of the named variable.  Variable names must start with a letter or underscore ('_') and contain only letters, digits, and underscores.  The following variables are predefined:",
            "            OBJ, STR, LIST, ERR, INT, FLOAT, NUM (same as INT)",
            "            player, caller, this, verb, args",
            "            argstr, dobj, dobjstr, prepstr, iobj, iobjstr",
            "Their initial values are described in detail in the LambdaMOO Programmer's Manual.",
            "",
            "        expression . name",
            "        expression . ( expression )",
            "        $ name",
            "Property-reading expressions return the current value of a named property on the object that is the value of the first subexpression.  In the second form, the second subexpression must return a string, the name of the property to be read.  The third form is an abbreviation for '#0.name'.",
            "",
            "        expression : name ( arguments )",
            "        expression : ( expression ) ( arguments )",
            "Verb-call expressions invoke a named verb on the object that is the value of the first subexpression, passing the given arguments.  In the second form, the second subexpression must return a string, the name of the verb to invoke.  The syntax and semantics of arguments is exactly as in the list-construction expression but no initial or final curly-braces ('{' or '}') are used.",
            "",
            "        function ( arguments )",
            "The function-call expression invokes one of the MOO primitive functions, as listed in 'help functions', passing the given arguments.",
            "",
            "        expression [ expression ]",
            "The indexing expression first evaluates the two subexpressions; call their values S and N, respectively.  S must be a string or a list and N must be a integer between 1 and the length of S, inclusive.  The Nth element of S is returned.  The elements of a string are themselves one-character strings. The special character `$' maybe used for N as shorthand for the length of the string or list S.",
            "",
            "        expression [ expression .. expression ]",
            "The subsequence expression first evaluates the three subexpressions; call their values S, N1, and N2, respecitively.  S must be a string or a list and N1 and N2 must be integers.  If N1 <= N2, then both must be between 1 and the length of S, inclusive (the shorthand character `$' may be used); the subsequence of S beginning at index N1 and continuing through index N2 is returned.  If N1 > N2, the empty sequence of the same type as S is returned, either \"\" or {}.",
            "",
            "        name = expression",
            "        expression . name = expression",
            "        expression . ( expression ) = expression",
            "        $ name = expression",
            "Assignment expressions give new values to variables and object properties.  For the second and third forms, the expressions on the left-hand side of the '=' are evaluated first.  Then the right-hand side expression is evaluated and result is stored in the indicated variable or object property.",
            "There is a special kind of assignment involving lists on the left hand side. See `help scattering' for details.",
            "",
            "        expression + expression",
            "        expression - expression",
            "        expression * expression",
            "        expression / expression",
            "        expression % expression",
            "        - expression",
            "        expression ^ expression",
            "The arithmetic expressions evaluate the subexpressions, all of which must return numbers of the same type (integer or floating-point), and then perform addition, subtraction, multiplication, division, remaindering, negation, or raising to a power, respectively.  For addition, the subexpressions may both return strings as well; in this case, the result is the concatenation of the two strings. For the last operation, raising to a power, if the first expression is an integer, the second must also be an integer. But if it is floating-point, then the second can be either floating point or an integer. This is the only type mixing permitted. You must do explicit type conversions with built-in functions (toint(), tofloat()) before evaluation mixed expressions on the other operations.",
            "",
            "        expression == expression",
            "        expression != expression",
            "        expression < expression",
            "        expression <= expression",
            "        expression > expression",
            "        expression >= expression",
            "The comparison expressions evaluate the subexpressions and then test whether or not the first result is equal to, unequal to, less than, less than or equal to, greater than, or greater than or equal to the second result, respectively.  If the indicated relation holds then they return 1 and otherwise they return 0.  Comparisons of strings are performed case-insensitively, those of lists are performed on an element-by-element basis, objects are compared by their object numbers, and errors by an ordering given in the LambdaMOO Programmer's Manual.",
            "",
            "        expression ? expression | expression",
            "        expression && expression",
            "        expression || expression",
            "        ! expression",
            "The logical expressions each return results based upon the truth value of their first subexpression; call the value of this expression X.  The first of these returns the value of the second subexpression if X is a true value and that of the third expression if X is a false value; the unused subexpression is not evaluated.  The definitions of 'true value' and 'false value' are given in 'help truth'.  The expression 'E1 && E2' is an abbreviation for 'E1 ? E2 | E1' except that E1 is only evaluated once.  The expression 'E1 || E2' is an abbreviation for 'E1 ? E1 | E2' except that E1 is only evaluated once.  The expression '! E' is an abbreviation for 'E ? 0 | 1'.",
            "",
            "        expression IN expression",
            "The list-membership expression first evaluates both subexpressions; call their values E and L, respectively.  L must be a list.  If E is an element of L, then the index of the first occurence of E in L is returned.  If E is not an element of L, then 0 is returned.",
            "",
            "        `expression-1 ! codes => expression-2'",
            "NOTE: the open- and close-quotation marks are really part of the syntax; they must be typed in. `Codes' is either the keywoard ANY or a comma-separated list of expressions that when evaluated should yield a list of error codes to be caught if they're raised. If `expression-1' is evaluated without raising an error, then its value is the value of the entire expresion. If it raises an error that is listed in `codes', it is caught. If the `=> expression-2' part was included (it is optional), then it is evaluated and its value is the result of the entire expression. If `expression-2' was omitted, then the error is the value of the expression. If the error was not listed and caught, then the error contines to be raised.",
            "",
            "The method for disambiguating the meaning of a complex MOO expression in the absence of sufficient parentheses is described in 'help precedence'.",
            ""
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  eval <MOO-code>",
            "         ; <MOO-code>",
            "         eval-d <MOO-code>",
            "",
            "Evaluates the given piece of MOO code and prints the resulting value.  If the MOO code begins with one of the MOO language keywords ('if', 'for', 'while', 'fork', or 'return') or with the character ';', then the entire piece of code is treated as the program for a verb, with ';' appended to the end.  Otherwise, 'return' is appended to the front and ';' is appended to the end and that string is treated as the code for a verb.  In either case, the resulting verb is invoked and whatever value it returns is printed.",
            "",
            "For programmers, this is such a mind-bogglingly useful thing to do that there is a simple abbreviation for this command; any command beginning with a semicolon (';') is treated as a use of 'eval'.",
            "",
            "Eval treats specially a duplicated semicolon at the beginning.  It enables you to make multi-statement programs within eval (but does not by default print the return value).",
            "",
            "Eval-d (no \";\" abbreviation for this) evaluates the following text exactly as eval, except that the \"d\" debug flag (see programmer's manual for explanation) is turned off.  Thus errors will cause an error return value rather than a traceback.",
            "",
            "If you set the programmer option `eval_time' to 1 (see `help @prog-options'), then eval will print out how many ticks and seconds the program required.",
            "",
            "Examples:",
            "   eval 3 + 4",
            "   =>  7",
            "   ;3+4",
            "   =>  7",
            "   ;for x in (player.aliases) player:tell(x); endfor",
            "   Haakon",
            "   Wizard",
            "   ArchWizard",
            "   =>  0",
            "   ;;l = {}; for i in [1..10] l = {@l, i}; endfor return l",
            "   =>  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "   eval-d 8 + \"foo\"",
            "   => E_TYPE  (Type mismatch)",
            "",
            "You may customize your evaluation environment.  The player property .eval_env may contain statements to be executed prior to any evaluated program.  Two caveats:  This will throw off the tick count.  You can account for additional ticks inserted by your environment with the .eval_ticks property; just set it to the number of ticks you'd like subtracted from the total.  Additionally, if you make a syntax error in your program, the line reported will be wrong (it will count those initial statements), and if you make an error in the eval_env itself, you can be in deep trouble.  Despite these drawbacks, the eval_env property can be quite useful.  The following is a sample:",
            "",
            "Eval_env:    \"me=player;here=player.location;\"",
            "eval_ticks:  3",
            "",
            "See also @setenv.",
            "",
            "You can also define textual substitutions in a separate property, called eval_subs.  These are discouraged, however, for anything that can be done with variable assignments, because the overhead of replacing the strings in the evaluated program is significant.  However, some things, such as substituting characters which can't be typed easily on one keyboard (e.g. \"[]\" is difficult to type on some IBM keyboards), can only be done by textual substitutions.  Note that the eval substitutions are also interpreted by the verb editor when \"eval_subs\" is selected in your .edit_options property (see `help editors').  This adds to their overhead, but again, makes it possible for people to program who otherwise can't type the full character set.  Remember:  Don't use eval_subs unless you really have to!"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*errors*",
            "The complete list of error codes:",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @verb <object>:<verb-name(s)>",
            "         @verb <object>:<verb-name(s)> <dobj> [<prep> [<iobj>]]",
            "",
            "Adds a new verb with the given name(s) to the named object.  If there are multiple names, they should be separated by spaces and all enclosed in quotes:",
            "",
            "        @verb foo:\"bar baz mum*ble\"",
            "",
            "The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'; their meaning is discussed in the LambdaMOO Programmer's Manual.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions' (a prepositional phrase with more than one word must be enclosed in quotes (\"\")).  All three specifiers default to 'none'.",
            "",
            "It is also possible to specify the new verb's permissions and owner as part of the same command (rather than having to issue separate @chmod/@chown commands)",
            "",
            "     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions>",
            "     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions> <owner>",
            "",
            "<permissions> are as with @chmod, i.e., must be some subset of \"rwxd\".  They default to \"rd\" (specifying \"w\" for a verb is highly inadvisable).  The owner defaults to the player typing the command; only wizards can create verbs with owners other than themselves.",
            "",
            "You may also use \"tnt\" in place of \"this none this\" for the dobj prep iobj arguments.  \"this none this\" is used to indicate non-command verbs, since the parser can't possibly interpret a command as \"this none this\".  For these verbs, the permissions default to \"rxd\"; the \"x\" bit is set so that they can be called from other programs.  (If they couldn't be used as commands, and they couldn't be called from programs, they wouldn't be good for anything!)"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @setenv <environment string>",
            "",
            "Defines the environment for eval (property player.eval_env).  See \"help eval\"",
            "for more information.",
            "",
            "Example:",
            "",
            "  @setenv me=player;here=player.location;"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @rmverb <object>:<verb-name>",
            "         @rmverb <object>:<verb-name>  <dobj> <prep> <iobj>",
            "         @rmverb# <object>:<verb-number>",
            "",
            "Removes the named verb from the named object.",
            "If there is more than one verb matching the given verb-name, this removes the most recently defined one.",
            "",
            "With the 2nd form of the command the verb removed is the most recent one matching both the given verb-name *and* the given dobj/prep/iobj specifiers.",
            "",
            "To remove the ambiguity in verbs with the same name, @rmverb# is provided where you can specify the verb by its 1-based index in the verbs() list output. Use of this form is strongly encouraged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @rmproperty <object>.<prop-name>",
            "",
            "Removes the named property from the named object.  '@rmproperty' may be abbreviated as '@rmprop'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:  @prospectus player [from number] [to number]",
            "",
            "Like @audit, but displays more information.  The optional from and to arguments are for restricting the display to specific object numbers, if you happen to know the player only owns objects in the included range.",
            "",
            "Example:",
            "   Objects owned by Frand (from #0 to #54949):",
            "     P[ 23]    #47 Frand                          [Hyperspace Hovel]",
            "     T        #152 Frand's trio of shoes          [Frand]",
            "   KfT[ 10]   #391 Frand's notifier class         [Nowhere]",
            "     T[  8]   #393 Frand's chessboard             [The Dining Room]",
            "   KfT[ 11]   #775 Frand's generic game board     [Nowhere]",
            "     T[  6]   #893 Ghost game                     [The Dining Room]",
            "     T[ 16]   #894 Frand's mind bender            [The Dining Room]",
            "     C        #997 polka-dot hole                 [Hyperspace Hovel]",
            "     R[  1]  #1002 Hyperspace Hovel              ",
            "     E      #11958 out                            Monster Cage->*Dr. Empirico's Lab",
            "      ...",
            "",
            "The K in the first column indicates that the object has children owned by other players.  A lowercase k indicates the object has children but owned only by the player.  The second column indicates whether the object is publicly readable or publicly parentable.  An r indicates readability.  A lowercase f indicates the object is both readable and allows children (is fertile).  An uppercase F indicates the object is not readable, yet allows children to be created.  (This is usually an error.)  If the object is readable by the issuer of the @prospectus command (that is, publicly readable or owned by the issuer), then the number in brackets indicates the number of verbs which have been defined on this object (not including any verbs from any parents).",
            "",
            "The third column indicates what type of object this is.",
            "        T       Thing",
            "        E       Exit",
            "        R       Room",
            "        C       Container",
            "        N       Note",
            "        P       Player",
            "        F       Feature",
            "        M       Mail Recipient",
            "        H       Help Database",
            "        D       Database",
            "        U       Utilities Package",
            "        O       Options Package",
            "        p       Parent object appropriate for players (\"Player class\")",
            "        blank   Other"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @property <object>.<prop-name>",
            "         @property <object>.<prop-name> <initial-value>",
            "",
            "Adds a new property named <prop-name> to the named object.  The initial value is given by the second argument, if present; it defaults to 0.  ",
            "",
            "Normally, a property is created with permissions 'rc' and owned by whoever types the command.  However, you may also specify these explicitly",
            "",
            "         @property <object>.<prop-name> <initial-value> <permissions>",
            "         @property <object>.<prop-name> <initial-value> <permissions> <owner>",
            "",
            "Only wizards can create properties with owners other than themselves.",
            "",
            "'@property' can be abbreviated as '@prop'."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @program <object>:<verb-name>",
            "         @program <object>:<verb-name> <dobj> <preposition> <iobj>",
            "         @program# <object>:<verb-number>",
            "",
            "Changes the MOO program associated with the named verb on the named object.",
            "If you provide <dobj> <preposition> and <iobj> as in the second form of this command, then it is the first verb with matching direct object, preposition and indirect object specifiers that is the one getting the new program.  This is useful if you have several verbs matching the same name.",
            "",
            "Or, you can use @program# if you know the verb's number. This is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.",
            "",
            "Typing the @program command always puts the server into a line-reading mode, in which each line you type is saved away without any action unless said line is one of the following:",
            "",
            "  .",
            "  @abort",
            "  .<text>",
            "",
            "A period on a line by itself ends the line-reading mode and continues with the command, in this case, the saved lines are considered as a program, checked for syntax errors and, if no errors are found, installed as the new program for the specified verb.  ",
            "",
            "@abort causes the command to terminate immediately with no change to any verb's program.  .<text> enters <text> literally as one of the lines to be saved, which is used for when, e.g., you want to enter the line `.' or the line `@abort'.",
            "",
            "Note that this command *always* enters the line-reading mode, even if the indicated verb is not found.  In this case, lines of text are still read but they are ignored.  After any @program command, you always need to type a period or `@abort' to get back into the normal command-reading mode."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @list <object>:<verb>",
            "         @list <object>:<verb> [with|without parentheses|numbers] [all]",
            "         @list <object>:<verb> <dobj> <prep> <iobj>",
            "         @list <object>:<verb> <start>..<end>",
            "         @list# <object>:<verb-number> [any of the above]",
            "",
            "Prints out the code for the MOO program associated with the named verb on the named object.  ",
            "",
            "Normally, the code is shown with each line numbered and with only those parentheses that are necessary to show the meaning of the program.  You can e.g., specify `without numbers' to have the numbers omitted or `with parentheses' to include all parentheses or even `with parentheses without numbers' to do both.  You can change the default behavior of this command via @prog-options (which see).",
            "",
            "Normally, the @list command only shows the code for the named verb on the object itself or on the nearest ancestor that defines it; if you give the `all' option, it shows the code for the named verb on every ancestor that defines it, as well as on the object itself.",
            "",
            "The 3rd form of the verb lists the verb matching the given dobj/prep/iobj specification if such exists.  ",
            "The 4th form prints only those lines in the specified range.",
            "",
            "Example:",
            "  Type `@list $room:say' to see the code for the `say' command, or even `@list $prog:@list' to see the code implementing @list itself...",
            "",
            "The 2nd-4th forms may be combined, e.g.,",
            "",
            "  @list frobule:burfle this in front of any without numbers 1..10",
            "",
            "which would be useful if `frobule' had more than one `burfle' verb and we wanted to see the first 10 lines of the one having `this' `in front of' `any' as its respective dobj/prep/iobj specifiers.",
            "",
            "Or, if you know the verb's number, you can use @list# to unambiguously refer to the verb. The number comes from the 1-based index of the verb as it appears in the verbs() (or @verbs) output list."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @kill task_id",
            "         @kill [object]:[verb]",
            "         @kill soon [number-of-seconds]",
            "         @kill all",
            "         @kill %trailing_id",
            "",
            "",
            "Immediately kills one or more forked tasks.  The '@forked' command is useful for finding out what tasks you have pending; see 'help @forked' for details.  Only the owner of a task may kill it.",
            "",
            "@kill task_id kills only the task with that id.",
            "",
            "@kill object:verb kills all tasks which were scheduled by the object running the verb named.  Both object and verb are optional:  @kill object: kills all tasks scheduled by that object, and @kill :verb kills all tasks which were scheduled by any object running that verb.  This can be useful if you have several similar objects which are running tasks from similarly named verbs.  (Perversely, @kill : kills all tasks...  Any object running any task.)",
            "",
            "@kill soon kills all tasks scheduled within the next minute.  @kill soon number kills all tasks scheduled within that number of seconds, e.g. @kill soon 300 would kill all tasks scheduled within the next five minutes.  This can be useful if you have a runaway task you want to quickly remove, but don't want to kill you later tasks.",
            "",
            "@kill all kills all tasks.  Like @kill soon, but more dramatic.",
            "",
            "@kill %trailing_id expects you to specify the last few digits of a task id.  It then kills all tasks that end with those digits.",
            "",
            "@killq*uiet does all of the above without the pretty printout if more than one task is being killed.  It tells you the number of tasks that have been killed when it's finished.",
            "",
            "Example:",
            "  @forked",
            "  1359083655  Sep 16 21:45:00 1991  yduJ          #5803:heartbeat (10) [#68]",
            "  @kill %655",
            "  Killed:   task 1359083655, verb #5803:heartbeat, line 10, this==#68"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @kids object",
            "",
            "A quick way to find out the children of an object.  Prints out the names and object numbers of the found children.  Note: this is not a list of all descendents, just direct children.",
            "",
            "Example:",
            "  @kids #3107",
            "  Generic Body of Chlorinated Water(#3107) has 3 kids.",
            "  The Pool(#1428)   The Hot Tub(#388)   Deep Blue Underground Pool(#17340)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @forked[-v*erbose] [all wizards]",
            "",
            "Gives a list of all of the forked tasks you own, along with detailed information about each one.  Wizardly characters may specify `all wizards' and see the queued tasks which are owned by a player with .wizard=1. This is useful to find a task that $wiz_utils:random_wizard has put in various queues, and to also find code which is running with wizardly permissions that shouldn't be.",
            "",
            "The information displayed includes the following:",
            "",
            "Queue ID:",
            "   A numeric identifier for the task, for use in killing it (see 'help @kill').",
            "",
            "Start Time:",
            "   The time after which the task will begin execution.",
            "",
            "Owner:",
            "   The player whose permissions under which the task is running.",
            "   Unless you are a wizard, @forked will show only your tasks.",
            "",
            "Verb:",
            "   The object and verb-name of the code that forked the task.",
            "",
            "Line:",
            "   The line number of the first statement that the task will execute when it starts.  Note that the code for the verb in question may have changed since the task was forked; the forked task will use the version that was being executed when it was forked.",
            "",
            "This:",
            "   The value of `this' for the forked task, in the case that it is different from (i.e., is a descendant of) the object on which the verb code lives.",
            "",
            "For a more verbose output, use `@forked-v*erbose'. This will display the same information as the above, but for any task which is not a fresh fork or foreground task, a callers()-style listing of the stack trace will be displayed."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax: @display <object>.[property]",
            "                         ,[inherited_property]",
            "                         :[verb]",
            "                         ;[inherited_verb]",
            "",
            "@display is a fancy version of @show.  As @show, it can select individual verbs or properties to display.  In addition, it can display all the verbs or properties defined on an object, or all the verbs or properties defined on any of the object's ancestors.  Don't specify a property or verbname after the punctuation mark to get the \"all\" feature.  Its display is more compact than that of @show (it uses a one-line format, and truncates values that don't fit in the value field).",
            "",
            "You may mix properties and verbs on the command line, but the parser may become confused.  (E.g. @display object,: displays all properties including inherited ones plus all locally defined verbs on the object.)",
            "",
            "Examples:",
            "Individual property:",
            "  @display poolsweep.count",
            "  .count                   yduJ (#68)            r c    8",
            "",
            "Individual verb:",
            "  @display poolsweep:tell",
            "  #3560:tell                     yduJ (#68)           rxd    this none this",
            "",
            "All properties, including one truncated value:",
            "  @display poolsweep.",
            "  poolsweep (#3560) [ readable ]",
            "    Owned by yduJ (#68).",
            "    Child of generic thing (#5).",
            "    Location The Pool (#1428).",
            "  .gagged                  yduJ (#68)            r c    0",
            "  .count                   yduJ (#68)            r c    8",
            "  .messages                yduJ (#68)            r c    {\"The poolsweep stir..",
            "  .index                   yduJ (#68)            r c    2",
            "  .quantum                 yduJ (#68)            r c    20",
            "",
            "Inherited verbs, edited for brevity, showing verbs from various parents, with owners, permissions, and argument lists.",
            "  @d poolsweep;",
            "  poolsweep (#3560) [ readable ]",
            "   #3560:tell                     yduJ (#68)           rxd    this none this",
            "   #3560:description              yduJ (#68)           rxd    this none this",
            "      #5:\"g*et t*ake\"             Haakon (#2)          rxd    this none none",
            "      #5:\"d*rop th*row\"           Haakon (#2)          rxd    this none none",
            "      #5:moveto                   Haakon (#2)          rxd    this none this",
            "      #1:description              Haakon (#2)          rxd    this none this",
            "      #1:look_self                Haakon (#2)          rxd    this none this",
            "",
            "Some aspects of @display can be customized (see `help @display-options')."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @dbsize",
            "",
            "@dbsize goes through the entire database, counting the valid and invalid objects, giving a summary at the end.  This information can be useful, but because this command is cpu intensive, it should be used sparingly."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @copy <object>:<verb> to [<newobject>][:<newverb>]",
            "         @copy-move <object>:<verb> to [<newobject>][:<newverb>]",
            "",
            "Copies the code of the named verb to the new object and verbname.  Permissions, and arguments of the new verb are set to match those of the old verb in the event that the new verb does not already exist.  One of <newobject> or :<newverb> must be supplied.  If no new verbname is given, the old name is retained.  Likewise, <newobject> defaults to <object> if not given.",
            "",
            "@copy-move will delete the old verb after it has copied.  Useful for restructuring code/object hierarchies.",
            "",
            "Examples:",
            "  @copy me:verbname to myobject",
            "  @copy me:test_verb to myobject:real_verb",
            "",
            "In general, @copy'ing verbs is a bad idea.  In the vast majority of cases, the desired effect can be accomplished with parenting (i.e., having <object> be an ancestor of <newobject>), which has the advantage that if a verb is updated or fixed, this immediately becomes available to child objects that inherit this verb.  In such a case, copies that were made using @copy have to be tracked down and fixed by hand.",
            "",
            "This facility is provided for those rare occasions where one has no choice but to actually copy the verb."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @chparent <object> to <new parent>",
            "",
            "Changes the parent of the named object to be the named parent.  The object acquires all the verb and property definitions of its parent.  Newly acquired properties are initilialized with `clear' values so that they inherit whatever values are currently assigned to the parent's corresponding properties (see `help @clearproperty').",
            "",
            "If the player does not own <new parent>, it must have been set `fertile'.  <object> must be owned by the player.  Neither <object> nor any descendant can define any property which already exist on <new parent>.  Use @check-chparent (see `help @check-chparent') to list such property conflicts.",
            "",
            "It is also sometimes the case that you will own some object and want to @chparent some child of that object that you do not own.  Use @disinherit (see `help @disinherit') in such situations."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @chmod <object> <object-permissions>",
            "         @chmod <object>.<prop-name> <property-permissions>",
            "         @chmod <object>:<verb-name> <verb-permissions>",
            "         @chmod# <object>:<verb-number> <verb-permissions>",
            "",
            "Changes the permissions of an object, property or verb, to those given.  The following table shows what permission bits are allowed for each form of the command:",
            "        <object-permissions>        r, w, f",
            "        <property-permissions>      r, w, c",
            "        <verb-permissions>          r, w, x, d",
            "",
            "See the LambdaMOO Programmer's Manual for their meanings.",
            "",
            "The form @chmod# is used to unambiguously refer to a verb by its 1-based index as it appears in the verbs() (or @verbs()) output list.",
            "",
            "To clear all of the permissions for an object, verb, or property, use \"\" as the second argument.",
            "",
            "@chmod also accepts +, !, and - as modifiers for a single permission to add or subtract that permission from the current set.  (! and - are the same.)",
            "",
            "Examples:",
            "",
            "Set a verb to be Readable and Callable:",
            "  @chmod chair:sit rx",
            "",
            "Set a verb to be not Callable, without changing its other permissions:",
            "  @chmod cookies:eat !x",
            "",
            "Set an object to be Fertile in addition to any current bits:",
            "  @chmod table +f"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @args <object>:<verb-name> <dobj>",
            "         @args <object>:<verb-name> <dobj> <prep>",
            "         @args <object>:<verb-name> <dobj> <prep> <iobj>",
            "         @args# <object>:<verb-number> [any above combinations]",
            "",
            "Changes the direct object, preposition, and/or indirect object specifiers for the named verb on the named object.  Any specifiers not provided on the command line are not changed.  The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions'.",
            "",
            "To unambiguously refer to the verb on the object, in case there are more than one with the same name, use @args#. This takes the 1-based index of the verb as it appears in the verbs() (or @verbs()) output list.",
            ""
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  .program <object>:<verb-name>",
            "              :",
            "              :",
            "              <lines of MOO code>",
            "              :",
            "              :",
            "         .",
            "",
            "Provides or changes the MOO program associated with the named verb on the named object.",
            "",
            "This command is mostly obsolete.  Use @program instead.  The only reason this command still exists is that it is a server builtin command that will continue to work in the (unlikely) event that @program gets trashed ...",
            "",
            "This command works differently from most other MOO commands, in that it actually changes how the server will interpret later lines that you type to it.  After typing the '.program' line, you are in 'programming mode'.  All lines that you type in this mode are simply saved away in the server until you type a line containing only a single period ('.').  At that point, those lines are interpreted as a MOO program and are checked for syntax errors.  If none are found, a message to that effect is printed and the code you typed is installed as the program for the verb in question.  In any case, after typing the '.' line, you are returned to the normal input-handling mode."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:   @clearproperty <object>.<prop-name>",
            "",
            "This clears <object>'s <prop-name> property.  That is the property value becomes `clear' and all further references to this property will use the value of the same property on the parent object.  Note that you can only clear inherited properties.  Nor is this the same as removing a property; the property continues to exist.",
            "",
            "`@clearproperty' can be abbreviated as `@clearp'.",
            "",
            "Example:",
            "",
            "  @create #1 named foo",
            "  You now have foo with object number #42 and parent Root Class (#1).",
            "    [foo, as a child of #1 has a .description property which starts out clear]",
            "  ;#1.description",
            "  => \"\"",
            "  ;#1.description = \"You see nothing special\"",
            "  => \"You see nothing special\"",
            "  ;#42.description  ",
            "  => \"You see nothing special\"",
            "  ;#42.description = \"Something special\"",
            "  => \"Something special\"",
            "   [foo.description is now no longer clear; it has a value of its own]",
            "  ;#1.description = \"Boring\"",
            "  => \"Boring\"",
            "  ;#42.description  ",
            "  => \"Something special\"",
            "   ",
            "  @clearp foo.description",
            "  Property #42.description cleared; value is now \"Boring\".",
            "   [foo.description is now clear again]",
            "  ;#1.description = \"\"",
            "  => \"\"",
            "  ;#42.description",
            "  => \"\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@disinherit"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   @disinherit <object> ",
            "          @disinherit <object> [from <parent>]",
            "",
            "Synonym:  @disown",
            "",
            "This command is used to remove an unwanted child from an object you own.  If you owned said child, you could use @chparent; this command is to cover the other case, namely where you don't own the child.  ",
            "",
            "Both forms of this command chparent <object> to its grandparent, provided you own the parent.  The second form matches the string you supply for <object> against the list of children of the given <parent>.",
            "",
            "Turning off the fertile bit (.f) for a particular object prevents others from creating children of it or chparenting to it (see `help @chmod').",
            "Note also that, though the name might seem to indicate otherwise, this command does not change the ownership of any object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@display-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @display-option",
            "         @display-option <option>",
            "",
            "Synonym:  @displayoption",
            "",
            "The display options customize the behavior of the @display command to your particular taste.  The first form of this command displays all of your display options.  The second form displays just that one option, one of the flags listed below.",
            "",
            "The remaining forms of this command are for setting your display options:",
            "",
            "         @display-option +<flag>",
            "         @display-option -<flag>",
            "         @display-option !<flag>           (equivalent to -<flag>)",
            "",
            "These respectively set and reset the specified flag",
            "",
            "-blank_tnt     Show the verb args on all verbs.",
            "+blank_tnt     Don't show the verb args on `this none this' verbs.",
            "-shortprep     Use full prepositions  (e.g., \"on top of/on/onto/upon\")",
            "+shortprep     Use short prepositions (e.g., \"on\")",
            "-thisonly      Specifying . (:) to retrieve all properties (verbs) will go",
            "               up the ancestor chain until it finds a readable object with",
            "               properties (verbs) defined on it.",
            "+thisonly      Specifying . (:) to retrieve all properties (verbs) will only",
            "               display properties (verbs) defined on the object itself."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@add-feature",
            "",
            "Note to programmers: @add-feature and @remove-feature are front-ends for player:add_feature and :remove_feature.",
            "",
            ":add_feature returns",
            "",
            " * E_PERM unless caller == this || $perm_utils:controls(caller_perms())",
            "",
            " * E_INVARG if feature is not an object or is invalid",
            "",
            " * E_PERM if the object is not feature_ok",
            "",
            " * a true value otherwise",
            "",
            "and calls feature:feature_add, if the verb exists.",
            "",
            ":remove_feature returns",
            "",
            " * E_PERM unless caller == this || $perm_utils:controls(caller_perms()) || caller_perms() == feature.owner",
            "",
            " * a true value otherwise",
            "",
            "and calls feature:feature_remove, if the verb exists."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@add-feature"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "features",
            "",
            "Note to programmers: In order to be available for general use as a feature, an object must have a verb or property named \"feature_ok\" which returns a true value.",
            "",
            "When a feature is added to a player's features list, feature:feature_add is called, if it exists, with the player in question as its argument.  Likewise, when a feature is removed, feature:feature_remove is called."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "examine",
            "",
            "[Note to programmers: the 'obvious' verbs are those that can be invoked as commands and are not specified by the :hidden_verbs verb.  The default definition of \"hidden\" is \"not readable\".  You can override this definition with a :hidden_verbs verb that gets the default list with pass(@args) and then alters that list.]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "mail",
            " - - - - -",
            "See `help mail-system' for a description of the programming interface to the mail system.",
            "In particular, see `help $mail_recipient' for information on creating new mail collections."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.",
            "If neither .<property>|.parent nor <code> is specified, just return <thing>.",
            "If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).",
            "If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.",
            "For example, the command",
            "  #JoeFeedback.parent player for toint(%#)",
            "will return 26026 (unless Joe has chparented since writing this)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@prog-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@prog-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@prog-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @prog-option",
            "         @prog-option <option>",
            "",
            "Synonyms:  @progoption, @programmer-option @programmeroption",
            "",
            "The first form displays all of your programmer options",
            "The second displays just that one option, which may be one of the flags listed below.  The programmer options control various annoying details of your programming commands (e.g., @list, eval, @copy, ...)",
            "",
            "The remaining forms of this command are for setting your programmer options:",
            "",
            "         @prog-option +<flag>",
            "         @prog-option -<flag>",
            "         @prog-option !<flag>           (equivalent to -<flag>)",
            "",
            "These respectively set and reset the specified flag",
            "",
            " -list_all_parens    @list shows only necessary parentheses by default",
            " +list_all_parens    @list shows all parentheses by default",
            " -list_no_numbers    @list gives line numbers by default",
            " +list_no_numbers    @list does not give line numbers by default",
            " -eval_time          eval does not show ticks/seconds consumed.",
            " +eval_time          eval shows ticks/seconds consumed.",
            " -copy_expert        @copy prints warning message.",
            " +copy_expert        @copy prints no warning message.",
            " -list_show_permissions  @list does not display permissions in header",
            " +list_show_permissions  @list displays permissions in header",
            "",
            "All flags default to the `-' settings.  ",
            "Finally, we have",
            "",
            "         @prog-option verb_args [is] <dobj> <prep> <iobj>",
            "         @prog-option verb_args=\"<dobj> <prep> <iobj>\"",
            "         @prog-option -verb_args",
            "                      (equivalent to verb_args=\"none none none\")",
            "         @prog-option +verb_args",
            "                      (equivalent to verb_args=\"this none this\")",
            "",
            "which all serve to specify the (direct/indirect)-object and preposition to use in a @verb command for which these are not given at all."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "options",
            "",
            "  @prog-options    --- programming commands (@list, @verb, ...)",
            "  @display-options --- @display (*)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@kill"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "It is often the case in MOO programming that you will want to access the elements of a list individually, with each element stored in a separate variables.  This desire arises, for example, at the beginning of almost every MOO verb, since the arguments to all verbs are delivered all bunched together in a single list.  In such circumstances, you could write statements like these:",
            "",
            "first = args[1];",
            "second = args[2];",
            "if (length(args) > 2)",
            "  third = args[3];",
            "else",
            "  third = 0;",
            "endif",
            "",
            "This approach gets pretty tedious, both to read and to write, and it's prone to errors if you mistype one of the indices. Also, you often want to check whether or not any extra list elements were present, adding to the tedium.",
            "",
            "MOO provides a special kind of assignment expression, called `scattering assignment' made just for cases such as these. A scattering assignment expression looks like this:",
            "",
            "{<target>, ...} = <expr>",
            "",
            "where each <target> describes a place to store elements of the list that results from evaluating <expr>. A <target> has one of the following forms:",
            "",
            "`variable'",
            "   This is the simplest target, just a simple variable; the list element in the corresponding position is assigned to the variable.  This is called a `required' target, since the assignment is required to put one of the list elements into the variable.",
            "",
            "`?variable'",
            "   This is called an `optional' target, since it doesn't always get assigned an element. If there are any list elements left over after all of the required targets have been accounted for (along with all of the other optionals to the left of this one), then this variable is treated like a required one and the list element in the corresponding position is assigned to the variable. If there aren't enough elements to assign one to this target, then no assignment is made to this variable, leaving it with whatever its previous value was.",
            "",
            "`?variable' = `default-expr'",
            "   This is also an optional target, but if there aren't enough list elements available to assign one to this target, the result of evaluating `default-expr' is assigned to it instead. Thus, `default-expr' provides a default value for the variable. The default value expressions are evaluated and assigned working from left to right -after- all of the other assignments have been performed.",
            "",
            "`@variable'",
            "   By analogy with the @ syntax in list construction, this variable is assigned a list of all of the `leftover' list elements in this part of the list after all of the other targets have been filled in. It is assigned the empty list if there aren't any elements left over. This is called a `rest' target, since it gets the rest of the elements. There may be at most one rest target in each scattering assignment expression.",
            "",
            "If there aren't enough list elements to fill all of the required targets, or if there are more than enough to fill all of the required and optional targets but there isn't a rest target to take the leftover ones, then E_ARGS is raised.",
            "",
            "Here are some examples of how this works.  Assume first that the verb me:foo() contains the following code:",
            "",
            "b = c = e = 17;",
            "{a, ?b, ?c = 8, @d, ?e = 9, f} = args;",
            "return {a, b, c, d, e, f};",
            "",
            "Then the following calls return the given values:",
            "",
            "me:foo(1)                        error-->   E_ARGS",
            "me:foo(1, 2)                     =>   {1, 17, 8, {}, 9, 2}",
            "me:foo(1, 2, 3)                  =>   {1, 2, 8, {}, 9, 3}",
            "me:foo(1, 2, 3, 4)               =>   {1, 2, 3, {}, 9, 4}",
            "me:foo(1, 2, 3, 4, 5)            =>   {1, 2, 3, {}, 4, 5}",
            "me:foo(1, 2, 3, 4, 5, 6)         =>   {1, 2, 3, {4}, 5, 6}",
            "me:foo(1, 2, 3, 4, 5, 6, 7)      =>   {1, 2, 3, {4, 5}, 6, 7}",
            "me:foo(1, 2, 3, 4, 5, 6, 7, 8)   =>   {1, 2, 3, {4, 5, 6}, 7, 8}",
            "",
            "Using scattering assignment, the example at the begining of this section could be rewritten more simply, reliably, and readably:",
            "",
            "{first, second, ?third = 0} = args;",
            "",
            "It is good MOO programming style to use a scattering assignment at the top of nearly every verb, since it shows so clearly just what kinds of arguments the verb expects."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  .flush",
            "",
            "Clear out all recent lines of input that haven't been processed yet by the server. Useful when you change your mind about lines you have typed that haven't run yet.",
            "",
            "This command name can be changed by the `set_connection_option()' built-in function, or if $server_options.default_flush_command exists and is non-empty, that value is used. If it exists and -is- empty, then no flush command exists at all."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@rmverb"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@list"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@program"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@args"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@chmod"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@rename"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@addalias"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@addalias"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@rmalias"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@rmalias"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The MOO checkpoint is created by a UNIX system fork() call, which creates a separate process but with the same memory image as the running the MOO.  That process then writes that information into a database.",
            "",
            "The act of calling this separate-but-equal process is intrinsically laggy because the MOO server memory is already saturated by the running version of the MOO.  Adding an equal size process to the mix results in heavy swapping between memory and harddrive.  It would therefore be considered wise not to run any processor or memory intensive MOOcode during checkpoint.",
            "",
            "If you wish to alter any of your code to avoid executing during a checkpoint, you can check the value of $login.checkpoint_in_progress, which returns 1 during checkpoint and 0 otherwise.  This value is itself toggled by the verbs $sysobj:checkpoint_started and $sysobj:checkpoint_finished.",
            "",
            "Also see help on:   dump_database()   @dump-database   checkpoint"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*verbdoc*",
            "$prog",
            "@properties"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@properties"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "prog-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Programmer Help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This provides help on the programmer commands available on $prog and related topics.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            103085,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "23": {
      "id": 23,
      "name": "Wizard Help",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "@guests",
        "@log",
        "@egrep",
        "@unnewt",
        "@denewt",
        "@newt",
        "@grep",
        "$site_db",
        "graylist",
        "blacklist",
        "@recycle",
        "wiz-index",
        "@dump-database",
        "@players",
        "@net-who",
        "@@who",
        "@quota",
        "@detoad",
        "@untoad",
        "@toad",
        "@grepcore",
        "@who-calls",
        "@abort-shutdown",
        "@shutdown",
        "@programmer",
        "@shout",
        "@chown",
        "redlist",
        "@blacklist",
        "@graylist",
        "@redlist",
        "@make-guest",
        "@spooflist",
        "spooflist",
        "@make-player",
        "@register",
        "@new-password",
        "@deprogrammer",
        "forked-tasks",
        "mail-lists",
        "@grant",
        "adding-help-text",
        "further-reading",
        "@temp-newt",
        "site-info",
        "recycling-players",
        "advertised",
        "news-items",
        "routine_tasks",
        "@chown#",
        "@grepall",
        "@egrepall",
        "mssp"
      ],
      "propdefs": [
        {
          "value": [
            "",
            "@guests now  [shows information about currently connected guests]",
            "@guests all  [shows all entries in $guest_log]",
            "@guests <n>  [shows the last <n> entries of $guest_log]",
            "",
            "Note, some wizards prefer to use verbs on $guest_log manually, particularly :last()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @log <message>",
            "         @log",
            "",
            "The first form enters <message> as a one-line comment in the server log.",
            "The second form prompts for a sequence of lines to be collectively entered as an extended comment.  This uses $command_utils:read_lines so all of those conventions apply, i.e., a period on a line by itself ends the text, `@abort' aborts the command, etc...).  Example:  If Wizard (#2) types",
            "",
            "    @log I did $dump_interval=3600",
            "",
            "the following line appears in the server log",
            "",
            "    Aug 19 22:36:52:  COMMENT:  from Wizard (#2):  I did $dump_interval=3600"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@denewt"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:    @denewt <player> [commentary]",
            "",
            "Synonyms:  @unnewt",
            "           @get-better",
            "",
            "@denewt reverses the effects of @newt, removing the player from $login.newted, and if appropriate, $login.temporary_newts.",
            "",
            "Mail is sent to $newt_log including any commentary you provide.  E.g.,",
            "",
            "  @denewt Twit  He promises not to do it again."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Syntax:  @newt <player> [commentary]",
            "         @temp-newt <player> for <period>",
            "",
            "The @newt command temporarily prevents logins on a given player.",
            "It works by adding the player to $login.newted, and for @temp-newt, also adding the player and an end time to $login.temporary_newts.  $login will deny connection to any player in $login.newted, unless they are temporarily newted and their time has expired, in which case it will clean up---denewt them---and allow the connection attempt.  Use @denewt to reverse this.",
            "",
            "You must give either the player's full name or its object number.",
            "Also, this command does not let you @newt yourself.",
            "",
            "Mail will be sent to $newt_log, listing the player's .all_connect_places and including any commentary you provide.  E.g.,",
            "",
            "  @newt Twit  did real annoying things.",
            "",
            "As with @toad and @programmer, there are messages that one may set",
            "",
            "@newt  [%[$wiz.newt_msg]]",
            "  Printed to everyone in the room in which the victim is being @newted.",
            "  If you're worried about accidentally newting yourself in the process of",
            "  setting this message, you can't (see above).",
            "",
            "@newt_victim  [%[$wiz.newt_victim_msg]]",
            "  Printed to the victim.  ",
            "  This is followed by $login:newt_registration_string().",
            "",
            "See `help @toad' if you need something more drastic.",
            "",
            "The @temp-newt variant of @newt permits you to specify a time period during which this player may not use the MOO.  Time units must be acceptable to $time_utils:parse_english_time_interval."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@grep",
            "",
            "For wizards, the following forms are also available for doing full-db searches",
            "",
            "         @grep  <pattern>",
            "         @grep  <pattern> from [#]<n>",
            "",
            "and likewise for @egrep, @grepall, and @egrepall.",
            "The first searches all objects in the database while the second searches the range [#<n>..max_object()]",
            "",
            "See also:  @grepcore, @who-calls."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Database of places",
            "------------------",
            "i.e., places people have connected from.",
            "",
            "  :add(sitename,player)",
            "      records the fact that player connected from sitename.",
            "  :load()",
            "      clears the db and reloads all of the player connection info.",
            "",
            "  .domain",
            "      default domain for unqualified sitenames given to :add.",
            "      ",
            "For each domain we keep a list of players and subdomains. ",
            "For example, :add(\"doc.ic.ac.uk\",#666) enters #666 on the lists for \"doc.ic.ac.uk\", and, if we have to create an entry for \"doc.ic.ac.uk\", we enter \"doc\" on the list for \"ic.ac.uk\", \"ic\" on the list for \"ac.uk\", etc....  In this case, :find(\"ic\") will return the \"ic.ac.uk\" list if there is no other domain in $site_db starting with \"ic\".  Note that the \"ic.ac.uk\" list may contain both objects, i.e., namely players that have connected from the site \"ic.ac.uk\", and strings, i.e., subdomains of \"ic.ac.uk\" like \"doc\".",
            "",
            "  :find_exact(string)    => player/subdomain list or $failed_match",
            "  :find_all_keys(string) => list of all domains that begin with string",
            "  :find_key     (string) => unique domain that begins with string, ",
            "                            $ambiguous_match or $failed_match",
            "",
            "The other $generic_db functions (:find, :find_all) are also available, though admittedly less useful."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "The Site Blacklist",
            "------------------",
            "$login maintains three lists of hosts/domains to support player registration schemes and blocking of connections from highly untrusted hosts:",
            "",
            "  .redlist   -- all connections from these sites are disabled ",
            "  .blacklist -- player creation and guest logins are disabled",
            "  .graylist  -- advisory list of potential trouble spots (putting a site on the",
            "                .graylist merely annotates it in @net-who listings).",
            "  .spooflist -- guests from these sites cannot use @request to request ",
            "                a character",
            "",
            "The lists are kept in a special format so it is highly recommended that you ",
            "either use $wiz:@*list/@un*list or the following verbs to query/update the ",
            "respective lists rather than bash them directly:",
            "",
            "  $login:*listed     (host)              is host is on .*list?",
            "  $login:*list_add   (domain or subnet)  add domain or subnet to .*list",
            "  $login:*list_remove(domain or subnet)  remove domain or subnet from .*list",
            "",
            "where `*' is one of `black', `red', `gray', or `spoof'.",
            "",
            "There are also temporary versions of the above four lists, stored in associated $login.temporary_*list in the same format, except two additional bits of data are stored.  The time the temporary *listing started, and the duration that it will last.  In addition there exists:",
            "",
            "  $login:*list_add_temp(domain or subnet, start time, duration)",
            "  $login:*list_remove_temp(domain or subnet)",
            "",
            "When the normal $login:*listed verb is called, both the regular *list and the temporary *list are checked.  If the host is on the temporary list, then the length of MOO up time since the start time is checked against the duration.  If expired, the host is removed from the temporary *list and a false value is returned (meaning that the host is not *listed).",
            "",
            "One may either specify a domain name (e.g., \"baz.edu\") or a numeric IP address (e.g., \"36.0.23.17\").  Domain names match all hosts underneath that domain, so, e.g., puting \"baz.edu\" on a list effectively adds \"x.bax.edu\" for all x as well.  ",
            "Likewise, an incomplete numeric address, e.g., \"128.42\" will match that entire subnet, in this case all hosts whose IP numbers have the form \"128.42.m.n\" for arbitrary integers m and n.",
            "",
            "One may also give a domain name containing a wildcard (\"*\"), e.g., \"fritz*.baz.edu\", in which case all hostnames matching in the sense of $string_utils:match_string() are considred to be on the list.  Wildcard matching should be avoided since it is more time-consuming.",
            "",
            "It should be noted that, since there is no direct access to the domain name service from within the MOO, it is possible for a host to be blacklisted or redlisted via its domain name, and yet have someone be able to connect from that host (and, in the case of a blacklisted host, create a character) --- this can happen if the name service is down and connection_name() on that player thus has given the numeric IP address rather than the domain name.  Similarly, if you list a host by IP number alone, it will still be possible to get in via the site's domain name.  Thus to be completely assured of shutting out a site, you need to list it both by domain name and IP number."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@recycle",
            "",
            "Of course, wizards are allowed to @recycle anything at all.",
            "",
            "There is, however, a block (in $player:recycle) against recycling actual players, i.e., descendants of $player that have the player flag set.  This is mainly to prevent stupid mistakes.  If, for some reason, you want to recycle a player, you need to @toad it first."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Wizard Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @dump-database",
            "",
            "Invokes the builtin dump_database(), which requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @players [with objects]",
            "",
            "Hmmm... what *does* this do, anyway?"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @net-who [<player>...]",
            "         @net-who from [<domain>]",
            "",
            "Synonym: @@who",
            "",
            "@net-who without any arguments prints all connected users and hosts.  If one or more <player> arguments are given, the specified users are printed along with their current or most recent connected hosts.  If any of these hosts are mentioned on $login.blacklist or $login.graylist (see `help blacklist'), ",
            "an annotation appears.",
            "",
            "With a `from...' argument, this command consults $site_db and prints all players who have ever connected from the given domain."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@net-who"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            "@quota",
            "",
            " - - - - - - - - - - - - - - - - - - - - - - - - - -",
            "Syntax:  @quota <player> is [public] [+]<number> [<reason>]",
            "",
            "This second and more interesting form of the verb is used to set a player's quota.  Mail will be sent to $quota_log, and also $local.public_quota_log if there is one and if the \"public\" argument is given; if a reason is supplied, it will be included in the message.  If the number is prefixed with a +, it's taken as an amount to add to the player's current quota; if not, it's an absolute amount."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@untoad"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @untoad <object> [as <name>,<alias>,<alias>...]",
            "",
            "Synonym: @detoad",
            "",
            "Turns the object into a player.  ",
            "If the name/alias... specification is given, the object is also renamed.",
            "In order for this to work, the object must be a nonplayer descendant of $player and the new object name (or the original name if none is given in the command line) must be available for use as a player name.  As with ordinary player @renaming, any aliases which are unavailable for use as player names are eliminated.",
            "",
            "If the object is a descendant of $guest, then it becomes a new guest character.",
            "Otherwise the object is chowned to itself.  In the latter case, it is advisable to check that the .password property has something nontrivial in it.",
            "",
            "If the object is a descendant of $prog, then its .programmer flag is set.",
            "Note that the .wizard flag is not set under any circumstances."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Syntax:  @toad   <player>  [graylist|blacklist|redlist]",
            "         @toad!  <player>",
            "         @toad!! <player>",
            "",
            "Resets the player flag of <player> (thus causing <player> to be booted), resets the .programmer and .wizard flags, chowns the player object to $hacker, and removes all of its names and aliases from $player_db.",
            "",
            "You must give either the player's full name or its object number.",
            "Also, this command does not let you @toad yourself.",
            "",
            "In some cases you may wish to add the player's last connected site to the site graylist, blacklist or redlist --- see `help blacklist' --- in order to invoke various kinds of blocking on that site (e.g., if player creation is enabled, you may want to enter the player on the blacklist to keep him from immediately creating a new character).  Specifying one of the listnames `graylist', `blacklist' or `redlist' will do this.",
            "",
            "@toad!  <player>  is synonymous with  @toad <player> blacklist",
            "@toad!! <player>  is synonymous with  @toad <player> redlist",
            "",
            "There are messages that one may set to customize toading.  After all, a toading is (supposed to be) a rare event and you will doubtless want to put on a good show.  Thus we have",
            "",
            "@toad  [%[$wiz.toad_msg]]",
            "  Printed to everyone in the room in which the victim is being @toaded.",
            "  If you're worried about accidentally toading yourself in the process of",
            "  setting this message, see above.",
            "",
            "@toad_victim  [%[$wiz.toad_victim_msg]]",
            "  Printed to the victim.",
            "",
            "These are pronoun_subbed with victim == dobj."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @grepcore <pattern>",
            "         @who-calls <verbname>",
            "",
            "@grepcore pattern is @grep pattern in {all core objects}.  Core objects are computed for you by #0:core_objects().",
            "",
            "@who-calls greps for the verbname + \"(\", hoping to catch it as a verb call.  Currently @who-calls does not allow you to restrict the search as @grep does.  (Volunteers?)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grepcore"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @abort-sh*utdown [<text>]",
            "",
            "This aborts any shutdown currently in progress (i.e., set in motion by @shutdown).  All players are notified that no shutdown will actually occur; <text>, if given will be included in this notification."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @shutdown [in <m>] [<text>]",
            "",
            "This is the friendly way to do a server shutdown; it arranges for the actual shutdown to take place `m' minutes hence (default two).  Shutdown is preceded by a sequence of warnings to all connected players.  Warnings are likewise given to all players who connect during this time.  <text>, if given is included in these warning messages, perhaps as an explanation for why the server is being shut down.",
            "",
            "Shutdown may be aborted at any time by using @abort-shutdown."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Syntax:  @programmer <player>",
            "",
            "Sets the programmer flag on the indicated player and sends mail to $new_prog_log.  ",
            "",
            "If the player is not already a descendant of $prog, we @chparent him/her to $prog.  In this case, if $prog has a larger .ownership_quota than its ancestors, then we raise the player's quota by the difference between $prog.ownership_quota and the .ownership_quota of the common ancestor of player and $prog, be this $player or some intermediate class.",
            "",
            "There are messages that one may set to customize how the granting of a programmer bit looks to the victim and to any onlookers.  After all, this is a seminal event in a MOOer's life...  Thus we have",
            "",
            "@programmer  [%[$wiz.programmer_msg]]",
            "  Printed to everyone in the room with the victim being @programmer'ed.",
            "",
            "@programmer_victim  [%[$wiz.programmer_victim_msg]]",
            "  Printed to the victim.",
            "",
            "These are pronoun subbed with victim == dobj."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @shout <text>",
            "",
            "Broadcasts the given text to all connected players."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @chown <object>            [to] <owner>",
            "         @chown <object>.<propname> [to] <owner>",
            "         @chown <object>:<verbname> [to] <owner>",
            "         @chown# <object>:<verbnumber> [to] <owner>",
            "",
            "Changes the ownership of the indicated object, property or verb.",
            "",
            "Verb ownership changes are fairly straightforward, being merely a matter of changing the verb_info() on a single verb. Referring to a verb isn't as straightforward since two verbs on the same object can have the same name. So, @chown# is provided where you can refer to a verb by it's 1-based index in the output of the verbs() builtin.",
            "",
            "Changing an object ownership includes changing the ownership on all +c properties on that object.  Note that @chown will not change the ownership of any other properties, nor will it change verb ownerships.  Use @grant if you need to do a more complete ownership change.  The quota of the former owner is increased by one, as is the quota of the new owner decreased by one.",
            "",
            "Changing a property ownership is truly hairy.  If the property is +c one shouldnot be doing this, unless it is to correct a past injustice which caused the property to be owned by the wrong player.  In the case of -c properties, the property ownership is changed on all descendent objects (currently, if +c instances of a -c property are found in the traversal of all of the descendants, these are not changed, being deemed sufficiently weird that they should be handled on a case-by-case basis...).",
            "",
            "If there's any justice, a future version of the server will prevent occurrences of (1) +c properties being owned by someone other than the object owner (2) -c properties with different owners on descendant objects (3) -c properties that are +c on some descendants."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @redlist   [<domain or subnet> [for <duration>] [commentary]]",
            "         @blacklist [<domain or subnet> [for <duration>] [commentary]]",
            "         @graylist  [<domain or subnet> [for <duration>] [commentary]]",
            "         @spooflist [<domain or subnet> [for <duration>] [commentary]]",
            "",
            "Syntax:  @unredlist   [<domain or subnet> [commentary]]",
            "         @unblacklist [<domain or subnet> [commentary]]",
            "         @ungraylist  [<domain or subnet> [commentary]]",
            "         @unspooflist [<domain or subnet> [commentary]]",
            "",
            "With no argument, the current contents of the corresponding list are printed.",
            "Otherwise, the specified domain or subnet is added to or removed from the list and mail will be sent to $site_log.",
            "",
            "To add a domain or subnet to a *list only temporarily, include a `for <duration>' statement before any commentary.  The <duration> should be in english form such as 1 day or 1 month 2 weeks or 1 year 3 months 2 weeks 4 days.  No commas should separate increments in the duration.  See `help $time_utils:parse_english_time_interval' for more details.  If you are not temporarily *listing a domain or subnet, but are including a commentary, be sure that the commentary does not start with the word `for'.",
            "",
            "If the given domain or subnet has subdomains/subsubnets that are already on the list, you will be prompted as to whether you want to remove them.  Note that adding an entry for a particular domain or subnet effectively adds all subdomains/subsubnets, so unless there's some reason for keeping an explicit entry for a particular subdomain, chances are you will indeed want to remove them.  One reason to keep an explicit entry for a subdomain would be if you intended to unlist the full domain later but wanted to be sure you didn't unlist the subdomain in the process.",
            "",
            "See `help blacklist' for a description of the functions of these lists."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @make-guest <adjective>",
            "",
            "This creates a new guest character.  For example,",
            "  @make-guest Loud",
            "creates a child of $guest, owned by $hacker, named Loud_Guest and with aliases Loud and Loud_Guest.",
            "",
            "Note that in order to have `connect guest' connect to a guest character, there needs to exist some guest character having \"Guest\" as a name or alias.",
            "",
            "See also `help @make-player'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "blacklist"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@make-player name [email-address [commentary]]",
            "Creates a player.",
            "Generates a random password for the player.",
            "Email-address is stored in $registration_db and on the player object.",
            "Comments should be enclosed in quotes.",
            "",
            "Example: @make-player George sanford@frobozz.com \"George shares email with Fred Sanford (Fred #5461)\"",
            "",
            "If the email address is already in use, prompts for confirmation.  If the name is already in use, prompts for confirmation.  (Say no, this is a bug: it will break if you say yes.)  If you say no at one of the confirming prompts, character is not made.",
            "",
            "If network is enabled (via $network.active) then asks if you want to mail the password to the user after character is made."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Information about $wizard:@register",
            "----",
            "Registers a player.",
            "Syntax:  @register name email-address [additional commentary]",
            "Email-address is stored in $registration_db and on the player object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@new-password player is [password]",
            "Sets a player's password; omit password string to have one randomly generated.  Prints the encrypted old string when done for error recovery.  [No current software will allow you to give the encrypted string as input.]",
            "",
            "Offers to send mail to the user with the new password, if the user has a registered email address and the network is enabled."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Information about $wiz:@deprog*rammer",
            "----",
            "@deprogrammer victim [for <duration>] [reason]",
            "",
            "Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "If you are a wizard, '@forked' with no arguments will spam you with all the forked tasks that there are (this is useful sometimes, but it's nice to know ahead of time).",
            "",
            "To see just your own, type '@forked me'.  To see just one player's, type '@forked <player>'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "You probably want to subscribe to (or at least be familiar with) the following mailing lists:",
            "",
            "*Player-Creation-Log",
            "*New-Prog-Log",
            "*Quota-Log",
            "*News",
            "*Site-Locks",
            "*Password-Change-Log",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Information about generic wizard(#218):@grant/@grants*/@transfer",
            "----",
            "@grant <object> to <player>",
            "@grants <object> to <player>   --- same as @grant but may suspend.",
            "@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer.",
            "",
            "Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).",
            "",
            "This verb does the transfer whether the recipient has enough quota for it or not."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'.",
            "",
            "To get a list of the object numbers associated with various $help databases, type 'help index'.",
            "",
            "If you need to modify existing help text, and need to find which help database the relevant property is defined on, use 'help full-index'.  (Note, it's spammy, but tells you what you need to know.)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Other topics of interest to wizards:",
            "",
            "$login",
            "$guest_log",
            "$no_one",
            "$recycler",
            "$help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Information about $wiz:@temp-newt",
            "----",
            "@temp-newt victim [for duration] [reason]",
            "",
            "Temporarily newts victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. E will be automatically removed the first time e tries to connect after the duration expires.  You will be prompted for a reason for the newting, but as of this writing, specifying a reason from the command line isn't an option."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "To look at where a player is currently connecting from, use @netwho.  To see previous connect sites, look at <player>.all_connect_places."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "General procedure:",
            "",
            "  Make sure e doesn't own anything.",
            "  @toad em",
            "  @recycle em",
            "",
            "It makes a real mess if you don't clean up .owned_objects.  See $wiz_utils:initialize_owned, but note, running this verb takes maybe three hours (at last report) and adds to lag.  This is why we frown so severely on leaving blood on the carpet."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Some wizards choose not to be among those listed when a player types '@wizards' (or similar).",
            "",
            "The property $wiz.advertised defaults to 1; set it to 0 to remove yourself from the list.",
            "",
            "To keep your non-wizard character off the list, set your wizard character's .public_identity character to 0.  To get it back on, set .public_identity to the object number of your non-wizard character.",
            "",
            "$wiz_utils:is_wizard returns true for the wizard and the corresponding .public_identity player.  Both will likewise appear in $wiz_utils:connected_wizards_unadvertised() and $wiz_utils:all_wizards_unadvertised().",
            "",
            ":is_wizard is for checking permissions on wizard feature-objects and the like, while :all/connected_wizards_unadvertised wouble be for things like wizard-shouts (e.g., the one issued by $player:recycle)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "To add a news item:",
            "",
            "Send regular mail to *news with the message you want in the news.  Then:",
            "",
            "  @addnews <message-number> to %[tostr($news)]",
            "",
            "To remove a news item:",
            "",
            "  @rmnews <message-number> from %[tostr($news)]",
            "",
            "Note, the message date doesn't show up, so you might consider adding a date to the message body itself."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "There are a number of routine daily or weekly tasks that can help keep your MOO clean or otherwise well-maintained.",
            "",
            "",
            "$byte_quota_utils:schedule_measurement_task",
            "        If you are using byte quota, this will schedule your quota measurement task.  Every night, every item on the moo which has not been measured in the last $byte_quota_utils.cycle_days will be measured.  A report will be mailed to $byte_quota_utils.report_recipients.  You may wish to edit this verb to change the time that it runs---it will run at midnight PST.",
            "",
            "$wiz_utils:expire_mail_weekly",
            "        If you wish to expire old mail from users and mailing lists, run this verb.  Once a week (scheduled from the first time you type ;$wiz_utils:expire_mail_weekly(), not at a particular hour) it will go through and expire mail based on players' @mail-options settings.",
            "",
            "$wiz_utils:flush_editors",
            "        Once a week this will remove all sessions which were begun more than 30 days ago in the note, verb, and mail editors.  Schedule is from when first typed.",
            "",
            "$paranoid_db:semiweeklyish",
            "        This will go through the @paranoid database and remove entries for players who have not connected within the past three days, and for those users who have turned off the @paranoid function.  Schedule is at 11pm PST.",
            "",
            "$login:sample_lag",
            "        This will provide an estimate of the CPU portion of what is normally called \"lag\"---that is, the delay between entering a command and having that command fulfilled.",
            "",
            "$housekeeper:continuous",
            "        If you wish to provide players with the ability to have individual items transported to a known starting location, use this verb.",
            "",
            "",
            "Additionally, there are tasks that you don't have to start manually, but which get started by various actions in the MOO.",
            "",
            "$network:add_queued_mail",
            "        This indicates that there was a temporary failure to deliver email.  If this task is constantly in the queue, it is worth checking $network.queued_mail, deleting those which will never be delivered.  Queued mail does not expire.",
            "",
            "$housekeeper:move_players_home",
            "        This task is used to consolidate the tasks spawned by disconnecting players---they get a 5 minute grace period to log back in before they are moved back home."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@chown"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@grep"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The MUD Server Status Protocol is a telnet protocol that allows your MOO to send detailed information to interested clients or MUD crawlers. At the time of writing, details on the protocol are outlined here: https://tintin.mudhalla.net/protocols/mssp/",
            "",
            "The ToastCore MSSP implementation lives on the Telnet Handler ($telnet) object. To enable MSSP, set the '$telnet.mssp_active` property to 1. This is the default value.",
            "",
            "Some crawlers and clients don't support the MSSP telnet protocol, but they do support a plaintext fallback. ToastCore implements this fallback via the 'mssp-request' verb on $login. Note that it also obeys the '$telnet.mssp_active' setting.",
            "",
            "MSSP variables are stored in the map '$telnet.mssp_data'. To add a new value, simply add a new key with the name of the MSSP variable. The value can be one of:",
            "",
            "$nothing - For all intents and purposes, the variable does not exist and will not be sent.",
            "1        - This indicates that the value should be derived from a verb on $telnet. Verb names should be in the form: \"mssp_variableName\"",
            "<other>  - Any other value is returned literally.",
            "",
            "If you need the literal value 1, simply omit the verb. The value \"1\" will be used.",
            "",
            "Examples:",
            "1. Implementing the \"name\" variable and returning '$network.moo_name'.",
            "This would require a verb. First, add the variable to the 'mssp_data' property and indicate that it's a verb (by giving it a value of 1):",
            "",
            ">;$telnet.mssp_data[\"name\"] = 1",
            "",
            "Now you would need to add a \"mssp_name\" verb to $telnet and program it.",
            "",
            ">@verb $telnet:mssp_name tnt",
            "",
            ">@prog $telnet:mssp_name",
            "return $network.moo_name;",
            ".",
            "",
            "You're done! Note that this is only an example. The name variable is already available by default.",
            "",
            "2. Implement the \"genre\" variable to indicate that your game is 'Science Fiction'.",
            "This is simply a matter of adding a key -> value pair to the 'mssp_data' map:",
            "",
            ">;$telnet.mssp_data[\"genre\"] = \"Science Fiction\"",
            "",
            "Done!"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "wiz-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Wizard Help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This describes the various commands available on $wiz."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            36730,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "24": {
      "id": 24,
      "name": "Wizard Utilities",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set_programmer",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_programmer(victim[,mail from])  => 1 or error.\";",
            "\"Sets victim.programmer, chparents victim to $prog if necessary, and sends mail to $new_prog_log, mail is from optional second arg or caller_perms().\";",
            "whodunnit = caller_perms();",
            "{victim, ?mailfrom = whodunnit} = args;",
            "if (!whodunnit.wizard)",
            "return E_PERM;",
            "elseif (!(valid(victim) && (is_player(victim) && $object_utils:isa(victim, $player))))",
            "return E_INVARG;",
            "elseif (victim.programmer)",
            "return E_NONE;",
            "elseif (this:check_prog_restricted(victim))",
            "return E_INVARG;",
            "elseif (typeof(e = `victim.programmer = 1 ! ANY') == ERR)",
            "return e;",
            "else",
            "$quota_utils:adjust_quota_for_programmer(victim);",
            "if (!$object_utils:isa(victim, $prog))",
            "if (typeof(e = `chparent(victim, $prog) ! ANY') == ERR)",
            "\"...this isn't really supposed to happen but it could...\";",
            "player:notify(tostr(\"chparent(\", victim, \",\", $prog, \") failed:  \", e));",
            "player:notify(\"Check for common properties.\");",
            "endif",
            "else",
            "player:notify(tostr(victim.name, \" was already a child of \", parent(victim).name, \" (\", parent(victim), \")\"));",
            "endif",
            "if (!$mail_agent:send_message(mailfrom, {$new_prog_log, victim}, tostr(\"@programmer \", victim.name, \" (\", victim, \")\"), tostr(\"I just gave \", victim.name, \" a programmer bit.\"))[1])",
            "$mail_agent:send_message(mailfrom, {$new_prog_log}, tostr(\"@programmer \", victim.name, \" (\", victim, \")\"), tostr(\"I just gave \", victim.name, \" a programmer bit.\"));",
            "endif",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "set_player",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_player(victim[,nochown]) => 1 or error\";",
            "\"Set victim's player flag, (maybe) chown to itself, add name and aliases to $player_db.\";",
            "\" E_NONE == already a player,\";",
            "\" E_NACC == player_db is frozen,\";",
            "\" E_RECMOVE == name is unavailable\";",
            "{victim, ?nochown = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!(valid(victim) && $object_utils:isa(victim, $player)))",
            "return E_INVARG;",
            "elseif (is_player(victim))",
            "return E_NONE;",
            "elseif ($player_db.frozen)",
            "return E_NACC;",
            "elseif (!$player_db:available(name = victim.name))",
            "return E_RECMOVE;",
            "else",
            "set_player_flag(victim, 1);",
            "if (0 && $object_utils:isa(victim, $prog))",
            "victim.programmer = 1;",
            "else",
            "victim.programmer = $player.programmer;",
            "endif",
            "if (!nochown)",
            "$wiz_utils:set_owner(victim, victim);",
            "endif",
            "$player_db:insert(name, victim);",
            "for a in (setremove(aliases = victim.aliases, name))",
            "if (index(a, \" \"))",
            "\"..ignore ..\";",
            "elseif ($player_db:available(a) in {this, 1})",
            "$player_db:insert(a, victim);",
            "else",
            "aliases = setremove(aliases, a);",
            "endif",
            "endfor",
            "victim.aliases = setadd(aliases, name);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "set_owner",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug). If force is specified and the object is already owned by newowner, c property ownership will proceed.\";",
            "{object, newowner, ?suspendok = 0, ?force = 0} = args;",
            "if (!valid(object))",
            "return E_INVIND;",
            "elseif (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!(valid(newowner) && is_player(newowner)))",
            "return E_INVARG;",
            "elseif ((object.owner == newowner) && (!force))",
            "return 1;",
            "endif",
            "oldowner = object.owner;",
            "object.owner = newowner;",
            "for pname in ($object_utils:all_properties(object))",
            "if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))",
            "suspend(0);",
            "endif",
            "perms = property_info(object, pname)[2];",
            "if (index(perms, \"c\"))",
            "set_property_info(object, pname, {newowner, perms});",
            "endif",
            "endfor",
            "if ($object_utils:isa(oldowner, $player))",
            "if (is_player(oldowner) && (object != oldowner))",
            "$quota_utils:reimburse_quota(oldowner, object);",
            "endif",
            "if (typeof(oldowner.owned_objects) == LIST)",
            "oldowner.owned_objects = setremove(oldowner.owned_objects, object);",
            "endif",
            "endif",
            "if ($object_utils:isa(newowner, $player))",
            "if (object != newowner)",
            "$quota_utils:charge_quota(newowner, object);",
            "endif",
            "if (typeof(newowner.owned_objects) == LIST)",
            "newowner.owned_objects = setadd(newowner.owned_objects, object);",
            "endif",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "set_property_owner",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_property_owner(object,prop,newowner[,suspendok])  changes the ownership of object.prop to newowner.  If the property is !c, changes the ownership on all of the descendents as well.  Otherwise, we just chown the property on the object itself and give a warning if newowner!=object.owner (--Rog thinks this is a server bug that one is able to do this at all...).\";",
            "{object, pname, newowner, ?suspendok = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!(info = `property_info(object, pname) ! ANY'))",
            "\"... handles E_PROPNF and invalid object errors...\";",
            "return info;",
            "elseif (!is_player(newowner))",
            "return E_INVARG;",
            "elseif (index(info[2], \"c\"))",
            "if (suspendok / 2)",
            "\"...(recursive call)...\";",
            "\"...child property is +c while parent is -c??...RUN AWAY!!\";",
            "return E_NONE;",
            "else",
            "set_property_info(object, pname, listset(info, newowner, 1));",
            "return (newowner == object.owner) || E_NONE;",
            "endif",
            "else",
            "set_property_info(object, pname, listset(info, newowner, 1));",
            "if ((suspendok % 2) && ((ticks_left() < 10000) || (seconds_left() < 2)))",
            "suspend(0);",
            "endif",
            "suspendok = 2 + suspendok;",
            "for c in (children(object))",
            "this:set_property_owner(c, pname, newowner, suspendok);",
            "endfor",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "unset_player",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":unset_player(victim[,newowner])  => 1 or error\";",
            "\"Reset victim's player flag, chown victim to newowner (if given), remove all of victim's names and aliases from $player_db.\";",
            "{victim, ?newowner = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!valid(victim))",
            "return E_INVARG;",
            "elseif (!is_player(victim))",
            "return E_NONE;",
            "endif",
            "if (typeof(newowner) == OBJ)",
            "$wiz_utils:set_owner(victim, newowner);",
            "endif",
            "victim.programmer = 0;",
            "victim.wizard = 0;",
            "set_player_flag(victim, 0);",
            "if ($object_utils:has_property($local, \"second_char_registry\"))",
            "$local.second_char_registry:delete_player(victim);",
            "`$local.second_char_registry:delete_shared(victim) ! ANY';",
            "endif",
            "if ($player_db.frozen)",
            "player:tell(\"Warning:  player_db is in the middle of a :load().\");",
            "endif",
            "$player_db:delete2(victim.name, victim);",
            "for a in (victim.aliases)",
            "$player_db:delete2(a, victim);",
            "\"I don't *think* this is bad---we've already toaded the guy.  And folks with lots of aliases screw us. --Nosredna\";",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return 1;",
            "\"Paragraph (#122534) - Sat Nov 5, 2005 - Remove any shared character registry listings for `victim'.\";"
          ]
        },
        {
          "name": "set_property_flags",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_property_flags(object,prop,flags[,suspendok])  changes the permissions on object.prop to flags.  Unlike a mere set_property_info, this changes the flags on all descendant objects as well.  We also change the ownership on the descendent properties where necessary.\";",
            "{object, pname, flags, ?suspendok = 0} = args;",
            "perms = caller_perms();",
            "if (!(info = `property_info(object, pname) ! ANY'))",
            "\"... handles E_PROPNF and invalid object errors...\";",
            "return info;",
            "elseif ($set_utils:difference($string_utils:char_list(flags), {\"r\", \"w\", \"c\"}))",
            "\"...not r, w, or c?...\";",
            "return E_INVARG;",
            "elseif ((pinfo = `property_info(parent(object), pname) ! ANY') && (flags != pinfo[2]))",
            "\"... property doesn't actually live here...\";",
            "\"... only allowed to correct so that this property matches parent...\";",
            "return E_INVARG;",
            "elseif (!(perms.wizard || (info[1] == perms)))",
            "\"... you have to own the property...\";",
            "return E_PERM;",
            "elseif (!(((!(c = index(flags, \"c\"))) == (!index(info[2], \"c\"))) || $perm_utils:controls(perms, object)))",
            "\"... if you're changing the c flag, you have to own the object...\";",
            "return E_PERM;",
            "else",
            "if (c)",
            "set_property_info(object, pname, {object.owner, kflags = flags});",
            "else",
            "set_property_info(object, pname, kflags = listset(info, flags, 2));",
            "endif",
            "for kid in (children(object))",
            "this:_set_property_flags(kid, pname, kflags, suspendok);",
            "endfor",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "_set_property_flags",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"_set_property_flags(object, pname, {owner, flags} or something+\\\"c\\\", suspendok)\";",
            "\"auxiliary to :set_property_flags... don't call this directly.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "if (args[4] && $command_utils:running_out_of_time(0))",
            "suspend(0);",
            "endif",
            "object = args[1];",
            "if (typeof(args[3]) != LIST)",
            "set_property_info(object, args[2], {object.owner, args[3]});",
            "else",
            "set_property_info(@args[1..3]);",
            "endif",
            "for kid in (children(object))",
            "this:_set_property_flags(@listset(args, kid, 1));",
            "endfor"
          ]
        },
        {
          "name": "random_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"Generate a random password of length args[1].  Alternates vowels and consonants, for maximum pronounceability.  Uses its own list of consonants which exclude F and C and K to prevent generating obscene sounding passwords.\";",
            "\"Capital I and lowercase L are excluded on the basis of looking like each other.\";",
            "vowels = \"aeiouyAEUY\";",
            "consonants = \"bdghjmnpqrstvwxzBDGHJLMNPQRSTVWXZ\";",
            "len = toint(args[1]);",
            "if (len)",
            "alt = random(2) - 1;",
            "s = \"\";",
            "for i in [1..len]",
            "newchar = alt ? vowels[random($)] | consonants[random($)];",
            "s = s + newchar;",
            "alt = !alt;",
            "endfor",
            "return s;",
            "else",
            "return E_INVARG;",
            "endif"
          ]
        },
        {
          "name": "queued_tasks",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":queued_tasks(player) => list of queued tasks for that player.\";",
            "\"shouldn't the server builtin should work this way?  oh well\";",
            "set_task_perms(caller_perms());",
            "if (typeof(e = `set_task_perms(who = args[1]) ! ANY') == ERR)",
            "return e;",
            "elseif (who.wizard)",
            "tasks = {};",
            "for t in (queued_tasks())",
            "if (t[5] == who)",
            "tasks = {@tasks, t};",
            "endif",
            "endfor",
            "return tasks;",
            "else",
            "return queued_tasks();",
            "endif"
          ]
        },
        {
          "name": "isnewt",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"Return 1 if args[1] is a newted player.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "return args[1] in $login.newted;",
            "endif"
          ]
        },
        {
          "name": "initialize_owned",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "set_task_perms(caller_perms());",
            "player:tell(\"Beginning initialize_owned:  \", ctime());",
            "for o in [#0..max_object()]",
            "if (valid(o))",
            "if ($object_utils:isa(owner = o.owner, $player) && (typeof(owner.owned_objects) == LIST))",
            "owner.owned_objects = setadd(owner.owned_objects, o);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "player:tell(\"Done adding, beginning verification pass.\");",
            "this:verify_owned_objects();",
            "player:tell(\"Finished:  \", ctime());",
            "endif"
          ]
        },
        {
          "name": "verify_owned_objects",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "for p in (players())",
            "if (typeof(p.owned_objects) == LIST)",
            "for o in (p.owned_objects)",
            "if (((typeof(o) != OBJ) || (!valid(o))) || (o.owner != p))",
            "p.owned_objects = setremove(p.owned_objects, o);",
            "player:tell(\"Removed \", $string_utils:nn(o), \" from \", $string_utils:nn(p), \"'s .owned_objects list.\");",
            "if (((typeof(o) == OBJ) && valid(o)) && (typeof(o.owner.owned_objects) == LIST))",
            "o.owner.owned_objects = setadd(o.owner.owned_objects, o);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0, p);",
            "endfor",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "connected_wizards connected_wizards_unadvertised",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":connected_wizards() => list of currently connected wizards and players mentioned in .public_identity properties as being wizard counterparts.\";",
            "wizzes = $object_utils:leaves($wiz);",
            "wlist = {};",
            "everyone = verb == \"connected_wizards_unadvertised\";",
            "for w in (wizzes)",
            "if (w.wizard && (w.advertised || everyone))",
            "if (`connected_seconds(w) ! ANY => 0')",
            "wlist = setadd(wlist, w);",
            "endif",
            "if (`connected_seconds(w.public_identity) ! ANY => 0')",
            "wlist = setadd(wlist, w.public_identity);",
            "endif",
            "endif",
            "endfor",
            "return wlist;"
          ]
        },
        {
          "name": "all_wizards_advertised all_wizards all_wizards_unadvertised",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":all_wizards_advertised() => list of all wizards who have set .advertised true and players mentioned their .public_identity properties as being wizard counterparts\";",
            "wizzes = $object_utils:leaves($wiz);",
            "wlist = {};",
            "everyone = verb == \"all_wizards_unadvertised\";",
            "for w in (wizzes)",
            "if (w.wizard && (w.advertised || everyone))",
            "if (is_player(w))",
            "wlist = setadd(wlist, w);",
            "endif",
            "if (`is_player(w.public_identity) ! ANY')",
            "wlist = setadd(wlist, w.public_identity);",
            "endif",
            "endif",
            "endfor",
            "return wlist;"
          ]
        },
        {
          "name": "rename_all_instances",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":rename_all_instances(object,oldname,newname)\";",
            "\"Used to rename all instances of an unwanted verb (like recycle or disfunc)\";",
            "\"if said verb is actually defined on the object itself\";",
            "if (caller_perms().wizard)",
            "found = 0;",
            "{object, oldname, newname} = args;",
            "while (info = `verb_info(object, oldname) ! ANY')",
            "`set_verb_info(object, oldname, listset(info, newname, 3)) ! ANY';",
            "found = 1;",
            "endwhile",
            "return found;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "missed_help",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (this.record_missed_help && (callers()[1][4] == $player))",
            "miss = args[1];",
            "if (!(index = miss in this.missed_help_strings))",
            "this.missed_help_strings = {miss, @this.missed_help_strings};",
            "this.missed_help_counters = {{0, 0}, @this.missed_help_counters};",
            "index = 1;",
            "endif",
            "which = args[2] ? 2 | 1;",
            "this.missed_help_counters[index][which] = this.missed_help_counters[index][which] + 1;",
            "endif"
          ]
        },
        {
          "name": "show_missing_help",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "mhs = this.missed_help_strings;",
            "cnt = this.missed_help_counters;",
            "\"save values first, so subsequent changes during suspends wont affect it\";",
            "thresh = args ? args[1] | 5;",
            "strs = {};",
            "for i in [1..length(mhs)]",
            "$command_utils:suspend_if_needed(0);",
            "if ((cnt[i][1] + cnt[i][2]) > thresh)",
            "strs = {@strs, ((($string_utils:right(tostr(cnt[i][1]), 5) + \" \") + $string_utils:right(tostr(cnt[i][2]), 5)) + \" \") + mhs[i]};",
            "endif",
            "endfor",
            "sorted = $list_utils:sort_suspended(0, strs);",
            "len = length(sorted);",
            "player:tell(\" miss ambig word\");",
            "for x in [1..len]",
            "$command_utils:suspend_if_needed(0);",
            "player:tell(sorted[(len - x) + 1]);",
            "endfor",
            "player:tell(\" - - - - - - - - -\");"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "`delete_property(this, \"guest_feature_restricted\") ! ANY';",
            "this.boot_exceptions = {};",
            "this.programmer_restricted = {};",
            "this.programmer_restricted_temp = {};",
            "this.chparent_restricted = {};",
            "this.rename_restricted = {};",
            "this.change_password_restricted = {};",
            "this.record_missed_help = 0;",
            "this.missed_help_counters = this.missed_help_strings = {};",
            "this.suicide_string = \"You don't *really* want to commit suicide, do you?\";",
            "this.wizards = {#2};",
            "this.next_perm_index = 1;",
            "this.system_chars = {$hacker, $no_one, $housekeeper};",
            "this.expiration_progress = $nothing;",
            "this.expiration_recipient = {#2};",
            "endif"
          ]
        },
        {
          "name": "show_netwho_listing",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":show_netwho_listing(tell,player_list)\";",
            "\" prints a listing of the indicated players showing connect sites.\";",
            "{who, unsorted} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!unsorted)",
            "return;",
            "endif",
            "su = $string_utils;",
            "au = $ansi_utils;",
            "alist = {};",
            "footnotes = {};",
            "nwidth = length(\"Player name\");",
            "for u in (unsorted)",
            "$command_utils:suspend_if_needed(0);",
            "if (u.programmer)",
            "pref = \"% \";",
            "footnotes = setadd(footnotes, \"prog\");",
            "else",
            "pref = \"  \";",
            "endif",
            "if (u in connected_players())",
            "lctime = ctime(time() - connected_seconds(u));",
            "where = $string_utils:connection_hostname(connection_name(u));",
            "else",
            "lctime = ctime(u.last_connect_time);",
            "where = u.last_connect_place;",
            "endif",
            "u3 = {tostr(pref, su:nn(u)), lctime[5..10] + lctime[20..24]};",
            "nwidth = max(au:length(u3[1]), nwidth);",
            "if ($login:blacklisted(where))",
            "where = \"(*) \" + where;",
            "footnotes = setadd(footnotes, \"black\");",
            "elseif ($login:graylisted(where))",
            "where = \"(+) \" + where;",
            "footnotes = setadd(footnotes, \"gray\");",
            "endif",
            "alist = {@alist, {@u3, where}};",
            "endfor",
            "alist = $list_utils:sort_alist_suspended(0, alist, 3);",
            "$command_utils:suspend_if_needed(0);",
            "headers = {\"Player name\", \"Last Login\", \"From Where\"};",
            "before = {0, nwidth + 3, (nwidth + length(ctime(0))) - 11};",
            "tell1 = \"  \" + headers[1];",
            "tell2 = \"  \" + su:space(headers[1], \"-\");",
            "for j in [2..3]",
            "tell1 = su:left(tell1, before[j]) + headers[j];",
            "tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");",
            "endfor",
            "who:notify(tell1);",
            "who:notify(tell2);",
            "for a in (alist)",
            "$command_utils:suspend_if_needed(0);",
            "tell1 = a[1];",
            "for j in [2..3]",
            "tell1 = su:left(tell1, before[j]) + a[j];",
            "endfor",
            "who:notify(tell1[1..min($, player:linelen())]);",
            "endfor",
            "if (footnotes)",
            "who:notify(\"\");",
            "if (\"prog\" in footnotes)",
            "who:notify(\" %  == programmer.\");",
            "endif",
            "if (\"black\" in footnotes)",
            "who:notify(\"(*) == blacklisted site.\");",
            "endif",
            "if (\"gray\" in footnotes)",
            "who:notify(\"(+) == graylisted site.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "show_netwho_from_listing",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":show_netwho_from_listing(tell,site)\";",
            "\"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{tellwho, where} = args;",
            "su = $string_utils;",
            "if (!index(where, \"*\"))",
            "\"Oh good... search for users from a site... the fast way.  No wild cards.\";",
            "nl = 0;",
            "bozos = {};",
            "sites = $site_db:find_all_keys(where);",
            "while (sites)",
            "s = sites;",
            "sites = {};",
            "for domain in (s)",
            "\"Temporary kluge until $site_db is repaired. --Nosredna\";",
            "for b in ($site_db:find_exact(domain) || {})",
            "$command_utils:suspend_if_needed(0, \"..netwho..\");",
            "if (typeof(b) == STR)",
            "sites = setadd(sites, (b + \".\") + domain);",
            "else",
            "bozos = setadd(bozos, b);",
            "nl = max(length(tostr(b, (valid(b) && is_player(b)) ? b.name | \"*** recreated ***\")), nl);",
            "endif",
            "endfor",
            "endfor",
            "endwhile",
            "if (bozos)",
            "tellwho:notify(tostr(su:left(\"  Player\", nl + 7), \"From\"));",
            "tellwho:notify(tostr(su:left(\"  ------\", nl + 7), \"----\"));",
            "for who in (bozos)",
            "st = su:left(tostr((valid(who) && is_player(who)) ? (who.programmer ? \"% \" | \"  \") + who.name | \"\", \" (\", who, \")\"), nl + 7);",
            "comma = 0;",
            "if ($object_utils:isa(who, $player) && is_player(who))",
            "for p in ({$wiz_utils:get_email_address(who) || \"*Unregistered*\", @who.all_connect_places})",
            "if (comma && (length(p) >= (78 - length(st))))",
            "tellwho:notify(tostr(st, \",\"));",
            "st = su:space(nl + 7) + p;",
            "else",
            "st = tostr(st, comma ? \", \" | \"\", p);",
            "endif",
            "comma = 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "else",
            "st = st + (valid(who) ? \"*** recreated ***\" | \"*** recycled ***\");",
            "endif",
            "tellwho:notify(st);",
            "endfor",
            "tellwho:notify(\"\");",
            "tellwho:notify(tostr(length(bozos), \" player\", (length(bozos) == 1) ? \"\" | \"s\", \" found.\"));",
            "else",
            "tellwho:notify(tostr(\"No sites matching `\", where, \"'\"));",
            "endif",
            "else",
            "\"User typed 'from'.  Go search for users from this site.  (SLOW!)\";",
            "howmany = 0;",
            "for who in (players())",
            "$command_utils:suspend_if_needed(0);",
            "matches = {};",
            "for name in (who.all_connect_places)",
            "if ((index(where, \"*\") && su:match_string(name, where)) || ((!index(where, \"*\")) && index(name, where)))",
            "matches = {@matches, name};",
            "endif",
            "endfor",
            "if (matches)",
            "howmany = howmany + 1;",
            "tellwho:notify(tostr(who.name, \" (\", who, \"): \", su:english_list(matches)));",
            "endif",
            "endfor",
            "tellwho:notify(tostr(howmany || \"No\", \" matches found.\"));",
            "endif"
          ]
        },
        {
          "name": "check_player_request check_reregistration",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":check_player_request(name [,email [,connection]])\";",
            "\" check if the request for player and email address is valid;\";",
            "\" return empty string if it valid, or else a string saying why not.\";",
            "\" The result starts with - if this is a 'send email, don't try again' situation.\";",
            "\":check_reregistration(who, email, connection)\";",
            "\"  Since name is ignored, only check the 'email' parts and use the first arg\";",
            "\"  for the re-registering player.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "\"accesses registration information -- wiz only\";",
            "endif",
            "name = args[1];",
            "if (verb == \"check_reregistration\")",
            "\"don't check player name\";",
            "elseif (!name)",
            "return \"A blank name isn't allowed.\";",
            "elseif (name == \"<>\")",
            "return \"Names with angle brackets aren't allowed.\";",
            "elseif (index(name, \" \"))",
            "return \"Names with spaces are not allowed. Use dashes or underscores.\";",
            "elseif (match(name, \"^<.*>$\"))",
            "return tostr(\"Try using \", name[2..$ - 1], \" instead of \", name, \".\");",
            "elseif ($player_db.frozen)",
            "return \"New players cannot be created at the moment, try again later.\";",
            "elseif (!$player_db:available(name))",
            "return (\"The name '\" + name) + \"' is not available.\";",
            "elseif ($login:_match_player(name) != $failed_match)",
            "return (\"The name '\" + name) + \"' doesn't seem to be available.\";",
            "endif",
            "if (length(args) == 1)",
            "\"no email address supplied.\";",
            "return \"\";",
            "endif",
            "address = args[2];",
            "addrargs = (verb == \"check_reregistration\") ? {name} | {};",
            "if ($registration_db:suspicious_address(address, @addrargs))",
            "return \"-There has already been a character with that or a similar email address.\";",
            "endif",
            "if (reason = $network:invalid_email_address(address))",
            "return reason + \".\";",
            "endif",
            "parsed = $network:parse_address(address);",
            "if ($registration_db:suspicious_userid(parsed[1]))",
            "return tostr(\"-Automatic registration from an account named \", parsed[1], \" is not allowed.\");",
            "endif",
            "connection = (length(args) > 2) ? args[3] | parsed[2];",
            "check_connection = $wiz_utils.registration_domain_restricted && (verb == \"check_player_request\");",
            "if ((connection[max($ - 2, 1)..$] == \".uk\") && (parsed[2][1..3] == \"uk.\"))",
            "return tostr(\"Addresses must be in internet form. Try \", parsed[1], \"@\", $string_utils:from_list($list_utils:reverse($string_utils:explode(parsed[2], \".\")), \".\"), \".\");",
            "elseif (check_connection && match(connection, \"^[0-9.]+$\"))",
            "\"Allow reregistration from various things we wouldn't allow registration from.  Let them register to their yahoo acct...\";",
            "return \"-The system cannot resolve the name of the system you're connected from.\";",
            "elseif (check_connection && ((a = $network:local_domain(connection)) != (b = $network:local_domain(parsed[2]))))",
            "return tostr(\"-The connection is from '\", a, \"' but the mail address is '\", b, \"'; these don't seem to be the same place.\");",
            "elseif ((verb == \"check_player_request\") && $login:spooflisted(parsed[2]))",
            "return tostr(\"-Automatic registration is not allowed from \", parsed[2], \".\");",
            "endif",
            "return \"\";"
          ]
        },
        {
          "name": "make_player",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"create a player named NAME with email address ADDRESS; return {object, password}.  Optional third arg is comment to be put in registration db.\";",
            "\"assumes $wiz_utils:check_player_request() has been called and it passes.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{name, address, @rest} = args;",
            "new = $quota_utils:bi_create($player_class, $nothing);",
            "new.name = name;",
            "new.aliases = {name};",
            "new.password = $login:encrypt_password(password = $wiz_utils:random_password(5));",
            "new.last_password_time = time();",
            "new.last_connect_time = $maxint;",
            "\"Last disconnect time is creation time, until they login.\";",
            "new.last_disconnect_time = time();",
            "$quota_utils:initialize_quota(new);",
            "if (!(error = $wiz_utils:set_player(new)))",
            "return player:tell(\"An error, \", error, \" occurred while trying to make \", new, \" a player. The database is probably inconsistent.\");",
            "endif",
            "$wiz_utils:set_email_address(new, address);",
            "$registration_db:add(new, address, @rest);",
            "move(new, $player_start);",
            "new.programmer = $player_class.programmer;",
            "return {new, password};"
          ]
        },
        {
          "name": "send_new_player_mail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":send_new_player_mail(preface, name, address, character#, password)\";",
            "\"  used by $wiz:@make-player and $guest:@request\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{preface, name, address, new, password} = args;",
            "msg = {preface};",
            "msg = {@msg, tostr(\"A character has been created, with name \\\"\", name, \"\\\" and password \\\"\", password, \"\\\".\"), \"Passwords are case sensitive, which means you have to type it exactly as\", \"it appears here, including capital and lowercase letters.\", \"So, to log in, you would type:\", tostr(\"  Connect \", name, \" \", password)};",
            "if ($object_utils:has_property($local, \"new_player_message\"))",
            "msg = {@msg, @$local.new_player_message};",
            "endif",
            "return $network:sendmail(address, ((\"Your \" + $network.moo_name) + \" character, \") + name, \"Reply-to: \" + $login.registration_address, @msg);"
          ]
        },
        {
          "name": "do_make_player",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 24,
          "code": [
            "\"do_maker_player(name,email,[comment])\";",
            "\"Common code for @make-player\";",
            "\"If no password is given, generates a random password for the player.\";",
            "\"Email-address is stored in $registration_db and on the player object.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{name, email, @comments} = args;",
            "comments = $string_utils:from_list(comments, \" \");",
            "reason = $wiz_utils:check_player_request(name, email);",
            "if (others = $registration_db:find_exact(email))",
            "player:notify(email + \" is the registered address of the following characters:\");",
            "for x in (others)",
            "player:notify(tostr(valid(x[1]) ? x[1].name | \"<recycled>\", (valid(x[1]) && (!is_player(x[1]))) ? \" {nonplayer}\" | \"\", \" (\", x[1], \") \", (length(x) > 1) ? (\"[\" + tostr(@x[2..$])) + \"]\" | \"\"));",
            "endfor",
            "if (!reason)",
            "reason = \"Already registered.\";",
            "endif",
            "endif",
            "if (reason)",
            "player:notify(reason);",
            "if (!$command_utils:yes_or_no(\"Create character anyway? \"))",
            "player:notify(\"Character not created.\");",
            "return;",
            "endif",
            "endif",
            "new = $wiz_utils:make_player(name, email, comments);",
            "player:notify(tostr(name, \" (\", new[1], \") created with password `\", new[2], \"' for \", email, comments ? (\" [\" + comments) + \"]\" | \"\"));",
            "$mail_agent:send_message(player, $new_player_log, tostr(name, \" (\", new[1], \")\"), tostr(email, comments ? \" \" + comments | \"\"));",
            "if ($network.active)",
            "if ($command_utils:yes_or_no((\"Send email to \" + email) + \" with password? \"))",
            "player:notify(tostr(\"Sending the password to \", email, \".\"));",
            "if ((result = $wiz_utils:send_new_player_mail(tostr(\"From \", player.name, \"@\", $network.moo_name, \":\"), name, email, new[1], new[2])) == 0)",
            "player:notify(tostr(\"Mail sent successfully to \", email, \".\"));",
            "else",
            "player:tell(\"Cannot send mail: \", result);",
            "endif",
            "else",
            "player:notify(\"No mail sent.\");",
            "endif",
            "else",
            "player:notify(\"Sorry, the network isn't active.\");",
            "endif"
          ]
        },
        {
          "name": "do_register",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"do_register(name, email_address [,comments])\";",
            "\"change player's email address.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{whostr, email, @comments} = args;",
            "comments = $string_utils:from_list(comments);",
            "who = $string_utils:match_player(whostr);",
            "if ($command_utils:player_match_failed(who, whostr))",
            "return;",
            "endif",
            "if (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))",
            "player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));",
            "return;",
            "endif",
            "if (reason = $network:invalid_email_address(email))",
            "player:notify(reason);",
            "if (!$command_utils:yes_or_no(\"Register anyway?\"))",
            "return player:notify(\"re-registration aborted.\");",
            "endif",
            "endif",
            "if (comments)",
            "$registration_db:add(who, email, comments);",
            "else",
            "$registration_db:add(who, email);",
            "endif",
            "old = $wiz_utils:get_email_address(who);",
            "$wiz_utils:set_email_address(who, email);",
            "player:notify(tostr(who.name, \" (\", who, \") formerly \", old ? old | \"unregistered\", \", registered at \", email, \".\", comments ? (\" [\" + comments) + \"]\" | \"\"));"
          ]
        },
        {
          "name": "do_new_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"do_new_password(who, [password])\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{who, ?password = $wiz_utils:random_password(6)} = args;",
            "if (!password)",
            "password = $wiz_utils:random_password(6);",
            "endif",
            "whostr = $string_utils:nn(who);",
            "player:notify(tostr(\"About to change password for \", whostr, \". Old encrypted password is \\\"\", who.password, \"\\\"\"));",
            "who.password = $login:encrypt_password(password);",
            "who.last_password_time = time();",
            "player:notify(tostr(whostr, \" new password is `\", password, \"'.\"));",
            "if (!$wiz_utils:get_email_address(who))",
            "player:notify(tostr(whostr, \" doesn't have a registered email_address, cannot mail password; tell them some some other way.\"));",
            "elseif ((who.last_connect_time == $maxint) && $command_utils:yes_or_no(tostr(who.name, \" has never logged in.  Send mail with the password as though this were a new player request?\")))",
            "if ((result = $wiz_utils:send_new_player_mail(tostr(\"From \", player.name, \"@\", $network.moo_name, \":\"), who.name, $wiz_utils:get_email_address(who), who, password)) == 0)",
            "player:tell(\"Mail sent.\");",
            "else",
            "player:tell(\"Trouble sending mail: \", result);",
            "endif",
            "elseif ($command_utils:yes_or_no(tostr(\"Email new password to \", whostr, \"?\")))",
            "player:notify(\"Sending the password via email.\");",
            "$network:adjust_postmaster_for_password(\"enter\");",
            "if ((result = $network:sendmail($wiz_utils:get_email_address(who), (\"Your \" + $network.moo_name) + \" password\", (\"The password for your \" + $network.moo_name) + \" character:\", \" \" + whostr, \"has been changed. The new password is:\", \" \" + password, \"\", \"Please note that passwords are case sensitive.\")) == 0)",
            "player:tell(\"Mail sent.\");",
            "else",
            "player:tell(\"Trouble sending mail: \", result);",
            "endif",
            "$network:adjust_postmaster_for_password(\"exit\");",
            "else",
            "player:tell(\"No mail sent.\");",
            "endif"
          ]
        },
        {
          "name": "set_owner_new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).\";",
            "{object, newowner, ?suspendok = 0} = args;",
            "if (!valid(object))",
            "return E_INVIND;",
            "elseif (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!(valid(newowner) && is_player(newowner)))",
            "return E_INVARG;",
            "endif",
            "oldowner = object.owner;",
            "object.owner = newowner;",
            "for pname in ($object_utils:all_properties(object))",
            "if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))",
            "suspend(0);",
            "endif",
            "perms = property_info(object, pname)[2];",
            "if (index(perms, \"c\"))",
            "set_property_info(object, pname, {newowner, perms});",
            "endif",
            "endfor",
            "if ($object_utils:isa(oldowner, $player))",
            "if (is_player(oldowner) && (object != oldowner))",
            "$quota_utils:reimburse_quota(oldowner, object);",
            "endif",
            "if (typeof(oldowner.owned_objects) == LIST)",
            "oldowner.owned_objects = setremove(oldowner.owned_objects, object);",
            "endif",
            "endif",
            "if ($object_utils:isa(newowner, $player))",
            "if (object != newowner)",
            "$quota_utils:charge_quota(newowner, object);",
            "endif",
            "if (typeof(newowner.owned_objects) == LIST)",
            "newowner.owned_objects = setadd(newowner.owned_objects, object);",
            "endif",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "boot_idlers",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "\"------- constants ---- \";",
            "\"20 minutes idle for regular players\";",
            "mintime = 60 * 20;",
            "\"10 minutes for guests\";",
            "minguest = 60 * 10;",
            "\"wait 3 minutes before actually booting\";",
            "bootdelay = 3;",
            "\"start booting when there are 20 less than max players\";",
            "threshold = 20;",
            "\" ----------------------\";",
            "if ($code_utils:task_valid(this.boot_task) && (task_id() != this.boot_task))",
            "\"starting a new one: kill the old one\";",
            "kill_task(this.boot_task);",
            "this.boot_task = 0;",
            "endif",
            "fork taskn ((bootdelay * 60) * 3)",
            "maxplayers = $login:max_connections() - threshold;",
            "if (length(pl = connected_players()) > maxplayers)",
            "pll = {};",
            "plt = {};",
            "for x in (pl)",
            "suspend(0);",
            "min = $object_utils:isa(x, $guest) ? minguest | mintime;",
            "if ((((idle = `idle_seconds(x) ! ANY => 0') > min) && (!x.wizard)) && (!(x in this.boot_exceptions)))",
            "pll = {x, @pll};",
            "plt = {idle, @plt};",
            "endif",
            "endfor",
            "if (pll)",
            "\"Sort by idle time, and choose person who has been idle longest.\";",
            "pll = $list_utils:sort(pll, plt);",
            "booted = pll[$];",
            "guest = $object_utils:isa(booted, $guest);",
            "min = guest ? minguest | mintime;",
            "if (`idle_seconds(booted) ! ANY => 0' > min)",
            "notify(booted, tostr(\"*** You've been idle more than \", min / 60, \" minutes, and there are more than \", maxplayers, \" players connected. If you're still idle and \", $network.moo_name, \" is still busy in \", bootdelay, \" minute\", (bootdelay == 1) ? \"\" | \"s\", \", you will be booted. ***\"));",
            "fork (60 * bootdelay)",
            "idle = `idle_seconds(booted) ! ANY => 0';",
            "if ((idle > min) && (length(connected_players()) > ($login:max_connections() - threshold)))",
            "notify(booted, tostr(\"*** You've been idle too long and \", $network.moo_name, \" is still too busy ***\"));",
            "server_log(tostr(\"IDLE: \", booted.name, \" (\", booted, \") idle \", idle / 60));",
            "boot_player(booted);",
            "endif",
            "endfork",
            "endif",
            "endif",
            "endif",
            "this:(verb)(@args);",
            "endfork",
            "this.boot_task = taskn;",
            "\"This is set up so that it forks the task first, and this.boot_task is the task_id of whatever is running the idle booter\";"
          ]
        },
        {
          "name": "grant_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":grant_object(what, towhom);\";",
            "\"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{object, newowner} = args;",
            "if (!is_player(newowner))",
            "return E_INVARG;",
            "endif",
            "same = object.owner == newowner;",
            "for vnum in [1..length(verbs(object))]",
            "info = verb_info(object, vnum);",
            "if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))",
            "same = same && (info[1] == newowner);",
            "set_verb_info(object, vnum, listset(info, newowner, 1));",
            "endif",
            "endfor",
            "for prop in (properties(object))",
            "$command_utils:suspend_if_needed(0);",
            "info = property_info(object, prop);",
            "if (!(index(info[2], \"c\") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))",
            "same = same && (info[1] == newowner);",
            "$wiz_utils:set_property_owner(object, prop, newowner, 1);",
            "endif",
            "endfor",
            "suspend(0);",
            "$wiz_utils:set_owner(object, newowner, 1);",
            "return same ? \"nothing changed\" | \"grant changed\";"
          ]
        },
        {
          "name": "connection_hash",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"connection_hash(forwhom, host [,seed])\";",
            "\"Compute an encrypted hash of the host for 'forwhom', using 'crypt'.\";",
            "{forwhom, host, @seed} = args;",
            "hash = toint(forwhom);",
            "for i in [1..length(host)]",
            "hash = (hash * 14) + index($string_utils.ascii, host[i]);",
            "endfor",
            "return crypt(tostr(hash), @seed);"
          ]
        },
        {
          "name": "newt_player",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":newt_player(who [ , commentary] [, temporary])\";",
            "{who, ?comment = \"\", ?temporary = 0} = args;",
            "if (!caller_perms().wizard)",
            "$error:raise(E_PERM);",
            "elseif (length(args) < 1)",
            "$error:raise(E_ARGS);",
            "elseif ((typeof(who = args[1]) != OBJ) || (!is_player(who)))",
            "$error:raise(E_INVARG);",
            "else",
            "if (!comment)",
            "player:notify(\"So why has this player been newted?\");",
            "comment = $command_utils:read();",
            "endif",
            "if (temporary)",
            "comment = temporary + comment;",
            "endif",
            "$login.newted = setadd($login.newted, who);",
            "if (msg = player:newt_victim_msg())",
            "notify(who, msg);",
            "endif",
            "notify(who, $login:newt_registration_string());",
            "boot_player(who);",
            "player:notify(tostr(who.name, \" (\", who, \") has been turned into a newt.\"));",
            "$mail_agent:send_message(player, $newt_log, tostr(\"@newt \", who.name, \" (\", who, \")\"), {$string_utils:from_list(who.all_connect_places, \" \"), @comment ? {comment} | {}});",
            "if ($object_utils:isa(who.location, $room) && (msg = player:newt_msg()))",
            "who.location:announce_all_but({who}, msg);",
            "endif",
            "player:notify(tostr(\"Mail sent to \", $mail_agent:name($newt_log), \".\"));",
            "endif"
          ]
        },
        {
          "name": "unset_programmer",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":unset_programmer(victim[,reason[,start time,duration]]) => 1 or error.\";",
            "\"Resets victim.programmer, adds victim to .programmer_restricted.\";",
            "\"Put into temporary list if 3rd and 4th arguments are given. Which restricts the victim for uptime duration since start time. Must give a reason, though it can be blank, in this case.\";",
            "{victim, ?reason = \"\", ?start = 0, ?duration = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (!valid(victim))",
            "return E_INVARG;",
            "elseif ((!victim.programmer) && this:check_prog_restricted(victim))",
            "return E_NONE;",
            "else",
            "victim.programmer = 0;",
            "if (is_player(victim) && $object_utils:isa(victim, $player))",
            "this.programmer_restricted = setadd(this.programmer_restricted, victim);",
            "if (start)",
            "this.programmer_restricted_temp = setadd(this.programmer_restricted_temp, {victim, start, duration});",
            "endif",
            "endif",
            "$mail_agent:send_message(caller_perms(), {$newt_log}, tostr(\"@deprogrammer \", victim.name, \" (\", victim, \")\"), reason ? (typeof(reason) == STR) ? {reason} | reason | {});",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "is_wizard",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\":is_wizard(who) => whether `who' is a wizard or is the .public_identity of some wizard.\";",
            "\"This verb is used for permission checks on commands that should only be accessible to wizards or their ordinary-player counterparts.  It will return true for unadvertised wizards.\";",
            "who = args[1];",
            "if (who.wizard)",
            "return 1;",
            "else",
            "for w in ($object_utils:leaves($wiz))",
            "if ((w.wizard && is_player(w)) && (who == `w.public_identity ! ANY'))",
            "return 1;",
            "endif",
            "endfor",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "expire_mail",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "this:expire_mail_lists();",
            "this:expire_mail_players();"
          ]
        },
        {
          "name": "expire_mail_weekly",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "fork (((7 * 24) * 60) * 60)",
            "this:(verb)();",
            "endfork",
            "this:expire_mail();"
          ]
        },
        {
          "name": "check_prog_restricted",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"Checks to see if args[1] is restricted from programmer either permanently or temporarily. Removes from temporary list if time is up\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "if ((who = args[1]) in this.programmer_restricted)",
            "\"okay, who is restricted. Now check to see if it is temporary\";",
            "if (entry = $list_utils:assoc(who, this.programmer_restricted_temp))",
            "if ($login:uptime_since(entry[2]) > entry[3])",
            "\"It's temporary and the time is up, remove and return false\";",
            "this.programmer_restricted_temp = setremove(this.programmer_restricted_temp, entry);",
            "this.programmer_restricted = setremove(this.programmer_restricted, who);",
            "return 0;",
            "else",
            "\"time is not up\";",
            "return 1;",
            "endif",
            "else",
            "return 1;",
            "endif",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "expire_mail_players",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "s = 0;",
            "for p in (players())",
            "this.expiration_progress = p;",
            "if ((p.owner == p) && is_player(p))",
            "s = s + (p:expire_old_messages() || 0);",
            "endif",
            "if (ticks_left() < 10000)",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endif",
            "endfor",
            "$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(s, \" messages have been expired from players.\"));",
            "return s;"
          ]
        },
        {
          "name": "expire_mail_lists",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "sum = 0;",
            "for x in ($object_utils:leaves_suspended($mail_recipient))",
            "this.expiration_progress = x;",
            "temp = x:expire_old_messages();",
            "if (typeof(temp) == INT)",
            "sum = sum + temp;",
            "endif",
            "\"just suspend for every fucker, I'm tired of losing.\";",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endfor",
            "$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(sum, \" messages have been expired from mailing lists.\"));",
            "return sum;"
          ]
        },
        {
          "name": "flush_editors",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "fork (86400 * 7)",
            "this:(verb)();",
            "endfork",
            "player:tell(\"Flushing ancient editor sessions.\");",
            "for x in ({$verb_editor, $note_editor, $mail_editor})",
            "x:do_flush(time() - (30 * 86400), 0);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "random_wizard",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "\"Put all your wizards in $wiz_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.\";",
            "w = this.wizards;",
            "i = this.next_perm_index;",
            "if (i >= length(w))",
            "i = 1;",
            "else",
            "i = i + 1;",
            "endif",
            "this.next_perm_index = i;",
            "return w[i];"
          ]
        },
        {
          "name": "set_email_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "set_task_perms(caller_perms());",
            "{who, email} = args;",
            "if (typeof(who.email_address) == LIST)",
            "who.email_address[1] = email;",
            "else",
            "who.email_address = email;",
            "endif"
          ]
        },
        {
          "name": "get_email_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 24,
          "code": [
            "set_task_perms(caller_perms());",
            "{who} = args;",
            "if (typeof(who.email_address) == LIST)",
            "return who.email_address[1];",
            "else",
            "return who.email_address;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "default_programmer_quota",
        "default_player_quota",
        "missed_help_strings",
        "missed_help_counters",
        "record_missed_help",
        "programmer_restricted",
        "boot_task",
        "boot_exceptions",
        "programmer_restricted_temp",
        "suicide_string",
        "next_perm_index",
        "wizards",
        "old_task_perms_user",
        "expiration_progress",
        "system_chars",
        "new_core_message",
        "chparent_restricted",
        "rename_restricted",
        "change_password_restricted",
        "expiration_recipient",
        "registration_domain_restricted",
        "shutdown_task",
        "shutdown_message",
        "gripe_recipients"
      ],
      "propdefs": [
        {
          "value": 7,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 7,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 585440461,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You don't *really* want to commit suicide, do you?",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            8060,
            39
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            36,
            38,
            71
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "Getting Started with your LambdaCore MOO",
            "========================================",
            "",
            "Thank you for choosing LambdaCore!",
            "",
            "Initial Setup Notes",
            "-------------------",
            "",
            "The \"welcome\" screen, seen when a player connects.",
            "  -- this is stored in $login.welcome_message",
            "",
            "Do you want on-line character creation?",
            "  -- this is stored in $login.create_enabled",
            "     for more detailed information, edit $login:player_creation_enabled",
            "",
            "Do you want to limit the number of players on the MOO at once?",
            "  -- look at $login.max_connections",
            "     the `connection_limit' message on $login is the message printed",
            "     when this limit is reached.",
            "",
            "Do you want a different default player class?",
            "  -- set $player_class to a different value",
            "     *do not* change $player",
            "",
            "You should also set the following:",
            "  $network.postmaster",
            "    -- your email address, or the email address of the person who will ",
            "       handle your email",
            "  $network.site",
            "    -- the machine your MOO is running on (e.g. \"lambda.moo.mud.org\")",
            "  $network.port",
            "    -- the port your MOO is running on (e.g. 8888)",
            "  $network.MOO_Name",
            "    -- the name of your MOO (e.g. \"LambdaMOO\")",
            "  $site_db.domain",
            "  -- this is set to the `domain' of your address",
            "     (eg `foo.com' for `moo.foo.com')",
            "",
            "If you compiled the server with open_network_connection() enabled (allowing the MOO to open up connections with other computers on the network), then you should set",
            "  $network.active = 1",
            "     This will enable @newpassword, @registerme, @password, @mailme, @netforward, and others to send mail from the MOO.",
            "",
            "-------------------------------------------------------------------",
            "",
            "Setting Yourself Up",
            "-------------------",
            "",
            "Set a password for yourself.",
            "  -- @password <new-password>",
            "",
            "Set a description for yourself.",
            "  -- @describe me as <anything>",
            "",
            "Set a gender for yourself.",
            "  -- @gender <gender>",
            "",
            "There are, also, a large number of messages you can set on yourself.  Setting them will enhance the virtual reality.",
            "",
            "-------------------------------------------------------------------",
            "",
            "About Guests",
            "------------",
            "",
            "To make a new Guest character:",
            "  -- @make-guest <guestname>",
            "     will make a new guest with the name you specify with `_Guest' appended",
            "     and some other standard but useful aliases",
            "",
            "This is the easiest way to make Guest characters.  The most important things to remember about Guests, if you want to make them yourself, are:",
            "  -- make them owned by nonwizards, and not owned by themselves",
            "  -- make sure they've got .password == 0, and that .password is nonclear",
            "  -- at least one Guest must always be named `Guest'; this can be an alias",
            "",
            "To set the default description and gender for a guest:",
            "  -- set .default_description to the description the guest should start with",
            "  -- set .default_gender to the gender the guest should start with",
            "  -- remember to set .description and .gender too, for the guest's first use",
            "",
            "-------------------------------------------------------------------",
            "",
            "Adding to the Newspaper",
            "-----------------------",
            "",
            "The newspaper is a special mailing list.  To add a post to the newspaper, send mail to it (as *News or $news), and then note the number of your post (let's call it <x> and:",
            "  -- @addnews <x> to *News",
            "... in general, `@addnews $ to *News' will work as well.",
            "",
            "-------------------------------------------------------------------",
            "",
            "Quota",
            "-----",
            "",
            "By default, LambdaCore runs with byte-based quota, an in-DB quota system, limiting users by total database space as opposed to total objects.  You'll need to do two things:",
            "  -- decide on the default quota:",
            "     ;$byte_quota_utils.default_quota[1] = <a number of bytes>",
            "  -- start the measurement task; see `help routine_tasks' for more information (Note: this help topic contains information about more than just the quota task; it should be read regardless of how quota is set).",
            "",
            "If you prefer the quota system documented in the LambdaMOO Programmer's Manual, directly supported by the server, you can enable object-based quota:",
            "  -- set $quota_utils to $object_quota_utils",
            "",
            "It's best that you make this switch before users start, because converting existing users is an awkward (and inherently arbitrary and political) move.",
            "",
            "-------------------------------------------------------------------",
            "",
            "Making Programmers",
            "------------------",
            "",
            "The command to turn someone into a programmer is `@programmer'  Its syntax is `@programmer <user>'.  For example:",
            "  -- @programmer Haakon",
            "The `@programmer' verb will prompt you if the user isn't set up with a description and a gender.",
            "",
            "No code to automatically grant programmer bits is included with LambdaCore.",
            "",
            "Making Wizards",
            "--------------",
            "",
            "THINK CAREFULLY.",
            "",
            "Be very careful before giving someone a wizard bit.  That person can do gross damage to your database, and fixable but serious damage to the machine it runs on.  That person can quite possibly open outbound network connections from your machine, and thus commit acts for which your host system will be blamed.  That person can ruin your MOO's as-yet-untarnished reputation.",
            "",
            "Wizards have technical power, the ability to change anything within the database, to create anything within the database.  Be careful with the idea of a `Social Wizard' -- a nontechnical person holding a wizard bit is fairly likely to, at some point, accidentally do something destructive.  It's a good idea not to socialize as your wizard character, for the same reason, to make it less likely to be accidentally destructive.",
            "",
            "That said, in general you don't turn an existing character into a wizard, you make a -new- character to be the wizard.  This is because the existing character probably owns code and objects which could be destructive if suddenly made wizardly; it's a good security measure to make a fresh player.  So, to make a fresh player:",
            "  -- @make-player (see `help @make-player' for more information)",
            "     this will make you a new player. for this example, #123",
            "",
            "To make #123 a wizard:",
            "  -- @programmer #123",
            "     (a nonprogrammer wizard is a truly strange beast)",
            "  -- ;#123.wizard = 1;",
            "  -- @chparent #123 to $wiz",
            "  -- ;#123.public_identity = <the player's nonwizard character's object number>",
            "",
            "-------------------------------------------------------------------",
            "",
            "Good luck with your new LambdaCore database!",
            "",
            "Visit us at LambdaMOO: lambda.moo.mud.org 8888",
            "",
            "Join the international mailing list for MOO coders: send an email message to moo-cows-request@the-b.org with the word `subscribe' as the body of your message.",
            "",
            "Do good things.",
            "",
            "The LambdaMOO Wizards",
            "[authored February 15, 1999]"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            2
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "Wizard Utilities",
            "----------------",
            "The following functions are substitutes for various server builtins.",
            "Anytime one feel tempted to use one of the expressions on the right,",
            "use the corresponding one on the left instead.  This will take care",
            "of various things that the server (for whatever reason) does not handle.",
            "",
            ":set_programmer(object)             object.programmer = 1;",
            "    chparent object to $prog",
            "    send mail to $prog_log",
            "",
            ":set_player(object[,nochown])       set_player_flag(object,1);",
            "    set player flag, ",
            "    add name/aliases to $player_db,",
            "    and maybe do a self chown.",
            "",
            ":unset_player(object[,newowner])    set_player_flag(object,0);",
            "    unset player flag,",
            "    remove name/aliases from $player_db",
            "    chown to newowner if given",
            "",
            ":set_owner(object, newowner)        object.owner = newowner;",
            "    change ownership on object",
            "    change ownership on all +c properties",
            "    juggle .ownership_quotas",
            "",
            ":set_property_owner(object, property, newowner[, suspend-ok])",
            "    change owner on a given property",
            "    if this is a -c property, we change the owner on all descendants",
            "    for which this is also a -c property.",
            "    Polite protest if property is +c and newowner != object.owner.",
            "",
            ":set_property_flags(object, property, flags[, suspend-ok])",
            "    change the permissions on a given property and propagate these to ",
            "    *all descendants*.  property ownership is changed on descendants ",
            "    where necessary."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Wizard Utilities"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the Wizard Utilities utility package.  See `help $wiz_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            75226,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "25": {
      "id": 25,
      "name": "Site DB",
      "flags": 0,
      "owner": 36,
      "location": -1,
      "parents": [
        37
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find* _only* _every*",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;"
          ]
        },
        {
          "name": "add",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "\":add(player,site)\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "{who, domain} = args;",
            "if (this:domain_literal(domain))",
            "\"... just enter it...\";",
            "l = this:find_exact(domain);",
            "if (l == $failed_match)",
            "this:insert(domain, {who});",
            "elseif (!(who in l))",
            "this:insert(domain, setadd(l, who));",
            "endif",
            "else",
            "\"...an actual domain name; add player to list for that domain...\";",
            "\"...then add domain itself to list for the next larger domain; repeat...\";",
            "\"...  Example:  domain == foo.bar.edu:  \";",
            "\"...            enter #who  on foo.bar.edu list\";",
            "\"...            enter `foo' on bar.edu list\";",
            "\"...            enter `bar' on edu list\";",
            "if (!(dot = index(domain, \".\")))",
            "dot = length(domain) + 1;",
            "domain = tostr(domain, \".\", this.domain);",
            "endif",
            "prev = who;",
            "while ($failed_match == (l = this:find_exact(domain)))",
            "this:insert(domain, {prev});",
            "if (dot)",
            "prev = domain[1..dot - 1];",
            "domain = domain[dot + 1..$];",
            "else",
            "return;",
            "endif",
            "dot = index(domain, \".\");",
            "endwhile",
            "if (!(prev in l))",
            "this:insert(domain, {@l, prev});",
            "endif",
            "return;",
            "endif"
          ]
        },
        {
          "name": "load",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "\":load([start]) -- reloads site_db with the connection places of all players.\";",
            "\"This routine calls suspend() if it runs out of time.\";",
            "\"WIZARDLY\";",
            "\"...needs to be able to read .all_connect_places\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "endif",
            "plist = players();",
            "if (!args)",
            "this:clearall();",
            "elseif (i = args[1] in plist)",
            "plist[1..i - 1] = {};",
            "else",
            "return E_INVARG;",
            "endif",
            "for p in (plist)",
            "if (valid(p) && (is_player(p) && (!$object_utils:isa(p, $guest))))",
            "\"... player may be recycled or toaded during the suspend(),...\";",
            "\"... guests login from everywhere...\";",
            "for c in (p.all_connect_places)",
            "this:add(p, c);",
            "if ($command_utils:running_out_of_time())",
            "player:tell(\"...\", p);",
            "suspend(0);",
            "endif",
            "endfor",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "domain_literal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "\":domain_literal(string)\";",
            "\" => true iff string is a domain literal (i.e., numeric IP address).\";",
            "if (10 <= (len = length(hnum = strsub(args[1], \".\", \"\"))))",
            "return toint(hnum[1..9]) && toint(hnum[6..len]);",
            "else",
            "return toint(hnum);",
            "endif",
            "\"SLEAZY CODE ALERT\";",
            "\"... what I wanted to do was return toint(strsub(args[1],\\\".\\\",\\\"\\\"))\";",
            "\"... but on a 32-bit machine, this has a 1 in 4294967296 chance of failing\";",
            "\"... (e.g., on \\\"42.94.967.296\\\", though I'll grant this particular example\";",
            "\"...  entails some very strange subnetting on net 42, to say the least).\";",
            "\"... So we do something that is guaranteed to work so long as internet\";",
            "\"... addresses stay under 32 bits --- a while yet...\";",
            "\"\";",
            "\"... As soon as we're sure match() is working, this will become a one-liner:\";",
            "return match(args[1], \"[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+\");"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this:clearall();",
            "this.domain = \"localdomain\";",
            "this:prune_reset();",
            "endif"
          ]
        },
        {
          "name": "prune_alpha",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "\"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.\";",
            "\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";",
            "\"Another thing it should do is be clever about string typed items.  (What did I mean by this?)\";",
            "\"New feature: If the site name contains `dialup', then, if none of the users who have connected from there still have it in their .all_connect_places, then consider it trashable.  Maybe this will get some space savings.\";",
            "\"To run: call $site_db:prune_reset() then $site_db:prune_alpha().\";",
            "\"or $site_db:prune_alpha(1) for verbose output\";",
            "verbose = args && args[1];",
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "this.prune_task = task_id();",
            "probe = this.prune_progress;",
            "while ((probe <= this.prune_stop) && (length(probe) == length(this.prune_stop)))",
            "for sitename in (z = this:find_all_keys(probe))",
            "items = this:find_exact(sitename);",
            "orig = items;",
            "dialup = index(sitename, \"dialup\");",
            "\"Don't keep around dialups.\";",
            "for y in (items)",
            "if ((typeof(y) == OBJ) && (((!valid(y)) || (!is_player(y))) || (dialup && (!(sitename in y.all_connect_places)))))",
            "verbose && player:tell(\"removing \", $string_utils:nn(y), \" from \", sitename);",
            "items = setremove(items, y);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "useless = 1;",
            "\"If no player has this site in eir .all_connect_places, nuke it anyway.\";",
            "for y in (items)",
            "if ((typeof(y) != OBJ) || (sitename in y.all_connect_places))",
            "useless = 0;",
            "break;",
            "\"unfortunately this can get kinna O(n^2).\";",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (useless)",
            "verbose && player:tell(sitename, \" declared useless and nuked\");",
            "items = {};",
            "endif",
            "if (!items)",
            "this:delete(sitename);",
            "this.total_pruned_sites = this.total_pruned_sites + 1;",
            "elseif (items == orig)",
            "else",
            "this:insert(sitename, items);",
            "this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "if (probe >= this.prune_stop)",
            "return player:tell(\"Prune stopped at \", toliteral(this.prune_progress));",
            "endif",
            "endfor",
            "probe = $string_utils:incr_alpha(probe, this.alphabet);",
            "this.prune_progress = probe;",
            "if ($command_utils:running_out_of_time())",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endif",
            "endwhile",
            "player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"
          ]
        },
        {
          "name": "report_prune_progress",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "player:tell(\"Prune is up to \", toliteral(this.prune_progress), \".\");",
            "mine = 0;",
            "if (typeof(this.prune_progress) == STR)",
            "alphalen = length(this.alphabet);",
            "total = (alphalen * alphalen) * alphalen;",
            "for x in [1..3]",
            "mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;",
            "endfor",
            "else",
            "total = 256 * 256;",
            "mine = (this.prune_progress[1] * 256) + this.prune_progress[2];",
            "endif",
            "percent = (100.0 * tofloat(mine)) / tofloat(total);",
            "player:tell(\"We have processed \", mine, \" entries out of \", total, \", or \", toint(percent), \".\", toint(10.0 * percent) % 10, \"%.\");",
            "player:tell(\"There were \", this.total_pruned_people, \" individual list entries removed, and \", this.total_pruned_sites, \" whole sites removed.\");",
            "if ($code_utils:task_valid(this.prune_task))",
            "player:tell(\"Prune task is \", this.prune_task, \".  Stacktrace:\");",
            "for x in (task_stack(this.prune_task, 1))",
            "if (valid(x[4]))",
            "player:tell(x[4], \":\", x[2], \" [\", x[1], \"]  \", x[3].name, \"  (\", x[6], \")\");",
            "endif",
            "endfor",
            "else",
            "player:tell(\"The recorded task_id is no longer valid.\");",
            "endif"
          ]
        },
        {
          "name": "prune_fixup",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "if (!args)",
            "for x in ({\"com\", \"edu\", \"us\", \"au\", \"net\", \"za\", \"uk\", \"at\", \"ca\", \"org\", \"il\", \"mil\", \"no\", \"gov\", \"se\", \"fi\", \"it\", \"be\", \"jp\", \"de\", \"pt\", \"sg\", \"ie\", \"br\", \"nl\", \"gr\", \"ch\", \"pl\", \"nz\", \"<none>\", \"<bad>\", \"ee\", \"dk\", \"fr\", \"si\", \"cz\", \"th\", \"tw\", \"hk\", \"su\", \"es\", \"kr\", \"hr\", \"is\", \"mx\", \"my\", \"ro\", \"kw\", \"cl\", \"ph\", \"cr\", \"tr\", \"in\", \"eg\", \"ec\", \"lv\", \"ve\", \"sk\", \"ar\", \"co\", \"pe\", \"hu\", \"jm\", \"ni\", \"ru\", \"id\", \"bm\", \"mt\", \"cn\", \"bg\", \"pk\", \"uy\", \"yu\", \"ae\", \"zw\", \"gi\", \"sm\", \"nu\"})",
            "this:prune_fixup(x);",
            "endfor",
            "return;",
            "endif",
            "root = args[1];",
            "items = this:find_exact(root);",
            "orig = items;",
            "if (items == #-3)",
            "return 1;",
            "endif",
            "$site_db.prune_progress = root;",
            "$site_db.prune_task = task_id();",
            "for item in (items)",
            "if (typeof(item) == STR)",
            "if (this:prune_fixup((item + \".\") + root))",
            "items = setremove(items, item);",
            "endif",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endif",
            "endfor",
            "if (!items)",
            "this:delete(root);",
            "this.total_pruned_sites = this.total_pruned_sites + 1;",
            "return 1;",
            "elseif (orig == items)",
            "else",
            "this:insert(root, items);",
            "endif"
          ]
        },
        {
          "name": "prune_numeric",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "\"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.\";",
            "\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";",
            "\"Another thing it should do is be clever about string typed items.\";",
            "\"Rewriting this to do numerics now.\";",
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "this.prune_task = task_id();",
            "probe = this.prune_progress;",
            "while (probe[1] <= this.prune_stop)",
            "probestring = tostr(probe[1], \".\", probe[2], \".\");",
            "for sitename in (z = this:find_all_keys(probestring))",
            "items = this:find_exact(sitename);",
            "orig = items;",
            "for y in (items)",
            "if ((typeof(y) == OBJ) && ((!valid(y)) || (!is_player(y))))",
            "items = setremove(items, y);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (!items)",
            "this:delete(sitename);",
            "this.total_pruned_sites = this.total_pruned_sites + 1;",
            "elseif (items == orig)",
            "else",
            "this:insert(sitename, items);",
            "this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (probe[2] == 255)",
            "probe[1] = probe[1] + 1;",
            "probe[2] = 0;",
            "else",
            "probe[2] = probe[2] + 1;",
            "endif",
            "this.prune_progress = probe;",
            "if ($command_utils:running_out_of_time())",
            "set_task_perms($wiz_utils:random_wizard());",
            "suspend(0);",
            "endif",
            "endwhile",
            "player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"
          ]
        },
        {
          "name": "schedule_prune",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "day = 24 * 3600;",
            "hour_of_day_GMT = 9;",
            "target = (((hour_of_day_GMT * 60) * 60) + day) - (time() % day);",
            "if (target > 86400)",
            "target = target - 86400;",
            "endif",
            "fork (target)",
            "\"Stop at 2am before checkpoint.\";",
            "if ($code_utils:task_valid(this.prune_task))",
            "$site_db.prune_stop = \"aaa\";",
            "\"Restart after 3am.  Er, 4am.\";",
            "suspend(7500);",
            "this:schedule_prune();",
            "$site_db.prune_stop = \"zzz\";",
            "\"Just in case it didn't actually stop...\";",
            "if (!$code_utils:task_valid(this.prune_task))",
            "$site_db:prune_alpha();",
            "endif",
            "endif",
            "endfork"
          ]
        },
        {
          "name": "prune_reset",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 25,
          "code": [
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "this:report_prune_progress();",
            "player:tell(\"Resetting...\");",
            "this.total_pruned_sites = 0;",
            "this.total_pruned_people = 0;",
            "this.prune_progress = \"aaa\";",
            "this.prune_stop = \"zzz\";",
            "`kill_task(this.prune_task) ! ANY';"
          ]
        }
      ],
      "propnames": [
        "domain",
        "prune_progress",
        "prune_stop",
        "total_pruned_people",
        "total_pruned_sites",
        "prune_task",
        "alphabet"
      ],
      "propdefs": [
        {
          "value": "localdomain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "aaa",
          "owner": 36,
          "perms": 4
        },
        {
          "value": "zzz",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 298000796,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "abcdefghijklmnopqrstuvwxy0123456789_z",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "",
            [],
            []
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "sitedb",
            "site",
            "db"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This object holds a db of places from which players have connected (see `help $site_db').",
            "The site blacklist and the graylist live as well (see `help blacklist')."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            18428,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "26": {
      "id": 26,
      "name": "Math Utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "xsin",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"xsin(INT x) -- calculates the taylor approximation for the sine function\";",
            "if (typeof(x = args[1]) != INT)",
            "return E_TYPE;",
            "endif",
            "if ((x * x) > this.taylor)",
            "return ((this:xsin(x / 2) * this:xcos((x + 1) / 2)) + (this:xsin((x + 1) / 2) * this:xcos(x / 2))) / 10000;",
            "else",
            "return (x * (17453000 - ((x * x) * 886))) / 100000;",
            "endif"
          ]
        },
        {
          "name": "xcos",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"xcos(INT x) -- calculates the taylor approximation for the cosine function\";",
            "if (typeof(x = args[1]) != INT)",
            "return E_TYPE;",
            "endif",
            "if ((x * x) > this.taylor)",
            "return ((this:xcos(x / 2) * this:xcos((x + 1) / 2)) - (this:xsin(x / 2) * this:xsin((x + 1) / 2))) / 10000;",
            "else",
            "return (1000000000 - ((x * x) * (152309 + ((4 * x) * x)))) / 100000;",
            "endif"
          ]
        },
        {
          "name": "factorial",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"factorial(INT n) -- returns n factorial for 0 <= n (<= 12).\";",
            "if ((number = args[1]) < 0)",
            "return E_INVARG;",
            "elseif (typeof(number) != INT)",
            "return E_TYPE;",
            "endif",
            "fact = 1;",
            "for i in [2..number]",
            "fact = fact * i;",
            "endfor",
            "return fact;"
          ]
        },
        {
          "name": "fibonacci",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"fibonacci(INT n) -- calculates the fibonacci numbers to the nth term\";",
            "\"and returns them in a list. n must be >= 0.\";",
            "if (typeof(n = args[1]) != INT)",
            "return E_TYPE;",
            "elseif (n < 0)",
            "return E_INVARG;",
            "elseif (n == 0)",
            "return {0};",
            "else",
            "x = {0, 1};",
            "for i in [2..n]",
            "x = {@x, x[$ - 1] + x[$]};",
            "endfor",
            "return x;",
            "endif"
          ]
        },
        {
          "name": "geometric",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"geometric(INT|FLOAT x [,INT n]) -- calculates the value of the geometric series at x to the nth term. i.e., approximates 1/(1-x) when |x| < 1. This, of course, is impossible in MOO, but someone may find it useful in some way.\";",
            "\"n defaults to 5. n must be >= 0.\";",
            "\"This verb was revised on 2006-03-16 by Gary (#110811) to allow for floating point input of the first argument.  The help documentation had said this was allowed but actually it caused a traceback.  How many people are actually using this, I wonder? \";",
            "{n, ?order = 5} = args;",
            "if ((!(typeof(n) in {INT, FLOAT})) || (typeof(order) != INT))",
            "return E_TYPE;",
            "elseif (order <= 0)",
            "return E_INVARG;",
            "endif",
            "x = (typeof(n) == FLOAT) ? 1.0 | 1;",
            "for i in [1..order]",
            "x = x + (n ^ i);",
            "endfor",
            "return x;"
          ]
        },
        {
          "name": "divmod",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"divmod(INT n, INT d) => {q,r} such that n = dq + r\";",
            "\"  handles negative numbers correctly   0<=r<d if d>0, -d<r<=0 if d<0.\";",
            "{n, d} = args;",
            "if ((typeof(n) != INT) && (typeof(d) != INT))",
            "return E_TYPE;",
            "endif",
            "r = ((n % d) + d) % d;",
            "q = (n - r) / d;",
            "return {q, r};"
          ]
        },
        {
          "name": "combinations",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"combinations(INT n, INT r) -- returns the number of ways one can choose r\";",
            "\"objects from n distinct choices.\";",
            "\"C(n,r) = n!/[r!(n-r)!]\";",
            "\"  overflow may occur if n>29...\";",
            "{n, r} = args;",
            "if ((typeof(n) != INT) && (typeof(r) != INT))",
            "return E_TYPE;",
            "endif",
            "if (0 > (r = min(r, n - r)))",
            "return 0;",
            "else",
            "c = 1;",
            "n = n + 1;",
            "for i in [1..r]",
            "c = (c * (n - i)) / i;",
            "endfor",
            "return c;",
            "endif"
          ]
        },
        {
          "name": "permutations",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"permutations(INT n, INT r) -- returns the number of ways possible for one to\";",
            "\"order r distinct objects given n locations.\";",
            "\"P(n,r) = n!/(n-r)!\";",
            "{n, r} = args;",
            "if ((typeof(n) != INT) && (typeof(r) != INT))",
            "return E_TYPE;",
            "endif",
            "if ((r < 1) || ((diff = n - r) < 0))",
            "return 0;",
            "else",
            "p = n;",
            "for i in [diff + 1..n - 1]",
            "p = p * i;",
            "endfor",
            "return p;",
            "endif"
          ]
        },
        {
          "name": "simpson",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"simpson({a,b},{f(a),f((a+b)/2),f(b)} [,INT ret-float])\";",
            "\" -- given two endpoints, a and b, and the functions value at a, (a+b)/2, and b, this will calculate a numerical approximation of the integral using simpson's rule.\";",
            "\"Entries can either be all INT or all FLOAT. Don't mix!\";",
            "\"If the optional 3rd argument is provided and true, the answer is returned as a floating point regardless of what the input was. Otherwise, if the input was all INT, the answer is returned as {integer,fraction}\";",
            "{point, fcn, ?retfloat = 0} = args;",
            "if ((!retfloat) && (typeof(point[1]) == INT))",
            "numer = (point[2] - point[1]) * ((fcn[1] + (4 * fcn[2])) + fcn[3]);",
            "return this:parts(numer, 6);",
            "else",
            "numer = tofloat(point[2] - point[1]) * ((tofloat(fcn[1]) + (4.0 * tofloat(fcn[2]))) + tofloat(fcn[3]));",
            "return numer / 6.0;",
            "endif"
          ]
        },
        {
          "name": "parts",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"parts(INT n, INT q [,INT i]) -- returns a decomposition of n by q into integer and floating point parts with i = the number of digits after the decimal.\";",
            "\"i defaults to 5.\";",
            "\"warning: it is quite easy to hit maxint which results in unpredictable\";",
            "\"         results\";",
            "{n, q, ?i = 5} = args;",
            "if (((typeof(n) != INT) && (typeof(q) != INT)) && (typeof(i) != INT))",
            "return E_TYPE;",
            "endif",
            "parts = {n / q, n % q};",
            "return {parts[1], (parts[2] * (10 ^ i)) / q};"
          ]
        },
        {
          "name": "div",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"div(INT n, INT d) => q such that n = dq + r and  (0<=r<d if d>0, -d<r<=0 if d<0).\";",
            "return this:divmod(@args)[1];"
          ]
        },
        {
          "name": "mod",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"A correct mod function.\";",
            "\"mod(INT n, INT d) => r such that n = dq + r and (0<=r<d if d>0 or -d<r<=0 if d<0).\";",
            "{n, d} = args;",
            "if ((typeof(n) != INT) && (typeof(d) != INT))",
            "return E_TYPE;",
            "endif",
            "return ((n % d) + d) % d;"
          ]
        },
        {
          "name": "exp",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"exp(INT|FLOAT x[,INT n]) -- calculates an nth order taylor approximation for e^x.\";",
            "\"n defaults to 5. Any n given must be >= 0. you need to divide the result\";",
            "\"the answer will be returned as {integer part,fractional part} if the input x was an integer. If it is floating point, so will the answer (and this uses the builtin function.)\";",
            "{x, ?n = 5} = args;",
            "if (typeof(x) == FLOAT)",
            "return exp(x);",
            "elseif ((typeof(x) != INT) && (typeof(n) != INT))",
            "return E_TYPE;",
            "endif",
            "ex = nfact = 1;",
            "for i in [0..n - 1]",
            "j = n - i;",
            "ex = (ex * x) + (nfact = nfact * j);",
            "endfor",
            "return this:parts(ex, nfact);"
          ]
        },
        {
          "name": "aexp",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"returns 10000 exp (x/10000)\";",
            "\"The accuracy seems to be ~0.1% for 0<x<4\";",
            "x = args[1];",
            "if (x < 0)",
            "z = this:(verb)(-x);",
            "return (100000000 + (z / 2)) / z;",
            "elseif (x > 1000)",
            "z = this:(verb)(x / 2);",
            "if (z > 1073741823)",
            "return $maxint;",
            "\"maxint for overflows\";",
            "elseif (z > 460000)",
            "z = ((z + 5000) / 10000) * z;",
            "elseif (z > 30000)",
            "z = ((((z + 50) / 100) * z) + 50) / 100;",
            "else",
            "z = ((z * z) + 5000) / 10000;",
            "endif",
            "if (x % 2)",
            "return z + ((z + 5000) / 10000);",
            "else",
            "return z;",
            "endif",
            "else",
            "return ((10000 + x) + (((x * x) + 10000) / 20000)) + ((((x * x) * x) + 300000000) / 600000000);",
            "endif"
          ]
        },
        {
          "name": "random",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"random(INT n): returns a random integer in the following manner:\";",
            "\"random(n > 0) will return a integer in the range 0 to n\";",
            "\"random(n < 0) will return a integer in the range n to 0\";",
            "if (typeof(prob = args[1]) != INT)",
            "return E_TYPE;",
            "endif",
            "mod = (prob < 0) ? -1 | 1;",
            "return (mod * random(abs(prob + mod))) - mod;"
          ]
        },
        {
          "name": "random_range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"random_range(INT range [,INT mean]): returns a random integer within the given range from the mean. if the mean isn't given, it defaults to 0\";",
            "\"e.g., random_range(10) => -10..10\";",
            "\"      random_range(10,4) => -6..14\";",
            "{range, ?mean = 0} = args;",
            "if ((typeof(range) != INT) && (typeof(mean) != INT))",
            "return E_TYPE;",
            "endif",
            "return mean + (((random(2) == 1) ? -1 | 1) * this:random(range));"
          ]
        },
        {
          "name": "is_prime",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"is_prime(INT number) returns 1 if the number is prime or 0 if it isn't.\";",
            "\"of course, only positive numbers are candidates for primality.\";",
            "if (typeof(number = args[1]) != INT)",
            "return E_TYPE;",
            "endif",
            "if (number == 2)",
            "return 1;",
            "elseif ((number < 2) || ((number % 2) == 0))",
            "return 0;",
            "else",
            "max = toint(ceil(sqrt(tofloat(number))));",
            "choice = 3;",
            "while (choice <= max)",
            "if ((seconds_left() < 2) || (ticks_left() < 25))",
            "suspend(0);",
            "endif",
            "if ((number % choice) == 0)",
            "return 0;",
            "endif",
            "choice = choice + 2;",
            "endwhile",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "NOT",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "return -(1 + args[1]);",
            "\"\";",
            "\"... here's what it used to be ...\";",
            "bl1 = this:BLFromInt(args[1]);",
            "blOut = {};",
            "for i in [1..32]",
            "blOut = {@blOut, !bl1[i]};",
            "endfor",
            "return this:IntFromBL(blOut);"
          ]
        },
        {
          "name": "BLFromInt",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"BlFromInt(INT x) => converts the number provided into a 32 bit binary number, which is returned via a 32 element LIST of 1's and 0's. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.\";",
            "if (typeof(x = args[1]) != INT)",
            "return E_TYPE;",
            "endif",
            "l = {};",
            "firstbit = x < 0;",
            "if (firstbit)",
            "x = x + $minint;",
            "endif",
            "for i in [1..31]",
            "l = {x % 2, @l};",
            "x = x / 2;",
            "endfor",
            "return {firstbit, @l};"
          ]
        },
        {
          "name": "IntFromBL",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"IntFromBl(LIST of 1's and 0's) => converts the 32 bit binary representation given by the list of 1's and 0's and converts it to a normal decimal number. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.\";",
            "bl = args[1];",
            "x = 0;",
            "for l in (bl)",
            "x = x * 2;",
            "x = x + l;",
            "endfor",
            "return x;"
          ]
        },
        {
          "name": "gcd greatest_common_divisor",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"gcd(INT num1,INT num2): find the greatest common divisor of the two numbers\";",
            "\"using the division algorithm. the absolute values of num1 and num2 are\";",
            "\"used without loss of generality.\";",
            "num1 = abs(args[1]);",
            "num2 = abs(args[2]);",
            "max = max(num1, num2);",
            "min = min(num1, num2);",
            "if (r1 = max % min)",
            "while (r2 = min % r1)",
            "min = r1;",
            "r1 = r2;",
            "endwhile",
            "return r1;",
            "else",
            "return min;",
            "endif"
          ]
        },
        {
          "name": "lcm least_common_multiple",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"lcm(INT num1,INT num2): find the least common multiple of the two numbers.\";",
            "\"we shall use the positive lcm value without loss of generality.\";",
            "\"since we have gcd already, we'll just use lcm*gcd = num1*num2\";",
            "num1 = abs(args[1]);",
            "num2 = abs(args[2]);",
            "return (num1 * num2) / this:gcd(num1, num2);"
          ]
        },
        {
          "name": "are_rel_prime are_relatively_prime",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"are_rel_prime(INT num1,INT num2): returns 1 if num1 and num2 are relatively\";",
            "\"prime.\";",
            "\"since we have gcd, this is pretty easy.\";",
            "if (this:gcd(args[1], args[2]) == 1)",
            "return 1;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "base_conversion",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Synopsis:    :base_conversion(number, current_base, desired_base)\";",
            "\"---\";",
            "\"Call with first arg either a number or a string, being the number\";",
            "\"desired for conversion. capital letters denote values from 10-35;\";",
            "\"lowercase letters from 36 to 61. Maximal base is 62.\";",
            "\"You will be unable to use the extra 26 lowercases as separate unless\";",
            "\"you pass a nonzero fourth argument. Passing zero or none uses the\";",
            "\"default value, which is to have AAAA=aaaa.\";",
            "\"The second and third arguments should be the base of the number and\";",
            "\"the base you want it in, respectively.\";",
            "\"Any of the arguments can be strings or nums, but high-base numbers\";",
            "\"will need to be strings. This returns a string.\";",
            "\"Any problems, talk to Ozymandias.\";",
            "sensitive = 0;",
            "if (length(args) < 3)",
            "return E_INVARG;",
            "elseif (length(args) == 4)",
            "sensitive = toint(args[4]);",
            "endif",
            "result = 0;",
            "thenum = tostr(args[1]);",
            "origbase = toint(args[2]);",
            "newbase = toint(args[3]);",
            "if ((((origbase < 2) || (newbase < 2)) || (origbase > 62)) || (newbase > 62))",
            "return E_INVARG;",
            "endif",
            "for which in [1..length(thenum)]",
            "value = index(this.base_alphabet, thenum[which], sensitive);",
            "if ((!value) || (value > origbase))",
            "return E_INVARG;",
            "endif",
            "result = ((result * origbase) + value) - 1;",
            "endfor",
            "thestring = \"\";",
            "if (result < 0)",
            "return E_INVARG;",
            "endif",
            "while (result)",
            "if ((which = (result % newbase) + 1) <= length(this.base_alphabet))",
            "thestring = this.base_alphabet[which] + thestring;",
            "else",
            "return E_INVARG;",
            "endif",
            "result = result / newbase;",
            "endwhile",
            "return thestring ? thestring | \"0\";"
          ]
        },
        {
          "name": "norm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":norm(a,b,c,d...) => sqrt(a^2+b^2+c^2+...)\";",
            "m = max(max(@args), -min(@args));",
            "logm = length(tostr(m));",
            "if (logm <= 4)",
            "s = 0;",
            "for a in (args)",
            "s = s + (a * a);",
            "endfor",
            "return toint(sqrt(tofloat(s)));",
            "else",
            "factor = toint(\"1\" + \"0000000\"[1..logm - 4]);",
            "s = 0;",
            "for a in (args)",
            "a = a / factor;",
            "s = s + (a * a);",
            "endfor",
            "return toint(sqrt(tofloat(s))) * factor;",
            "endif"
          ]
        },
        {
          "name": "sin",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):sin by Obvious (#54879) Fri Nov 17 06:07:39 1995 PST\";",
            "theta = args[1];",
            "if (typeof(theta) == FLOAT)",
            "return sin(theta);",
            "elseif (typeof(theta) == INT)",
            "degtheta = theta % 360;",
            "mintheta = 0;",
            "elseif (typeof(theta) == LIST)",
            "degtheta = theta[1] % 360;",
            "mintheta = theta[2] % 60;",
            "else",
            "return E_INVARG;",
            "endif",
            "if (mintheta < 0)",
            "mintheta = mintheta + 60;",
            "degtheta = degtheta - 1;",
            "endif",
            "while (degtheta < 1)",
            "degtheta = degtheta + 360;",
            "endwhile",
            "if (mintheta == 0)",
            "return this.sines[degtheta];",
            "endif",
            "lim1 = this.sines[degtheta];",
            "lim2 = this.sines[degtheta + 1];",
            "delta = lim2 - lim1;",
            "result = (((delta * mintheta) + 30) / 60) + lim1;",
            "return result;"
          ]
        },
        {
          "name": "cos",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):cos by Obvious (#54879) Fri Nov 17 06:07:50 1995 PST\";",
            "theta = args[1];",
            "if (typeof(theta) == FLOAT)",
            "return cos(theta);",
            "elseif (typeof(theta) == INT)",
            "degtheta = 90 - theta;",
            "mintheta = 0;",
            "elseif (typeof(theta) == LIST)",
            "degtheta = 89 - theta[1];",
            "mintheta = 60 - theta[2];",
            "else",
            "return;",
            "endif",
            "return this:sin({degtheta, mintheta});"
          ]
        },
        {
          "name": "tan",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):tan by Obvious (#54879) Fri Nov 17 06:07:53 1995 PST\";",
            "{theta} = args;",
            "if (typeof(theta) == FLOAT)",
            "return tan(theta);",
            "endif",
            "sine = this:sin(theta);",
            "cosine = this:cos(theta);",
            "return ((sine * 10000) + ((cosine + 1) / 2)) / cosine;"
          ]
        },
        {
          "name": "arcsin asin",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):arcsin by Obvious (#54879) Fri Nov 17 06:08:01 1995 PST\";",
            "{given} = args;",
            "if (typeof(given) == FLOAT)",
            "return asin(given);",
            "endif",
            "given = abs(given);",
            "if (given > 10000)",
            "return E_RANGE;",
            "endif",
            "i = 1;",
            "while (given > this.sines[i])",
            "i = i + 1;",
            "endwhile",
            "if (given == this.sines[i])",
            "if (args[1] < 0)",
            "return {-i, 0};",
            "else",
            "return {i, 0};",
            "endif",
            "endif",
            "degrees = i - 1;",
            "if (i == 1)",
            "lower = 0;",
            "else",
            "lower = this.sines[i - 1];",
            "endif",
            "upper = this.sines[i];",
            "delta1 = given - lower;",
            "delta2 = upper - lower;",
            "minutes = ((delta1 * 60) + ((delta2 + 1) / 2)) / delta2;",
            "if (args[1] < 0)",
            "degrees = -degrees;",
            "minutes = -minutes;",
            "endif",
            "return {degrees, minutes};"
          ]
        },
        {
          "name": "arccos acos",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):arccos by Obvious (#54879) Fri Nov 17 06:08:08 1995 PST\";",
            "given = args[1];",
            "if (typeof(given) == FLOAT)",
            "return acos(given);",
            "endif",
            "arcsin = this:arcsin(given);",
            "degrees = 89 - arcsin[1];",
            "minutes = 60 - arcsin[2];",
            "\"//* Changed (minutes > 60) to (minutes >= 60) following bug report by Loufah (#116455).  2000-03-24 23:00 CST  Gary (#110811).\";",
            "if (minutes >= 60)",
            "minutes = minutes - 60;",
            "degrees = degrees + 1;",
            "endif",
            "return {degrees, minutes};"
          ]
        },
        {
          "name": "arctan atan",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Copied from Trig_Utils (#25800):arctan by Obvious (#54879) Fri Nov 17 06:08:18 1995 PST\";",
            "given = args[1];",
            "if (typeof(given) == FLOAT)",
            "return atan(given);",
            "endif",
            "reciprocal = ((given * given) / 10000) + 10000;",
            "reciprocal = sqrt(reciprocal * 10000);",
            "cosine = 100000000 / reciprocal;",
            "return this:arccos(cosine);"
          ]
        },
        {
          "name": "deg2rads deg2rad",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":deg2rad(FLOAT Degrees) => FLOAT Radians\";",
            "return tofloat(args[1]) * 0.0174532925199433;"
          ]
        },
        {
          "name": "rads2deg rad2deg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":rads2deg(FLOAT Radians) => FLOAT Degrees\";",
            "return tofloat(args[1]) * 57.2957795130824;"
          ]
        },
        {
          "name": "precision",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":precision(FLOAT Number, INT Digits of Precision) => FLOAT Number\";",
            "\"Cuts the given number to the given digits of precision.  Uses rounding.\";",
            "{digits, pre} = args;",
            "mult = 10.0 ^ pre;",
            "return this:rint(digits * mult) / mult;"
          ]
        },
        {
          "name": "round",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Usage: round(INT number, INT round)\";",
            "\"Rounds 'number' off to the nearest multiple of 'round'.\";",
            "\"Rounds UP numbers exactly half way in between two round possibilities.\";",
            "{what, round} = args;",
            "low = (what / round) * round;",
            "return (what < (low + (round / 2))) ? low | (low + round);"
          ]
        },
        {
          "name": "mean average",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\"Usage: mean(INT, INT, ... )\";",
            "\"       mean({INT, INT, ...})\";",
            "\"Returns the average of all integers provided.\";",
            "return this:sum(rlist = (typeof(args[1]) == LIST) ? args[1] | args) / length(rlist);"
          ]
        },
        {
          "name": "sum_float",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":sum_float(FLOAT num, num, num ...) => Total of all arguments added together.\";",
            "\":sum_float({num, num, num, ...}) will also work.\";",
            "{?total = 0.0, @rest} = args;",
            "if (typeof(total) == LIST)",
            "{?total = 0.0, @rest} = total;",
            "endif",
            "for number in (rest)",
            "total = total + number;",
            "endfor",
            "return total;"
          ]
        },
        {
          "name": "sum_int sum",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":sum_int(INT num, num, num ...) => Total of all arguments added together.\";",
            "\":sum_int({num, num, num, ...}) will also work.\";",
            "\"(...also named :sum for backward compatibility).\";",
            "\"Use :sum_float to sum a list of floats.\";",
            "{?total = 0, @rest} = args;",
            "if (typeof(total) == LIST)",
            "{?total = 0, @rest} = total;",
            "endif",
            "for number in (rest)",
            "total = total + number;",
            "endfor",
            "return total;",
            "\"... N.B.  For the sake of backward compatibility this routine will also return the float sum of a non-empty lists of floats, but using it this way should not be encouraged.\";"
          ]
        },
        {
          "name": "rint",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "\":rint(FLOAT Number) => FLOAT Number\";",
            "\"Returns the given floating-point number rounded to the nearest integer, as a floating-point number.  In case of ties, rounds away from 0.\";",
            "{f} = args;",
            "return trunc((f > 0.0) ? f + 0.5 | (f - 0.5));"
          ]
        },
        {
          "name": "to_percent",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 26,
          "code": [
            "{per1, per2} = args;",
            "return (tofloat(per1) / tofloat(per2)) * 100.0;"
          ]
        }
      ],
      "propnames": [
        "base_alphabet",
        "tangents",
        "factor",
        "taylor",
        "sines",
        "pi",
        "piscale",
        "phi",
        "e",
        "e_string"
      ],
      "propdefs": [
        {
          "value": "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            174,
            349,
            524,
            699,
            874,
            1051,
            1227,
            1405,
            1583,
            1763,
            1943,
            2125,
            2308,
            2493,
            2679,
            2867,
            3057,
            3249,
            3443,
            3639,
            3838,
            4040,
            4244,
            4452,
            4663,
            4877,
            5095,
            5317,
            5543,
            5773,
            6008,
            6248,
            6494,
            6745,
            7002,
            7265,
            7535,
            7812,
            8097,
            8390,
            8692,
            9004,
            9325,
            9656,
            10000
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 10000,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 100,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            175,
            349,
            523,
            698,
            872,
            1045,
            1219,
            1392,
            1564,
            1736,
            1908,
            2079,
            2250,
            2419,
            2588,
            2756,
            2924,
            3090,
            3256,
            3420,
            3584,
            3746,
            3907,
            4067,
            4226,
            4384,
            4540,
            4695,
            4848,
            5000,
            5150,
            5299,
            5446,
            5592,
            5736,
            5878,
            6018,
            6157,
            6293,
            6428,
            6561,
            6691,
            6820,
            6947,
            7071,
            7193,
            7314,
            7431,
            7547,
            7660,
            7771,
            7880,
            7986,
            8090,
            8192,
            8290,
            8387,
            8480,
            8572,
            8660,
            8746,
            8829,
            8910,
            8988,
            9063,
            9135,
            9205,
            9272,
            9336,
            9397,
            9455,
            9511,
            9563,
            9613,
            9659,
            9703,
            9744,
            9781,
            9816,
            9848,
            9877,
            9903,
            9925,
            9945,
            9962,
            9976,
            9986,
            9994,
            9998,
            10000,
            9998,
            9994,
            9986,
            9976,
            9962,
            9945,
            9925,
            9903,
            9877,
            9848,
            9816,
            9781,
            9744,
            9703,
            9659,
            9613,
            9563,
            9511,
            9455,
            9397,
            9336,
            9272,
            9205,
            9135,
            9063,
            8988,
            8910,
            8829,
            8746,
            8660,
            8572,
            8480,
            8387,
            8290,
            8192,
            8090,
            7986,
            7880,
            7771,
            7660,
            7547,
            7431,
            7314,
            7193,
            7071,
            6947,
            6820,
            6691,
            6561,
            6428,
            6293,
            6157,
            6018,
            5878,
            5736,
            5592,
            5446,
            5299,
            5150,
            5000,
            4848,
            4695,
            4540,
            4384,
            4226,
            4067,
            3907,
            3746,
            3584,
            3420,
            3256,
            3090,
            2924,
            2756,
            2588,
            2419,
            2250,
            2079,
            1908,
            1736,
            1564,
            1392,
            1219,
            1045,
            872,
            698,
            523,
            349,
            175,
            0,
            -175,
            -349,
            -523,
            -698,
            -872,
            -1045,
            -1219,
            -1392,
            -1564,
            -1736,
            -1908,
            -2079,
            -2250,
            -2419,
            -2588,
            -2756,
            -2924,
            -3090,
            -3256,
            -3420,
            -3584,
            -3746,
            -3907,
            -4067,
            -4226,
            -4384,
            -4540,
            -4695,
            -4848,
            -5000,
            -5150,
            -5299,
            -5446,
            -5592,
            -5736,
            -5878,
            -6018,
            -6157,
            -6293,
            -6428,
            -6561,
            -6691,
            -6820,
            -6947,
            -7071,
            -7193,
            -7314,
            -7431,
            -7547,
            -7660,
            -7771,
            -7880,
            -7986,
            -8090,
            -8192,
            -8290,
            -8387,
            -8480,
            -8572,
            -8660,
            -8746,
            -8829,
            -8910,
            -8988,
            -9063,
            -9135,
            -9205,
            -9272,
            -9336,
            -9397,
            -9455,
            -9511,
            -9563,
            -9613,
            -9659,
            -9703,
            -9744,
            -9781,
            -9816,
            -9848,
            -9877,
            -9903,
            -9925,
            -9945,
            -9962,
            -9976,
            -9986,
            -9994,
            -9998,
            -10000,
            -9998,
            -9994,
            -9986,
            -9976,
            -9962,
            -9945,
            -9925,
            -9903,
            -9877,
            -9848,
            -9816,
            -9781,
            -9744,
            -9703,
            -9659,
            -9613,
            -9563,
            -9511,
            -9455,
            -9397,
            -9336,
            -9272,
            -9205,
            -9135,
            -9063,
            -8988,
            -8910,
            -8829,
            -8746,
            -8660,
            -8572,
            -8480,
            -8387,
            -8290,
            -8192,
            -8090,
            -7986,
            -7880,
            -7771,
            -7660,
            -7547,
            -7431,
            -7314,
            -7193,
            -7071,
            -6947,
            -6820,
            -6691,
            -6561,
            -6428,
            -6293,
            -6157,
            -6018,
            -5878,
            -5736,
            -5592,
            -5446,
            -5299,
            -5150,
            -5000,
            -4848,
            -4695,
            -4540,
            -4384,
            -4226,
            -4067,
            -3907,
            -3746,
            -3584,
            -3420,
            -3256,
            -3090,
            -2924,
            -2756,
            -2588,
            -2419,
            -2250,
            -2079,
            -1908,
            -1736,
            -1564,
            -1392,
            -1219,
            -1045,
            -872,
            -698,
            -523,
            -349,
            -175,
            0,
            175
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 3.141592653589793,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0.00872664625997164,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1.618033988749895,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2.71828182845905,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Trigonometric/Exponential functions:",
            "  sin(a),cos(a),tan(a) -- returns 10000*(the value of the corresponding",
            "       trigonometric function) angle a is in degrees.",
            "  arctan([x,]y) -- returns arctan(y/x) in degrees in the range -179..180.",
            "       x defaults to 10000.  Quadrant is that of (x,y).",
            "  exp(x[,n]) -- calculates e^x with an nth order taylor polynomial",
            "  aexp(x) -- calculates 10000 e^(x/10000)",
            "",
            "Statistical functions:",
            "  combinations(n,r) -- returns the number of combinations given n objects",
            "       taken r at a time.",
            "  permutations(n,r) -- returns the number of permutations possible given",
            "       n objects taken r at a time.",
            "",
            "Number decomposition:",
            "  div(n,d) -- correct version of / (handles negative numbers correctly)",
            "  mod(n,d) -- correct version of % (handles negative numbers correctly)",
            "  divmod(n,d) -- {div(n,d),mod(n,d)}",
            "  parts(n,q[,i]) -- returns a list of two elements {integer,decimal fraction}",
            "",
            "Other math functions:",
            "  factorial(x) -- returns x!",
            "  norm(a,b,c,d,...) -- returns sqrt(a^2+b^2+c^2+...)",
            "  sum(a,b,c,d,...) -- returns the sum of all arguments.",
            "",
            "Series:",
            "  fibonacci(n) -- returns the 1st n fibonacci numbers in a list",
            "  geometric(x,n) -- returns the value of the nth order geometric series at x",
            "",
            "Integer Properties:",
            "  gcd(a,b) -- find the greatest common divisor of the two numbers",
            "  lcm(a,b) -- find the least common multiple of the two numbers",
            "  are_relatively_prime(a,b) -- return 1 if a and b are relatively prime",
            "  is_prime(n) -- returns 1 if the number is a prime and 0 otherwise",
            "  ",
            "Miscellaneous:",
            "  random(n) -- returns a random number from 0..n if n > 0 or n..0 if n < 0",
            "  random_range(n[,mean]) -- returns a random number from mean - n..mean + n",
            "      with mean defaulting to 0",
            "  simpson({a,b},{f(a),f((a+b)/2),f(b)}) -- returns the numerical",
            "      approximation of an integral using simpson's rule",
            "  base_conversion(num|string, oldbase, newbase [,sens]) -- converts the number",
            "      given as first arg from oldbase to the newbase.",
            "",
            "Bitwise Arithmetic:",
            "  NOT(x) -- returns the complement of x",
            "      All bitwise manipulation is of 32-bit values.",
            "",
            "Bitwise Conversions:",
            "  BlFromInt(d) -- converts a decimal number d to a list of 1's and 0's, 32-bit",
            "  IntFromBl(b) -- converts a list of 1's and 0's (any precision) to decimal"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Math Utilities",
            "Math_Utils",
            "trigonometric utilites",
            "trig_utils"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the Math Utilities utility package.  See `help $math_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            44800,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "27": {
      "id": 27,
      "name": "Set Utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "union",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Returns the set union of all of the lists provided as arguments.\";",
            "if (!args)",
            "return {};",
            "endif",
            "{set, @rest} = args;",
            "for l in (rest)",
            "for x in (l)",
            "set = setadd(set, x);",
            "endfor",
            "endfor",
            "return set;"
          ]
        },
        {
          "name": "intersection",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Returns the set intersection of all the lists provided as arguments.\";",
            "if (!args)",
            "return {};",
            "endif",
            "max = 0;",
            "{result, @rest} = args;",
            "for set in (rest)",
            "if (length(result) < length(set))",
            "set1 = result;",
            "set2 = set;",
            "else",
            "set1 = set;",
            "set2 = result;",
            "endif",
            "for x in (set1)",
            "if (!(x in set2))",
            "set1 = setremove(set1, x);",
            "endif",
            "endfor",
            "result = set1;",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "diff*erence",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Usage:  diff(set 1, set 2, ..., set n)\";",
            "\"Returns all elements of set 1 that are not in sets 2..n\";",
            "{set, @rest} = args;",
            "for l in (rest)",
            "for x in (l)",
            "set = setremove(set, x);",
            "endfor",
            "endfor",
            "return set;"
          ]
        },
        {
          "name": "contains",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"True if the first list given is a superset of all subsequent lists.\";",
            "\"False otherwise.  {} is a superset of {} and nothing else; anything is\";",
            "\"a superset of {}.  If only one list is given, return true.\";",
            "{?super = {}, @rest} = args;",
            "for l in (rest)",
            "for x in (l)",
            "if (!(x in super))",
            "return 0;",
            "endif",
            "endfor",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "exclusive_or xor",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Usage:  exclusive_or(set, set, ...)\";",
            "\"Return the set of all elements that are in exactly one of the input sets\";",
            "\"For two sets, this is the equivalent of (A u B) - (A n B).\";",
            "if (!args)",
            "return {};",
            "endif",
            "{set, @rest} = args;",
            "so_far = set;",
            "for l in (rest)",
            "for x in (l)",
            "if (x in so_far)",
            "set = setremove(set, x);",
            "else",
            "set = setadd(set, x);",
            "endif",
            "endfor",
            "so_far = {@so_far, @l};",
            "endfor",
            "return set;"
          ]
        },
        {
          "name": "difference_suspended diff_suspended",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Usage:  diff_suspended(set 1, set 2, ..., set n)\";",
            "\"Returns all elements of set 1 that are not in sets 2..n\";",
            "\"Suspends as needed if the lists are large.\";",
            "{set, @rest} = args;",
            "for l in (rest)",
            "for x in (l)",
            "set = setremove(set, x);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endfor",
            "return set;"
          ]
        },
        {
          "name": "equal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"True if the two lists given contain the same elements.\";",
            "\"False otherwise.\";",
            "{set1, set2} = args;",
            "while (set1)",
            "{elt, @set1} = set1;",
            "if (elt in set2)",
            "set2 = setremove(set2, elt);",
            "while (elt in set2)",
            "set2 = setremove(set2, elt);",
            "endwhile",
            "while (elt in set1)",
            "set1 = setremove(set1, elt);",
            "endwhile",
            "else",
            "return 0;",
            "endif",
            "endwhile",
            "if (set2)",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "intersection_preserve_case",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 27,
          "code": [
            "\"Copied from Fox (#54902):intersection Mon Dec 27 17:02:57 1993 PST\";",
            "\"a version of $set_utils:intersection that maintains the property that everything in the return value is in the first argument, even considering case\";",
            "if (!args)",
            "return {};",
            "endif",
            "{result, @rest} = args;",
            "for s in (rest)",
            "for x in (result)",
            "if (!(x in s))",
            "result = setremove(result, x);",
            "endif",
            "endfor",
            "endfor",
            "return result;"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "This object is useful for operations that treat lists as sets (i.e.,",
            "without concern about order and assuming no duplication).",
            "",
            " union(set, set, ...)        => union",
            " intersection(set, set, ...) => intersection",
            " intersection_preserve_case(base set, set, set, ...)",
            "        => intersection with the case of the base set's elements preserved",
            "",
            " diff*erence(set1, set2, ..., setn)",
            "        => result of removing all elements of sets 2..n from set 1.",
            "",
            " difference_suspended(set1, set2, ..., setn)",
            "        => same as above except it suspends as needed.",
            "",
            " exclusive_or(set, set, set, ...)",
            "        => all elements that are contained in exactly one of the sets",
            "",
            " contains(set1, set2, ..., setn)",
            "        => true if and only if all of sets 2..n are subsets of set 1",
            "",
            " equal(set1, set2)",
            "        => true if and only if set1 and set2 are equal"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Set Utilities",
            "set_utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the Set Utilities utility package.  See `help $set_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            8102,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "28": {
      "id": 28,
      "name": "Builtin Function Help",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "match()",
        "rmatch()",
        "substitute()",
        "sqrt()",
        "server_log()",
        "pass()",
        "builtin-index",
        "open_network_connection()",
        "connection_name()",
        "shutdown()",
        "dump_database()",
        "memory_usage()",
        "reset_max_object()",
        "renumber()",
        "server_version()",
        "output_delimiters()",
        "callers()",
        "kill_task()",
        "queued_tasks()",
        "read()",
        "suspend()",
        "task_id()",
        "seconds_left()",
        "ticks_left()",
        "caller_perms()",
        "set_task_perms()",
        "eval()",
        "boot_player()",
        "notify()",
        "idle_seconds()",
        "connected_seconds()",
        "connected_players()",
        "set_player_flag()",
        "is_player()",
        "players()",
        "set_verb_code()",
        "verb_code()",
        "delete_verb()",
        "add_verb()",
        "set_verb_args()",
        "verb_args()",
        "set_verb_info()",
        "verb_info()",
        "verbs()",
        "delete_property()",
        "add_property()",
        "set_property_info()",
        "property_info()",
        "properties()",
        "move()",
        "max_object()",
        "recycle()",
        "children()",
        "parent()",
        "valid()",
        "chparent()",
        "create()",
        "setremove()",
        "setadd()",
        "listset()",
        "listdelete()",
        "listinsert()",
        "listappend()",
        "strcmp()",
        "rindex()",
        "index()",
        "crypt()",
        "strsub()",
        "length()",
        "ctime()",
        "time()",
        "random()",
        "abs()",
        "max()",
        "min()",
        "toobj()",
        "tonum()",
        "tostr()",
        "typeof()",
        "clear_property()",
        "is_clear_property()",
        "set_connection_option()",
        "queue_info()",
        "is_member()",
        "equal()",
        "toliteral()",
        "value_bytes()",
        "acos()",
        "asin()",
        "atan()",
        "binary_hash()",
        "string_hash()",
        "buffered_output_length()",
        "call_function()",
        "ceil()",
        "connection_options()",
        "connection_option()",
        "sin()",
        "cos()",
        "tan()",
        "sinh()",
        "cosh()",
        "tanh()",
        "db_disk_size()",
        "decode_binary()",
        "disassemble()",
        "encode_binary()",
        "exp()",
        "floatstr()",
        "floor()",
        "flush_input()",
        "force_input()",
        "function_info()",
        "listen()",
        "listeners()",
        "log()",
        "log10()",
        "object_bytes()",
        "raise()",
        "resume()",
        "task_stack()",
        "tofloat()",
        "toint()",
        "trunc()",
        "unlisten()",
        "value_hash()",
        "load_server_options()",
        "verb_cache_stats()",
        "log_cache_stats()"
      ],
      "propdefs": [
        {
          "value": [
            "Syntax:  match (STR <subject>, STR <pattern> [, <case-matters>])  => LIST",
            "         rmatch (STR <subject>, STR <pattern> [, <case-matters>])  => LIST",
            "",
            "The function `match()' (`rmatch()') searches for the first (last) occurrence of the regular expression <pattern> in the string <subject>.  If <pattern> is syntactically malformed, then E_INVARG is raised. The process of matching can in some cases consume a great deal of memory in the server; should this memory consumption become excessive, then the matching process is aborted and E_QUOTA is raised.",
            "",
            "If no match is found, the empty list is returned; otherwise, these functions return a list containing information about the match (see below).  By default, the search ignores upper/lower case distinctions.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.",
            "",
            "The list that `match()' (`rmatch()') returns contains the details about the match made.  The list is in the form:",
            "",
            "     {<start>, <end>, <replacements>, <subject>}",
            "",
            "where <start> is the index in STRING of the beginning of the match, <end> is the index of the end of the match, <replacements> is a list described below, and <subject> is the same string that was given as the first argument to the `match()' or `rmatch()'.",
            "",
            "The <replacements> list is always nine items long, each item itself being a list of two numbers, the start and end indices in <subject> matched by some parenthesized sub-pattern of <pattern>.  The first item in <replacements> carries the indices for the first parenthesized sub-pattern, the second item carries those for the second sub-pattern, and so on.  If there are fewer than nine parenthesized sub-patterns in <pattern>, or if some sub-pattern was not used in the match, then the corresponding item in <replacements> is the list {0, -1}.  See the discussion of `%)' in `help regular-expressions', for more information on parenthesized sub-patterns.",
            "",
            "   match(\"foo\", \"f*o\")          =>  {1, 2, {{0, -1}, ...}, \"foo\"}",
            "   match(\"foo\", \"fo*\")          =>  {1, 3, {{0, -1}, ...}, \"foo\"}",
            "   match(\"foobar\", \"o*b\")       =>  {2, 4, {{0, -1}, ...}, \"foobar\"}",
            "   rmatch(\"foobar\", \"o*b\")      =>  {4, 4, {{0, -1}, ...}, \"foobar\"}",
            "   match(\"foobar\", \"f%(o*%)b\")  =>  {1, 4, {{2, 3}, {0, -1}, ...}, \"foobar\"}",
            "",
            "See `help regular-expressions' for information on the syntax and semantics of patterns."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "match()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  substitute (STR <template>, LIST <subs>)  => STR",
            "",
            "Performs a standard set of substitutions on the string <template>, using the information contained in <subs>, returning the resulting, transformed <template>.  <Subs> should be a list like those returned by `match()' or `rmatch()' when the match succeeds.",
            "",
            "In <template>, the strings `%1' through `%9' will be replaced by the text matched by the first through ninth parenthesized sub-patterns when `match()' or `rmatch()' was called.  The string `%0' in <template> will be replaced by the text matched by the pattern as a whole when `match()' or `rmatch()' was called. The string '%%' will be replaced by a single '%' sign. If '%' appears in <template> followed by any other character, E_INVARG will be raised.",
            "",
            "     subs = match(\"*** Welcome to LambdaMOO!!!\", \"%(%w*%) to %(%w*%)\");",
            "     substitute(\"I thank you for your %1 here in %2.\", subs)",
            "             =>   \"I thank you for your Welcome here in LambdaMOO.\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  sqrt (FLOAT <x>)  => FLOAT",
            "",
            "Returns the square root of <x>.  If <x> is negative, then E_INVARG is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  server_log (STR <message> [, <is-error>])  => none",
            "",
            "The text in <message> is sent to the server log.  If the programmer is not a wizard, then E_PERM is raised.  If <is-error> is provided and true, then <message> is marked in the server log as an error."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  pass (<arg>, ...)   => value",
            "",
            "Often, it is useful for a child object to define a verb that *augments* the behavior of a verb on its parent object. For example, the root object (an ancestor of every other object) defines a :description() verb that simply returns the value of `this.description'; this verb is used by the implementation of the `look' command. In many cases, a programmer would like the description of some object to include some non-constant part; for example, a sentence about whether or not the object was `awake' or `sleeping'.  This sentence should be added onto the end of the normal description.  The programmer would like to have a means of calling the normal `description' verb and then appending the sentence onto the end of that description.  The function `pass()' is for exactly such situations.",
            "",
            "`Pass()' calls the verb with the same name as the current verb but as defined on the parent of the object that defines the current verb.  The arguments given to the called verb are the ones given to pass() and the returned value of the called verb is returned from the call to pass(). The initial value of `this' in the called verb is the same as in the calling verb.",
            "",
            "Thus, in the example above, the child-object's :description() verb might have the following implementation:",
            "",
            "    return pass(@args) + \"  It is \" + (this.awake ? \"awake.\" | \"sleeping.\");",
            "",
            "That is, it calls its parent's :description() verb and then appends to the result a sentence whose content is computed based on the value of a property on the object.",
            "",
            "In the above example, `pass()' would have worked just as well, since :description() is not normally given any arguements.  However, it is a good idea to get into the habit of using `pass(@args)' rather than `pass(args[1])' or `pass()' even if the verb being pass()ed to is already known to take a set number of arguments or none at all.  For one thing, though the args may be irrelevant to the code that you've written, it may be that the corresponding verb on the parent has been rewritten to take additional arguments, in which case you will want your verb to continue to work..."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Server Built-in Functions"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  open_network_connection (<value>, ... [, <use_ipv6>, <listener>])   => obj",
            "",
            "Establishes a network connection to the place specified by the arguments and more-or-less pretends that a new, normal player connection has been established from there.  The new connection, as usual, will not be logged in initially and will have a negative object number associated with it for use with `read()', `notify()', and `boot_player()'.  This object number is the value returned by this function.",
            "",
            "If the programmer is not a wizard or if the `OUTBOUND_NETWORK' compilation option was not used in building the server, then `E_PERM' is raised.  If the network connection cannot be made for some reason, then other errors will be returned, depending upon the particular network implementation in use.",
            "",
            "For the TCP/IP network implementations (the only ones as of this writing that support outbound connections), there must be at least two arguments, a string naming a host (possibly using the numeric Internet syntax) and an integer specifying a TCP port.  If a connection cannot be made because the host does not exist, the port does not exist, the host is not reachable or refused the connection, `E_INVARG' is raised.  If the connection cannot be made for other reasons, including resource limitations, then `E_QUOTA' is raised.",
            "",
            "An optional third agument can be supplied indicating that the connection should be created on the destination's IPv6 interface rather than IPv4.",
            "",
            "Finally, an optional fourth argument may be supplied, `listener' must be an object, whose listening verbs will be called at appropriate points.  See the description in `listen()' for more details.",
            "",
            "The outbound connection process involves certain steps that can take quite a long time, during which the server is not doing anything else, including responding to user commands and executing MOO tasks.  See the chapter on server assumptions about the database for details about how the server limits the amount of time it will wait for these steps to successfully complete.",
            "",
            "It is worth mentioning one tricky point concerning the use of this function.  Since the server treats the new connection pretty much like any normal player connection, it will naturally try to parse any input from that connection as commands in the usual way.  To prevent this treatment, you should use `set_connection_option()' to set the `hold-input' option true on the connection."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_name (obj <player> [, <method>])   => str",
            "",
            "Returns a network-specific string identifying the connection being used by the given player.  If the programmer is not a wizard and not <player>, then E_PERM is raised.  If <player> is not currently connected, then E_INVARG is raised.",
            "",
            "For the TCP/IP networking configurations, for in-bound connections, the string contains the resolved DNS hostname of the connection.",
            "",
            "If <method> is set to 1, the string will always contain the numeric IP address of the connection.",
            "",
            "If <method> is set to 2, the string will contain the full legacy connection_name string with the form:",
            "",
            "  \"port <lport> from <host>, port <port>\"",
            "",
            "where <lport> is the listening port on which the connection arrived, <host> is either the name or decimal TCP address of the host to which the connection was opened, and <port> is the decimal TCP port of the connection on that host."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  shutdown ([STR <message>])   => none",
            "",
            "Requests that the server shut itself down at its next opportunity.  Before doing so, the given <message> is printed to all connected players.  If the programmer is not a wizard, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  dump_database ()   => none",
            "",
            "Requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details.  If the programmer is not a wizard, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  memory_usage ()   => list",
            "",
            "On some versions of the server, this returns statistics concerning the server",
            "consumption of system memory.  The result is a list of lists, each in the",
            "following format:",
            "",
            "    {<block-size>, <nused>, <nfree>}",
            "",
            "where <block-size> is the size in bytes of a particular class of memory",
            "fragments, <nused> is the number of such fragments currently in use in the",
            "server, and <nfree> is the number of such fragments that have been reserved",
            "for use but are currently free.",
            "",
            "On servers for which such statistics are not available, `memory_usage()'",
            "returns `{}'.  The compilation option `USE_SYSTEM_MALLOC' controls",
            "whether or not statistics are available; if the option is provided, statistics",
            "are not available."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  reset_max_object ()   => none",
            "",
            "The server's idea of the highest object number ever used is changed to be the highest object number of a currently-existing object, thus allowing reuse of any higher numbers that refer to now-recycled objects.  If the programmer is not a wizard, then E_PERM is raised.",
            "",
            "This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  renumber (OBJ <object>)   => OBJ",
            "",
            "The object number of the object currently numbered <object> is changed to be the least nonnegative object number not currently in use and the new object number is returned.  If <object> is not valid, then E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised. If there are no unused nonnegative object numbers less than <object>, then <object> is returned and no changes take place.",
            "",
            "The references to <object> in the parent/children and location/contents hierarchies are updated to use the new object number, and any verbs, properties and/or objects owned by <object> are also changed to be owned by the new object number.  The latter operation can be quite time consuming if the database is large.  No other changes to the database are performed; in particular, no object references in property values or verb code are updated.",
            "",
            "This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  server_version ()   => str",
            "",
            "Returns a string giving the version number of the MOO server in the following",
            "format:",
            "",
            "    \"<major>.<minor>.<release>\"",
            "",
            "where <major>, <minor>, and <release> are all decimal numbers.",
            "",
            "The major version number changes very slowly, only when existing MOO code might",
            "stop working, due to an incompatible change in the syntax or semantics of the",
            "programming language, or when an incompatible change is made to the database",
            "format.",
            "",
            "The minor version number changes more quickly, whenever an upward-compatible",
            "change is made in the programming language syntax or semantics.  The most",
            "common cause of this is the addition of a new kind of expression, statement, or",
            "built-in function.",
            "",
            "The release version number changes as frequently as bugs are fixed in the",
            "server code.  Changes in the release number indicate changes that should only",
            "be visible to users as bug fixes, if at all."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  output_delimiters (OBJ <player>)   => LIST",
            "",
            "Returns a list of two strings, the current \"output prefix\" and \"output suffix\" for <player>.  If <player> does not have an active network connection, then E_INVARG is raised.  If either string is currently undefined, the value `\"\"' is used instead.  See the discussion of the `PREFIX' and `SUFFIX' commands in the LambdaMOO Programmers Manual for more information about the output prefix and suffix."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  callers ([include-line-numbers])   => list",
            "",
            "Returns information on each of the verbs and built-in functions currently waiting to resume execution in the current task.  When one verb or function calls another verb or function, execution of the caller is temporarily suspended, pending the called verb or function returning a value.  At any given time, there could be several such pending verbs and functions: the one that called the currently executing verb, the verb or function that called that one, and so on.  The result of `callers()' is a list, each element of which gives information about one pending verb or function in the following format:",
            "",
            "  {<this>, <verb-name>, <programmer>, <verb-loc>, <player>, <line-number>}",
            "",
            "For verbs, <this> is the initial value of the variable `this' in that verb, <verb-name> is the name used to invoke that verb, <programmer> is the player with whose permissions that verb is running, <verb-loc> is the object on which that verb is defined, and <player> is the initial value of the variable `player' in that verb, and <line-number> indicates which line of the verb's code is executing. The <line-number> element is included only if the `include-line-numbers' argument was provided and is true.",
            "",
            "For functions, <this>, <programmer>, and <verb-loc> are all #-1, <verb-name> is the name of the function, and <line-number> is an index used internally to determine the current state of the built-in function. The simplest correct test for a built-in function entry is",
            "",
            "(VERB-LOC == #-1 && PROGRAMMER == #-1 && VERB-NAME != \"\")",
            "",
            "",
            "The first element of the list returned by `callers()' gives information on the verb that called the currently-executing verb, the second element describes the verb that called that one, and so on.  The last element of the list describes the first verb called in this task."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  kill_task (INT <task-id>)   => none",
            "",
            "Removes the task with the given <task-id> from the queue of waiting tasks. If the programmer is not the owner of that task and not a wizard, then E_PERM is raised.  If there is no task on the queue with the given <task-id>, then E_INVARG is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  queued_tasks ()   => LIST",
            "",
            "Returns information on each of the background tasks (i.e., forked, suspended, or reading)  owned by the programmer (or, if the programmer is a wizard, all queued tasks). The returned value is a list of lists, each of which encodes certain information about a particular queued task in the following format:",
            "",
            "    {<task-id>, <start-time>, <ticks>, <clock-id>,",
            "     <programmer>, <verb-loc>, <verb-name>, <line>, <this>, <task-size>}",
            "",
            "where <task-id> is a numeric identifier for this queued task, <start-time> is the time after which this task will begin execution (in `time()' format), <ticks> is the number of ticks this task will have when it starts (always 20,000 now, though this is changeable. This makes this value obsolete and no longer interesting), <clock-id> is a number whose value is no longer interesting, <programmer> is the permissions with which this task will begin execution (and also the player who \"owns\" this task), <verb-loc> is the object on which the verb that forked this task was defined at the time, <verb-name> is that name of that verb, <line> is the number of the first line of the code in that verb that this task will execute, and <this> is the value of the variable `this' in that verb. For reading tasks, <start-time> is `-1'.  <task-size> is in bytes, and is the size of memory in use by the task for local variables, stack frames, etc.",
            "",
            "The <ticks> and <clock-id> fields are now obsolete and are retained only for backward-compatibility reasons.  They may disappear in a future version of the server."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  read ([OBJ <conn> [, non-blocking]])   => STR",
            "",
            "Reads and returns a line of input from the connection <conn> (or, if not provided, from the player that typed the command that initiated the current task). If <non-blocking> is false or not provided, this function suspends the current task, resuming it when there is input available to be read. If <non-blocking> is provided and true, this function never suspends the calling task; if there is no input currently available for input, `read()' simply returns 0 immediately.",
            "",
            "If <conn> is provided, then the programmer must either be a wizard or the owner of <conn>, if <conn> is not provided, then `read()' may only be called by a wizard and only in the task that was last spawned by a command from the connection in question. Otherwise, E_PERM is raised. If the given <conn> is not currently connected and has no pending lines of input, or if the connection is closed while a task is waiting for input but before any lines of input are received, then `read()' raises E_INVARG.",
            "",
            "The restriction on the use of `read()' without any arguments preserves the following simple invariant: if input is being read from a player, it is for the task started by the last command that the player typed. This invariant adds responsibility to the programmer, however. If your program calls another verb before doing a `read()', then either that verb must not suspend, or else you must arrange that no commands will be read from the connection in the meantime. The most straightforward way to do this is to call",
            "",
            "  set_connection_option(<conn>, \"hold-input\", 1)",
            "",
            "before any task suspension could happen, then make all of your calls to `read()' and other code that might suspend, and finally call",
            "",
            "  set_connection_option(<conn>, \"hold-input\", 0)",
            "",
            "to allow commands once again to be read and interpreted normally."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  suspend ([INT <seconds>])   => value",
            "",
            "Suspends the current task, and resumes it after at least <seconds> seconds. (If <seconds> is not provided, the task is suspended indefinitely; such a task can only be resumed by use of the `resume()' function.) When the task is resumed, it will have a full quota of ticks and seconds.  This function is useful for programs that run for a long time or require a lot of ticks.  If <seconds> is negative, then E_INVARG is raised. `Suspend()' returns zero unless it was resumed via `resume()' in which case it returns the second argument given to that function.",
            "",
            "In some sense, this function forks the `rest' of the executing task.  However, there is a major difference between the use of `suspend(<seconds>)' and the use of the `fork (<seconds>)'.  The `fork' statement creates a new task (a \"forked task\") while the currently-running task still goes on to completion, but a `suspend()' suspends the currently-running task (thus making it into a \"suspended task\").  This difference may be best explained by the following examples, in which one verb calls another:",
            "",
            "    .program   #0:caller_A",
            "    #0.prop = 1;",
            "    #0:callee_A();",
            "    #0.prop = 2;",
            "    .",
            "",
            "    .program   #0:callee_A",
            "    fork(5)",
            "      #0.prop = 3;",
            "    endfork",
            "    .",
            "",
            "    .program   #0:caller_B",
            "    #0.prop = 1;",
            "    #0:callee_B();",
            "    #0.prop = 2;",
            "    .",
            "",
            "    .program   #0:callee_B",
            "    suspend(5);",
            "    #0.prop = 3;",
            "    .",
            "",
            "Consider `#0:caller_A', which calls `#0:callee_A'.  Such a task would assign 1 to `#0.prop', call `#0:callee_A', fork a new task, return to `#0:caller_A', and assign 2 to `#0.prop', ending this task.  Five seconds later, if the forked task had not been killed, then it would begin to run; it would assign 3 to `#0.prop' and then stop.  So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 3.",
            "",
            "Now consider `#0:caller_B', which calls `#0:callee_B' instead of `#0:callee_A'.  This task would assign 1 to `#0.prop', call `#0:callee_B', and suspend.  Five seconds later, if the suspended task had not been killed, then it would resume; it would assign 3 to `#0.prop', return to `#0:caller', and assign 2 to `#0.prop', ending the task. So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 2.",
            "",
            "A suspended task, like a forked task, can be described by the `queued_tasks()' function and killed by the `kill_task()' function. Suspending a task does not change its task id.  A task can be suspended again and again by successive calls to `suspend()'.",
            "",
            "Once `suspend()' has been used in a particular task, then the `read()' function will always raise E_PERM in that task.  For more details, see the description of `read()'.",
            "",
            "By default, there is no limit to the number of tasks any player may suspend, but such a limit can be imposed from within the database. See the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  task_id ()   => INT",
            "",
            "Returns the numeric identifier for the currently-executing task.  Such numbers are randomly selected for each task and can therefore safely be used in circumstances where unpredictability is required."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "ticks_left()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ticks_left ()   => INT",
            "       seconds_left ()   => INT",
            "",
            "These two functions return the number of ticks or seconds (respectively) left to the current task before it will be forcibly terminated.  These are useful, for example, in deciding when to fork another task to continue a long-lived computation."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  caller_perms ()   => obj",
            "",
            "Returns the permissions in use by the verb that called the currently-executing",
            "verb.  If the currently-executing verb was not called by another verb (i.e., it",
            "is the first verb called in a command or server task), then",
            "`caller_perms()' returns `#-1'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  set_task_perms (OBJ <player>)   => none",
            "",
            "Changes the permissions with which the currently-executing verb is running to be those of <player>.  If <player> is not of type OBJ, then E_INVARG is raised.  If the programmer is neither <player> nor a wizard, then E_PERM is raised.",
            "",
            "Note: This does not change the owner of the currently-running verb, only the permissions of this particular invocation.  It is used in verbs owned by wizards to make themselves run with lesser (usually non-wizard) permissions."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  eval (str <string>)   => list",
            "",
            "The MOO-code compiler processes <string> as if it were to be the program associated with some verb and, if no errors are found, that fictional verb is invoked.  If the programmer is not, in fact, a programmer, then E_PERM is raised.  The normal result of calling `eval()' is a two element list. The first element is true if there were no compilation errors and false otherwise.  The second element is either the result returned from the fictional verb (if there were no compilation errors) or a list of the compiler's error messages (otherwise).",
            "",
            "When the fictional verb is invoked, the various built-in variables have values as shown below:",
            "",
            "    player    the same as in the calling verb",
            "    this      #-1",
            "    caller    the same as the initial value of `this' in the calling verb",
            "",
            "    args      {}",
            "    argstr    \"\"",
            "",
            "    verb      \"\"",
            "    dobjstr   \"\"",
            "    dobj      #-1",
            "    prepstr   \"\"",
            "    iobjstr   \"\"",
            "    iobj      #-1",
            "",
            "The fictional verb runs with the permissions of the programmer and as if its `d' permissions bit were on.",
            "",
            "    eval(\"return 3 + 4;\")   =>   {1, 7}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  boot_player (obj <player>)   => none",
            "",
            "Immediately terminates any currently-active connection to the given <player>.  The connection will not actually be closed until the currently-running task returns or suspends, but all MOO functions (such as notify(), connected_players(), and the like) immediately behave as if the connection no longer exists. If the programmer is not either a wizard or the same as <player>, then `E_PERM' is returned.  If there is no currently-active connection to <player>, then this function does nothing.",
            "",
            "If there was a currently-active connection, then the following verb call is made when the connection is actually closed:",
            "",
            "$user_disconnected(player)",
            "",
            "It is not an error if this verb does not exist; the corresponding call is simply skipped."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  notify (OBJ conn, STR string [, no-flush]) => 0 or 1",
            "",
            "Enqueues <string> for output (on a line by itself) on the connection <conn>. If the programmer is not <conn> or a wizard, then E_PERM is raised. If <conn> is not a currently-active connection, then this function does nothing. Output is normally written to connections only between tasks, not during execution.",
            "",
            "The server will not queue an arbitrary amount of output for a connection; the `MAX_QUEUED_OUTPUT' compilation option (in `options.h') controls the limit. When an attempt is made to enqueue output that would take the server over its limit, it first tries to write as much output as possible to the connection without having to wait for the other end. If that doesn't result in the new output being able to fit in the queue, the server starts throwing away the oldest lines in the queue until the new output will fit. The server remembers how many lines of output it has `flushed' in this way and, when next it can succeed in writing anything to the connection, it first writes a line like `>> Network buffer overflow; X lines of output to you have been lost <<' where <X> is the number of of flushed lines.",
            "",
            "If <no-flush> is provided and true, then `notify()' never flushes any output from the queue; instead it immediately returns false. `Notify()' otherwise always returns true."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "connected_seconds()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connected_seconds (obj <player>)   => int",
            "              idle_seconds (obj <player>)   => int",
            "",
            "These functions return the number of seconds that the currently-active connection to <player> has existed and been idle, respectively.  If <player> is not the object number of a player object with a currently-active connection, then E_INVARG is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connected_players ([include-all])   => LIST",
            "",
            "Returns a list of the object numbers of those player objects with currently-active connections. If <include-all> is provided and true, includes the object numbers associated with all current connections, including those that are outbound and/or not yet logged-in."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  set_player_flag (OBJ <object>, <value>)   => none",
            "",
            "Confers or removes the ``player object'' status of the given <object>, depending upon the truth value of <value>.  If <object> is not valid, E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised.",
            "",
            "If <value> is true, then <object> gains (or keeps) \"player object\" status: it will be an element of the list returned by `players()', the expression `is_player(<object>)' will return true, and users can connect to <object> by name when they log into the server.",
            "",
            "If <value> is false, the <object> loses (or continues to lack) \"player object\" status: it will not be an element of the list returned by `players()', the expression `is_player(<object>)' will return false, and users cannot connect to <object> by name when they log into the server.  In addition, if a user is connected to <object> at the time that it loses ``player object'' status, then that connection is immediately broken, just as if `boot_player(<object>)' had been called (see the description of `boot_player()' below)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  is_player (OBJ <object>)   => INT",
            "",
            "Returns a true value if the given <object> is a player object and a false value otherwise.  If <object> is not valid, E_INVARG is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  players ()   => list",
            "",
            "Returns a list of the object numbers of all player objects in the database."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "verb_code()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_code (OBJ <object>, STR <verb-name> [, <fully-paren> [, <indent>]])   => LIST",
            "     set_verb_code (OBJ <object>, STR <verb-name>, LIST <code>)   => LIST",
            "",
            "These functions get and set (respectively) the MOO-code program associated with the verb named <verb-name> on <object>.  The program is represented as a list of strings, one for each line of the program; this is the kind of value returned by `verb_code()' and expected as the third argument to `set_verb_code()'.  For `verb_code()', the expressions in the returned code are usually written with the minimum-necessary parenthesization; if <fully-paren> is true, then all expressions are fully parenthesized. Also for `verb_code()', the lines in the returned code are usually not indented at all; if <indent> is true, each line is indented to better show the nesting of statements.",
            "",
            "If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_code()' (`set_verb_code()') raises E_PERM.  If the programmer is not, in fact, a programmer, then E_PERM is raised.",
            "",
            "For `set_verb_code()', the result is a list of strings, the error messages generated by the MOO-code compiler during processing of <code>.  If the list is non-empty, then `set_verb_code()' did not install <code>; the program associated with the verb in question is unchanged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  delete_verb (obj <object>, str <verb-name>)   => none",
            "",
            "Removes the verb named <verb-name> from the given <object>.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised. If <object> does not define a verb named <verb-name>, then E_VERBNF is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  add_verb (obj <object>, list <info>, list <args>)   => int",
            "",
            "Defines a new verb on the given <object>.  The new verb's owner, permission bits and name(s) are given by <info> in the same format as is returned by `verb_info()'.  The new verb's direct-object, preposition, and indirect-object specifications are given by <args> in the same format as is returned by `verb_args()'.  The new verb initially has the empty program associated with  it; this program does nothing but return an unspecified value.  ",
            "",
            "If <object> is not valid, or <info> does not specify a valid owner and well-formed permission bits and verb names, or <args> is not a legitimate syntax specification, then `E_INVARG' is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then `E_PERM' is raised.  Otherwise, this function returns a positive integer representing the new verb's index in this object's `verbs()' list.  "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "verb_args()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_args (OBJ <object>, STR <verb-name>)   => LIST",
            "     set_verb_args (OBJ <object>, STR <verb-name>, LIST <args>)   => none",
            "",
            "These two functions get and set (respectively) the direct-object, preposition, and indirect-object specifications for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_args()' (`set_verb_args()') raises E_PERM.  Verb args specifications have the following form:",
            "",
            "    {<dobj>, <prep>, <iobj>}",
            "",
            "where <dobj> and <iobj> are strings drawn from the set `\"this\"', `\"none\"', and `\"any\"', and <prep> is a string that is either `\"none\"', `\"any\"', or one of the prepositional phrases listed much earlier in the description of verbs in the first chapter.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'.  Note that for `set_verb_args()', <prep> must be only one of the prepositional phrases, not (as is shown in that table) a set of such phrases separated by `/' characters.  `Set_verb_args()' raises E_INVARG if any of the <dobj>, <prep>, or <iobj> strings is illegal.",
            "",
            "    verb_args($container, \"take\")",
            "                        =>   {\"any\", \"out of/from inside/from\", \"this\"}",
            "    set_verb_args($container, \"take\", {\"any\", \"from\", \"this\"})"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "verb_info()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_info (OBJ <object>, STR <verb-name>)   => LIST",
            "     set_verb_info (OBJ <object>, STR <verb-name>, LIST <info>)   => none",
            "",
            "These two functions get and set (respectively) the owner, permission bits, and name(s) for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised. If the programmer does not have read (write) permission on the verb in question, then `verb_info()' (`set_verb_info()') raises E_PERM.  Verb info has the following form:",
            "",
            "    {<owner>, <perms>, <names>}",
            "",
            "where <owner> is an object, <perms> is a string containing only characters from the set `r', `w', `x', and `d', and <names> is a string.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'. The latter function raises E_INVARG if <owner> is not valid, if <perms> contains any illegal characters, or if <names> is the empty string or consists entirely of spaces; it raises E_PERM if <owner> is not the programmer and the programmer is not a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verbs (OBJ <object>)   => LIST",
            "",
            "Returns a list of the names of the verbs defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  delete_property (obj <object>, str <prop-name>)   => none",
            "",
            "Removes the property named <prop-name> from the given <object> and all of its descendants.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised.  If <object> does not directly define a property named <prop-name> (as opposed to inheriting one from its parent), then `E_PROPNF' is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  add_property (obj <object>, str <prop-name>, <value>, list <info>)   => none",
            "",
            "Defines a new property on the given <object>, inherited by all of its descendants; the property is named <prop-name>, its initial value is <value>, and its owner and initial permission bits are given by <info> in the same format as is returned by `property_info()'. If <object> is not valid or <object> already has a property named <prop-name> or <info> does not specify a legitimate owner and permission bits, then E_INVARG is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "property_info()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  property_info (OBJ <object>, STR <prop-name>)   => LIST",
            "     set_property_info (OBJ <object>, STR <prop-name>, LIST <info>)   => none",
            "",
            "These two functions get and set (respectively) the owner and permission bits for the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `property_info()' (`set_property_info()') raises E_PERM.  Property info has the following form:",
            "",
            "    {<owner>, <perms> [, new-name]}",
            "",
            "where <owner> is an object and <perms> is a string containing only characters from the set `r', `w', and `c', and <new-name> is a string; <new-name> is never part of the value returned by `property_info()', but it may optionally be given as part of the value provided to `set_property_info()'.  This list is the kind of value returned by `property_info()' and expected as the third argument to `set_property_info()'; the latter function raises E_INVARG if <owner> is not valid or <perms> contains any illegal characters, or, when <new-name> is given, if <prop-name> is not defined directly on <object> or <new-name> names an existing property defined on <object> or any of its ancestors or descendants."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  properties (OBJ <object>)   => LIST",
            "",
            "Returns a list of the names of the properties defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  move (OBJ <what>, OBJ <where>)   => none",
            "",
            "Changes <what>'s location to be <where>.  This is a complex process because a number of permissions checks and notifications must be performed. The actual movement takes place as described in the following paragraphs.",
            "",
            "<what> should be a valid object and <where> should be either a valid object or `#-1' (denoting a location of 'nowhere'); otherwise E_INVARG is raised.  The programmer must be either the owner of <what> or a wizard; otherwise, E_PERM is raised.",
            "",
            "If <where> is a valid object, then the verb-call",
            "",
            "    <where>:accept(<what>)",
            "",
            "is performed before any movement takes place.  If the verb returns a false value and the programmer is not a wizard, then <where> is considered to have refused entrance to <what>; `move()' raises E_NACC.  If <where> does not define an `accept' verb, then it is treated as if it defined one that always returned false.",
            "",
            "If moving <what> into <where> would create a loop in the containment hierarchy (i.e., <what> would contain itself, even indirectly), then E_RECMOVE is raised instead.",
            "",
            "The `location' property of <what> is changed to be <where>, and the `contents' properties of the old and new locations are modified appropriately.  Let <old-where> be the location of <what> before it was moved.  If <old-where> is a valid object, then the verb-call",
            "",
            "    <old-where>:exitfunc(<what>)",
            "",
            "is performed and its result is ignored; it is not an error if <old-where> does not define a verb named `exitfunc'.  Finally, if <where> and <what> are still valid objects, and <where> is still the location of <what>, then the verb-call",
            "",
            "    <where>:enterfunc(<what>)",
            "",
            "is performed and its result is ignored; again, it is not an error if <where> does not define a verb named `enterfunc'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  max_object ()   => obj",
            "",
            "Returns the largest object number yet assigned to a created object.  Note that",
            "the object with this number may no longer exist; it may have been recycled.",
            "The next object created will be assigned the object number one larger than the",
            "value of `max_object()'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  recycle (OBJ <object>)   => none",
            "",
            "The given <object> is destroyed, irrevocably.  The programmer must either own <object> or be a wizard; otherwise, E_PERM is raised.  If <object> is not valid, then E_INVARG is raised.  The children of <object> are reparented to the parent of <object>.  Before <object> is recycled, each object in its contents is moved to `#-1' (implying a call to <object>'s `exitfunc' verb, if any) and then <object>'s `recycle' verb, if any, is called with no arguments.",
            "",
            "After <object> is recycled, if the owner of the former object has a property named `ownership_quota' and the value of that property is a number, then `recycle()' treats that value as a \"quota\" and increments it by one, storing the result back into the `ownership_quota' property."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "parent()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  parent (OBJ <object>)   => OBJ",
            "       children (OBJ <object>)   => LIST",
            "",
            "These functions return the parent and a list of the children of <object>, respectively.  If <object> is not valid, then E_INVARG is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  valid (OBJ <object>)   => INT",
            "",
            "Returns a non-zero integer (i.e., a true value) if <object> is a valid object (one that has been created and not yet recycled) and zero (i.e., a false value) otherwise.",
            "",
            "    valid(#0)    =>   1",
            "    valid(#-1)   =>   0"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  chparent (obj <object>, obj <new-parent>)   => none",
            "",
            "Changes the parent of <object> to be <new-parent>. If <object> is not valid, or if <new-parent> is neither valid nor equal to #-1, then E_INVARG is raised. If the programmer is neither a wizard or the owner of <object>, or if <new-parent> is not fertile (i.e., its `f' bit is not set) and the programmer is neither the owner of <new-parent> nor a wizard, then `E_PERM' is raised.  If <new-parent> is equal to <object> or one of its current ancestors, E_RECMOVE is raised. If <object> or one of its descendants defines a property with the same name as one defined either on <new-parent> or on one of its ancestors, then `E_INVARG' is returned.",
            "",
            "Changing an object's parent can have the effect of removing some properties from and adding some other properties to that object and all of its descendants (i.e., its children and its children's children, etc.).  Let <common> be the nearest ancestor that <object> and <new-parent> have in common before the parent of <object> is changed.  Then all properties defined by ancestors of <object> under <common> (that is, those ancestors of <object> that are in turn descendants of <common>) are removed from <object> and all of its descendants.  All properties defined by <new-parent> or its ancestors under <common> are added to <object> and all of its descendants.  As with `create()', the newly-added properties are given the same permission bits as they have on <new-parent>, the owner of each added property is either the owner of the object it's added to (if the `c' permissions bit is set) or the owner of that property on <new-parent>, and the value of each added property is \"clear\"; see the description of the built-in function `clear_property()' for details.  All properties that are not removed or added in the reparenting process are completely unchanged.",
            "",
            "If <new-parent> is equal to #-1, then <object> is given no parent at all; it becomes a new root of the parent/child hierarchy. In this case, all formerly inherited properties on <object> are simply removed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  create (obj <parent> [, obj <owner>])   => obj",
            "",
            "Creates and returns a new object whose parent is <parent> and whose owner is as described below.  Either the given <parent> object must be fertile (i.e., its `f' bit must be set) or else the programmer must own <parent> or be a wizard; otherwise `E_PERM' is raised. `E_PERM' is also raised if <owner> is provided and not the same as the programmer, unless the programmer is a wizard.  After the new object is created, its `initialize' verb, if any, is called with no arguments.",
            "",
            "The new object is assigned the least non-negative object number that has not yet been used for a created object.  Note that no object number is ever reused, even if the object with that number is recycled.",
            "",
            "The owner of the new object is either the programmer (if <owner> is not provided), the new object itself (if <owner> was given as `#-1'), or <owner> (otherwise).",
            "",
            "The other built-in properties of the new object are initialized as follows:",
            "    name         \"\"",
            "    location     #-1",
            "    contents     {}",
            "    programmer   0",
            "    wizard       0",
            "    r            0",
            "    w            0",
            "    f            0",
            "",
            "In addition, the new object inherits all of the other properties on <parent>.  These properties have the same permission bits as on <parent>.  If the `c' permissions bit is set, then the owner of the property on the new object is the same as the owner of the new object itself; otherwise, the owner of the property on the new object is the same as that on <parent>.  The initial value of every inherited property is \"clear\"; see the description of the built-in function `clear_property()' for details.",
            "",
            "",
            "If the intended owner of the new object has a property named `ownership_quota' and the value of that property is a number, then `create()' treats that value as a \"quota\".  If the quota is less than or equal to zero, then the quota is considered to be exhausted and `create()' raises `E_QUOTA' instead of creating an object. Otherwise, the quota is decremented and stored back into the `ownership_quota' property as a part of the creation of the new object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "setadd()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  setadd (LIST <list>, <value>)   => LIST",
            "      setremove (LIST <list>, <value>)   => LIST",
            "",
            "Returns a copy of <list> with the given <value> added or removed, as appropriate.  `Setadd()' only adds <value> if it is not already an element of <list>; <list> is thus treated as a mathematical set. <value> is added at the end of the resulting list, if at all.  Similarly, `setremove()' returns a list identical to <list> if <value> is not an element.  If <value> appears more than once in <list>, only the first occurrence is removed in the returned copy.",
            "",
            "    setadd({1, 2, 3}, 3)         =>   {1, 2, 3}",
            "    setadd({1, 2, 3}, 4)         =>   {1, 2, 3, 4}",
            "    setremove({1, 2, 3}, 3)      =>   {1, 2}",
            "    setremove({1, 2, 3}, 4)      =>   {1, 2, 3}",
            "    setremove({1, 2, 3, 2}, 2)   =>   {1, 3, 2}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listset (LIST <list>, <value>, INT <index>)   => LIST",
            "",
            "Returns a copy of <list> with the <index>th element replaced by <value>.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.",
            "",
            "    x = {\"foo\", \"bar\", \"baz\"};",
            "    listset(x, \"mumble\", 2)   =>   {\"foo\", \"mumble\", \"baz\"}",
            "",
            "This function exists primarly for historical reasons; it was used heavily before the server supported indexed assignments like x[i] = v. New code should always use indexed assignment instead of `listset()' wherever possible."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listdelete (LIST <list>, INT <index>)   => LIST",
            "",
            "Returns a copy of <list> with the <index>th element removed.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.",
            "",
            "    x = {\"foo\", \"bar\", \"baz\"};",
            "    listdelete(x, 2)   =>   {\"foo\", \"baz\"}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listinsert (LIST <list>, <value> [, INT <index>])   => list",
            "         listappend (LIST <list>, <value> [, INT <index>])   => list",
            "",
            "These functions return a copy of <list> with <value> added as a new element.  `listinsert()' and `listappend()' add <value> before and after (respectively) the existing element with the given <index>, if provided.",
            "",
            "The following three expressions always have the same value:",
            "",
            "    listinsert(<list>, <element>, <index>)",
            "    listappend(<list>, <element>, <index> - 1)",
            "    {@<list>[1..<index> - 1], <element>, @<list>[<index>..length(<list>)]}",
            "",
            "If <index> is not provided, then `listappend()' adds the <value> at the end of the list and `listinsert()' adds it at the beginning; this usage is discouraged, however, since the same intent can be more clearly expressed using the list-construction expression, as shown in the examples below.",
            "",
            "    x = {1, 2, 3};",
            "    listappend(x, 4, 2)   =>   {1, 2, 4, 3}",
            "    listinsert(x, 4, 2)   =>   {1, 4, 2, 3}",
            "    listappend(x, 4)      =>   {1, 2, 3, 4}",
            "    listinsert(x, 4)      =>   {4, 1, 2, 3}",
            "    {@x, 4}               =>   {1, 2, 3, 4}",
            "    {4, @x}               =>   {4, 1, 2, 3}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "listinsert()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  strcmp (STR <str1>, STR <str2>)   => INT",
            "",
            "Performs a case-sensitive comparison of the two argument strings.  If <str1> is lexicographically less than <str2>, the `strcmp()' returns a negative number.  If the two strings are identical, `strcmp()' returns zero.  Otherwise, `strcmp()' returns a positive number.  The ASCII character ordering is used for the comparison."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "index()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  index (STR <str1>, STR <str2> [, <case-matters>])   => INT",
            "        rindex (STR <str1>, STR <str2> [, <case-matters>])   => INT",
            "",
            "The function `index()' (`rindex()') returns the index of the first character of the first (last) occurrence of <str2> in <str1>, or zero if <str2> does not occur in <str1> at all.  By default the search for an occurrence of <str2> is done while ignoring the upper/lower case distinction.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.",
            "",
            "    index(\"foobar\", \"o\")        =>   2",
            "    rindex(\"foobar\", \"o\")       =>   3",
            "    index(\"foobar\", \"x\")        =>   0",
            "    index(\"foobar\", \"oba\")      =>   3",
            "    index(\"Foobar\", \"foo\", 1)   =>   0"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  crypt (str <text> [, str <salt>])   => str",
            "",
            "Encrypts the given <text> using the standard UNIX encryption method.  If provided, <salt> should be a two-character string for use as the extra encryption ``salt'' in the algorithm.  If <salt> is not provided, a random pair of characters is used.  In any case, the salt used is also returned as the first two characters of the resulting encrypted string.  ",
            "",
            "Aside from the possibly-random selection of the salt, the encryption algorithm is entirely deterministic.  In particular, you can test whether or not a given string is the same as the one used to produced a given piece of encrypted text; simply extract the first two characters of the encrypted text and pass the candidate string and those two characters to `crypt()'.  If the result is identical to the given encrypted text, then you've got a match.  ",
            "",
            "    crypt(\"foobar\")         =>   \"J3fSFQfgkp26w\"",
            "    crypt(\"foobar\", \"J3\")   =>   \"J3fSFQfgkp26w\"",
            "    crypt(\"mumble\", \"J3\")   =>   \"J3D0.dh.jjmWQ\"",
            "    crypt(\"foobar\", \"J4\")   =>   \"J4AcPxOJ4ncq2\"",
            "",
            "Note: As of version 1.8.3, the entire salt (of any length) is passed to the operating system's low-level crypt function.  It is unlikely, however, that all operating systems will return the same string when presented with a longer salt.  Therefore, identical calls to `crypt()' may generate different results on different platforms, and your password verification systems will fail.  Use a salt longer than two characters at your own risk."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  strsub (STR <subject>, STR <what>, STR <with> [, <case-matters>])   => STR",
            "",
            "Replaces all occurrences in <subject> of <what> with <with>, performing string substitution.  The occurrences are found from left to right and all substitutions happen simultaneously.  By default, occurrences of <what> are searched for while ignoring the upper/lower case distinction. If <case-matters> is provided and true, then case is treated as significant in all comparisons.",
            "",
            "    strsub(\"%n is a fink.\", \"%n\", \"Fred\")   =>   \"Fred is a fink.\"",
            "    strsub(\"foobar\", \"OB\", \"b\")             =>   \"fobar\"",
            "    strsub(\"foobar\", \"OB\", \"b\", 1)          =>   \"foobar\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  length (<list or string>)   => int",
            "",
            "Returns the number of characters in <list or string>.  ",
            "",
            "    length(\"foo\")       =>   3",
            "    length(\"\")          =>   0",
            "    length({1, 2, 3})   =>   3",
            "    length({})          =>   0"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ctime ([INT <time>])   => str",
            "",
            "Interprets <time> as a time, using the same representation as given in the description of `time()', and converts it into a 28-character, human-readable string in the following format:",
            "",
            "    Mon Aug 13 19:13:20 1990 PDT",
            "",
            "If the current day of the month is less than 10, then an extra blank appears between the month and the day:",
            "",
            "    Mon Apr  1 14:10:43 1991 PST",
            "",
            "If <time> is not provided, then the current time is used.",
            "",
            "Note that `ctime()' interprets <time> for the local time zone of the computer on which the MOO server is running."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  time ()   => INT",
            "",
            "Returns the current time, represented as the number of seconds that have elapsed since midnight on 1 January 1970, Greenwich Mean Time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  random ([INT <mod>])   => INT",
            "",
            "<Mod> must be a positive integer; otherwise, E_INVARG is raised.  An integer is chosen randomly from the range `[1..<mod>]' and returned. If <mod> is not provided, it defaults to the largest MOO integer, 2147483647."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  abs (num <x>)   => num",
            "",
            "Returns the absolute value of <x>.  If <x> is negative, then the result is `-<x>'; otherwise, the result is <x>. The number x can be either integer or floating-point; the result is of the same kind."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "min()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  min (num <x>, ...)   => num",
            "         max (num <x>, ...)   => num",
            "",
            "These two functions return the smallest or largest of their arguments, respectively.  All of the arguments must be numbers of the same kind (i.e., either integer or floating-point); otherwise E_TYPE is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  toobj (<value>)   => OBJ",
            "",
            "Converts the given MOO value into an object number and returns that object number.  The conversions are very similar to those for `toint()' except that for strings, the number *may* be preceded by `#'.",
            "",
            "    toobj(\"34\")       =>   #34",
            "    toobj(\"#34\")      =>   #34",
            "    toobj(\"foo\")      =>   #0",
            "    toobj({1, 2})     -error->   E_TYPE"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  toint (<value>)   => INT",
            "         tonum (<value>)   => INT",
            "",
            "Converts the given MOO value into an integer and returns that integer. Floating-point numbers are rounded toward zero, truncating their fractional parts. Object numbers are converted into the equivalent integers, strings are parsed as the decimal encoding of a real number which is then converted to an integer. Errors are converted into integers obeying the same ordering (with respect to `<=' as the errors themselves.) `Toint()' raises E_TYPE if <value> is a LIST.  If <value> is a string but the string does not contain a syntactically-correct number, then `toint()' returns 0.",
            "",
            "    toint(34.7)        =>   34",
            "    toint(-34.7)       =>   34",
            "    toint(#34)         =>   34",
            "    toint(\"34\")        =>   34",
            "    toint(\"34.7\")      =>   34",
            "    toint(\" - 34  \")   =>  -34",
            "    toint(E_TYPE)      =>    1"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  tostr (<value>, ...)   => STR",
            "",
            "Converts all of the given MOO values into strings and returns the concatenation of the results.",
            "",
            "    tostr(17)                  =>   \"17\"",
            "    tostr(1.0/3.0)             =>   \"0.333333333333333\"",
            "    tostr(#17)                 =>   \"#17\"",
            "    tostr(\"foo\")               =>   \"foo\"",
            "    tostr({1, 2})              =>   \"{list}\"",
            "    tostr(E_PERM)              =>   \"Permission denied\"",
            "    tostr(\"3 + 4 = \", 3 + 4)   =>   \"3 + 4 = 7\"",
            "",
            "Note that `tostr()' does not do a good job of converting lists into strings; all lists, including the empty list, are converted into the string `\"{list}\"'. The function `toliteral()' is better for this purpose."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  typeof (<value>)   => INT",
            "",
            "Takes any MOO value and returns a number representing the type of <value>. The result is the same as the initial value of one of these built-in variables: `INT', `FLOAT', `STR', `LIST', `OBJ', or `ERR'.  Thus, one usually writes code like this:",
            "",
            "    if (typeof(x) == LIST) ...",
            "",
            "and not like this:",
            "",
            "    if (typeof(x) == 4) ...",
            "",
            "because the former is much more readable than the latter."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  clear_property (OBJ <object>, STR <prop-name>)  => none",
            "      is_clear_property (OBJ <object>, STR <prop-name>)  => INT",
            "",
            "These two functions test for clear and set to clear, respectively, the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `is_clear_property()' (`clear_property()') raises E_PERM. If a property is clear, then when the value of that property is queried the value of the parent's property of the same name is returned.  If the parent's property is clear, then the parent's parent's value is examined, and so on. If <object> is the definer of the property <prop-name>, as opposed to an inheritor of the property, then `clear_property()' raises E_INVARG."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "clear_property()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  set_connection_option (OBJ conn, STR option, value)   => none",
            "",
            "Controls a number of optional behaviors associated the connection <conn>. Raises `E_INVARG' if <conn> does not specify a current connection and `E_PERM' if the programmer is neither <conn> nor a wizard. Unless otherwise specified below, options can only be set (<value> is true) or unset (otherwise). The following values for <option> are currently supported:  ",
            "",
            "\"binary\"",
            "   When set, the connection is in `binary mode', in which case both input from and output to <conn> can contain arbitrary bytes. Input from a connection in binary mode is not broken into lines at all; it is delivered to either the read() function or normal command parsing as `binary strings', in whatever size chunks come back from the operating system. (See the early section in the LambdaMOO Programmers Manual on MOO value types for a description of the binary string representation.) For output to a connection in binary mode, the second argument to `notify()' must be a binary string; if it is malformed, `E_INVARG' is raised.",
            "",
            "   Fine point: If the connection mode is changed at any time when there is pending input on the connection, said input will be delivered as per the previous mode (i.e., when switching out of binary mode, there may be pending ``lines'' containing tilde-escapes for embedded linebreaks, tabs, tildes and other characters; when switching into binary mode, there may be pending lines containing raw tabs and from which nonprintable characters have been silently dropped as per normal mode. Only during the initial invocation of `$do_login_command()' on an incoming connection or immediately after the call to `open_network_connection()' that creates an outgoing connection is there guaranteed not to be pending input. At other times you will probably want to flush any pending input immediately after changing the connection mode.",
            "",
            "\"hold-input\"",
            "   When set, no input received on <conn> will be treated as a command; instead, all input remains in the queue until retrieved by calls to `read()' or until this connection option is unset, at which point command processing resumes. Processing of out-of-band input lines is unaffected by this option.",
            "",
            "\"disable-oob\"",
            "   When set, disables all out of band processing. All subsequent input lines until the next command that unsets this option will be made available for reading tasks or normal command parsing exactly as if the out-of-band prefix and the out-of-band quoting prefix had not been defined for this server.",
            "",
            "\"client-echo\"",
            "   The setting of this option is of no significance to the server. However calling `set_connection_option()' for this option sends the Telnet Protocol `WONT ECHO' or `WILL ECHO' command, depending on whether <value> is true or false, respectively. For clients that support the Telnet Protocol, this should toggle whether or not the client echoes locally the characters typed by the user. Note that the server itself never echoes input characters under any circumstances. (This option is only available under the TCP/IP networking configurations.)",
            "",
            "\"flush-command\"",
            "   This option is string-valued. If <value> is a non-empty string, then it becomes the new `flush' command for this connection, by which the player can flush all queued input that has not yet been processed by the server. If the string is empty, then <conn> is set to have no flush command at all. `set_connection_option' also allows specifying a non-string <value> which is equivalent to specifying the empty string. The default value of this option can be set via the property `$server_options.default_flush_command'; see the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details.",
            "",
            "\"intrinsic-commands\"",
            "   This option value is a list of strings, each being the name of one of the available server intrinsic commands (see the section in the LambdaMOO Programmers Manual on Command Lines That Receive Special Treatment). Commands not on the list are disabled, i.e., treated as normal MOO commands to be handled by `$do_command' and/or the built-in command parser. `set_connection_option' also allows specifying an integer <value> which, if zero, is equivalent to specifying the empty list, and otherwise is taken to be the list of all available intrinsic commands (the default setting).  ",
            "",
            "   Thus, one way to make the verbname `PREFIX' available as an ordinary command is as follows:",
            "",
            "    set_connection_option(player, \"intrinsic-commands\",",
            "      setremove(connection_option(player, \"intrinsic-commands\"), \"PREFIX\"));",
            "",
            "   Note that `connection_option()' always returns the list, even if `set_connection_option' was previously called with a numeric value.  Thus,",
            "",
            "    save = connection_option(player,\"intrinsic-commands\");",
            "    set_connection_option(player, \"intrinsic-commands, 1);",
            "    full_list = connection_option(player,\"intrinsic-commands\");",
            "    set_connection_option(player,\"intrinsic-commands\", save);",
            "    return full_list;",
            "",
            "   is a way of getting the full list of intrinsic commands available in the server while leaving the current connection unaffected."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "queue_info([obj user])",
            "",
            "Returns the number of forked tasks that <user> has at the moment.  Since it doesn't say which tasks, security is not a significant issue.  If no argument is given, then gives a list of all users with task queues in the server.  (Essentially all connected players + all open connections + all users with tasks running in the background.)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  is_member (ANY value, LIST list)   => INT",
            "",
            "Returns true if there is an element of <list> that is completely indistinguishable from <value>. This is much the same operation as \"<value> in <list>\" except that, unlike `in', the `is_member()' function does not treat upper- and lower-case characters in strings as equal.",
            "",
            "Raises E_ARGS if two values are given or if more than two values are given. Raises E_TYPE if the second argument is not a list. Otherwise returns the index of <value> in <list>, or 0 if it's not in there.",
            "",
            "  is_member(3, {3, 10, 11})                 => 1",
            "  is_member(\"a\", {\"A\", \"B\", \"C\"})           => 0",
            "  is_member(\"XyZ\", {\"XYZ\", \"xyz\", \"XyZ\"})   => 3"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  equal(value1, value2)   => INT",
            "",
            "Returns true if <value1> is completely indistinguishable from <value2>. This is much the same operation as \"<value1> == <value2>\" except that, unlike ==, the `equal()' function does not treat upper- and lower-case characters in strings as equal.",
            "",
            "Raises E_ARGS if none, one, or more than two arguments are given.",
            "",
            "equal(1, 2)                   => 0",
            "equal(\"ChIcKeN\", \"chicken\")   => 0",
            "equal(\"ABC123\", \"ABC123\")     => 1"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  toliteral (<value>)   => STR",
            "",
            "Returns a string containing a MOO literal expression that, when evaluated, would be equal to <value>. If no arguments or more than one argument is given, E_ARGS is raised.",
            "",
            "Examples:",
            "toliteral(43)                       =>  \"43\"",
            "toliteral(1.0/3.0)                  =>  \"0.33333333333333\"",
            "toliteral(#17)                      =>  \"#17\"",
            "toliteral(E_PERM)                   =>  \"E_PERM\"",
            "toliteral({\"A\", \"B\", {\"C\", 123}})   =>  \"{\\\"A\\\", \\\"B\\\", {\\\"C\\\", 123}}\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  value_bytes(<value>)   => INT",
            "",
            "Returns the number of bytes of the server's memory required to store the given <value>."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  acos (FLOAT <x>)   => FLOAT",
            "",
            "Returns the arc-cosine (inverse cosine) of x, in the range [0..pi]. Raises E_INVARG if x is outside the range [-1.0..1.0]."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  asin (FLOAT <x>)   => FLOAT",
            "",
            "Returns the arc-sine (inverse sine) of x, in the range [-pi/2..pi/2]. Raises E_INVARG if x is outside the range [-1.0..1.0]."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  atan (FLOAT <y> [, FLOAT <x>])   => FLOAT",
            "",
            "Returns the arc-tangent (inverse tangent) of y in the range [-pi/2..pi/2] if x is not provided, or of y/x in the range [-pi..pi] if x is provided."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  binary_hash (STR bin-string)   => STR",
            "         string_hash (STR text)         => STR",
            "",
            "Returns a 32-character hexadecimal string encoding the result of applying the MD5 cryptographically secure hash function to the contents of the string `text' or the binary string `bin-string'. MD5, like other such functions, has the property that, if",
            "",
            "string_hash(x) == string_hash(y)",
            "",
            "then, almost certainly",
            "",
            "equal(x, y)",
            "",
            "This can be useful, for example, in certain networking applications:  after sending a large piece of text across a connection, also send across the result of applying string_hash() to the text; if the destination site also applies string_hash() to the text and gets the same result, you can be quite confident that the large text has arrived unchanged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "binary_hash()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  buffered_output_length ([OBJ conn])   => INT",
            "",
            "Returns the number of bytes currently buffered for output to the connection `conn'.  If conn is not provided, returns the maximum number of bytes that will be buffered up for output on any connection."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  call_function (STR func-name, arg, ...)   => value",
            "",
            "Calls the built-in function named `func-name', passing the given arguments, and returns whatever that function returns. Raises E_INVARG if func-name is not recognized as the name of a known built-in function. This allows you to compute the name of the function to call and, in particular, allows you to write a call to a built-in function that may or may not exist in the particular version of the server you're using."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ceil (FLOAT <x>)   => FLOAT",
            "",
            "Returns the smallest integer not less than x, as a floating-point number."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_options (OBJ conn)   => LIST",
            "",
            "Return a list of (<name>, <value>) pairs describing the current settings of all of the allowed options for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_option (OBJ conn, STR name)   => value",
            "",
            "Returns the current setting of the option <name> for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  cos (FLOAT x)   => FLOAT",
            "         sin (FLOAT x)   => FLOAT",
            "         tan (FLOAT x)   => FLOAT",
            "",
            "Returns the cosine, sine, or tangent of <x>, respectively."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "sin()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "sin()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  cosh (FLOAT x)   => FLOAT",
            "         sinh (FLOAT x)   => FLOAT",
            "         tanh (FLOAT x)   => FLOAT",
            "",
            "Returns the hyperbolic cosine, sine, or tangent of <x>, respectively."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "sinh()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "sinh()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  db_disk_size()   => INT",
            "",
            "Returns the total size, in bytes, of the most recent full representation of the database as one or more disk files. Raises E_QUOTA if, for some reason, no such on-disk representation is currently available."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  decode_binary (STR bin-string [, fully])   => LIST",
            "",
            "Returns a list of strings and/or integers representing the bytes in the binary string <bin-string> in order. If <fully> is false or omitted, the list contains an integer only for each non-printing, non-space byte; all other characters are grouped into the longest possible contiguous substrings. If <fully> is proved and true, the list contains only integers, one for each byte represented in <bin-string>. Raises E_INVARG if <bin-string> is not a properly-formed binary string. (See the LambdaMOO programmer's manual on MOO value types for a full description of binary strings.)",
            "",
            "decode_binary(\"foo\")               =>  {\"foo\"}",
            "decode_binary(\"~~foo\")             =>  {\"~foo\"}",
            "decode_binary(\"foo~0D~0A\")         =>  {\"foo\", 13, 10}",
            "decode_binary(\"foo~0Abar~0Abaz\")   =>  {\"foo\", 10, \"bar\", 10, \"baz\"}",
            "decode_binary(\"foo~0D~0A\", 1)      =>  {102, 111, 111, 13, 10}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  disassemble (OBJ object, STR verb-desc)   => LIST",
            "",
            "Returns a (longish) list of strings giving a listing of the server's internal \"compiled\" form of the verb as specified by <verb-desc> on <object>. This format may indeed change from release to release, but some programmers may nonetheless find the output of `disassemble()' interesting to peruse as a way to gain a deeper appreciation of how the server works.",
            "",
            "If <object> is not valid, then E_INVARG is raised. If <object> does not define a verb as specified by <verb-desc>, then E_VERBNF is raised. If the programmer does not have read permission on the verb in question, then disassemble() raises E_PERM.",
            "",
            "Each line of output roughly follows the form: <frame number>: <opcode byte> <opcode arguments (if any)> <ticks?> <human readable opcode mnemonic and arguments>",
            "",
            "For example:",
            "",
            "1: 004 000 022\t* FORK_NAMED 0 foo",
            "\t1: Frame number",
            "\t2. Opcode byte 4",
            "\t3. ARGUMENT 1: Forked vector number to switch to.",
            "\t4. ARGUMENT 2: Reference to the fork's label.",
            "\t5. *, indicating that the tick counter will be decremented.",
            "\t6. The human readable name of the opcode.",
            "\t7. ARGUMENT 1: The forked vector number to switch to.",
            "\t8. ARGUMENT 2: The name of the fork's label."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  encode_binary(arg, ...)   => STR",
            "",
            "Each argument must be an integer between 0 and 255, a string, or a list containing only legal arguments for this function. This function translates each integer and string in turn into its binary string equivalent, returning the concatenation of all these substrings into a single binary string. (See the early sections in the LambdaMOO Programmer's Manual on MOO value types for a full description of binary strings.)",
            "",
            "encode_binary(\"~foo\")                     =>  \"~7Efoo\"",
            "encode_binary({\"foo\", 10}, {\"bar\", 13})   =>  \"foo~0Abar~0D\"",
            "encode_binary(\"foo\", 10, \"bar\", 13)       =>  \"foo~0Abar~0D\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  exp (FLOAT x)   => FLOAT",
            "",
            "Returns `e' raised to the power of <x>."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  floatstr (FLOAT x, INT precision [, scientific])   => STR",
            "",
            "Converts <x> into a string with more control than provided by either `tostr()' or `toliteral()'. <Precision> is the number of digits to appear to the right of the decimal point, capped at 4 more than the maximum available precision, a total of 19 on most machines; this makes it possible to avoid rounding errors if the resulting string is subsequently read back as a floating-point value. If <scientific> is false or not provided, the result is a string in the form \"MMMMMMM.DDDDDD\", preceded by a minus sign if and only if <x> is negative. If <scientific> is provided and true, the result is a string in the form \"M.DDDDDDe+EEE\", again preceded by a minus sign if and only if <x> is negative."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  floor (FLOAT x)   => FLOAT",
            "",
            "Returns the largest integer not greater than x, as a floating-point number."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  flush_input (OBJ conn [, show-messages])   => none",
            "",
            "Performs the same actions as if the connection <conn>'s definied flush command had been received on that connection, i.e., removes all pending lines of input from <conn>'s queue and, if <show-messages> is provided and true, prints a messages to <conn> listing the flushed lines, if any.  See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for more information about a connection's defined flush command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  force_input (OBJ conn, STR line [, at-front])   => none",
            "",
            "Inserts the string <line> as an input task in the queue for the connection <conn>, just as if it had arrived as input over the network. If <at-front> is provided and true, then the new line of input is put at the front of <conn>'s queue, so that it will be the very next line of input processed even if there is already some other input in that queue. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  function_info ([STR name])   => LIST",
            "",
            "Returns descriptions of the various built-in functions available on the server. If <name> is provided, only the description of the function with that name is returned. If <name> is omitted, a list of descriptions is returned, one for each function available on the server. E_INVARG is raised if <name> is provided but no function with that name is available on the server.",
            "",
            "Each function description is a list of the following form:",
            "",
            "  {<name>, <min-args>, <max-args>, <types>}",
            "",
            "where <name> is the name of the built-in function, <min-args> is the minimum number of arguments that must be to the function, <max-args> is the maximum number of arguments that can be provided to the function or -1 if there is no maximum, and <types> is a list of <max-args> integers (or <min-args> if <max-args> is -1), each of which represents the type of argument required in the corresponding position. Each type number is as would be returned from the `typeof()' built-in function except that -1 indicates that any type of value is acceptable and -2 indicates that either integers or floating-point numbers may be given. For example, here are several entries from the list:",
            "",
            "  {\"listdelete\", 2, 2, {4, 0}}",
            "  {\"suspend\", 0, 1, {0}}",
            "  {\"server_log\", 1, 2, {2, -1}}",
            "  {\"max\", 1, -1, {-2}}",
            "  {\"tostr\", 0, -1, {}}",
            "",
            "`Listdelete()' takes exactly 2 arguments, of which the first must be a list (LIST == 4) and the second must be an integer (INT == 0). `Suspend()' has one optional argument that, if provided, must be an integer. `Server_log()' has one required argument that must be a string (STR == 2) and one optional argument that, if provided, may be of any type. `Max()' requires at least one argument but can take any number above that, and the first argument must be either an integer or a floating-point number; the type(s) required for any other arguments can't be determined from this description. Finally, `tostr()' takes any number of arguments at all, but it can't be determined from this description which argument types would be acceptable in which positions."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listen (OBJ object, point [, print-messages, use_ipv6])   => value",
            "",
            "Create a new point at which the server will listen for network connections, just as it does normally. <Object> is the object whose verbs `do_login_command', `do_command', `do_out_of_band_command', `user_connected', `user_created', `user_reconnected', `user_disconnected', and `user_client_disconnected' will be called at appropriate points asthese verbs are called on #0 for normal connections. (See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for the complete story on when these functions are called.) <Point> is a network-configuration-specific parameter describing the listening point. If <print-messages> is provided and true, then the various database-configurable messages (also detailed in the chapter on server assumptions) will be printed on connections received at the new listening point. `Listen()' returns <canon>, a `canonicalized' version of <point>, with any configuration-specific defaulting or aliasing accounted for.",
            "",
            "This raises E_PERM if the programmer is not a wizard, E_INVARG if <object> is invalid or there is already a listening point described by <point>, and E_QUOTA if some network-configuration-specific error occurred.",
            "",
            "For the TCP/IP configurations, <point> is a TCP port number on which to listen and <canon> is equal to <point> unless <point> is zero, in which case <canaon> is a port number assigned by the operating system.",
            "",
            "For the local multi-user configurations, <point> is the UNIX file name to be used as the connection point and <canon> is always equal to <point>.",
            "",
            "In the single-user configuration, there can be only one listening point at a time; <point> can be any value at all and <canon> is always zero.",
            "",
            "If <use_ipv6> is true, the connection will listen on the IPv6 interface.  "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listeners ([<obj>])  => LIST",
            "",
            "Returns a list of maps describing all existing listening points, including the default one set up automatically by the server when it was started (unless that one has since been destroyed by a call to `unlisten()'). Each element of the list has the following keys:",
            "",
            "[<object>, <port>, <print-messages>, <ipv6>]",
            "",
            "where <object> is the first argument given in the call to `listen()' to create this listening point, <print-messages> is true if the third argument in that call was provided and true, <ipv6> is true if the connection is listening on the IPv6 interface, and <port> was the value returned by that call. (For the initial listening point, <object> is #0, <port> is determined by the command-line arguments or a network-configuration-specific default, and <print-messages> is true.)",
            "",
            "An optional argument, <obj>, can be supplied to filter the list of listeners by that object only."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  log (FLOAT x)     => FLOAT",
            "         log10 (FLOAT x)   => FLOAT",
            "",
            "Returns the natural or base 10 logarithm of <x>. Raises E_INVARG if <x> is not positive."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "log()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  object_bytes (OBJ object)   => INT",
            "",
            "Returns the number of bytes of the server's memory required to store the given <object>, including the space used by the values of all its non-clear properties and by the verbs and properties defined directly on the object. Raises E_INVARG if <object> is not a valid object and E_PERM if the programmer is not a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  raise (code [, STR message [, value]])   => none",
            "",
            "Raises <code> as an error in the same way as other MOO expressions, statements, and functions do. <Message>, which defaults to the value `tostr(<code>)', and <value>, which defaults to zero, are made available to any `try-except' statements to catch the error. If the error is not caught, then <message> will appear on the first line of the traceback printed to the user."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  resume (INT task-id [, value])   => none",
            "",
            "Immediately ends the suspension of the suspended task with the given <task-id>; that task's call to `suspend()' will return <value>, which defaults to zero. `Resume()' raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  task_stack (INT task-id [, include-line-numbers])  => LIST",
            "",
            "Returns information like that returned by the `callers()' function, but for the suspended task with the given <task-id>; the <include-line-numbers> argument has the same meaning as in `callers()'. Raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  tofloat (value)   => FLOAT",
            "",
            "Converts the given MOO value into a floating-point number and returns that number. Integers and objects numbers are converted into the corresponding integral floating-point numbers. Strings are parsed as the decimal encoding of a real number which is then represented as closely as possible as a floating-point number. Errors are first converted to integers as in `toint()' and then converted as integers are. `Tofloat()' raises E_TYPE if <value> is a LIST. If <value> is a string but the string does not contain a syntactically-correct number, then `tofloat()' raises E_INVARG.",
            "",
            "  tofloat(34)       =>  34.0",
            "  tofloat(#34)      =>  34.0",
            "  tofloat(\"34\")     =>  34.0",
            "  tofloat(\"34.7\")   =>  34.7",
            "  tofloat(E_TYPE)   =>  1.0"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "tonum()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  trunc (FLOAT <x>)   => FLOAT",
            "",
            "Returns the integer obtained by truncating <x> at the decimal point, as a floating-point number. For negative <x>, this is equivalent to `ceil()'; otherwise, it is equivalent to `floor()'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  unlisten (<canon>)   => none",
            "",
            "Stop listening for connections on the point described by <canon>, which should be the second element of some element of the list returned by `listeners()'. Raises E_PERM if the programmer is not a wizard and E_INVARG if there does not exist a listener with that description."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  value_hash (<value>)   => STR",
            "",
            "Returns the same string as `string_hash(toliteral(<value>))'; see the description of `string_hash()' for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  load_server_options ()   => none",
            "",
            "After modifying properties on $server_options, wizards must call `load_server_options()'.  Changes made may not take effect until this function is called.  This allows the server to cache option values internally; this significantly speeds up built-in function invocation.  If the programmer is not a wizard, then E_PERM is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_cache_stats ()   => LIST",
            "         log_cache_stats ()    => none",
            "",
            "As of version 1.8.1, the server caches verbname-to-program lookups to improve performance.  These functions respectively return or write to the server log file the current cache statistics.  For `verb_cache_stats' the return value will be a list of the form",
            "",
            "    {<hits>, <negative_hits>, <misses>, <table_clears>, <histogram>}",
            "",
            "though this may change in future server releases.  The cache is invalidated by any builtin function call that may have an effect on verb lookups (e.g., `delete_verb()')."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "verb_cache_stats()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "builtin-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Builtin Function Help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "A help database (in the sense of anything that is usable by $player:help()) is any object having the following two verbs:",
            "",
            "  :find_topics(string)",
            "     returns a list of strings or some boolean false value.",
            "",
            "  :get_topic(string)",
            "     given one of the strings returned by :find_topics this either",
            "     returns a list of strings (text to be spewed to the player) or",
            "     returns 1 to indicate that it has already taken care of printing",
            "     information to the player.",
            "",
            "$player:help() consults any .help properties that exist on the player, its ancestors, player.location and its ancestors (in that order).  These properties are assumed to have values that are objects or lists of objects, each object itself assumed to be a help database in the above sense.  The main help database ($help) is placed at the end of the list of databases to be consulted.",
            "",
            "The Generic Help Database (this object) is the standard model help database of which the actual help database itself ($help) is an instance.  On help databases of this type, every help topic has a corresponding property, interpreted as follows:",
            "",
            "this.(topic) = string           - one-line help text.",
            "this.(topic) = {\"*verb*\",@args} - call this:verb(@args) to get text",
            "this.(topic) = any other list   - multi-line help text",
            "",
            "For the {\"*verb*\",...} form, the current verbs available are",
            "",
            "  {\"*forward*\", topic2, @rest}   ",
            "     - get topic2 help text and then append rest.  ",
            "       rest may, in turn, begin with a \"*verb*\"...",
            "",
            "  {\"*subst*\", @lines} ",
            "     - all occurences of %[exp] in lines are replaced with value of exp.  ",
            "       exp is assumed to evaluate to a string.  Evaluation is done using ",
            "       $no_one's permissions so exp can only refer to public information.",
            "",
            "  {\"*index*\"}",
            "     - returns a list of all topics in this database, arranged in columns."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            107206,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "29": {
      "id": 29,
      "name": "New-Prog-Log",
      "flags": 0,
      "owner": 2,
      "location": 46,
      "parents": [
        45
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_notify = {player};",
            "player:set_current_message(this, 0, 0, 1);",
            "this.moderated = 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "receive_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "if (!this:is_writable_by(caller_perms()))",
            "return E_PERM;",
            "else",
            "if (msgs = this.messages)",
            "new = msgs[$][1] + 1;",
            "else",
            "new = 1;",
            "endif",
            "if (rmsgs = this.messages_going)",
            "lbrm = rmsgs[$][2];",
            "new = max(new, lbrm[$][1] + 1);",
            "endif",
            "m = args[1];",
            "if (index(m[4], \"@programmer \") == 1)",
            "m = {m[1], toobj(args[2]), o = $mail_agent:parse_address_field(m[4])[1], o.name};",
            "endif",
            "this.messages = {@msgs, {new, m}};",
            "this.last_msg_date = m[1];",
            "this.last_used_time = time();",
            "return new;",
            "endif"
          ]
        },
        {
          "name": "display_seq_headers display_seq_full",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "\":display_seq_headers(msg_seq[,cur])\";",
            "\":display_seq_full(msg_seq[,cur]) => {cur}\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{msg_seq, ?cur = 0, ?read_date = $maxint} = args;",
            "last = ldate = 0;",
            "player:tell(\"       WHEN           \", $string_utils:left(this.keyword, -30), \"BY\");",
            "for x in (msgs = this:messages_in_seq(args[1]))",
            "msgnum = $string_utils:right(last = x[1], 4, (cur == x[1]) ? \">\" | \" \");",
            "ldate = x[2][1];",
            "if (typeof(x[2][2]) != OBJ)",
            "hdr = this:msg_summary_line(@x[2]);",
            "else",
            "if (ldate < (time() - 31536000))",
            "c = player:ctime(ldate);",
            "date = c[5..11] + c[21..25];",
            "else",
            "date = player:ctime(ldate)[5..16];",
            "endif",
            "hdr = tostr(ctime(ldate)[5..16], \"   \", $string_utils:left(tostr(x[2][4], \" (\", x[2][3], \")\"), 30), valid(w = x[2][2]) ? w.name | \"??\", \" (\", x[2][2], \")\");",
            "endif",
            "player:tell(msgnum, (ldate > read_date) ? \":+ \" | \":  \", hdr);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (verb == \"display_seq_full\")",
            "return {last, ldate};",
            "else",
            "player:tell(\"----+\");",
            "endif"
          ]
        },
        {
          "name": "from_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "\":from_msg_seq(object or list[,mask])\";",
            "\" => msg_seq of messages from any of these senders\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{plist, ?mask = {1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "i = 1;",
            "fseq = {};",
            "for msg in (this.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "if (msg[2][2] in plist)",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "to_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "\":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{plist, ?mask = {1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "i = 1;",
            "fseq = {};",
            "for msg in (this.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "if (msg[2][3] in plist)",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return fseq || (\"%f %<has> no messages about @programmer'ing \" + $string_utils:english_list(plist, \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%to_msg_seq subject_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "\":%to_msg_seq/subject_msg_seq(string or list of strings[,mask])\";",
            "\" => msg_seq of messages containing one of strings in the to line\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "{nlist, ?mask = {1}} = args;",
            "if (typeof(nlist) != LIST)",
            "nlist = {nlist};",
            "endif",
            "i = 1;",
            "fseq = {};",
            "for msg in (this.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "if (msg[2][4] in nlist)",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return fseq || (\"%f %<has> no messages about @programmer'ing \" + $string_utils:english_list(nlist, \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%from_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 29,
          "code": [
            "return this.name + \" doesn't understand %%from:\";"
          ]
        }
      ],
      "propnames": [
        "keyword"
      ],
      "propdefs": [
        {
          "value": "PROGRAMMER",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            [
              0,
              [
                [
                  1,
                  [
                    1541028136,
                    2,
                    98,
                    "Anti-Wizard"
                  ]
                ]
              ]
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1541028136,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "New-Prog-Log",
            "New_Prog_Log",
            "NPL"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "Record of who's been made a @programmer.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            9347,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "30": {
      "id": 30,
      "name": "Generic Help Database",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        60,
        44,
        28,
        23,
        22,
        19,
        84,
        85,
        92,
        101,
        116,
        86
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find_topics",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"WIZARDLY\";",
            "if (args)",
            "\"...check for an exact match first...\";",
            "search = args[1];",
            "if (`$object_utils:has_property(parent(this), search) ! ANY')",
            "if ($object_utils:has_property(this, \" \" + search))",
            "return {search};",
            "endif",
            "elseif ($object_utils:has_property(this, search))",
            "return {search};",
            "endif",
            "\"...search for partial matches, allowing for\";",
            "\"...confusion between topics that do and don't start with @, and\";",
            "\".. confusion between - and _ characters.\";",
            "props = properties(this);",
            "topics = {};",
            "if (search[1] == \"@\")",
            "search = search[2..$];",
            "endif",
            "search = strsub(search, \"-\", \"_\");",
            "if (!search)",
            "\"...don't try searching for partial matches if the string is empty or @\";",
            "\"...we'd get *everything*...\";",
            "return {};",
            "endif",
            "for prop in (props)",
            "if (((i = index(strsub(prop, \"-\", \"_\"), search)) == 1) || ((i == 2) && index(\" @\", prop[1])))",
            "topics = {@topics, (prop[1] == \" \") ? prop[2..$] | prop};",
            "endif",
            "endfor",
            "return topics;",
            "else",
            "\"...return list of all topics...\";",
            "props = setremove(properties(this), \"\");",
            "for p in (`$object_utils:all_properties(parent(this)) ! ANY => {}')",
            "if (i = (\" \" + p) in props)",
            "props = {p, @listdelete(props, i)};",
            "endif",
            "endfor",
            "return props;",
            "endif"
          ]
        },
        {
          "name": "get_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"WIZARDLY\";",
            "{topic, ?dblist = {}} = args;",
            "if (`$object_utils:has_property(parent(this), topic) ! ANY')",
            "text = `this.(\" \" + topic) ! ANY';",
            "else",
            "text = `this.(topic) || this.(\" \" + topic) ! ANY';",
            "endif",
            "if (typeof(text) == LIST)",
            "if (text && (text[1] == ((\"*\" + (vb = strsub(text[1], \"*\", \"\"))) + \"*\")))",
            "text = `this:(vb)(listdelete(text, 1), dblist) ! ANY';",
            "endif",
            "endif",
            "return text;"
          ]
        },
        {
          "name": "sort_topics",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\":sort_topics(list_of_topics) -- sorts the given list of strings, assuming that they're help-system topic names\";",
            "buckets = \"abcdefghijklmnopqrstuvwxyz\";",
            "keys = names = $list_utils:make(length(buckets) + 1, {});",
            "for name in (setremove(args[1], \"\"))",
            "key = index(\".@\", name[1]) ? name[2..$] + \" \" | name;",
            "k = index(buckets, key[1]) + 1;",
            "bucket = keys[k];",
            "i = $list_utils:find_insert(bucket, key);",
            "keys[k] = listinsert(bucket, key, i);",
            "names[k] = listinsert(names[k], name, i);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return $list_utils:append(@names);"
          ]
        },
        {
          "name": "columnize",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\":columnize(@list_of_strings) -- prints the given list in a number of columns wide enough to accomodate longest entry. But no more than 4 columns.\";",
            "longest = $list_utils:longest(args);",
            "for d in ({4, 3, 2, 1})",
            "if ((79 / d) >= length(longest))",
            "return $string_utils:columnize_suspended(0, args, d);",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "forward pass",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"{\\\"*forward*\\\", topic, @rest}  => text for topic from this help db.\";",
            "\"{\\\"*pass*\\\",    topic, @rest}  => text for topic from next help db.\";",
            "\"In both cases the text of @rest is appended.  \";",
            "\"@rest may in turn begin with a *<verb>*\";",
            "{text, ?dblist = {}} = args;",
            "if (verb == \"forward\")",
            "first = this:get_topic(text[1], dblist);",
            "elseif ((result = $code_utils:help_db_search(text[1], dblist)) && ((db = result[1]) != $ambiguous_match))",
            "first = db:get_topic(result[2], dblist[(db in dblist) + 1..$]);",
            "else",
            "first = {};",
            "endif",
            "if (2 <= length(text))",
            "if (text[2] == ((\"*\" + (vb = strsub(text[2], \"*\", \"\"))) + \"*\"))",
            "return {@first, @`this:(vb)(text[3..$], dblist) ! ANY => {}'};",
            "else",
            "return {@first, @text[2..$]};",
            "endif",
            "else",
            "return first;",
            "endif"
          ]
        },
        {
          "name": "subst",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"{\\\"*subst*\\\", @text} => text with the following substitutions:\";",
            "\"  \\\"...%[expr]....\\\" => \\\"...\\\"+value of expr (assumed to be a string)+\\\"....\\\"\";",
            "\"  \\\"%;expr\\\"         => @(value of expr (assumed to be a list of strings))\";",
            "newlines = {};",
            "for old in (args[1])",
            "new = \"\";",
            "bomb = 0;",
            "while ((prcnt = index(old, \"%\")) && (prcnt < length(old)))",
            "new = new + old[1..prcnt - 1];",
            "code = old[prcnt + 1];",
            "old = old[prcnt + 2..$];",
            "if (code == \"[\")",
            "prog = \"\";",
            "while ((b = index(old + \"]\", \"]\")) > (p = index(old + \"%\", \"%\")))",
            "prog = (prog + old[1..p - 1]) + old[p + 1];",
            "old = old[p + 2..$];",
            "endwhile",
            "prog = prog + old[1..b - 1];",
            "old = old[b + 1..$];",
            "value = $no_one:eval_d(prog);",
            "if (value[1])",
            "new = tostr(new, value[2]);",
            "else",
            "new = tostr(new, toliteral(value[2]));",
            "bomb = 1;",
            "endif",
            "elseif ((code != \";\") || new)",
            "new = (new + \"%\") + code;",
            "else",
            "value = $no_one:eval_d(old);",
            "if (value[1] && (typeof(r = value[2]) == LIST))",
            "newlines = {@newlines, @r[1..$ - 1]};",
            "new = tostr(r[$]);",
            "else",
            "new = tostr(new, toliteral(value[2]));",
            "bomb = 1;",
            "endif",
            "old = \"\";",
            "endif",
            "endwhile",
            "if (bomb)",
            "newlines = {@newlines, new + old, tostr(\"@@@ Helpfile alert:  Previous line is messed up; notify \", this.owner.wizard ? \"\" | tostr(this.owner.name, \" (\", this.owner, \") or \"), \"a wizard. @@@\")};",
            "else",
            "newlines = {@newlines, new + old};",
            "endif",
            "endfor",
            "return newlines;"
          ]
        },
        {
          "name": "index",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"{\\\"*index*\\\" [, title]}\";",
            "\"This produces a columnated list of topics in this help db, headed by title.\";",
            "$command_utils:suspend_if_needed(0);",
            "title = args[1] ? args[1][1] | tostr(this.name, \" (\", this, \")\");",
            "su = $string_utils;",
            "return {\"\", title, su:from_list($list_utils:map_arg(su, \"space\", su:explode(title), \"-\"), \" \"), @this:columnize(@this:sort_topics(this:find_topics()))};"
          ]
        },
        {
          "name": "initialize",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "pass(@args);",
            "if ($perm_utils:controls(caller_perms(), this))",
            "this.r = 1;",
            "this.f = 0;",
            "endif"
          ]
        },
        {
          "name": "verbdoc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"{\\\"*verbdoc*\\\", \\\"object\\\", \\\"verbname\\\"}  use documentation for this verb\";",
            "set_task_perms(this.owner);",
            "if (!valid(object = $string_utils:match_object(args[1][1], player.location)))",
            "return E_INVARG;",
            "elseif (!(hv = $object_utils:has_verb(object, vname = args[1][2])))",
            "return E_VERBNF;",
            "else",
            "return $code_utils:verb_documentation(hv[1], vname);",
            "endif"
          ]
        },
        {
          "name": "dump_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "try",
            "text = this.(fulltopic = args[1]);",
            "return {tostr(\";;\", $code_utils:corify_object(this), \".(\", toliteral(fulltopic), \") = $command_utils:read_lines()\"), @$command_utils:dump_lines(text)};",
            "except error (ANY)",
            "return error[1];",
            "endtry"
          ]
        },
        {
          "name": "objectdoc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\"{\\\"*objectdoc*\\\", \\\"object\\\"} => text for topic from object:help_msg\";",
            "if (!valid(object = $string_utils:literal_object(args[1][1])))",
            "return E_INVARG;",
            "elseif (!($object_utils:has_verb(object, \"help_msg\") || $object_utils:has_property(object, \"help_msg\")))",
            "return E_VERBNF;",
            "else",
            "return $code_utils:verb_or_property(object, \"help_msg\");",
            "endif"
          ]
        },
        {
          "name": "find_index_topics",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 30,
          "code": [
            "\":find_index_topic([search])\";",
            "\"Return the list of index topics of this help DB\";",
            "\"(i.e., those which contain an index (list of topics)\";",
            "\"this DB, return it, otherwise return false.\";",
            "\"If search argument is given and true,\";",
            "\"we first remove any cached information concerning index topics.\";",
            "{?search = 0} = args;",
            "if (this.index_cache && (!search))",
            "\"...make sure every topic listed in .index_cache really is an index topic\";",
            "for p in (this.index_cache)",
            "if (!(\"*index*\" in `this.(p) ! ANY => {}'))",
            "search = 1;",
            "endif",
            "endfor",
            "if (!search)",
            "return this.index_cache;",
            "endif",
            "elseif ($generic_help == this)",
            "return {};",
            "endif",
            "itopics = {};",
            "for p in (properties(this))",
            "if ((h = `this.(p) ! ANY') && (\"*index*\" in h))",
            "itopics = {@itopics, p};",
            "endif",
            "endfor",
            "this.index_cache = itopics;",
            "return itopics;"
          ]
        }
      ],
      "propnames": [
        "index",
        "index_cache"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Help Database"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "A help database of the standard form in need of a description. See `help $generic_help'...",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            13690,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "31": {
      "id": 31,
      "name": "Generic Guest",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        88
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "boot",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (!caller_perms().wizard)",
            "return;",
            "endif",
            "player = this;",
            "this:notify(tostr(\"Sorry, but you've been here for \", $string_utils:from_seconds(connected_seconds(this)), \" and someone else wants to be a guest now.  Feel free to come back\", @$login:player_creation_enabled(player) ? {\" or even create your own character if you want...\"} | {\" or type `create' to learn more about how to get a character of your own.\"}));",
            "\"boot_player(this)\";",
            "return;",
            "\"See #0:user_reconnected.\";"
          ]
        },
        {
          "name": "disfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))",
            "return E_PERM;",
            "endif",
            "\"Don't let another guest use this one until all this is done. See :defer, Ho_Yan 1/19/94\";",
            "this.free_to_use = 0;",
            "this:log_disconnect();",
            "this:erase_paranoid_data();",
            "try",
            "if (this.location != this.home)",
            "this:room_announce(player.name, \" has disconnected.\");",
            "this:room_announce($string_utils:pronoun_sub($housekeeper.take_away_msg, this, $housekeeper));",
            "move(this, this.home);",
            "this:room_announce($string_utils:pronoun_sub($housekeeper.drop_off_msg, this, $housekeeper));",
            "endif",
            "finally",
            "this:do_reset();",
            "this.free_to_use = 1;",
            "endtry"
          ]
        },
        {
          "name": "defer",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "\"Called by #0:connect_player when this object is about to be used as the next guest character.  Usually returns `this', but if for some reason some other guest character should be used, that player object is returned instead\";",
            "if (!caller_perms().wizard)",
            "\"...caller is not :do_login_command; doesn't matter what we return...\";",
            "return this;",
            "elseif ($login:blacklisted($string_utils:connection_hostname(player)))",
            "return #-2;",
            "elseif (!(this in connected_players()))",
            "\"...not logged in, no problemo...\";",
            "return this;",
            "endif",
            "longest = 900;",
            "\"...guests get 15 minutes before they can be dislodged...\";",
            "candidate = #-1;",
            "free = {};",
            "for g in ($object_utils:leaves($guest))",
            "if (!is_player(g))",
            "\"...a toaded guest?...\";",
            "elseif ((!(con = g in connected_players())) && g.free_to_use)",
            "\"...yay; found an unused guest...and their last :disfunc is complete\";",
            "free = {@free, g};",
            "elseif (con && ((t = connected_seconds(g)) > longest))",
            "longest = t;",
            "candidate = g;",
            "endif",
            "endfor",
            "if (free)",
            "candidate = free[random($)];",
            "elseif (valid(candidate))",
            "\"...someone's getting bumped...\";",
            "candidate:boot();",
            "endif",
            "return candidate;"
          ]
        },
        {
          "name": "mail_catch_up",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "return;"
          ]
        },
        {
          "name": "create",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 31,
          "code": [
            "if ($login:player_creation_enabled(player))",
            "player:tell(\"First @quit, then connect to the MOO again and, rather than doing `connect guest' do `create <name> <password>'\");",
            "else",
            "player:tell($login:registration_string());",
            "endif"
          ]
        },
        {
          "name": "eject",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "return pass(@args);"
          ]
        },
        {
          "name": "log",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "\":log(islogin,time,where) adds an entry to the connection log for this guest.\";",
            "if (caller != this)",
            "return E_PERM;",
            "elseif (length(this.connect_log) < this.max_connect_log)",
            "this.connect_log = {args, @this.connect_log};",
            "else",
            "this.connect_log = {args, @this.connect_log[1..this.max_connect_log - 1]};",
            "endif"
          ]
        },
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))",
            "return E_PERM;",
            "else",
            "$guest_log:enter(1, time(), $string_utils:connection_hostname(this));",
            "ret = pass(@args);",
            "this:tell_lines(this:extra_confunc_msg());",
            "return ret;",
            "endif"
          ]
        },
        {
          "name": "log_disconnect",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "else",
            "$guest_log:enter(0, time(), $string_utils:connection_hostname((this in connected_players(1)) ? this | this.last_connect_place));",
            "endif"
          ]
        },
        {
          "name": "@last-c*onnection",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 31,
          "code": [
            "if (!valid(caller_perms()))",
            "player:tell(\"Sorry, that information is not available.\");",
            "endif"
          ]
        },
        {
          "name": "my_huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (caller_perms() != this)",
            "return E_PERM;",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "@read @peek",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 31,
          "code": [
            "return pass(@args);"
          ]
        },
        {
          "name": "set_current_folder",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "return pass(@args);",
            "\"only for setting permission\";"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.extra_confunc_msg = \"\";",
            "endif"
          ]
        },
        {
          "name": "set_name set_aliases",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "\"disallow guests from setting aliases on themselves\";",
            "if ($perm_utils:controls(caller_perms(), this))",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "extra_confunc_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "return $string_utils:pronoun_sub(this.(verb));"
          ]
        },
        {
          "name": "do_reset",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "flush_input(this, 0);",
            "for x in ({\"paranoid\", \"lines\", \"responsible\", \"linelen\", \"linebuffer\", \"brief\", \"gaglist\", \"rooms\", \"pagelen\", \"current_message\", \"current_folder\", \"messages\", \"messages_going\", \"request\", \"mail_options\", \"edit_options\", \"home\", \"spurned_objects\", \"web_info\", \"ansi_options\", \"replace_codes\"})",
            "if ($object_utils:has_property(parent(this), x))",
            "clear_property(this, x);",
            "endif",
            "endfor",
            "this:set_description(this.default_description);",
            "this:set_gender(this.default_gender);",
            "for x in (this.contents)",
            "this:eject(x);",
            "endfor",
            "for x in (this.features)",
            "if (!(x in $guest.features))",
            "this:remove_feature(x);",
            "endif",
            "endfor",
            "for x in ($guest.features)",
            "if (!(x in this.features))",
            "this:add_feature(x);",
            "endif",
            "endfor",
            "for x in ($object_utils:descendants($generic_editor))",
            "if (loc = this in x.active)",
            "x:kill_session(loc);",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "@request",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 31,
          "code": [
            "\"Usage:  @request <player-name> for <email-address>\";",
            "if (player != this)",
            "return player:tell(E_PERM);",
            "endif",
            "if (this.request)",
            "return player:tell(\"Sorry, you appear to have already requested a character.\");",
            "endif",
            "name = dobjstr;",
            "if ((prepstr != \"for\") || ((!dobjstr) || index(address = iobjstr, \" \")))",
            "return player:notify_lines($code_utils:verb_usage());",
            "endif",
            "if ($login:request_character(player, name, address))",
            "this.request = 1;",
            "endif",
            "\"Copied from Generic Guest (#5678):@request by Froxx (#49853) Mon Apr  4 10:49:26 1994 PDT\";"
          ]
        },
        {
          "name": "connection_name_hash",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "\"Compute an encrypted hash of the guest's (last) connection, using 'crypt'. Basically, you can't tell where the guest came from, but it is unlikely that two guests will have the same hash\";",
            "\"You can use guest:connection_name_hash(seed) as a string to identify whether two guests are from the same place.\";",
            "hash = toint(caller_perms());",
            "host = $string_utils:connection_hostname(this.last_connect_place);",
            "for i in [1..length(host)]",
            "hash = (hash * 14) + index($string_utils.ascii, host[i]);",
            "endfor",
            "return crypt(tostr(hash), @args);"
          ]
        },
        {
          "name": "@subscribe*-quick @unsubscribed*-quick",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 31,
          "code": [
            "if ((caller_perms() != $nothing) && (caller_perms() != player))",
            "return E_PERM;",
            "endif",
            "if (!args)",
            "all_mlists = {@$mail_agent.contents, @this.mail_lists};",
            "if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr(\"There are \", length(all_mlists), \" mailing lists.  Are you sure you want the whole list?\"))))",
            "return player:tell(\"OK, aborting.\");",
            "endif",
            "for c in (all_mlists)",
            "$command_utils:suspend_if_needed(0);",
            "if ((c:is_usable_by(this) || c:is_readable_by(this)) && (verb != \"@unsubscribed\"))",
            "`c:look_self(1) ! ANY';",
            "endif",
            "endfor",
            "player:tell(\"--End of List--\");",
            "else",
            "player:tell(\"Sorry, Guests don't have full mailing privileges.  You may use @read and @peek for mailing lists.  Or try @request to get yourself a character.\");",
            "endif",
            "\"Paragraph (#122534) - Tue Nov 8, 2005 - Added to prevent a silly traceback from occuring, since Guests can't read their own .current_message.\";"
          ]
        },
        {
          "name": "current_folder",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if (caller_perms() in {this, this.owner})",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 31,
          "code": [
            "if ((caller_perms().wizard || (caller_perms() in {this, this.owner})) || (caller == this))",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "default_gender",
        "default_description",
        "request",
        "extra_confunc_msg",
        "free_to_use"
      ],
      "propdefs": [
        {
          "value": "neuter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "By definition, guests appear nondescript."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": "",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%t (%[#t]) is a guest character.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 79,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            0,
            0,
            0,
            0
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Guest"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "By definition, guests appear nondescript."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            22493,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "32": {
      "id": 32,
      "name": "Mr. Spell",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "valid",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 32,
          "code": [
            "return (spellcheck(args[1]) == 1) || (args[1] in player.dict);"
          ]
        },
        {
          "name": "get_input",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 32,
          "code": [
            "set_task_perms(caller_perms());",
            "source = args[1];",
            "data = {};",
            "ref = $code_utils:parse_propref(source);",
            "if (ref)",
            "\"User entered a prop. Deal with it.\";",
            "{thing, prop} = ref;",
            "thing = $string_utils:match_object(thing, player.location);",
            "if (!valid(thing))",
            "player:tell(\"No such object: \", ref[1]);",
            "data = $failed_match;",
            "elseif ((!prop) || (`thing.(tostr(prop)) ! ANY' == E_PROPNF))",
            "player:tell(\"There is no such property `\", prop, \"' on object \", thing, \".\");",
            "data = $failed_match;",
            "else",
            "data = `thing.(tostr(prop)) ! ANY';",
            "if (typeof(data) == STR)",
            "data = {data};",
            "endif",
            "$command_utils:suspend_if_needed(3);",
            "if (typeof(data) == ERR)",
            "player:tell(\"Error: \", tostr(data));",
            "data = $failed_match;",
            "elseif (typeof(data) != LIST)",
            "player:tell(\"Spellchecker needs a string or list as input.\");",
            "data = $failed_match;",
            "endif",
            "endif",
            "else",
            "ref = $code_utils:parse_verbref(source);",
            "if (ref)",
            "\"User entered a verb. Deal with it.\";",
            "{thing, verb} = ref;",
            "thing = $string_utils:match_object(thing, player.location);",
            "if (!valid(thing))",
            "player:tell(\"No such object: \", ref[1]);",
            "data = $failed_match;",
            "elseif (`verb_info(thing, verb) ! ANY' == E_VERBNF)",
            "player:tell(\"There is no such verb `\", verb, \"' on object \", thing, \".\");",
            "data = $failed_match;",
            "else",
            "data = `verb_code(thing, verb) ! ANY => {}';",
            "for i in [1..length(data)]",
            "if (!index(data[i], \"\\\"\"))",
            "data[i] = \"\";",
            "else",
            "data[i] = data[i][index(data[i], \"\\\"\") + 1..$];",
            "data[i] = data[i][1..rindex(data[i], \"\\\"\") - 1];",
            "foo = \"\";",
            "while (index(data[i], \"\\\"\"))",
            "foo = foo + data[i][1..index(data[i], \"\\\"\") - 1];",
            "foo = foo + \" \";",
            "data[i] = data[i][index(data[i], \"\\\"\") + 1..$];",
            "data[i] = data[i][index(data[i], \"\\\"\") + 1..$];",
            "endwhile",
            "if (foo == \"\")",
            "foo = data[i];",
            "else",
            "foo = foo + data[i];",
            "endif",
            "data[i] = $string_utils:trim(foo);",
            "endif",
            "endfor",
            "endif",
            "else",
            "\"User entered word/phrase on command line.\";",
            "data = {argstr};",
            "endif",
            "endif",
            "for i in [1..length(data)]",
            "$command_utils:suspend_if_needed(1);",
            "if (typeof(data[i]) != STR)",
            "data[i] = \"\";",
            "endif",
            "data[i] = $string_utils:strip_chars(data[i], \"!@#$%^&*()_+1234567890={}[]`<>?:;,./|\\\"~'\");",
            "endfor",
            "return data;"
          ]
        },
        {
          "name": "guess_words",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 32,
          "code": [
            "{nastyword} = args;",
            "guesses = spellcheck(nastyword);",
            "\"Transpose adjacent characters\";",
            "nastyword = nastyword + \" \";",
            "for i in [1..length(nastyword) - 1]",
            "foo = ((nastyword[1..i - 1] + nastyword[i + 1]) + nastyword[i]) + nastyword[i + 2..$];",
            "foo = $string_utils:trim(foo);",
            "if (this:valid(foo))",
            "guesses = setadd(guesses, foo);",
            "endif",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "nastyword = $string_utils:trim(nastyword);",
            "\"Erase each character - check for an extra typoed character\";",
            "for i in [1..length(nastyword)]",
            "foo = nastyword[1..i - 1] + nastyword[i + 1..$];",
            "if (this:valid(foo))",
            "guesses = setadd(guesses, foo);",
            "endif",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "\"Alter one character\";",
            "for i in [1..length(nastyword)]",
            "for ii in ({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"'\", \"-\"})",
            "foo = (nastyword[1..i - 1] + ii) + nastyword[i + 1..$];",
            "if (this:valid(foo))",
            "guesses = setadd(guesses, foo);",
            "endif",
            "endfor",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "\"insert one character\";",
            "for i in [1..length(nastyword)]",
            "for ii in ({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"'\", \"-\"})",
            "foo = (nastyword[1..i - 1] + ii) + nastyword[i..$];",
            "if (this:valid(foo))",
            "guesses = setadd(guesses, foo);",
            "endif",
            "endfor",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "\"Clean up and go home\";",
            "guesses = $list_utils:sort(guesses);",
            "return guesses;"
          ]
        },
        {
          "name": "help_msg",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 32,
          "code": [
            "return this.description;"
          ]
        },
        {
          "name": "proxy_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 32,
          "code": [
            "return this;"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Mr. Spell",
            "spell"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "For help on using the speller, use 'help spelling' and 'help @spell'.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            6242,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "33": {
      "id": 33,
      "name": "sequence utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "add remove",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\"   add(seq,start[,end]) => seq with range added.\";",
            "\"remove(seq,start[,end]) => seq with range removed.\";",
            "\"  both assume start<=end.\";",
            "remove = verb == \"remove\";",
            "seq = args[1];",
            "start = args[2];",
            "s = (start == $minint) ? 1 | $list_utils:find_insert(seq, start - 1);",
            "if (length(args) < 3)",
            "return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}};",
            "else",
            "e = $list_utils:find_insert(seq, after = args[3] + 1);",
            "return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}, @((e + remove) % 2) ? {after} | {}, @seq[e..$]};",
            "endif"
          ]
        },
        {
          "name": "contains",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":contains(seq,elt) => true iff elt is in seq.\";",
            "return ($list_utils:find_insert(@args) + 1) % 2;"
          ]
        },
        {
          "name": "complement",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":complement(seq[,lower[,upper]]) => the sequence containing all integers *not* in seq.\";",
            "\"If lower/upper are given, the resulting sequence is restricted to the specified range.\";",
            "\"Bad things happen if seq is not a subset of [lower..upper]\";",
            "{seq, ?lower = $minint, ?upper = $nothing} = args;",
            "if (upper != $nothing)",
            "if (seq[$] >= (upper = upper + 1))",
            "seq[$..$] = {};",
            "else",
            "seq[$ + 1..$] = {upper};",
            "endif",
            "endif",
            "if (seq && (seq[1] <= lower))",
            "return listdelete(seq, 1);",
            "else",
            "return {lower, @seq};",
            "endif"
          ]
        },
        {
          "name": "union",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":union(seq1,seq2,...)        => union of all sequences...\";",
            "if ({} in args)",
            "args = $list_utils:setremove_all(args, {});",
            "endif",
            "if (length(args) <= 1)",
            "return args ? args[1] | {};",
            "endif",
            "return this:_union(@args);"
          ]
        },
        {
          "name": "tostr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\"tostr(seq [,delimiter]) -- turns a sequence into a string, delimiting ranges with delimiter, defaulting to .. (e.g. 5..7)\";",
            "{seq, ?separator = \"..\"} = args;",
            "if (!seq)",
            "return \"empty\";",
            "endif",
            "e = tostr((seq[1] == $minint) ? \"\" | seq[1]);",
            "len = length(seq);",
            "for i in [2..len]",
            "e = e + ((i % 2) ? tostr(\", \", seq[i]) | ((seq[i] == (seq[i - 1] + 1)) ? \"\" | tostr(separator, seq[i] - 1)));",
            "endfor",
            "return e + ((len % 2) ? separator | \"\");"
          ]
        },
        {
          "name": "for",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":for([n,]seq,obj,verb,@args) => for s in (seq) obj:verb(s,@args); endfor\";",
            "set_task_perms(caller_perms());",
            "if (typeof(n = args[1]) == INT)",
            "args = listdelete(args, 1);",
            "else",
            "n = 1;",
            "endif",
            "{seq, object, vname, @args} = args;",
            "if (seq[1] == $minint)",
            "return E_RANGE;",
            "endif",
            "for r in [1..length(seq) / 2]",
            "for i in [seq[(2 * r) - 1]..seq[2 * r] - 1]",
            "if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)",
            "return;",
            "endif",
            "endfor",
            "endfor",
            "if (length(seq) % 2)",
            "i = seq[$];",
            "while (1)",
            "if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)",
            "return;",
            "endif",
            "i = i + 1;",
            "endwhile",
            "endif"
          ]
        },
        {
          "name": "extract",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\"extract(seq,array) => list of elements of array with indices in seq.\";",
            "{seq, array} = args;",
            "if (alen = length(array))",
            "e = $list_utils:find_insert(seq, 1);",
            "s = $list_utils:find_insert(seq, alen);",
            "seq = {@(e % 2) ? {} | {1}, @seq[e..s - 1], @(s % 2) ? {} | {alen + 1}};",
            "ret = {};",
            "for i in [1..length(seq) / 2]",
            "$command_utils:suspend_if_needed(0);",
            "ret = {@ret, @array[seq[(2 * i) - 1]..seq[2 * i] - 1]};",
            "endfor",
            "return ret;",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "tolist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "seq = args[1];",
            "if (!seq)",
            "return {};",
            "else",
            "if (length(seq) % 2)",
            "seq = {@seq, $minint};",
            "endif",
            "l = {};",
            "for i in [1..length(seq) / 2]",
            "for j in [seq[(2 * i) - 1]..seq[2 * i] - 1]",
            "l = {@l, j};",
            "endfor",
            "endfor",
            "return l;",
            "endif"
          ]
        },
        {
          "name": "from_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":fromlist(list) => corresponding sequence.\";",
            "return this:from_sorted_list($list_utils:sort(args[1]));"
          ]
        },
        {
          "name": "from_sorted_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":from_sorted_list(sorted_list) => corresponding sequence.\";",
            "if (!(lst = args[1]))",
            "return {};",
            "else",
            "seq = {i = lst[1]};",
            "next = i + 1;",
            "for i in (listdelete(lst, 1))",
            "if (i != next)",
            "seq = {@seq, next, i};",
            "endif",
            "next = i + 1;",
            "endfor",
            "return (next == $minint) ? seq | {@seq, next};",
            "endif"
          ]
        },
        {
          "name": "first",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "return (seq = args[1]) ? seq[1] | E_NONE;"
          ]
        },
        {
          "name": "last",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "return (seq = args[1]) ? (length(seq) % 2) ? $minint - 1 | (seq[$] - 1) | E_NONE;"
          ]
        },
        {
          "name": "size",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":size(seq) => number of elements in seq\";",
            "\"  for sequences consisting of more than half of the 4294967298 available integers, this returns a negative number, which can either be interpreted as (cardinality - 4294967298) or -(size of complement sequence)\";",
            "n = 0;",
            "for i in (seq = args[1])",
            "n = i - n;",
            "endfor",
            "return (length(seq) % 2) ? $minint - n | n;"
          ]
        },
        {
          "name": "from_string",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":from_string(string) => corresponding sequence or E_INVARG\";",
            "\"  string should be a comma separated list of numbers and\";",
            "\"  number..number ranges\";",
            "su = $string_utils;",
            "if (!(words = su:explode(su:strip_chars(args[1], \" \"), \",\")))",
            "return {};",
            "endif",
            "parts = {};",
            "for word in (words)",
            "to = index(word, \"..\");",
            "if ((!to) && su:is_numeric(word))",
            "part = {toint(word), toint(word) + 1};",
            "elseif (to)",
            "if (to == 1)",
            "start = $minint;",
            "elseif (su:is_numeric(start = word[1..to - 1]))",
            "start = toint(start);",
            "else",
            "return E_INVARG;",
            "endif",
            "end = word[to + 2..length(word)];",
            "if (!end)",
            "part = {start};",
            "elseif (!su:is_numeric(end))",
            "return E_INVARG;",
            "elseif ((end = toint(end)) >= start)",
            "part = {start, end + 1};",
            "else",
            "part = {};",
            "endif",
            "else",
            "return E_INVARG;",
            "endif",
            "parts = {@parts, part};",
            "endfor",
            "return this:union(@parts);"
          ]
        },
        {
          "name": "firstn",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":firstn(seq,n) => first n elements of seq as a sequence.\";",
            "if ((n = args[2]) <= 0)",
            "return {};",
            "endif",
            "l = length(seq = args[1]);",
            "s = 1;",
            "while (s <= l)",
            "n = n + seq[s];",
            "if ((s >= l) || (n <= seq[s + 1]))",
            "return {@seq[1..s], n};",
            "endif",
            "n = n - seq[s + 1];",
            "s = s + 2;",
            "endwhile",
            "return seq;"
          ]
        },
        {
          "name": "lastn",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":lastn(seq,n) => last n elements of seq as a sequence.\";",
            "n = args[2];",
            "if ((l = length(seq = args[1])) % 2)",
            "return {$minint - n};",
            "else",
            "s = l;",
            "while (s)",
            "n = seq[s] - n;",
            "if (n >= seq[s - 1])",
            "return {n, @seq[s..l]};",
            "endif",
            "n = seq[s - 1] - n;",
            "s = s - 2;",
            "endwhile",
            "return seq;",
            "endif"
          ]
        },
        {
          "name": "range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":range(start,end) => sequence corresponding to [start..end] range\";",
            "return ((start = args[1]) <= (end = args[2])) ? {start, end + 1} | {};"
          ]
        },
        {
          "name": "expand",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":expand(seq,eseq[,include=0])\";",
            "\"eseq is assumed to be a finite sequence consisting of intervals \";",
            "\"[f1..a1-1],[f2..a2-1],...  We map each element i of seq to\";",
            "\"  i               if               i < f1\";",
            "\"  i+(a1-f1)       if         f1 <= i < f2-(a1-f1)\";",
            "\"  i+(a1-f1+a2-f2) if f2-(a1-f1) <= i < f3-(a2-f2)-(a1-f1)\";",
            "\"  ...\";",
            "\"returning the resulting sequence if include=0,\";",
            "\"returning the resulting sequence unioned with eseq if include=1;\";",
            "{old, insert, ?include = 0} = args;",
            "exclude = !include;",
            "if (!insert)",
            "return old;",
            "elseif ((length(insert) % 2) || (insert[1] == $minint))",
            "return E_TYPE;",
            "endif",
            "olast = length(old);",
            "ilast = length(insert);",
            "\"... find first o for which old[o] >= insert[1]...\";",
            "ifirst = insert[i = 1];",
            "o = $list_utils:find_insert(old, ifirst - 1);",
            "if (o > olast)",
            "return ((olast % 2) == exclude) ? {@old, @insert} | old;",
            "endif",
            "new = old[1..o - 1];",
            "oe = old[o];",
            "diff = 0;",
            "while (1)",
            "\"INVARIANT: oe == old[o]+diff\";",
            "\"INVARIANT: oe >= ifirst == insert[i]\";",
            "\"... at this point we need to dispose of the interval ifirst..insert[i+1]\";",
            "if (oe == ifirst)",
            "new = {@new, insert[i + ((o % 2) == exclude)]};",
            "if (o >= olast)",
            "return ((olast % 2) == exclude) ? {@new, @insert[i + 2..ilast]} | new;",
            "endif",
            "o = o + 1;",
            "else",
            "if ((o % 2) != exclude)",
            "new = {@new, @insert[i..i + 1]};",
            "endif",
            "endif",
            "\"... advance i...\";",
            "diff = (diff + insert[i + 1]) - ifirst;",
            "if ((i = i + 2) > ilast)",
            "for oe in (old[o..olast])",
            "new = {@new, oe + diff};",
            "endfor",
            "return new;",
            "endif",
            "ifirst = insert[i];",
            "\"... find next o for which old[o]+diff >= ifirst )...\";",
            "while ((oe = old[o] + diff) < ifirst)",
            "new = {@new, oe};",
            "if (o >= olast)",
            "return ((olast % 2) == exclude) ? {@new, @insert[i..ilast]} | new;",
            "endif",
            "o = o + 1;",
            "endwhile",
            "endwhile"
          ]
        },
        {
          "name": "contract",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":contract(seq,cseq)\";",
            "\"cseq is assumed to be a finite sequence consisting of intervals \";",
            "\"[f1..a1-1],[f2..a2-1],...  From seq, we remove any elements that \";",
            "\"are in those ranges and map each remaining element i to\";",
            "\"  i               if       i < f1\";",
            "\"  i-(a1-f1)       if a1 <= i < f2\";",
            "\"  i-(a1-f1+a2-f2) if a2 <= i < f3 ...\";",
            "\"returning the resulting sequence.\";",
            "\"\";",
            "\"For any finite sequence cseq, the following always holds:\";",
            "\"  :contract(:expand(seq,cseq,include),cseq)==seq\";",
            "{old, removed} = args;",
            "if (!removed)",
            "return old;",
            "elseif (((rlen = length(removed)) % 2) || (removed[1] == $minint))",
            "return E_TYPE;",
            "endif",
            "rfirst = removed[1];",
            "ofirst = $list_utils:find_insert(old, rfirst - 1);",
            "new = old[1..ofirst - 1];",
            "diff = 0;",
            "rafter = removed[r = 2];",
            "for o in [ofirst..olast = length(old)]",
            "while (old[o] > rafter)",
            "if ((o - ofirst) % 2)",
            "new = {@new, rfirst - diff};",
            "ofirst = o;",
            "endif",
            "diff = (diff + rafter) - rfirst;",
            "if (r >= rlen)",
            "for oe in (old[o..olast])",
            "new = {@new, oe - diff};",
            "endfor",
            "return new;",
            "endif",
            "rfirst = removed[r + 1];",
            "rafter = removed[r = r + 2];",
            "endwhile",
            "if (old[o] < rfirst)",
            "new = {@new, old[o] - diff};",
            "ofirst = o + 1;",
            "endif",
            "endfor",
            "return ((olast - ofirst) % 2) ? new | {@new, rfirst - diff};"
          ]
        },
        {
          "name": "_union",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":_union(seq,seq,...)\";",
            "\"assumes all seqs are nonempty and that there are at least 2\";",
            "nargs = length(args);",
            "\"args  -- list of sequences.\";",
            "\"nexts -- nexts[i] is the index in args[i] of the start of the first\";",
            "\"         interval not yet incorporated in the return sequence.\";",
            "\"heap  -- a binary tree of indices into args/nexts represented as a list where\";",
            "\"         heap[1] is the root and the left and right children of heap[i]\";",
            "\"         are heap[2*i] and heap[2*i+1] respectively.  \";",
            "\"         Parent index h is <= both children in the sense of args[h][nexts[h]].\";",
            "\"         heap[i]==0 indicates a nonexistant child; we fill out the array with\";",
            "\"         zeros so that length(heap)>2*length(args).\";",
            "\"...initialize heap...\";",
            "heap = {0, 0, 0, 0, 0};",
            "nexts = {1, 1};",
            "hlen2 = 2;",
            "while (hlen2 < nargs)",
            "nexts = {@nexts, @nexts};",
            "heap = {@heap, @heap};",
            "hlen2 = hlen2 * 2;",
            "endwhile",
            "for n in [-nargs..-1]",
            "s1 = args[i = -n][1];",
            "while ((hleft = heap[2 * i]) && (s1 > (m = min(la = args[hleft][1], (hright = heap[(2 * i) + 1]) ? args[hright][1] | $maxint))))",
            "if (m == la)",
            "heap[i] = hleft;",
            "i = 2 * i;",
            "else",
            "heap[i] = hright;",
            "i = (2 * i) + 1;",
            "endif",
            "endwhile",
            "heap[i] = -n;",
            "endfor",
            "\"...\";",
            "\"...find first interval...\";",
            "h = heap[1];",
            "rseq = {args[h][1]};",
            "if (length(args[h]) < 2)",
            "return rseq;",
            "endif",
            "current_end = args[h][2];",
            "nexts[h] = 3;",
            "\"...\";",
            "while (1)",
            "if (length(args[h]) >= nexts[h])",
            "\"...this sequence has some more intervals in it...\";",
            "else",
            "\"...no more intevals left in this sequence, grab another...\";",
            "h = heap[1] = heap[nargs];",
            "heap[nargs] = 0;",
            "if ((nargs = nargs - 1) > 1)",
            "elseif (args[h][nexts[h]] > current_end)",
            "return {@rseq, current_end, @args[h][nexts[h]..$]};",
            "elseif ((i = $list_utils:find_insert(args[h], current_end)) % 2)",
            "return {@rseq, current_end, @args[h][i..$]};",
            "else",
            "return {@rseq, @args[h][i..$]};",
            "endif",
            "endif",
            "\"...\";",
            "\"...sink the top sequence...\";",
            "i = 1;",
            "first = args[h][nexts[h]];",
            "while ((hleft = heap[2 * i]) && (first > (m = min(la = args[hleft][nexts[hleft]], (hright = heap[(2 * i) + 1]) ? args[hright][nexts[hright]] | $maxint))))",
            "if (m == la)",
            "heap[i] = hleft;",
            "i = 2 * i;",
            "else",
            "heap[i] = hright;",
            "i = (2 * i) + 1;",
            "endif",
            "endwhile",
            "heap[i] = h;",
            "\"...\";",
            "\"...check new top sequence ...\";",
            "if (args[h = heap[1]][nexts[h]] > current_end)",
            "\"...hey, a new interval! ...\";",
            "rseq = {@rseq, current_end, args[h][nexts[h]]};",
            "if (length(args[h]) <= nexts[h])",
            "return rseq;",
            "endif",
            "current_end = args[h][nexts[h] + 1];",
            "nexts[h] = nexts[h] + 2;",
            "else",
            "\"...first interval overlaps with current one ...\";",
            "i = $list_utils:find_insert(args[h], current_end);",
            "if (i % 2)",
            "nexts[h] = i;",
            "elseif (i > length(args[h]))",
            "return rseq;",
            "else",
            "current_end = args[h][i];",
            "nexts[h] = i + 1;",
            "endif",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "intersection",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 33,
          "code": [
            "\":intersection(seq1,seq2,...) => intersection of all sequences...\";",
            "if ((U = {$minint}) in args)",
            "args = $list_utils:setremove_all(args, U);",
            "endif",
            "if (length(args) <= 1)",
            "return args ? args[1] | U;",
            "endif",
            "return this:complement(this:_union(@$list_utils:map_arg(this, \"complement\", args)));"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "A sequence is a set of integers (*)",
            "This package supplies the following verbs:",
            "",
            "  :add      (seq,f,t)  => seq with [f..t] interval added",
            "  :remove   (seq,f,t)  => seq with [f..t] interval removed",
            "  :range    (f,t)      => sequence corresponding to [f..t]",
            "  {}                   => empty sequence",
            "  :contains (seq,n)    => n in seq",
            "  :size     (seq)      => number of elements in seq",
            "  :first    (seq)      => first integer in seq or E_NONE",
            "  :firstn   (seq,n)    => first n integers in seq (as a sequence)",
            "  :last     (seq)      => last integer in seq  or E_NONE",
            "  :lastn    (seq,n)    => last n integers in seq (as a sequence)",
            "",
            "  :complement   (seq)         => sequence consisting of integers not in seq",
            "  :union        (seq,seq,...) => union of all sequences",
            "  :intersection (seq,seq,...) => intersection of all sequences",
            "  :contract (seq,cseq)              (see `help $seq_utils:contract')",
            "  :expand   (seq,eseq[,include])    (see `help $seq_utils:expand')",
            "  ",
            "  :extract(seq,array)           => array[@seq]",
            "  :for([n,]seq,obj,verb,@args)  => for s in (seq) obj:verb(s,@args); endfor",
            "",
            "  :tolist(seq)            => list corresponding to seq",
            "  :tostr(seq)             => contents of seq as a string",
            "  :from_list(list)        => sequence corresponding to list",
            "  :from_sorted_list(list) => sequence corresponding to list (assumed sorted)",
            "  :from_string(string)    => sequence corresponding to string",
            "",
            "For boolean expressions, note that",
            "  the representation of the empty sequence is {} (boolean FALSE) and",
            "  all non-empty sequences are represented as nonempty lists (boolean TRUE).",
            "",
            "The representation used works better than the usual list implementation for sets consisting of long uninterrupted ranges of integers.  ",
            "For sparse sets of integers the representation is decidedly non-optimal (though it never takes more than double the space of the usual list representation).",
            "",
            "(*) i.e., integers in the range [$minint+1..$maxint].  The implementation depends on $minint never being included in a sequence.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "sequence utilities",
            "seq_utils",
            "squ"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the sequence utilities utility package.  See `help $seq_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            23817,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "34": {
      "id": 34,
      "name": "Quota-Log",
      "flags": 0,
      "owner": 2,
      "location": 46,
      "parents": [
        45
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 34,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_notify = {player};",
            "player:set_current_message(this, 0, 0, 1);",
            "this.moderated = 1;",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            [
              0,
              [
                [
                  1,
                  [
                    1541028153,
                    "Wizard (#2)",
                    "*Quota-Log (#34)",
                    "@quota Anti-Wizard (#98) 1000000 (from 20000)",
                    "",
                    "Reason for quota increase: (none)."
                  ]
                ]
              ]
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1541028153,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Quota-Log",
            "Quota_Log",
            "QL",
            "Quota"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "Record of whose quota has been messed with and why.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2326,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "35": {
      "id": 35,
      "name": "you",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        94
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "verb_sub",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 35,
          "code": [
            "\"$you:verb_sub(STR verbspec) -> returns verbspec conjugated for singular use as if `you' were saying it.\";",
            "return $gender_utils:get_conj(args[1], this);",
            "x = args[1];",
            "len = length(x);",
            "if ((len > 3) && (rindex(x, \"n't\") == (len - 3)))",
            "return this:verb_sub(x[1..len - 3]) + \"n't\";",
            "endif",
            "for y in (this.conjugations)",
            "if (x == y[1])",
            "return y[2];",
            "endif",
            "endfor",
            "for y in ({{\"ches\", \"ch\"}, {\"ies\", \"y\"}, {\"sses\", \"ss\"}, {\"shes\", \"sh\"}, {\"s\", \"\"}})",
            "if ((len > length(y[1])) && (rindex(x, y[1]) == ((len - length(y[1])) + 1)))",
            "return x[1..len - length(y[1])] + y[2];",
            "endif",
            "endfor",
            "return x;"
          ]
        },
        {
          "name": "say_action",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 35,
          "code": [
            "\"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])\";",
            "\"announce 'message' with pronoun substitution as if it were just \";",
            "\"  where:announce_all_but(excluding-whom, \";",
            "\"    $string_utils:pronoun_sub(message, who, thing, where));\";",
            "\"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.\";",
            "\"who       default player\";",
            "\"thing     default object that called this verb\";",
            "\"where     default who.location\";",
            "\"excluding default {}\";",
            "{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;",
            "you = this;",
            "if (typeof(msg) == LIST)",
            "tell = \"\";",
            "for x in (msg)",
            "tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);",
            "endfor",
            "else",
            "tell = msg;",
            "endif",
            "if (!(who in excluding))",
            "who:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%n\"), you, thing, where));",
            "endif",
            "if ($object_utils:has_callable_verb(where, \"announce_all_but\"))",
            "where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));",
            "endif",
            "if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))",
            "x = dobj;",
            "dobj = you;",
            "x:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%d\"), who, thing, where));",
            "dobj = x;",
            "endif",
            "if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))",
            "x = iobj;",
            "iobj = you;",
            "x:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%i\"), who, thing, where));",
            "iobj = x;",
            "endif"
          ]
        },
        {
          "name": "fixpos",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 35,
          "code": [
            "\"This is horribly dwimmy.  E.g. %x's gets turned into your, %X's gets turned into Your, and %X'S gets turned into YOUR. --Nosredna\";",
            "upper = $string_utils:uppercase(args[2]);",
            "allupper = upper + \"'S\";",
            "upper = upper + \"'s\";",
            "lower = $string_utils:lowercase(args[2]) + \"'s\";",
            "return strsub(strsub(strsub(args[1], lower, \"your\", 1), upper, \"Your\", 1), allupper, \"YOUR\", 1);"
          ]
        },
        {
          "name": "reflexive",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 35,
          "code": [
            "\"Copied from you (#67923):reflexive [verb author Blob (#21528)] at Wed Jul 13 05:09:32 2005 PDT\";",
            "\":reflexive(msg, %[di])\";",
            "\"Make a message reflexive by replacing %d or %i with %r.\";",
            "{msg, pos} = args;",
            "upper = $string_utils:uppercase(pos) + \"'s\";",
            "lower = $string_utils:lowercase(pos) + \"'s\";",
            "msg = strsub(msg, lower, \"%p\", 1);",
            "msg = strsub(msg, upper, \"%P\", 1);",
            "msg = strsub(msg, pos, \"%r\", 1);",
            "msg = strsub(msg, $string_utils:uppercase(pos), \"%R\", 1);",
            "return msg;"
          ]
        },
        {
          "name": "say_action_reflexive",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 35,
          "code": [
            "\"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])\";",
            "\"announce 'message' with pronoun substitution as if it were just \";",
            "\"  where:announce_all_but(excluding-whom, \";",
            "\"    $string_utils:pronoun_sub(message, who, thing, where));\";",
            "\"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.\";",
            "\"who       default player\";",
            "\"thing     default object that called this verb\";",
            "\"where     default who.location\";",
            "\"excluding default {}\";",
            "{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;",
            "you = this;",
            "if (typeof(msg) == LIST)",
            "tell = \"\";",
            "for x in (msg)",
            "tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);",
            "endfor",
            "else",
            "tell = msg;",
            "endif",
            "if (who == dobj)",
            "tell = this:reflexive(tell, \"%d\");",
            "endif",
            "if (who == iobj)",
            "tell = this:reflexive(tell, \"%i\");",
            "endif",
            "if (!(who in excluding))",
            "msg = tell;",
            "x = dobj;",
            "y = iobj;",
            "dobj = (dobj == who) ? you | dobj;",
            "iobj = (iobj == who) ? you | iobj;",
            "who:tell($string_utils:pronoun_sub(this:fixpos(msg, \"%n\"), you, thing, where));",
            "dobj = x;",
            "iobj = y;",
            "endif",
            "if ($object_utils:has_callable_verb(where, \"announce_all_but\"))",
            "where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));",
            "endif",
            "if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))",
            "x = dobj;",
            "y = iobj;",
            "msg = this:fixpos(tell, \"%d\");",
            "if (dobj == iobj)",
            "iobj = you;",
            "msg = this:fixpos(msg, \"%i\");",
            "endif",
            "dobj = you;",
            "x:tell($string_utils:pronoun_sub(msg, who, thing, where));",
            "dobj = x;",
            "iobj = y;",
            "endif",
            "if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))",
            "x = iobj;",
            "iobj = you;",
            "x:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%i\"), who, thing, where));",
            "iobj = x;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "conjugations",
        "help_msg"
      ],
      "propdefs": [
        {
          "value": [
            [
              "is",
              "are"
            ],
            [
              "was",
              "were"
            ],
            [
              "does",
              "do"
            ],
            [
              "has",
              "have"
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "This object is useful for announcing messages that switch between third and second person when addressed to the appropriate parties in a room.",
            "",
            "Verbs:",
            "",
            "  :verb_sub(STR verbspec) -> conjugates the given verb into singular form",
            "  :say_action(message [,who [,thing, [,where]]]) -> appropriately pronoun ",
            "      substituted message announced to where, which defaults to who.location",
            "      where who defaults to player.",
            "  Ex:  if player=#123 (Munchkin), dobj=#456 (Frebblebit), and iobj=#789",
            "       (Bob) and they are all in the same room,",
            "       $you:say_action(\"%N %<waves> happily to %d and %i.\") would do this:",
            "",
            "Munchkin sees:       You wave happily to Frebblebit and Bob.",
            "Frebblebit sees:     Munchkin waves happily to you and Bob.",
            "Bob sees:            Munchkin waves happily to Frebblebit and you.",
            "Everyone else sees:  Munchkin waves happily to Frebblebit and Bob."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "2nd",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Yours",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "yours",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Your",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "your",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Yourself",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "yourself",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "you",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "you",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "you"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "An object useful for pronoun substitution for switching between third and second person.  See `help $you' for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            9767,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "36": {
      "id": 36,
      "name": "Hacker",
      "flags": 19,
      "owner": 36,
      "location": -1,
      "parents": [
        58
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 36,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_forward = {$owner};",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 37331,
          "owner": 36,
          "perms": 0
        },
        {
          "value": -1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            100000008,
            -28350490,
            1008125633,
            1510998
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Hacker"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "A system character used to own non-wizardly system verbs , properties, and objects in the core.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            4196,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "37": {
      "id": 37,
      "name": "Generic Database",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        16,
        25,
        39
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "find find_key",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\"find(string[,n]) => datum corresponding to string with the search starting at node \\\" \\\"+string[1..n], n defaults to 0 (root node), $ambiguous_match or $failed_match\";",
            "\"find_key(string[,n]) is like :find but returns the full string key rather than the associated datum.  Note that if several string keys present in the db share a common prefix, :find_key(prefix) will return $ambiguous_match, but if there is a unique datum associated with all of these strings :find(prefix) will return it rather than $ambiguous_match.\";",
            "\"Assumes n<=length(string)\";",
            "{search, ?sofar = 0} = args;",
            "rest = search;",
            "prefix = search[1..sofar];",
            "rest[1..sofar] = \"\";",
            "info = this.(\" \" + prefix);",
            "data = (verb == \"find\") ? this.data | 3;",
            "if (i = search in info[3])",
            "\"...exact match for one of the strings in this node...\";",
            "return info[data][i];",
            "elseif (index(info[1], rest) == 1)",
            "\"...ambiguous iff there's more than one object represented in this node..\";",
            "return this:_only(prefix, data);",
            "elseif (index(rest, info[1]) != 1)",
            "\"...search string doesn't agree with common portion...\";",
            "return $failed_match;",
            "elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))",
            "\"...search string follows one of continuations leading to other nodes...\";",
            "return this:(verb)(search, nsofar);",
            "else",
            "\"...search string may partially match one of the strings in this node...\";",
            "for i in [1..length(exacts = info[3])]",
            "if (index(exacts[i], search) == 1)",
            "return info[data][i];",
            "endif",
            "endfor",
            "return $failed_match;",
            "endif"
          ]
        },
        {
          "name": "find_exact",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "{search, ?sofar = 0} = args;",
            "rest = search;",
            "prefix = search[1..sofar];",
            "rest[1..sofar] = \"\";",
            "info = this.(\" \" + prefix);",
            "if (i = search in info[3])",
            "return info[this.data][i];",
            "elseif ((length(rest) <= (common = length(info[1]))) || (rest[1..common] != info[1]))",
            "return $failed_match;",
            "elseif (index(info[2], search[(sofar + common) + 1]))",
            "return this:find_exact(search, (sofar + common) + 1);",
            "else",
            "return $failed_match;",
            "endif"
          ]
        },
        {
          "name": "find_all find_all_keys",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":find_all(string [,n=0])\";",
            "\"assumes n <= length(string)\";",
            "{search, ?sofar = 0} = args;",
            "rest = search;",
            "prefix = search[1..sofar];",
            "rest[1..sofar] = \"\";",
            "info = this.(\" \" + prefix);",
            "data = (verb == \"find_all\") ? this.data | 3;",
            "if (index(info[1], rest) == 1)",
            "\"...return entire subtree.\";",
            "return this:((data == 3) ? \"_every_key\" | \"_every\")(prefix);",
            "elseif (index(rest, info[1]) != 1)",
            "\"...common portion doesn't agree.\";",
            "return {};",
            "elseif (index(info[2], rest[1 + (common = length(info[1]))]))",
            "\"...matching strings are in a subnode.\";",
            "return this:(verb)(search, (sofar + common) + 1);",
            "else",
            "\"...matching string is in info[3].  length(rest) > common,\";",
            "\"...so there will be at most one matching string.\";",
            "for i in [1..length(info[3])]",
            "if (index(info[3][i], search) == 1)",
            "return {info[data][i]};",
            "endif",
            "endfor",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "_only",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":_only(prefix,data) => if all strings in this node have the same datum, return it, otherwise, return $ambiguous_match.\";",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "{prefix, data} = args;",
            "info = this.(\" \" + prefix);",
            "if (data == 3)",
            "\"... life is much simpler if there's no separate datum.\";",
            "\"... if there's more than one string here, we barf.\";",
            "if (info[2] || (length(info[3]) > 1))",
            "return $ambiguous_match;",
            "elseif (info[3])",
            "return info[3][1];",
            "else",
            "\"..this can only happen with the root node of an empty db.\";",
            "return $failed_match;",
            "endif",
            "elseif (info[2])",
            "what = this:_only(tostr(prefix, info[1], info[2][1]), data);",
            "if (what == $ambiguous_match)",
            "return what;",
            "endif",
            "elseif (info[data])",
            "what = info[data][1];",
            "info[data] = listdelete(info[data], 1);",
            "else",
            "\"..this can only happen with the root node of an empty db.\";",
            "return $failed_match;",
            "endif",
            "for x in (info[data])",
            "if (what != x)",
            "return $ambiguous_match;",
            "endif",
            "endfor",
            "for i in [2..length(info[2])]",
            "if (what != this:_only(tostr(prefix, info[1], info[2][i]), data))",
            "return $ambiguous_match;",
            "endif",
            "endfor",
            "return what;"
          ]
        },
        {
          "name": "_every",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "info = this.(\" \" + args[1]);",
            "prefix = args[1] + info[1];",
            "r = $list_utils:remove_duplicates(info[4]);",
            "for i in [1..length(branches = info[2])]",
            "for new in (this:_every(prefix + branches[i]))",
            "r = setadd(r, new);",
            "endfor",
            "endfor",
            "return r;"
          ]
        },
        {
          "name": "_every_key",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "info = this.(\" \" + args[1]);",
            "prefix = args[1] + info[1];",
            "r = info[3];",
            "for i in [1..length(branches = info[2])]",
            "for new in (this:_every_key(prefix + branches[i]))",
            "r = setadd(r, new);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return r;"
          ]
        },
        {
          "name": "insert",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":insert([n,]string,datum) -- inserts <string,datum> correspondence into tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node).\";",
            "\"Assumes length(string) >= n\";",
            "\"Returns {old_datum} (or 1) if there was a <string,old_datum> correspondence there before, otherwise returns 0\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "has_datum = this.data > 3;",
            "if (typeof(sofar = args[1]) == INT)",
            "search = args[2];",
            "datum = has_datum ? args[3] | 0;",
            "else",
            "search = sofar;",
            "sofar = 0;",
            "datum = has_datum ? args[2] | 0;",
            "endif",
            "prefix = search[1..sofar];",
            "info = this.(\" \" + prefix);",
            "if (i = search in info[3])",
            "\"... exact match ...\";",
            "if (has_datum)",
            "previous = {info[this.data][i]};",
            "info[this.data][i] = datum;",
            "this:set_node(prefix, @info);",
            "return previous;",
            "else",
            "return 1;",
            "endif",
            "endif",
            "rest = search;",
            "rest[1..sofar] = \"\";",
            "if (index(rest, info[1]) != 1)",
            "\"... find where new string disagrees with common portion...\";",
            "c = $string_utils:common(rest, info[1]) + 1;",
            "\"... make a new node with a shorter common portion....\";",
            "this:make_node(prefix + info[1][1..c], @listset(info, info[1][c + 1..$], 1));",
            "this:set_node(prefix, info[1][1..c - 1], info[1][c], {search}, @has_datum ? {{datum}} | {});",
            "return 0;",
            "elseif (rest == info[1])",
            "\".. new string == common portion, insert...\";",
            "info[3] = {@info[3], search};",
            "if (has_datum)",
            "info[this.data] = {@info[this.data], datum};",
            "endif",
            "this:set_node(prefix, @info);",
            "return 0;",
            "elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))",
            "\"... new string matches pre-existing continuation. insert in subnode....\";",
            "return this:insert(nsofar, search, datum);",
            "else",
            "\"... new string may blow away one of the exact matches (i.e., matches one of them up to the first character beyond the common portion) in which case we need to create a new subnode....\";",
            "s = search[1..nsofar];",
            "for m in (info[3])",
            "if (index(m, s) == 1)",
            "i = m in info[3];",
            "\"... we know m != search ...\";",
            "\"... string m has been blown away.  create new node ...\";",
            "cbegin = cafter = length(s) + 1;",
            "cend = $string_utils:common(search, m);",
            "this:make_node(s, m[cbegin..cend], \"\", {search, m}, @has_datum ? {{datum, info[this.data][i]}} | {});",
            "this:set_node(prefix, info[1], info[2] + s[nsofar], listdelete(info[3], i), @has_datum ? {listdelete(info[this.data], i)} | {});",
            "return 0;",
            "endif",
            "endfor",
            "\"... new string hasn't blown away any of the exact matches, insert it as a new exact match...\";",
            "info[3] = {search, @info[3]};",
            "if (has_datum)",
            "info[this.data] = {datum, @info[this.data]};",
            "endif",
            "this:set_node(prefix, @info);",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "delete",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":delete(string[,n]) deletes any <string,something> pair from the tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node)\";",
            "\"Returns {something} if such a pair existed, otherwise returns 0\";",
            "\"If that node is not the root node and ends up containing only one string and no subnodes, we kill it and return {something,string2,something2} where <string2,something2> is the remaining pair.\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "{search, ?sofar = 0} = args;",
            "rest = search;",
            "prefix = search[1..sofar];",
            "rest[1..sofar] = \"\";",
            "info = this.(\" \" + prefix);",
            "if (i = search in info[3])",
            "previous = {info[this.data][i]};",
            "info[3] = listdelete(info[3], i);",
            "if (this.data > 3)",
            "info[this.data] = listdelete(info[this.data], i);",
            "endif",
            "elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))",
            "\"... hmm string isn't in here...\";",
            "return 0;",
            "elseif ((previous = this:delete(search, d)) && (length(previous) > 1))",
            "i = index(info[2], search[d]);",
            "info[2][i..i] = \"\";",
            "info[3] = {previous[2], @info[3]};",
            "if (this.data > 3)",
            "info[this.data] = {previous[3], @info[this.data]};",
            "endif",
            "previous = previous[1..1];",
            "else",
            "return previous;",
            "endif",
            "if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))",
            "this:set_node(prefix, @info);",
            "return previous;",
            "elseif (info[3])",
            "this:kill_node(prefix);",
            "return {@previous, info[3][1], info[this.data][1]};",
            "else",
            "sub = this.(\" \" + (p = tostr(prefix, info[1], info[2])));",
            "this:kill_node(p);",
            "this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));",
            "return previous;",
            "endif"
          ]
        },
        {
          "name": "delete2",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":delete2(string,datum[,n]) deletes the pair <string,datum> from the tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node)\";",
            "\"Similar to :delete except that if the entry for that string has a different associated datum, it will not be removed.  \";",
            "\":delete2(string,datum) is equivalent to \";",
            "\" \";",
            "\"  if(this:find_exact(string)==datum) \";",
            "\"    this:delete(string); \";",
            "\"  endif\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "{search, datum, ?sofar = 0} = args;",
            "rest = search;",
            "prefix = search[1..sofar];",
            "rest[1..sofar] = \"\";",
            "info = this.(\" \" + prefix);",
            "if (i = search in info[3])",
            "previous = {info[this.data][i]};",
            "if (previous[1] != datum)",
            "return previous;",
            "endif",
            "info[3] = listdelete(info[3], i);",
            "if (this.data > 3)",
            "info[this.data] = listdelete(info[this.data], i);",
            "endif",
            "elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))",
            "\"... hmm string isn't in here...\";",
            "return 0;",
            "elseif ((previous = this:delete2(search, datum, d)) && (length(previous) > 1))",
            "i = index(info[2], search[d]);",
            "info[2][i..i] = \"\";",
            "info[3] = {previous[2], @info[3]};",
            "if (this.data > 3)",
            "info[this.data] = {previous[3], @info[this.data]};",
            "endif",
            "previous = previous[1..1];",
            "else",
            "return previous;",
            "endif",
            "if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))",
            "this:set_node(prefix, @info);",
            "return previous;",
            "elseif (info[3])",
            "this:kill_node(prefix);",
            "return {@previous, info[3][1], info[this.data][1]};",
            "else",
            "sub = this.(\" \" + (p = tostr(prefix, info[1], info[2])));",
            "this:kill_node(p);",
            "this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));",
            "return previous;",
            "endif"
          ]
        },
        {
          "name": "set_node",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "return (caller != this) ? E_PERM | (this.(\" \" + args[1]) = listdelete(args, 1));"
          ]
        },
        {
          "name": "make_node",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\"WIZARDLY\";",
            "return (caller != this) ? E_PERM | add_property(this, \" \" + args[1], listdelete(args, 1), {$generic_db.owner, this.node_perms});"
          ]
        },
        {
          "name": "kill_node",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\"WIZARDLY\";",
            "return (caller != this) ? E_PERM | delete_property(this, \" \" + args[1]);"
          ]
        },
        {
          "name": "clearall",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\"WIZARDLY\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "if (args && ((d = args[1]) in {3, 4}))",
            "this.data = d;",
            "endif",
            "root = {\"\", \"\", {}, @(this.data > 3) ? {{}} | {}};",
            "\"...since the for loop contains a suspend, we want to keep people\";",
            "\"...from getting at properties which are now garbage but which we\";",
            "\"...haven't had a chance to wipe yet.  Somebody might yet succeed\";",
            "\"...in adding something; thus we have the outer while loop.\";",
            "this:set_node(\"\", 37);",
            "while (this.(\" \") != root)",
            "this:set_node(\"\", @root);",
            "for p in (properties(this))",
            "if ((p[1] == \" \") && (p != \" \"))",
            "delete_property(this, p);",
            "endif",
            "\"...Bleah; db is inconsistent now....\";",
            "\"...At worst someone will add something that references an\";",
            "\"...existing property.  He will deserve to die...\";",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endwhile"
          ]
        },
        {
          "name": "clearall_big",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "this:_kill_subtrees(\"\", 0);",
            "this:clearall(@args);"
          ]
        },
        {
          "name": "_kill_subtrees",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\":_kill_subtree(node,count)...wipes out all subtrees\";",
            "\"...returns count + number of nodes removed...\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "endif",
            "info = this.(\" \" + (prefix = args[1]));",
            "count = args[2];",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "player:tell(\"...\", count);",
            "suspend(0);",
            "endif",
            "for i in [1..length(info[2])]",
            "count = this:_kill_subtrees(n = tostr(prefix, info[1], info[2][i]), count) + 1;",
            "this:kill_node(n);",
            "endfor",
            "return count;"
          ]
        },
        {
          "name": "depth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "info = this.(\" \" + (prefix = (args || {\"\"})[1]));",
            "depth = 0;",
            "string = prefix;",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "player:tell(\"...\", prefix);",
            "suspend(0);",
            "endif",
            "for i in [1..length(info[2])]",
            "if ((r = this:depth(tostr(prefix, info[1], info[2][i])))[1] > depth)",
            "depth = r[1];",
            "string = r[2];",
            "endif",
            "endfor",
            "return {depth + 1, string};"
          ]
        },
        {
          "name": "count_entries",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "info = this.(\" \" + (prefix = args[1]));",
            "count = length(info[3]) + args[2];",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "player:tell(\"...\", count);",
            "suspend(0);",
            "endif",
            "for i in [1..length(info[2])]",
            "count = this:count_entries(tostr(prefix, info[1], info[2][i]), count);",
            "endfor",
            "return count;"
          ]
        },
        {
          "name": "count_chars",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "info = this.(\" \" + (prefix = args[1]));",
            "count = args[2];",
            "for s in (info[3])",
            "count = count + length(s);",
            "endfor",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "player:tell(\"...\", count);",
            "suspend(0);",
            "endif",
            "for i in [1..length(info[2])]",
            "count = this:count_chars(tostr(prefix, info[1], info[2][i]), count);",
            "endfor",
            "return count;"
          ]
        },
        {
          "name": "count",
          "owner": 36,
          "perms": 153,
          "preps": 3,
          "object": 37,
          "code": [
            "\"count [entries|chars] in <db>\";",
            "\"  reports on the number of distinct string keys or the number of characters\";",
            "\"  in all string keys in the db\";",
            "if (index(\"entries\", dobjstr) == 1)",
            "player:tell(this:count_entries(\"\", 0), \" strings in \", this.name, \"(\", this, \")\");",
            "elseif (index(\"chars\", dobjstr) == 1)",
            "player:tell(this:count_chars(\"\", 0), \" chars in \", this.name, \"(\", this, \")\");",
            "else",
            "player:tell(\"Usage: \", verb, \" entries|chars in <db>\");",
            "endif"
          ]
        },
        {
          "name": "proxy_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 37,
          "code": [
            "\"Create a stand-in for the core-extraction process\";",
            "\"  (rather than change the ownership on 80000 properties only to delete them).\";",
            "{core_variant, is_mcd} = args;",
            "if (!is_mcd)",
            "return this;",
            "elseif (caller != #0)",
            "raise(E_PERM);",
            "elseif (children(this) || (length(properties(this)) < 100))",
            "return this;",
            "endif",
            "proxy = $recycler:_create(parent(this), this.owner);",
            "player:tell(\"Creating proxy object \", proxy, \" for \", this.name, \" (\", this, \")\");",
            "for p in ({\"name\", \"r\", \"w\", \"f\"})",
            "proxy.(p) = this.(p);",
            "endfor",
            "for p in ($object_utils:all_properties_suspended(parent(this)))",
            "if (!is_clear_property(this, p))",
            "$command_utils:suspend_if_needed(0, \"...setting props from parent...\");",
            "proxy.(p) = this.(p);",
            "endif",
            "endfor",
            "for p in (properties(this))",
            "$command_utils:suspend_if_needed(0);",
            "if ((p[1] == \" \") && (p != \" \"))",
            "continue;",
            "endif",
            "add_property(proxy, p, this.(p), property_info(this, p));",
            "endfor",
            "for v in [1..length(verbs(this))]",
            "add_verb(proxy, verb_info(this, v), verb_args(this, v));",
            "set_verb_code(proxy, v, verb_code(this, v));",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "proxy:clearall();",
            "return proxy;"
          ]
        }
      ],
      "propnames": [
        "node_perms",
        "data",
        " "
      ],
      "propdefs": [
        {
          "value": "r",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 4,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "",
            [],
            []
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Database"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "A generic `database' (well, really more like a string-indexed array if you want the truth...). See `help $generic_db' for details.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            24015,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "38": {
      "id": 38,
      "name": "Everyman",
      "flags": 19,
      "owner": 36,
      "location": -1,
      "parents": [
        40
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "eval",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "\"eval(code)\";",
            "\"Evaluate code with $no_one's permissions (so you won't damage anything).\";",
            "\"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.\";",
            "\"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.\";",
            "exp = args[1];",
            "if (this:bad_eval(exp))",
            "return E_PERM;",
            "endif",
            "set_task_perms(this);",
            "if (exp[1] != \";\")",
            "return eval(tostr(\"this=\", caller, \"; return \", exp, \";\"));",
            "else",
            "return eval(tostr(\"this=\", caller, \";\", exp, \";\"));",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "return 0;"
          ]
        },
        {
          "name": "eval_d",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "\":eval_d(code)\";",
            "\"exactly like :eval except that the d flag is unset\";",
            "\"Evaluate code with $no_one's permissions (so you won't damage anything).\";",
            "\"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.\";",
            "\"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.\";",
            "exp = args[1];",
            "if (this:bad_eval(exp))",
            "return E_PERM;",
            "endif",
            "set_task_perms(this);",
            "if (exp[1] != \";\")",
            "return $code_utils:eval_d(tostr(\"this=\", caller, \"; return \", exp, \";\"));",
            "else",
            "return $code_utils:eval_d(tostr(\"this=\", caller, \";\", exp, \";\"));",
            "endif"
          ]
        },
        {
          "name": "call_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "\"call_verb(object, verb name, args)\";",
            "\"Call verb with $no_one's permissions (so you won't damage anything).\";",
            "\"One could do this with $no_one:eval, but ick.\";",
            "set_task_perms(this);",
            "return args[1]:(args[2])(@args[3]);"
          ]
        },
        {
          "name": "bad_eval",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "\":bad_eval(exp)\";",
            "\"  Returns 1 if the `exp' is inappropriate for use by $no_one.  In particular, if `exp' contains calls to `eval', `fork', `suspend', or `call_function' it is bad.  Similarly, if `player' is a nonvalid object the expression is considered `bad' because it is likely an attempt to anonymously spoof.\";",
            "\"  At present, the checks for bad builtins are overzealous.  It should check for delimited uses of the above calls, in case someone has a variable called `prevalent'.\";",
            "{exp} = args;",
            "if (((index(exp, \"eval\") || index(exp, \"fork\")) || index(exp, \"suspend\")) || index(exp, \"call_function\"))",
            "\"Well, they had one of the evil words in here.  See if it was in a quoted string or not -- we want to permit player:tell(\\\"Gentlemen use forks.\\\")\";",
            "for bad in ({\"eval\", \"fork\", \"suspend\", \"call_function\"})",
            "tempindex = 1;",
            "while (l = index(exp[tempindex..$], bad, 0))",
            "if ($code_utils:inside_quotes(exp[1..(tempindex + l) - 1]))",
            "tempindex = tempindex + l;",
            "else",
            "\"it's there, bad unquoted string\";",
            "return 1;",
            "endif",
            "endwhile",
            "endfor",
            "endif",
            "if ((!$recycler:valid(player)) && (player >= #0))",
            "return 1;",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "set_*",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 38,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "return pass(@args);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "queued_task_limit"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": "Everyman ($no_one) can not receive mail.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [],
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": "",
          "owner": 2,
          "perms": 0
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "... no one out there to see it.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": -10000,
          "owner": 36,
          "perms": 0
        },
        {
          "value": -1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            0,
            0,
            1671219241,
            0
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Everyman",
            "everyone",
            "no_one",
            "noone"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "The character used for \"safe\" evals.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            8606,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "39": {
      "id": 39,
      "name": "Player Database",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        37
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "load",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "\":load() -- reloads the player_db with the names of all existing players.\";",
            "\"This routine calls suspend() if it runs out of time.\";",
            "\".frozen is set to 1 while the load is in progress so that other routines are warned and don't try to do any updates.  Sometimes, an update is unavoidable (e.g., player gets recycled) in which case the offending routine should set .frozen to 2, causing the load to start over at the beginning.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "\"...N.B. clearall suspends, therefore we put the .frozen mark on FIRST...\";",
            "this.frozen = 1;",
            "this:clearall();",
            "for p in (players())",
            "this:suspend_restart(p);",
            "\"... note that if a player is recycled or toaded during the suspension,...\";",
            "\"... it won't be removed from the for loop iteration; thus this test:     \";",
            "if (valid(p) && is_player(p))",
            "if (typeof(po = this:find_exact(p.name)) == ERR)",
            "player:tell(p.name, \":  \", po);",
            "return;",
            "elseif (po != p)",
            "if (valid(po) && is_player(po))",
            "player:tell(\"name `\", p.name, \"' for \", p, \" subsumes alias for \", po.name, \"(\", po, \").\");",
            "endif",
            "this:insert(p.name, p);",
            "endif",
            "for a in (p.aliases)",
            "this:suspend_restart(p);",
            "if (index(a, \" \") || index(a, \"\t\"))",
            "\"don't bother, space or tab\";",
            "elseif (typeof(ao = this:find_exact(a)) == ERR)",
            "player:tell(a, \":  \", ao);",
            "return;",
            "elseif (!(valid(ao) && is_player(ao)))",
            "this:insert(a, p);",
            "elseif (ao != p)",
            "player:tell(\"alias `\", a, \"' for \", p.name, \"(\", p, \") used by \", ao.name, \"(\", ao, \").\");",
            "endif",
            "endfor",
            "endif",
            "endfor",
            "this.frozen = 0;"
          ]
        },
        {
          "name": "check",
          "owner": 36,
          "perms": 45,
          "preps": -1,
          "object": 39,
          "code": [
            "\":check() -- checks for recycled and toaded players that managed not to get expunged from the db.\";",
            "for p in (properties($player_db))",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "player:tell(\"...\", p);",
            "suspend(0);",
            "endif",
            "if (p[1] == \" \")",
            "nlist = this.(p)[3];",
            "olist = this.(p)[4];",
            "for i in [1..length(nlist)]",
            "if (valid(olist[i]) && (is_player(olist[i]) && (nlist[i] in olist[i].aliases)))",
            "else",
            "player:tell(\".\", p[2..$], \" <- \", nlist[i], \" \", olist[i]);",
            "endif",
            "endfor",
            "endif",
            "endfor",
            "player:tell(\"done.\");"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.reserved = {};",
            "this:load();",
            "endif"
          ]
        },
        {
          "name": "available",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "\":available(name,who) => 1 if a name is available for use, or the object id of whoever is currently using it, or 0 if the name is otherwise forbidden.\";",
            "\"If $player_db is not .frozen and :available returns 1, then $player:set_name will succeed.\";",
            "{name, ?target = valid(caller) ? caller | player} = args;",
            "if ((name in this.stupid_names) || (name in this.reserved))",
            "return 0;",
            "elseif (target in $wiz_utils.rename_restricted)",
            "return 0;",
            "elseif (((((!name) || index(name, \" \")) || index(name, \"\\\\\")) || index(name, \"\\\"\")) || index(name, \"\t\"))",
            "return 0;",
            "elseif (index(\"*#()\", name[1]))",
            "return 0;",
            "elseif (match(name, \"(#[0-9]+)\"))",
            "return 0;",
            "elseif (valid(who = this:find_exact(name)) && is_player(who))",
            "return who;",
            "elseif ($object_utils:has_callable_verb($local, \"legal_name\") && (!$local:legal_name(name, target)))",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "suspend_restart",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "\"used during :load to do the usual out-of-time check.\";",
            "\"if someone makes a modification during the suspension (indicated by this.frozen being set to 2), we have to restart the entire load.\";",
            "if (caller != this)",
            "return E_PERM;",
            "elseif ($command_utils:running_out_of_time())",
            "player:tell(\"...\", args[1]);",
            "set_task_perms($byte_quota_utils:task_perms());",
            "suspend(0);",
            "if (this.frozen != 1)",
            "player:tell(\"...argh... restarting $player_db:load...\");",
            "fork (0)",
            "this:load();",
            "endfork",
            "kill_task(task_id());",
            "endif",
            "endif"
          ]
        },
        {
          "name": "why_bad_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "\":why_bad_name(player, namespec) => Returns a message explaining why a player name change is invalid.  Stolen from APHiD's #15411:name_okay.\";",
            "who = args[1];",
            "name = $building_utils:parse_names(args[2])[1];",
            "si = index(name, \" \");",
            "qi = index(name, \"\\\"\");",
            "bi = index(name, \"\\\\\");",
            "ti = index(name, \"\t\");",
            "if (((si || qi) || bi) || ti)",
            "return tostr(\"You may not use a name containing \", $string_utils:english_list({@si ? {\"spaces\"} | {}, @qi ? {\"quotation marks\"} | {}, @bi ? {\"backslashes\"} | {}, @ti ? {\"tabs\"} | {}}, \"ERROR\", \" or \"), \".  Try \\\"\", strsub(strsub(strsub(strsub(name, \" \", \"_\"), \"\\\"\", \"'\"), \"\\\\\", \"/\"), \"\t\", \"___\"), \"\\\" instead.\");",
            "elseif (name == \"\")",
            "return tostr(\"You may not use a blank name.\");",
            "elseif (i = index(\"*#()\", name[1]))",
            "return tostr(\"You may not begin a name with the \\\"\", \"*#()\"[i], \"\\\" character.\");",
            "elseif (match(name, \"(#[0-9]+)\"))",
            "return tostr(\"A name can't contain a parenthesized object number.\");",
            "elseif (name in $player_db.stupid_names)",
            "return tostr(\"The name \\\"\", name, \"\\\" would probably cause problems in command parsing or similar usage.\");",
            "elseif (name in $player_db.reserved)",
            "return tostr(\"The name \\\"\", name, \"\\\" is reserved.\");",
            "elseif (length(name) > $login.max_player_name)",
            "return tostr(\"The name \\\"\", name, \"\\\" is too long.  Maximum name length is \", $login.max_player_name, \" characters.\");",
            "elseif ((valid(match = $player_db:find_exact(name)) && is_player(match)) && (who != match))",
            "return tostr(\"The name \\\"\", name, \"\\\" is already being used by \", match.name, \"(\", match, \").\");",
            "elseif ($player_db.frozen)",
            "return tostr(\"$player_db is not accepting new changes at the moment.\");",
            "elseif ($object_utils:has_callable_verb($local, \"legal_name\") && (!$local:legal_name(name, who)))",
            "return \"That name is reserved.\";",
            "elseif (who in $wiz_utils.rename_restricted)",
            "return \"This player is not allowed to change names.\";",
            "endif"
          ]
        },
        {
          "name": "insert",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 39,
          "code": [
            "((typeof(args[1]) == NUM) && (typeof(args[2]) == STR)) && (args[2] = $ansi_utils:delete(args[2]));",
            "(typeof(args[1]) == STR) && (args[1] = $ansi_utils:delete(args[1]));",
            "return pass(@args);"
          ]
        }
      ],
      "propnames": [
        "stupid_names",
        "frozen",
        "reserved",
        " H",
        " e",
        " n",
        " Ev"
      ],
      "propdefs": [
        {
          "value": [
            "with",
            "using",
            "at",
            "to",
            "in",
            "into",
            "on",
            "onto",
            "upon",
            "out",
            "from",
            "inside",
            "over",
            "through",
            "under",
            "underneath",
            "beneath",
            "behind",
            "beside",
            "for",
            "about",
            "is",
            "as",
            "off",
            "of",
            "me",
            "you",
            "here"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "",
            [
              "Hacker",
              "housekeeper"
            ],
            [
              36,
              71
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "v",
            [
              "Editor_Owner"
            ],
            [
              96
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "o",
            "",
            [
              "noone",
              "no_one"
            ],
            [
              38,
              38
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "ery",
            "",
            [
              "everyone",
              "Everyman"
            ],
            [
              38,
              38
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "",
            "Hen",
            [
              "programmer",
              "generic",
              "Core",
              "Wizard"
            ],
            [
              98,
              98,
              98,
              2
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "player_db",
            "plyrdb",
            "pdb"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "A database containing all player names and aliases.  ",
            "See `help $player_db' for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            12464,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "40": {
      "id": 40,
      "name": "Generic Mail Receiving Player",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        100
      ],
      "children": [
        88,
        38
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "mail_forward",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "if (typeof(mf = this.(verb)) == STR)",
            "return $string_utils:pronoun_sub(mf, @args);",
            "else",
            "return mf;",
            "endif"
          ]
        },
        {
          "name": "receive_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":receive_message(msg,from)\";",
            "if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))",
            "return E_PERM;",
            "endif",
            "if (this:mail_option(\"no_dupcc\", args[1][1], args[1][2]))",
            "\"pass to :mail_option the TEXT versions of who the message is from and to\";",
            "recipients = setremove($mail_agent:parse_address_field(args[1][3]), this);",
            "for x in (recipients)",
            "if (this:get_current_message(x))",
            "return 0;",
            "endif",
            "endfor",
            "endif",
            "if (this:mail_option(\"netmail\"))",
            "msg = args[1];",
            "message = {\"Forwarded: \" + msg[4], \"Original-date: \" + ctime(msg[1]), \"Original-From: \" + msg[2], \"Original-To: \" + msg[3], (((\"Reply-To: \" + $string_utils:substitute(args[2].name, {{\"@\", \"%\"}})) + \"@\") + $network.moo_name) + \".moo.mud.org\"};",
            "for x in (msg[5..$])",
            "message = {@message, @$generic_editor:fill_string(x, this:linelen())};",
            "endfor",
            "if (this:send_self_netmail(message, @listdelete(args, 1)) == 0)",
            "return 0;",
            "endif",
            "endif",
            "set_task_perms(this.owner);",
            "new = this:new_message_num();",
            "ncur = (new <= 1) ? 0 | min(this:current_message(this), new);",
            "this:set_current_message(this, ncur);",
            "new = max(new, ncur + 1);",
            "this.messages = {@this.messages, {new, args[1]}};",
            "\"... new-mail notification is now done directly by $mail_agent:raw_send\";",
            "\"... see :notify_mail...\";",
            "return new;"
          ]
        },
        {
          "name": "display_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":display_message(preamble,msg) --- prints msg to player.\";",
            "vb = ((this._mail_task == task_id()) || (caller == $mail_editor)) ? \"notify_lines_suspended\" | \"tell_lines_suspended\";",
            "preamble = args[1];",
            "player:(vb)({@(typeof(preamble) == LIST) ? preamble | {preamble}, @args[2], \"--------------------------\"});"
          ]
        },
        {
          "name": "parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_date_gt length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string rm_message_seq undo_rmm expunge_rmm renumber keep_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\"parse_message_seq(strings,cur)         => msg_seq\";",
            "\"messages_in_seq(msg_seq);              => text of messages in msg_seq\";",
            "\"display_seq_headers(msg_seq[,current]) :displays summary lines of those msgs\";",
            "\"rmm_message_seq(msg_seq)               => string giving msg numbers removed\";",
            "\"undo_rmm()    => msg_seq of restored messages\";",
            "\"expunge_rmm() => number of messages expunged\";",
            "\"list_rmm()    => number of messages awaiting expunge\";",
            "\"renumber(cur) => {number of messages in folder, new_cur}\";",
            "\"\";",
            "\"See the corresponding routines on $mail_agent.\";",
            "if ((caller == $mail_agent) || $perm_utils:controls(caller_perms(), this))",
            "set_task_perms(this.owner);",
            "return $mail_agent:(verb)(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "msg_summary_line",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "return $mail_agent:msg_summary_line(@args);"
          ]
        },
        {
          "name": "msg_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":msg_text(@msg) => list of strings.\";",
            "\"msg is a mail message (in the usual transmission format) being read BY this player.\";",
            "\"The default version of recipient:msg_full_text calls this to obtain the actual list of strings to display.  (this is a badly named verb).\";",
            "\"returns the actual list of strings to display.\";",
            "return $mail_agent:to_text(@args);"
          ]
        },
        {
          "name": "notify_mail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":notify_mail(from,recipients[,msgnums])\";",
            "\" used by $mail_agent:raw_send to notify this player about mail being sent\";",
            "\" from <from> to <recipients>.  <msgnums> if given gives the message number(s) assigned (in the event that the corresponding recipient actually kept the mail)\";",
            "if (!$object_utils:connected(this))",
            "return;",
            "elseif (!((caller in {this, $mail_agent}) || $perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "else",
            "{from, recipients, ?msgnums = {}} = args;",
            "from_name = $mail_agent:name(from);",
            "\"... msgnums may be shorter than recipients or may have some slots filled\";",
            "\"... with 0's if msg numbers are not available for some recipients.\";",
            "if ((t = this in recipients) && ((length(msgnums) >= t) && msgnums[t]))",
            "\"... you are getting the mail and moreover your :receive_message kept it.\";",
            "namelist = $string_utils:english_list($list_utils:map_arg($mail_agent, \"name\", setremove(recipients, this)), \"\");",
            "this:notify(tostr(\"You have new mail (\", msgnums[t], \") from \", from_name, namelist ? \" which was also sent to \" + namelist | \"\", \".\"));",
            "if (!this:mail_option(\"expert\"))",
            "this:notify(tostr(\"Type `help mail' for info on reading it.\"));",
            "endif",
            "else",
            "\"... vanilla notification; somebody got sent mail and you're finding out.\";",
            "namelist = $string_utils:english_list({@t ? {\"You\"} | {}, @$list_utils:map_arg($mail_agent, \"name\", setremove(recipients, this))}, \"\");",
            "this:tell(tostr(namelist, (length(recipients) == 1) ? \" has\" | \" have\", \" just been sent new mail by \", from_name, \".\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "current_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":current_message([recipient])\";",
            "\" => current message number for the given recipient (defaults to this).\";",
            "\" => 0 if we have no record of that recipient\";",
            "\"      or current message happens to be 0.\";",
            "\"This verb is mostly obsolete; consider using :get_current_message()\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "raise(E_PERM);",
            "elseif ((!args) || (args[1] == this))",
            "return this.current_message[1];",
            "elseif (a = $list_utils:assoc(args[1], this.current_message))",
            "return a[2];",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "get_current_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":get_current_message([recipient])\";",
            "\" => {msg_num, last_read_date} for the given recipient.\";",
            "\" => 0 if we have no record of that recipient.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "raise(E_PERM);",
            "elseif ((!args) || (args[1] == this))",
            "if (length(this.current_message) < 2)",
            "\"Whoops, this got trashed---fix it up!\";",
            "this.current_message = {0, time(), @this.current_message};",
            "endif",
            "return this.current_message[1..2];",
            "elseif (a = $list_utils:assoc(args[1], this.current_message))",
            "return a[2..3];",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "set_current_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":set_current_message(recipient[,number[,date]])\";",
            "\"Returns the new {number,last-read-date} pair for recipient.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "raise(E_PERM);",
            "endif",
            "{recip, ?number = E_NONE, ?date = 0, ?force = 0} = args;",
            "cm = this.current_message;",
            "if (recip == this)",
            "this.current_message[2] = max(date, cm[2]);",
            "if (number != E_NONE)",
            "this.current_message[1] = number;",
            "endif",
            "return this.current_message[1..2];",
            "elseif (i = $list_utils:iassoc(recip, cm))",
            "if (force)",
            "\"`force' is assumed to come from `@unread'\";",
            "return (this.current_message[i] = {recip, number, date})[2..3];",
            "else",
            "return (this.current_message[i] = {recip, (number == E_NONE) ? cm[i][2] | number, max(date, cm[i][3])})[2..3];",
            "endif",
            "else",
            "entry = {recip, (number != E_NONE) && number, date};",
            "this.current_message = {@cm, entry};",
            "return entry[2..3];",
            "endif"
          ]
        },
        {
          "name": "make_current_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":make_current_message(recipient[,index])\";",
            "\"starts a new current_message record for recipient.\";",
            "\"index, if given, indicates where recipient is to be\";",
            "\"  placed (n = at or after nth entry in .current_message).\";",
            "recip = args[1];",
            "cm = this.current_message;",
            "if (length(args) > 1)",
            "i = max(2, min(args[2], length(cm)));",
            "else",
            "i = 0;",
            "endif",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "raise(E_PERM);",
            "elseif (recip == this)",
            "\"...self...\";",
            "elseif (j = $list_utils:iassoc(recip, cm))",
            "\"...already present...\";",
            "if (i)",
            "if (j < i)",
            "this.current_message = {@cm[1..j - 1], @cm[j + 1..i], cm[j], @cm[i + 1..$]};",
            "elseif (j > (i + 1))",
            "this.current_message = {@cm[1..i], cm[j], @cm[i + 1..j - 1], @cm[j + 1..$]};",
            "endif",
            "endif",
            "else",
            "this.current_message = listappend(cm, {recip, 0, 0}, @i ? {i} | {});",
            "endif"
          ]
        },
        {
          "name": "kill_current_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":kill_current_message(recipient)\";",
            "\"entirely forgets current message for this recipient...\";",
            "\"Returns true iff successful.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "raise(E_PERM);",
            "else",
            "return ((recip = args[1]) != this) && ((i = $list_utils:iassoc(recip, cm = this.current_message)) && (this.current_message = listdelete(cm, i)));",
            "endif"
          ]
        },
        {
          "name": "current_folder",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":current_folder() => default folder to use, always an object, usually `this'\";",
            "set_task_perms(caller_perms());",
            "return ((!this:mail_option(\"sticky\")) || this.current_folder) && this;"
          ]
        },
        {
          "name": "set_current_folder",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "set_task_perms(caller_perms());",
            "return this.current_folder = args[1];"
          ]
        },
        {
          "name": "parse_folder_spec",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":parse_folder_spec(verb,args,expected_preposition[,allow_trailing_args_p])\";",
            "\" => {folder, msg_seq_args, trailing_args}\";",
            "set_task_perms(caller_perms());",
            "folder = this:current_folder();",
            "if (!prepstr)",
            "return {folder, args[2], {}};",
            "endif",
            "{verb, args, prep, ?extra = 0} = args;",
            "p = prepstr in args;",
            "if (prepstr != prep)",
            "\"...unexpected preposition...\";",
            "if (extra && (!index(prepstr, \" \")))",
            "return {folder, args[1..p - 1], args[p..$]};",
            "else",
            "player:tell(\"Usage:  \", verb, \" [<message numbers>] [\", prep, \" <folder/list-name>]\");",
            "endif",
            "elseif (!((p < length(args)) && (fname = args[p + 1])))",
            "\"...preposition but no iobj...\";",
            "player:tell(verb, \" \", $string_utils:from_list(args, \" \"), \" WHAT?\");",
            "elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname, this), fname))",
            "\"...bogus mail folder...\";",
            "else",
            "return {folder, args[1..p - 1], args[p + 2..$]};",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "parse_mailread_cmd",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":parse_mailread_cmd(verb,args,default,prep[,trailer])\";",
            "\"  handles anything of the form  `VERB message_seq [PREP folder ...]'\";",
            "\"    default is the default msg-seq to use if none given\";",
            "\"    prep is the expected prepstr (assumes prepstr is set), usually `on'\";",
            "\"    trailer, if present and true, indicates trailing args are permitted.\";",
            "\"  returns {recipient object, message_seq, current_msg,\\\"...\\\"} or 0\";",
            "set_task_perms(caller_perms());",
            "if (!(pfs = this:parse_folder_spec(@listdelete(args, 3))))",
            "return 0;",
            "endif",
            "{verb, args, default, prep, ?extra = 0} = args;",
            "folder = pfs[1];",
            "cur = this:get_current_message(folder) || {0};",
            "if (typeof(pms = folder:parse_message_seq(pfs[2], @cur)) == LIST)",
            "rest = {@listdelete(pms, 1), @pfs[3]};",
            "if ((!extra) && rest)",
            "\"...everything should have been gobbled by :parse_message_seq...\";",
            "player:tell(\"I don't understand `\", rest[1], \"'\");",
            "return 0;",
            "elseif (pms[1])",
            "\"...we have a nonempty message sequence...\";",
            "return {folder, pms[1], cur, rest};",
            "elseif (used = (length(pfs[2]) + 1) - length(pms))",
            "\"...:parse_message_seq used some words, but didn't get anything out of it\";",
            "pms = (\"%f %<has> no `\" + $string_utils:from_list(pfs[2][1..used], \" \")) + \"' messages.\";",
            "elseif (typeof(pms = folder:parse_message_seq(default, @cur)) == LIST)",
            "\"...:parse_message_seq used nothing, try the default; wow it worked\";",
            "return {folder, pms[1], cur, rest};",
            "endif",
            "elseif (typeof(pms) == ERR)",
            "player:tell($mail_agent:name(folder), \" is not readable by you.\");",
            "if (!$object_utils:isa(folder, $mail_recipient))",
            "player:tell(\"Use * to indicate a non-player mail recipient.\");",
            "endif",
            "return 0;",
            "endif",
            "if (folder == this)",
            "subst = {{\"%f's\", \"Your\"}, {\"%f\", \"You\"}, {\"%<has>\", \"have\"}};",
            "elseif (is_player(folder))",
            "subst = {{\"%f\", folder.name}, {\"%<has>\", $gender_utils:get_conj(\"has\", folder)}};",
            "else",
            "subst = {{\"%f\", $mail_agent:name(folder)}, {\"%<has>\", \"has\"}};",
            "endif",
            "player:tell($string_utils:substitute(pms, {@subst, {\"%%\", \"%\"}}));",
            "return 0;"
          ]
        },
        {
          "name": "@mail",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@mail <msg-sequence>                --- as in help @mail\";",
            "\"@mail <msg-sequence> on <recipient> --- shows mail on mailing list or player.\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "if (p = this:parse_mailread_cmd(\"@mail\", args, this:mail_option(\"@mail\") || $mail_agent.(\"player_default_@mail\"), \"on\"))",
            "this:set_current_folder(folder = p[1]);",
            "msg_seq = p[2];",
            "seq_size = $seq_utils:size(msg_seq);",
            "if ((lim = player:mail_option(\"manymsgs\")) && ((lim <= seq_size) && (!$command_utils:yes_or_no(tostr(\"You are about to see \", seq_size, \" message headers.  Continue?\")))))",
            "player:notify(tostr(\"Aborted.  @mailoption manymsgs=\", lim));",
            "return;",
            "endif",
            "if (1 != seq_size)",
            "player:notify(tostr(seq_size, \" messages\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\"));",
            "endif",
            "folder:display_seq_headers(msg_seq, @p[3]);",
            "endif"
          ]
        },
        {
          "name": "@read @peek",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@read <msg>...                  -- as in help @read\";",
            "\"@read <msg>... on *<recipient>  -- reads messages on recipient.\";",
            "\"@peek ...                       -- like @read, but don't set current message\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "if (p = this:parse_mailread_cmd(\"@read\", args, \"\", \"on\"))",
            "this:set_current_folder(folder = p[1]);",
            "msg_seq = p[2];",
            "if ((lim = player:mail_option(\"manymsgs\")) && ((lim <= (seq_size = $seq_utils:size(msg_seq))) && (!$command_utils:yes_or_no(tostr(\"You are about to see \", seq_size, \" messages.  Continue?\")))))",
            "player:notify(tostr(\"Aborted.  @mailoption manymsgs=\", lim));",
            "return;",
            "endif",
            "this._mail_task = task_id();",
            "if (cur = folder:display_seq_full(msg_seq, tostr(\"Message %d\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\")))",
            "if (verb != \"@peek\")",
            "this:set_current_message(folder, @cur);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@next @prev",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "set_task_perms(player.owner);",
            "if (dobjstr && (!(n = toint(dobjstr))))",
            "player:notify(tostr(\"Usage:  \", verb, \" [<number>] [on <recipient>]\"));",
            "elseif (dobjstr)",
            "this:(\"@read\")(tostr(verb[2..5], n), @listdelete(args, 1));",
            "else",
            "this:(\"@read\")(verb[2..5], @args);",
            "endif"
          ]
        },
        {
          "name": "@rmm*ail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@rmm <message-sequence> [from <recipient>].   Use @unrmm if you screw up.\";",
            "\" Beware, though.  @unrmm can only undo the most recent @rmm.\";",
            "set_task_perms(player);",
            "if (!(p = this:parse_mailread_cmd(\"@rmm\", args, \"cur\", \"from\")))",
            "\"...parse failed, we've already complained...\";",
            "elseif ((!prepstr) && ((p[1] != this) && (!$command_utils:yes_or_no((\"@rmmail from \" + $mail_agent:name(p[1])) + \".  Continue?\"))))",
            "\"...wasn't the folder player was expecting...\";",
            "player:notify(\"@rmmail aborted.\");",
            "else",
            "this:set_current_folder(folder = p[1]);",
            "e = folder:rm_message_seq(p[2]);",
            "if (typeof(e) == ERR)",
            "player:notify(tostr($mail_agent:name(folder), \":  \", e));",
            "else",
            "count = ((n = $seq_utils:size(p[2])) == 1) ? \".\" | tostr(\" (\", n, \" messages).\");",
            "fname = (folder == this) ? \"\" | (\" from \" + $mail_agent:name(folder));",
            "player:notify(tostr(\"Deleted \", e, fname, count));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@renumber",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 40,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "folder = this:current_folder();",
            "elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(dobjstr), dobjstr))",
            "return;",
            "endif",
            "cur = this:current_message(folder);",
            "fname = $mail_agent:name(folder);",
            "if (typeof(h = folder:renumber(cur)) == ERR)",
            "player:notify(tostr(h));",
            "else",
            "if (!h[1])",
            "player:notify(tostr(\"No messages on \", fname, \".\"));",
            "else",
            "player:notify(tostr(\"Messages on \", fname, \" renumbered 1-\", h[1], \".\"));",
            "this:set_current_folder(folder);",
            "if (h[2] && this:set_current_message(folder, h[2]))",
            "player:notify(tostr(\"Current message is now \", h[2], \".\"));",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@unrmm*ail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@unrmm [on <recipient>]  -- undoes the previous @rmm on that recipient.\";",
            "set_task_perms(player);",
            "if (!(p = this:parse_folder_spec(\"@unrmm\", args, \"on\")))",
            "return;",
            "endif",
            "dobjstr = $string_utils:from_list(p[2], \" \");",
            "keep = 0;",
            "if ((!dobjstr) || (keep = index(\"keep\", dobjstr) == 1))",
            "do = \"undo_rmm\";",
            "elseif (index(\"expunge\", dobjstr) == 1)",
            "do = \"expunge_rmm\";",
            "elseif (index(\"list\", dobjstr) == 1)",
            "do = \"list_rmm\";",
            "else",
            "player:notify(tostr(\"Usage:  \", verb, \" [expunge|list] [on <recipient>]\"));",
            "return;",
            "endif",
            "this:set_current_folder(folder = p[1]);",
            "if (msg_seq = folder:(do)(@keep ? {keep} | {}))",
            "if (do == \"undo_rmm\")",
            "player:notify(tostr($seq_utils:size(msg_seq), \" messages restored to \", $mail_agent:name(folder), \".\"));",
            "folder:display_seq_headers(msg_seq, 0);",
            "else",
            "player:notify(tostr(msg_seq, \" zombie message\", (msg_seq == 1) ? \" \" | \"s \", (do == \"expunge_rmm\") ? \"expunged from \" | \"on \", $mail_agent:name(folder), \".\"));",
            "endif",
            "elseif (typeof(msg_seq) == ERR)",
            "player:notify(tostr($mail_agent:name(folder), \":  \", msg_seq));",
            "else",
            "player:notify(tostr(\"No messages to \", (do == \"expunge_rmm\") ? \"expunge from \" | \"restore to \", $mail_agent:name(folder)));",
            "endif"
          ]
        },
        {
          "name": "@send",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 40,
          "code": [
            "if (args && (args[1] == \"to\"))",
            "args = listdelete(args, 1);",
            "endif",
            "subject = {};",
            "for a in (args)",
            "if (((i = index(a, \"=\")) > 3) && (index(\"subject\", a[1..i - 1]) == 1))",
            "args = setremove(args, a);",
            "a[1..i] = \"\";",
            "subject = {a};",
            "endif",
            "endfor",
            "$mail_editor:invoke(args, verb, @subject);"
          ]
        },
        {
          "name": "@answer @repl*y",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@answer <msg> [on *<recipient>] [<flags>...]\";",
            "set_task_perms(who = valid(caller_perms()) ? caller_perms() | player);",
            "if (p = this:parse_mailread_cmd(verb, args, \"cur\", \"on\", 1))",
            "if ($seq_utils:size(p[2]) != 1)",
            "player:notify(\"You can only answer *one* message at a time.\");",
            "elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(@p[4])))",
            "player:notify_lines({tostr(\"Usage:  \", verb, \" [message-# [on <recipient>]] [flags...]\"), \"where flags include any of:\", \"  all        reply to everyone\", \"  sender     reply to sender only\", \"  include    include the original message in your reply\", \"  noinclude  don't include the original in your reply\"});",
            "else",
            "this:set_current_folder(p[1]);",
            "$mail_editor:invoke(2, verb, p[1]:messages_in_seq(p[2])[1][2], @flags_replytos);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@forward",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@forward <msg> [on *<recipient>] to <recipient> [<recipient>...]\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "if (!(p = this:parse_mailread_cmd(verb, args, \"\", \"on\", 1)))",
            "\"...lose...\";",
            "return;",
            "elseif ($seq_utils:size(sequence = p[2]) != 1)",
            "player:notify(\"You can only forward *one* message at a time.\");",
            "return;",
            "elseif ((length(p[4]) < 2) || (p[4][1] != \"to\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" [<message>] [on <folder>] to <recip>...\"));",
            "return;",
            "endif",
            "recips = {};",
            "for rs in (listdelete(p[4], 1))",
            "if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))",
            "return;",
            "endif",
            "recips = {@recips, r};",
            "endfor",
            "this:set_current_folder(folder = p[1]);",
            "m = folder:messages_in_seq(sequence)[1];",
            "msgnum = m[1];",
            "msgtxt = m[2];",
            "from = msgtxt[2];",
            "if (msgtxt[4] != \" \")",
            "subject = tostr(\"[\", from, \":  \", msgtxt[4], \"]\");",
            "elseif ((h = \"\" in msgtxt) && (h < length(msgtxt)))",
            "subject = tostr(\"[\", from, \":  `\", msgtxt[h + 1][1..min(20, $)], \"']\");",
            "else",
            "subject = tostr(\"[\", from, \"]\");",
            "endif",
            "result = $mail_agent:send_message(player, recips, subject, $mail_agent:to_text(@msgtxt));",
            "if (!result)",
            "player:notify(tostr(result));",
            "elseif (result[1])",
            "player:notify(tostr(\"Message \", msgnum, @(folder == this) ? {} | {\" on \", $mail_agent:name(folder)}, \" @forwarded to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "else",
            "player:notify(\"Message not sent.\");",
            "endif"
          ]
        },
        {
          "name": "@gripe",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "$mail_editor:invoke($wiz_utils.gripe_recipients, \"@gripe\", \"@gripe: \" + argstr);"
          ]
        },
        {
          "name": "@typo @bug @suggest*ion @idea @comment",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "subject = tostr($string_utils:capitalize(verb[2..$]), \":  \", (loc = this.location).name, \"(\", loc, \")\");",
            "if (this != player)",
            "return E_PERM;",
            "elseif (argstr)",
            "result = $mail_agent:send_message(this, {loc.owner}, subject, argstr);",
            "if (result && result[1])",
            "player:notify(tostr(\"Your \", verb, \" sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".  Input is appreciated, as always.\"));",
            "else",
            "player:notify(tostr(\"Huh?  This room's owner (\", loc.owner, \") is invalid?  Tell a wizard...\"));",
            "endif",
            "return;",
            "elseif (!($object_utils:isa(loc, $room) && loc.free_entry))",
            "player:notify_lines({tostr(\"You need to make it a one-liner, i.e., `\", verb, \" something or other'.\"), \"This room may not let you back in if you go to the Mail Room.\"});",
            "elseif ($object_utils:isa(loc, $generic_editor))",
            "player:notify_lines({tostr(\"You need to make it a one-liner, i.e., `\", verb, \" something or other'.\"), \"Sending you to the Mail Room from an editor is usually a bad idea.\"});",
            "else",
            "$mail_editor:invoke({tostr(loc.owner)}, verb, subject);",
            "endif",
            "if (verb == \"@bug\")",
            "player:notify(\"For a @bug report, be sure to mention exactly what it was you typed to trigger the error...\");",
            "endif"
          ]
        },
        {
          "name": "@skip",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@skip [*<folder/mailing_list>...]\";",
            "\"  sets your last-read time for the given lists to now, indicating your\";",
            "\"  disinterest in any new messages that might have appeared recently.\";",
            "set_task_perms(player);",
            "current_folder = this:current_folder();",
            "for a in (args || {0})",
            "if (a ? $mail_agent:match_failed(folder = $mail_agent:match_recipient(a), a) | (folder = this:current_folder()))",
            "\"...bogus folder name, done...  No, try anyway.\";",
            "if (this:kill_current_message(this:my_match_object(a)))",
            "player:notify(\"Invalid folder, but found it subscribed anyway.  Removed.\");",
            "endif",
            "else",
            "lseq = folder:length_all_msgs();",
            "unread = (n = this:get_current_message(folder)) ? folder:length_date_gt(n[2]) | lseq;",
            "this:set_current_message(folder, lseq && folder:messages_in_seq({lseq, lseq + 1})[1][1], time());",
            "player:notify(tostr(unread ? tostr(\"Ignoring \", unread) | \"No\", \" unread message\", (unread != 1) ? \"s\" | \"\", \" on \", $mail_agent:name(folder)));",
            "if (current_folder == folder)",
            "this:set_current_folder(this);",
            "endif",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "@subscribe*-quick @unsubscribed*-quick",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@subscribe *<folder/mailing_list> [with notification] [before|after *<folder>]\";",
            "\"  causes you to be notified when new mail arrives on this list\";",
            "\"@subscribe\";",
            "\"  just lists available mailing lists.\";",
            "\"@unsubscribed\";",
            "\"  prints out available mailing lists you aren't already subscribed to.\";",
            "\"@subscribe-quick and @unsubscribed-quick\";",
            "\"  prints out same as above except without mail list descriptions, just names.\";",
            "set_task_perms(player);",
            "quick = 0;",
            "if (qi = index(verb, \"-q\"))",
            "verb = verb[1..qi - 1];",
            "quick = 1;",
            "endif",
            "fname = {@args, 0}[1];",
            "if (!fname)",
            "ml = $list_utils:slice(this.current_message[3..$]);",
            "all_mlists = {@$mail_agent.contents, @this.mail_lists};",
            "if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr(\"There are \", length(all_mlists), \" mailing lists.  Are you sure you want the whole list?\"))))",
            "return player:tell(\"OK, aborting.\");",
            "endif",
            "for c in (all_mlists)",
            "$command_utils:suspend_if_needed(0);",
            "if ((c:is_usable_by(this) || c:is_readable_by(this)) && ((verb != \"@unsubscribed\") || (!(c in ml))))",
            "c:look_self(quick);",
            "endif",
            "endfor",
            "player:notify(tostr(\"-------- end of \", verb, \" -------\"));",
            "return;",
            "elseif (verb == \"@unsubscribed\")",
            "player:notify(\"@unsubscribed does not take arguments.\");",
            "return;",
            "elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname), fname))",
            "return;",
            "elseif (folder == this)",
            "player:notify(\"You don't need to @subscribe to yourself\");",
            "return;",
            "elseif ($object_utils:isa(folder, $mail_recipient) ? !folder:is_readable_by(this) | (!$perm_utils:controls(this, folder)))",
            "player:notify(\"That mailing list is not readable by you.\");",
            "return;",
            "endif",
            "notification = this in folder.mail_notify;",
            "i = 0;",
            "beforeafter = 0;",
            "while (length(args) >= 2)",
            "if (length(args) < 3)",
            "player:notify(args[2] + \" what?\");",
            "return;",
            "elseif (args[2] in {\"with\", \"without\"})",
            "with = args[2] == \"with\";",
            "if (index(\"notification\", args[3]) != 1)",
            "player:notify(tostr(\"with \", args[3], \"?\"));",
            "return;",
            "elseif (!$object_utils:isa(folder, $mail_recipient))",
            "player:notify(tostr(\"You cannot use \", verb, \" to change mail notification from a non-$mail_recipient.\"));",
            "elseif ((!with) == (!notification))",
            "\"... nothing to do...\";",
            "elseif (with)",
            "if (this in folder:add_notify(this))",
            "notification = 1;",
            "else",
            "player:notify(\"This mail recipient does not allow immediate notification.\");",
            "endif",
            "else",
            "folder:delete_notify(this);",
            "notification = 0;",
            "endif",
            "elseif (args[2] in {\"before\", \"after\"})",
            "if (beforeafter)",
            "player:notify((args[2] == beforeafter) ? tostr(\"two `\", beforeafter, \"'s?\") | \"Only use one of `before' or `after'\");",
            "return;",
            "elseif ($mail_agent:match_failed(other = $mail_agent:match_recipient(args[3]), args[3]))",
            "return;",
            "elseif (other == this)",
            "i = 2;",
            "elseif (!(i = $list_utils:iassoc(other, this.current_message)))",
            "player:notify(tostr(\"You aren't subscribed to \", $mail_agent:name(other), \".\"));",
            "return;",
            "endif",
            "beforeafter = args[2];",
            "i = i - (beforeafter == \"before\");",
            "if (this:mail_option(\"rn_order\") != \"fixed\")",
            "player:notify(\"Warning:  Do `@mail-option rn_order=fixed' if you do not want your @rn listing reordered when you next login.\");",
            "endif",
            "endif",
            "args[2..3] = {};",
            "endwhile",
            "this:make_current_message(folder, @i ? {i} | {});",
            "len = folder:length_all_msgs();",
            "player:notify(tostr($mail_agent:name(folder), \" has \", len, \" message\", (len == 1) ? \"\" | \"s\", \".\", notification ? \"  You will be notified immediately when new messages are posted.\" | \"  Notification of new messages will be printed when you connect.\"));",
            "this:set_current_folder(folder);"
          ]
        },
        {
          "name": "mail_catch_up",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "set_task_perms((caller == this) ? this.owner | caller_perms());",
            "this:set_current_folder(this);",
            "dates = new_cm = head = {};",
            "sort = this:mail_option(\"rn_order\") || \"read\";",
            "for n in (this.current_message)",
            "$command_utils:suspend_if_needed(0);",
            "if (typeof(n) != LIST)",
            "head = {@head, n};",
            "elseif ($object_utils:isa(folder = n[1], $mail_recipient) && folder:is_readable_by(this))",
            "\"...set current msg to be the last one you could possibly have read.\";",
            "if (n[3] < folder.last_msg_date)",
            "i = folder:length_date_le(n[3]);",
            "n[2] = i && folder:messages_in_seq(i)[1];",
            "endif",
            "if (sort == \"fixed\")",
            "new_cm = {n, @new_cm};",
            "elseif (sort == \"send\")",
            "j = $list_utils:find_insert(dates, folder.last_msg_date - 1);",
            "dates = listinsert(dates, folder.last_msg_date, j);",
            "new_cm = listinsert(new_cm, n, j);",
            "else",
            "new_cm = listappend(new_cm, n, $list_utils:iassoc_sorted(n[3] - 1, new_cm, 3));",
            "endif",
            "endif",
            "endfor",
            "this.current_message = {@head, @$list_utils:reverse(new_cm)};"
          ]
        },
        {
          "name": "@rn check_mail_lists @subscribed @rn-full",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 40,
          "code": [
            "set_task_perms((caller == this) ? this.owner | caller_perms());",
            "which = {};",
            "cm = this.current_message;",
            "cm[1..2] = ((verb == \"@rn\") || (verb == \"@rn-full\")) ? {{this, @cm[1..2]}} | {};",
            "all = verb == \"@subscribed\";",
            "fast = this:mail_option(\"fast_check\") && (verb != \"@rn-full\");",
            "for n in (cm)",
            "rcpt = n[1];",
            "if (rcpt == $news)",
            "\"... $news is handled separately ...\";",
            "elseif ($mail_agent:is_recipient(rcpt))",
            "if (fast)",
            "if (rcpt == this)",
            "nmsgs = ((m = this.messages) && (m[length(m)][2][1] > n[3])) ? $maxint | 0;",
            "else",
            "try",
            "nmsgs = (n[1].last_msg_date > n[3]) ? $maxint | 0;",
            "except (E_PERM, E_PROPNF)",
            "player:notify(tostr(\"Bogus recipient \", rcpt, \" removed from .current_message.\"));",
            "this.current_message = setremove(this.current_message, n);",
            "nmsgs = 0;",
            "endtry",
            "endif",
            "else",
            "nmsgs = n[1]:length_date_gt(n[3]);",
            "endif",
            "if (nmsgs || all)",
            "which = {@which, {n[1], nmsgs}};",
            "endif",
            "else",
            "player:notify(tostr(\"Bogus recipient \", rcpt, \" removed from .current_message.\"));",
            "this.current_message = setremove(this.current_message, n);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (which)",
            "player:notify(tostr((verb == \"@subscribed\") ? \"You are subscribed to the following\" | \"There is new activity on the following\", (length(which) > 1) ? \" lists:\" | \" list:\"));",
            "for w in (which)",
            "name = (w[1] == this) ? \" me\" | $mail_agent:name(w[1]);",
            "player:notify(tostr($string_utils:left(\"    \" + name, 40), \" \", (w[2] == $maxint) ? \"has\" | w[2], \" new message\", (w[2] == 1) ? \"\" | \"s\"));",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (verb != \"check_mail_lists\")",
            "player:notify(\"-- End of listing\");",
            "endif",
            "elseif ((verb == \"@rn\") || (verb == \"@rn-full\"))",
            "player:notify(\"No new activity on any of your lists.\");",
            "elseif (verb == \"@subscribed\")",
            "player:notify(\"You aren't subscribed to any mailing lists.\");",
            "endif",
            "return which;"
          ]
        },
        {
          "name": "mail_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":mail_option(name)\";",
            "\"Returns the value of the specified mail option\";",
            "if ((caller in {this, $mail_editor, $mail_agent}) || $perm_utils:controls(caller_perms(), this))",
            "return $options[\"mail\"]:get(this.mail_options, args[1]);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "@unsub*scribe",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@unsubscribe [*<folder/mailing_list> ...]\";",
            "\"entirely removes the record of your current message for the named folders,\";",
            "\"indicating your disinterest in anything that might appear there in the future.\";",
            "set_task_perms(player);",
            "unsubscribed = {};",
            "current_folder = this:current_folder();",
            "for a in (args || {0})",
            "if (a != 0)",
            "folder = $mail_agent:match_recipient(a);",
            "if (folder == $failed_match)",
            "folder = this:my_match_object(a);",
            "endif",
            "else",
            "folder = current_folder;",
            "endif",
            "if (!valid(folder))",
            "\"...bogus folder name...  try removing it anyway.\";",
            "if (this:kill_current_message(folder))",
            "player:notify(\"Invalid folder, but found it subscribed anyway.  Removed.\");",
            "else",
            "$mail_agent:match_failed(folder, a);",
            "endif",
            "elseif (folder == this)",
            "player:notify(tostr(\"You can't \", verb, \" yourself.\"));",
            "else",
            "if (!this:kill_current_message(folder))",
            "player:notify(tostr(\"You weren't subscribed to \", $mail_agent:name(folder)));",
            "if ($object_utils:isa(folder, $mail_recipient))",
            "result = folder:delete_notify(this);",
            "if ((typeof(result) == LIST) && (result[1] == this))",
            "player:notify(\"Removed you from the mail notifications list.\");",
            "endif",
            "endif",
            "else",
            "unsubscribed = {@unsubscribed, folder};",
            "if ($object_utils:isa(folder, $mail_recipient))",
            "folder:delete_notify(this);",
            "endif",
            "endif",
            "endif",
            "endfor",
            "if (unsubscribed)",
            "player:notify(tostr(\"Forgetting about \", $string_utils:english_list($list_utils:map_arg($mail_agent, \"name\", unsubscribed))));",
            "if (current_folder in unsubscribed)",
            "this:set_current_folder(this);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "send_self_netmail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":send_self_netmail(msg [ ,from ])\";",
            "\"return 0 if successful, otherwise error.\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "elseif (error = $network:invalid_email_address($wiz_utils:get_email_address(this)))",
            "return \"Invalid email address: \" + error;",
            "else",
            "msg = args[1];",
            "if (length(args) > 1)",
            "from = args[2];",
            "this:notify(tostr(\"Receiving mail from \", from:title(), \" (\", from, \") and forwarding it to your .email_address.\"));",
            "endif",
            "oplayer = player;",
            "player = this;",
            "error = $network:sendmail($wiz_utils:get_email_address(this), @msg);",
            "if (error && (length(args) > 1))",
            "this:notify(tostr(\"Mail sending failed: \", error));",
            "endif",
            "player = oplayer;",
            "return error;",
            "endif"
          ]
        },
        {
          "name": "@netforw*ard",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@netforward <msg>...                  -- as in help on @netforward\";",
            "\"@netforward <msg>... on *<recipient>  -- netforwards messages on recipient.\";",
            "\"This command forwards mail-messages to your registered email-address.\";",
            "if (player != this)",
            "return player:tell(E_PERM);",
            "endif",
            "if (reason = $network:email_will_fail(email = $wiz_utils:get_email_address(player)))",
            "return player:notify(tostr(\"Cannot forward mail to your email address: \", reason));",
            "endif",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "if (p = player:parse_mailread_cmd(verb, args, \"\", \"on\"))",
            "player:set_current_folder(folder = p[1]);",
            "msg_seq = p[2];",
            "folderstr = (folder == player) ? \"\" | tostr(\" from \", $mail_agent:name(folder));",
            "if ((!this:mail_option(\"expert_netfwd\")) && (!$command_utils:yes_or_no(tostr(\"You are about to forward \", seq_size = $seq_utils:size(msg_seq), \" message(s)\", folderstr, \" to your registered email-address, \", email, \".  Continue?\"))))",
            "player:notify(tostr(\"@Netforward cancelled.\"));",
            "return;",
            "endif",
            "player:notify(\"Attempting to send network mail...\");",
            "player._mail_task = task_id();",
            "multiple_vals = this:format_for_netforward(folder:messages_in_seq(msg_seq), folderstr);",
            "netmail = multiple_vals[1];",
            "header = multiple_vals[2];",
            "reason = player:send_self_netmail({header, @netmail});",
            "player:notify((reason == 0) ? tostr(\"@netforward of \", header, \" completed.\") | tostr(\"@netforward failed: \", reason, \".\"));",
            "endif"
          ]
        },
        {
          "name": "@@sendmail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"Syntax: @@sendmail\";",
            "\"This is intended for use with client editors.  You probably don't want to try using this command manually.\";",
            "\"Reads a formatted mail message, extracts recipients, subject line and/or reply-to header and sends message without going to the mailroom.  Example:\";",
            "\"\";",
            "\"@@send\";",
            "\"To: Rog (#4292)\";",
            "\"Subject: random\";",
            "\"\";",
            "\"first line\";",
            "\"second line\";",
            "\".\";",
            "\"\";",
            "\"Currently, header lines must have the same format as in an actual message.\";",
            "set_task_perms(player);",
            "if (args)",
            "player:notify(tostr(\"The \", verb, \" command takes no arguments.\"));",
            "$command_utils:read_lines();",
            "return;",
            "elseif (this != player)",
            "player:notify(tostr(\"You can't use \", this.pp, \" \", verb, \" verb.\"));",
            "$command_utils:read_lines();",
            "return;",
            "endif",
            "msg = $command_utils:read_lines();",
            "end_head = (\"\" in msg) || (length(msg) + 1);",
            "from = this;",
            "subject = \"\";",
            "replyto = \"\";",
            "rcpts = {};",
            "body = msg[end_head + 1..$];",
            "for i in [1..end_head - 1]",
            "line = msg[i];",
            "if (index(line, \"Subject:\") == 1)",
            "subject = $string_utils:trim(line[9..$]);",
            "elseif (index(line, \"To:\") == 1)",
            "if (!(rcpts = $mail_agent:parse_address_field(line)))",
            "player:notify(\"No recipients found in To: line\");",
            "return;",
            "endif",
            "elseif (index(line, \"Reply-to:\") == 1)",
            "if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..$]))",
            "player:notify(\"No address found in Reply-to: line\");",
            "return;",
            "endif",
            "elseif (index(line, \"From:\") == 1)",
            "\"... :send_message() bombs if designated sender != player ...\";",
            "if (!(from = $mail_agent:parse_address_field(line)))",
            "player:notify(\"No sender found in From: line\");",
            "return;",
            "elseif (length(from) > 1)",
            "player:notify(\"Multiple senders?\");",
            "return;",
            "endif",
            "from = from[1];",
            "elseif (i = index(line, \":\"))",
            "player:notify(tostr(\"Unknown header \\\"\", line[1..i], \"\\\"\"));",
            "return;",
            "else",
            "player:notify(\"Blank line must separate headers from body.\");",
            "return;",
            "endif",
            "endfor",
            "if (!rcpts)",
            "player:notify(\"No To: line found.\");",
            "elseif (!(subject || body))",
            "player:notify(\"Blank message not sent.\");",
            "else",
            "player:notify(\"Sending...\");",
            "result = $mail_agent:send_message(from, rcpts, replyto ? {subject, replyto} | subject, body);",
            "if (e = result && result[1])",
            "if (length(result) == 1)",
            "player:notify(\"Mail actually went to no one.\");",
            "else",
            "player:notify(tostr(\"Mail actually went to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "endif",
            "else",
            "player:notify(tostr((typeof(e) == ERR) ? e | (\"Bogus recipients:  \" + $string_utils:from_list(result[2]))));",
            "player:notify(\"Mail not sent.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@keep-m*ail @keepm*ail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@keep-mail [<msg-sequence>|none] [on <recipient>]\";",
            "\"marks the indicated messages as `kept'.\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "if (!args)",
            "return player:notify(\"Usage:  @keep-mail [<msg-sequence>|none] [on <recipient>]\");",
            "elseif (args[1] == \"none\")",
            "args[1..1] = {};",
            "if (!(pfs = this:parse_folder_spec(verb, args, \"on\", 0)))",
            "return;",
            "elseif (pfs[2])",
            "player:notify(tostr(verb, \" <message-sequence> or `none', but not both.\"));",
            "return;",
            "endif",
            "this:set_current_folder(folder = pfs[1]);",
            "if (e = folder:keep_message_seq({}))",
            "player:notify(tostr(\"Messages on \", $mail_agent:name(folder), \" are no longer marked as kept.\"));",
            "else",
            "player:notify(tostr(e));",
            "endif",
            "return;",
            "elseif (p = this:parse_mailread_cmd(verb, args, \"\", \"on\"))",
            "if ((folder = p[1]) != this)",
            "\"... maybe I'll take this clause out some day...\";",
            "player:notify(tostr(verb, \" can only be used on your own mail collection.\"));",
            "return;",
            "endif",
            "this:set_current_folder(folder);",
            "if (e = folder:keep_message_seq(msg_seq = p[2]))",
            "player:notify(tostr(\"Message\", match(e, \"[.,]\") ? \"s \" | \" \", e, \" now marked as kept.\"));",
            "elseif (typeof(e) == ERR)",
            "player:notify(tostr(e));",
            "else",
            "player:notify(tostr(((seq_size = $seq_utils:size(msg_seq)) == 1) ? \"That message is\" | \"Those messages are\", \" already marked as kept.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "my_match_recipient",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":my_match_recipient(string) => matches string against player's private mailing lists.\";",
            "if (!(string = args[1]))",
            "return $nothing;",
            "elseif (string[1] == \"*\")",
            "string = string[2..$];",
            "endif",
            "return $string_utils:match(string, this.mail_lists, \"aliases\");"
          ]
        },
        {
          "name": "expire_old_messages",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "set_task_perms(caller_perms());",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "else",
            "seq = this:expirable_msg_seq();",
            "if (seq)",
            "this:rm_message_seq(seq);",
            "return this:expunge_rmm();",
            "else",
            "return 0;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "msg_full_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":msg_full_text(@msg) => list of strings.\";",
            "\"msg is a mail message (in the usual transmission format).\";",
            "\"display_seq_full calls this to obtain the actual list of strings to display.\";",
            "return player:msg_text(@args);",
            "\"default is to leave it up to the player how s/he wants it to be displayed.\";"
          ]
        },
        {
          "name": "@resend",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@resend <msg> [on *<recipient>] to <recipient> [<recipient>...]\";",
            "set_task_perms(valid(caller_perms()) ? caller_perms() | player);",
            "\"...\";",
            "\"... parse command...\";",
            "\"...\";",
            "if (!(p = this:parse_mailread_cmd(verb, args, \"\", \"on\", 1)))",
            "\"...lose...\";",
            "return;",
            "elseif ($seq_utils:size(sequence = p[2]) != 1)",
            "player:notify(\"You can only resend *one* message at a time.\");",
            "return;",
            "elseif ((length(p[4]) < 2) || (p[4][1] != \"to\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" [<message>] [on <folder>] to <recip>...\"));",
            "return;",
            "endif",
            "recips = {};",
            "for rs in (listdelete(p[4], 1))",
            "if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))",
            "return;",
            "endif",
            "recips = {@recips, r};",
            "endfor",
            "this:set_current_folder(folder = p[1]);",
            "\"...\";",
            "\"... retrieve original message...\";",
            "\"...\";",
            "{msgnum, msgtxt} = folder:messages_in_seq(sequence)[1];",
            "if (forward_style = this:mail_option(\"resend_forw\"))",
            "\"...message will be from player...\";",
            "pmh = $mail_agent:parse_misc_headers(msgtxt, \"Reply-To\", \"Original-Date\", \"Original-From\");",
            "orig_from = pmh[3][3] || msgtxt[2];",
            "else",
            "\"...message will be from author...\";",
            "pmh = $mail_agent:parse_misc_headers(msgtxt, \"Reply-To\", \"Original-Date\", \"Original-From\", \"Resent-By\", \"Resent-To\");",
            "orig_from = pmh[3][3];",
            "from = $mail_agent:parse_address_field(msgtxt[2])[1];",
            "to = $mail_agent:parse_address_field(msgtxt[3]);",
            "endif",
            "\"...\";",
            "\"... report bogus headers...\";",
            "\"...\";",
            "if (bogus = pmh[2])",
            "player:notify(\"Bogus headers stripped from original message:\");",
            "for b in (bogus)",
            "player:notify(\"  \" + b);",
            "endfor",
            "if (!$command_utils:yes_or_no(\"Continue?\"))",
            "player:notify(\"Message not resent.\");",
            "return;",
            "endif",
            "endif",
            "\"...\";",
            "\"... subject, replyto, original-date, original-from ...\";",
            "\"...\";",
            "hdrs = {msgtxt[4], pmh[3][1], {\"Original-Date\", pmh[3][2] || ctime(msgtxt[1])}, @orig_from ? {{\"Original-From\", orig_from}} | {}, @pmh[1]};",
            "\"...\";",
            "\"... send it ...\";",
            "\"...\";",
            "if (forward_style)",
            "result = $mail_agent:send_message(player, recips, hdrs, pmh[4]);",
            "else",
            "\"... resend inserts resent-to and resent-by...\";",
            "result = $mail_agent:resend_message(player, recips, from, to, hdrs, pmh[4]);",
            "endif",
            "\"...\";",
            "\"... report outcome...\";",
            "\"...\";",
            "if (!result)",
            "player:notify(tostr(result));",
            "elseif (result[1])",
            "player:notify(tostr(\"Message \", msgnum, @(folder == this) ? {} | {\" on \", $mail_agent:name(folder)}, \" @resent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "else",
            "player:notify(\"Message not resent.\");",
            "endif"
          ]
        },
        {
          "name": "expirable_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\"Return a sequence indicating the expirable messages for this player.\";",
            "set_task_perms(caller_perms());",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "elseif (!(curmsg = this:get_current_message(this)))",
            "\"No messages!  Don't even try.\";",
            "return {};",
            "elseif (0 >= (period = this:mail_option(\"expire\") || $mail_agent.player_expire_time))",
            "\"...no expiration allowed here...\";",
            "return {};",
            "else",
            "return $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(min(time() - period, curmsg[2] - 86400)));",
            "\"... the 86400 is pure fudge...\";",
            "endif"
          ]
        },
        {
          "name": "format_for_netforward",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}\";",
            "set_task_perms(caller_perms());",
            "{message_seq, folderstr} = args;",
            "netmail = {};",
            "linelen = this:linelen();",
            "maxmsg = minmsg = 0;",
            "for msg in (message_seq)",
            "minmsg = minmsg ? min(msg[1], minmsg) | msg[1];",
            "maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];",
            "lines = {tostr(\"Message \", msg[1], folderstr, \":\"), tostr(\"Date:     \", ctime(msg[2][1])), \"From:     \" + msg[2][2], \"To:       \" + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {\"Subject:  \" + subj} | {}};",
            "for line in (msg[2][5..$])",
            "if (typeof(line) != STR)",
            "\"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.\";",
            "line = tostr(line);",
            "endif",
            "lines = {@lines, @$generic_editor:fill_string(line, linelen)};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "netmail = {@netmail, @lines, \"\", \"--------------------------\", \"\", \"\"};",
            "endfor",
            "header = tostr($network.MOO_name, \" Message(s) \", minmsg, @(minmsg != maxmsg) ? {\" - \", maxmsg} | {}, folderstr);",
            "return {netmail, header};"
          ]
        },
        {
          "name": "format_for_netforward_debug",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}\";",
            "set_task_perms(caller_perms());",
            "{message_seq, folderstr} = args;",
            "netmail = {};",
            "linelen = this:linelen();",
            "maxmsg = minmsg = 0;",
            "for msg in (message_seq)",
            "minmsg = minmsg ? min(msg[1], minmsg) | msg[1];",
            "maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];",
            "lines = {tostr(\"Message \", msg[1], folderstr, \":\"), tostr(\"Date:     \", ctime(msg[2][1])), \"From:     \" + msg[2][2], \"To:       \" + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {\"Subject:  \" + subj} | {}};",
            "for line in (msg[2][5..$])",
            "if (typeof(line) != STR)",
            "\"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.\";",
            "line = tostr(line);",
            "endif",
            "lines = {@lines, @$generic_editor:fill_string(line, linelen)};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "netmail = {@netmail, @lines, \"\", \"--------------------------\", \"\", \"\"};",
            "endfor",
            "header = tostr($network.MOO_name, \" Message(s) \", minmsg, @(minmsg != maxmsg) ? {\" - \", maxmsg} | {}, folderstr);",
            "return {netmail, header};"
          ]
        },
        {
          "name": "@nn",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 40,
          "code": [
            "\"@nn  -- reads the first new message on the first mail_recipient (in .current_message) where new mail exists.\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "cm = this.current_message;",
            "cm[1..2] = {{this, @cm[1..2]}};",
            "for n in (cm)",
            "if ($mail_agent:is_recipient(n[1]))",
            "if (new = n[1]:length_date_gt(n[3]))",
            "next = (n[1]:length_all_msgs() - new) + 1;",
            "this:set_current_folder(folder = n[1]);",
            "this._mail_task = task_id();",
            "cur = folder:display_seq_full({next, next + 1}, tostr(\"Message %d\", \" on \", $mail_agent:name(folder), \":\"));",
            "this:set_current_message(folder, @cur);",
            "return;",
            "endif",
            "else",
            "player:notify(tostr(\"Bogus recipient \", n[1], \" removed from .current_message.\"));",
            "this.current_message = setremove(this.current_message, n);",
            "endif",
            "endfor",
            "player:tell(\"No News (is good news)\");"
          ]
        },
        {
          "name": "@unread",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@unread <msg> [on *<recipient>]  -- resets last-read-date for recipient to just before the first of the indicated messages.\";",
            "set_task_perms(player);",
            "if (p = this:parse_mailread_cmd(\"@unread\", args, \"cur\", \"on\"))",
            "this:set_current_folder(folder = p[1]);",
            "msg_ord = $seq_utils:first(msg_seq = p[2]);",
            "msgdate = folder:messages_in_seq(msg_ord)[2][1] - 1;",
            "if ((!(cm = this:get_current_message(folder))) || (cm[2] < msgdate))",
            "player:notify(\"Already unread.\");",
            "else",
            "if (folder == this)",
            "this.current_message[2] = msgdate - 1;",
            "else",
            "\"this:kill_current_message(folder);\";",
            "this:set_current_message(folder, cm[1], min(cm[2], msgdate), 1);",
            "endif",
            "folder:display_seq_headers({msg_ord, msg_ord + 1}, cm[1], msgdate);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@refile @copym*ail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@refile/@copym*ail <msg-sequence> [on <recipient>] to <recipient>\";",
            "\"@refile will delete the messages from the source folder.  @copym does not.\";",
            "\"I'm not happy with this one, yet...\";",
            "set_task_perms(player);",
            "if (!(p = this:parse_mailread_cmd(\"@refile\", args, \"cur\", \"on\", 1)))",
            "\"...lose...\";",
            "elseif ((length(p[4]) != 2) || (p[4][1] != \"to\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" [<message numbers>] [on <folder>] to <folder>\"));",
            "elseif ($mail_agent:match_failed(dest = $mail_agent:match_recipient(p[4][2]), p[4][2]))",
            "\"...bogus destination folder...\";",
            "else",
            "source = p[1];",
            "msg_seq = p[2];",
            "for m in (source:messages_in_seq(msg_seq))",
            "if (!(e = dest:receive_message(m[2], source)))",
            "player:notify(tostr(\"Copying msg. \", m[1], \":  \", e));",
            "return;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (refile = verb == \"@refile\")",
            "if (typeof(e = source:rm_message_seq(msg_seq)) == ERR)",
            "player:notify(tostr(\"Deleting from \", source, \":  \", e));",
            "endif",
            "endif",
            "count = tostr(n = $seq_utils:size(msg_seq), \" message\", (n == 1) ? \"\" | \"s\");",
            "fname = (source == this) ? \"\" | tostr(is_player(source) ? \" from \" | \" from *\", source.name, \"(\", source, \")\");",
            "suffix = tostr(is_player(dest) ? \" to \" | \" to *\", dest.name, \"(\", dest, \").\");",
            "player:notify(tostr(refile ? \"Refiled \" | \"Copied \", count, fname, suffix));",
            "endif"
          ]
        },
        {
          "name": "@quickr*eply @qreply",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@qreply <msg> [on *<recipient>] [<flags>...]\";",
            "\"like @reply only, as in @qsend, we prompt for the message text using \";",
            "\"$command_utils:read_lines() rather than invoking the $mail_editor.\";",
            "set_task_perms(who = valid(cp = caller_perms()) ? cp | player);",
            "if (!(p = this:parse_mailread_cmd(verb, args, \"cur\", \"on\", 1)))",
            "\"...garbled...\";",
            "elseif ($seq_utils:size(p[2]) != 1)",
            "player:notify(\"You can only answer *one* message at a time.\");",
            "elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(\"noinclude\", @p[4])))",
            "player:notify_lines({tostr(\"Usage:  \", verb, \" [message-# [on <recipient>]] [flags...]\"), \"where flags include any of:\", \"  all        reply to everyone\", \"  sender     reply to sender only\", tostr(\"  include    include the original message in reply (can't do this for \", verb, \")\"), \"  noinclude  don't include the original in your reply\"});",
            "elseif (\"include\" in flags_replytos[1])",
            "player:notify(tostr(\"Can't include message on a \", verb));",
            "else",
            "this:set_current_folder(p[1]);",
            "if (to_subj = $mail_editor:parse_msg_headers(p[1]:messages_in_seq(p[2])[1][2], flags_replytos[1]))",
            "player:notify(tostr(\"To:       \", $mail_agent:name_list(@to_subj[1])));",
            "if (to_subj[2])",
            "player:notify(tostr(\"Subject:  \", to_subj[2]));",
            "endif",
            "if (replytos = flags_replytos[2])",
            "player:notify(tostr(\"Reply-to: \", $mail_agent:name_list(@replytos)));",
            "endif",
            "hdrs = {to_subj[2], replytos || {}};",
            "player:notify(\"Enter lines of message:\");",
            "message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are composing mail to \", $mail_agent:name_list(@to_subj[1]), \".\"), @active ? {} | {\"Type `@edit' to take this into the mail editor.\"}});",
            "if (typeof(message) == ERR)",
            "player:notify(tostr(message));",
            "elseif (message[1] == \"@edit\")",
            "$mail_editor:invoke(1, verb, to_subj[1], @hdrs, message[2]);",
            "elseif (!message[2])",
            "player:notify(\"Blank message not sent.\");",
            "else",
            "result = $mail_agent:send_message(this, to_subj[1], hdrs, message[2]);",
            "if (result && result[1])",
            "player:notify(tostr(\"Message sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "else",
            "player:notify(\"Message not sent.\");",
            "endif",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@mail-all-new*-mail",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 40,
          "code": [
            "\"@mail-all-new-mail\";",
            "\" Prints headers for all new mail on every mail-recipient mentioned in .current_message.\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "cm = this.current_message;",
            "cm[1..2] = {{this, @cm[1..2]}};",
            "this._mail_task = task_id();",
            "nomail = 1;",
            "new_cms = {};",
            "for f in (cm)",
            "if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))",
            "player:notify(tostr(folder, \" is neither a $player nor a $mail_recipient\"));",
            "elseif (typeof(flen = folder:length_all_msgs()) == ERR)",
            "player:notify(tostr($mail_agent:name(folder), \" \", flen));",
            "elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))",
            "nomail = 0;",
            "player:notify(\"===== \" + $string_utils:left(tostr($mail_agent:name(folder), \" (\", s = $seq_utils:size(msg_seq), \" message\", (s == 1) ? \") \" | \"s) \"), 40, \"=\"));",
            "folder:display_seq_headers(msg_seq, @f[2..3]);",
            "player:notify(\"\");",
            "$command_utils:suspend_if_needed(2);",
            "endif",
            "endfor",
            "if (nomail)",
            "player:notify(\"You don't have any new mail anywhere.\");",
            "else",
            "player:notify(\"===== \" + $string_utils:left(\"End of new mail \", 40, \"=\"));",
            "endif"
          ]
        },
        {
          "name": "@read-all-new*-mail @ranm",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 40,
          "code": [
            "\"@read-all-new-mail [yes]\";",
            "\" Prints all new mail on every mail-recipient mentioned in .current_message\";",
            "\" Generally this will spam you into next Tuesday.\";",
            "\" You will be queried for whether you want your last-read dates updated\";",
            "\"   but you can specify \\\"yes\\\" on the command line to suppress this.\";",
            "\"   If you do so, last-read dates will be updated after each folder read.\";",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "noconfirm = args && args[1];",
            "if ((noconfirm && (noconfirm != \"yes\")) && (noconfirm != \"no\"))",
            "player:notify(\"Unexpected argument(s): \" + argstr);",
            "return;",
            "endif",
            "cm = this.current_message;",
            "cm[1..2] = {{this, @cm[1..2]}};",
            "this._mail_task = task_id();",
            "nomail = 1;",
            "new_cms = {};",
            "for f in (cm)",
            "if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))",
            "player:notify(tostr(folder, \" is neither a $player nor a $mail_recipient\"));",
            "elseif (typeof(flen = folder:length_all_msgs()) == ERR)",
            "player:notify(tostr($mail_agent:name(folder), \" \", flen));",
            "elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))",
            "nomail = 0;",
            "player:notify(\"===== \" + $string_utils:left(tostr($mail_agent:name(folder), \" (\", s = $seq_utils:size(msg_seq), \" message\", (s == 1) ? \") \" | \"s) \"), 40, \"=\"));",
            "player:notify(\"\");",
            "if (cur = folder:display_seq_full(msg_seq, tostr(\"Message %d\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\")))",
            "if (noconfirm == \"yes\")",
            "this:set_current_message(folder, @cur);",
            "this:set_current_folder(folder);",
            "else",
            "new_cms = {@new_cms, {folder, @cur}};",
            "endif",
            "player:notify(\"\");",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(1);",
            "this._mail_task = task_id();",
            "endfor",
            "if (nomail)",
            "player:notify(\"You don't have any new mail anywhere.\");",
            "elseif (player:notify(\"===== \" + $string_utils:left(\"End of new mail \", 40, \"=\")) || (noconfirm ? noconfirm == \"yes\" | $command_utils:yes_or_no(\"Did you get all of that?\")))",
            "for n in (new_cms)",
            "this:set_current_message(@n);",
            "this:set_current_folder(n[1]);",
            "endfor",
            "player:notify(\"Last-read-dates updated\");",
            "else",
            "player:notify(\"Last-read-dates not updated\");",
            "endif"
          ]
        },
        {
          "name": "@quick*send @qsend",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"Syntax: @quicksend <recipients(s)> [subj=<text>] [<message>]\";",
            "\"Sends the recipients(s) a quick message, wit{out having to go to the mailroom. If there is more than one recipients, place them all in quotes. If the subj contains spaces, place it in quotes.\";",
            "\"To put line breaks in the message, use a caret (^).\";",
            "\"If no message is given, prompt for lines of message.\";",
            "\"Examples:\";",
            "\"@quicksend Alice subj=\\\"Wonderland is neat!\\\" Have you checked out the Wonderland scenario yet? I think you'd like it!\";",
            "\"@quicksend \\\"Ethel Fred\\\" Have you seen Lucy around?^--Ricky\";",
            "set_task_perms($object_utils:isa(player, $guest) ? player.owner | player);",
            "if (!args)",
            "player:notify(tostr(\"Usage: \", verb, \" <recipients(s)> [subj=<text>] [<message>]\"));",
            "return E_INVARG;",
            "elseif (this != player)",
            "player:notify(tostr(\"You can't use \", this.pp, \" @quicksend verb.\"));",
            "return E_PERM;",
            "elseif (!(recipients = $mail_editor:parse_recipients({}, $string_utils:explode(args[1]))))",
            "return;",
            "else",
            "if ((length(args) > 1) && ((eq = index(args[2], \"=\")) && (index(\"subject\", args[2][1..eq - 1]) == 1)))",
            "subject = $string_utils:trim(args[2][eq + 1..$]);",
            "ws = $string_utils:word_start(argstr);",
            "argstr = argstr[1..ws[1][2]] + argstr[ws[2][2] + 1..$];",
            "args = listdelete(args, 2);",
            "else",
            "subject = \"\";",
            "endif",
            "if (length(args) > 1)",
            "unbroken = argstr[(argstr[1] == \"\\\"\") ? length(args[1]) + 4 | (length(args[1]) + 2)..$] + \"^\";",
            "message = {};",
            "while (unbroken)",
            "if (i = index(unbroken, \"^\"))",
            "message = {@message, unbroken[1..i - 1]};",
            "endif",
            "unbroken = unbroken[i + 1..$];",
            "endwhile",
            "else",
            "if (!(subject || player:mail_option(\"nosubject\")))",
            "player:notify(\"Subject:\");",
            "subject = $command_utils:read();",
            "endif",
            "player:notify(\"Enter lines of message:\");",
            "message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are composing mail to \", $mail_agent:name_list(@recipients), \".\"), @active ? {} | {\"Type `@edit' to take this into the mail editor.\"}});",
            "if (typeof(message) == ERR)",
            "player:notify(tostr(message));",
            "return;",
            "elseif (message[1] == \"@edit\")",
            "$mail_editor:invoke(1, verb, recipients, subject, {}, message[2]);",
            "return;",
            "elseif (!(message[2] || subject))",
            "player:notify(\"Blank message not sent.\");",
            "return;",
            "endif",
            "message = message[2];",
            "endif",
            "result = $mail_agent:send_message(this, recipients, subject, message);",
            "if (result && result[1])",
            "player:notify(tostr(\"Message sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "else",
            "player:notify(\"Message not sent.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_options = {};",
            "endif"
          ]
        },
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))",
            "return E_PERM;",
            "endif",
            "this:check_mail();",
            "this:mail_catch_up();",
            "this:check_mail_lists();",
            "pass(@args);"
          ]
        },
        {
          "name": "@add-notify",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 40,
          "code": [
            "\"Ideally, in order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.\";",
            "\"Usage:  @add-notify me to player\";",
            "\"    Sends mail to player saying that I want to be added to their mail notification property.\";",
            "\"Usage:  @add-notify player to me\";",
            "\"    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.  (Deletes from temporary record.)\";",
            "if (this == dobj)",
            "target = $string_utils:match_player(iobjstr);",
            "if ($command_utils:player_match_failed(target, iobjstr))",
            "return;",
            "elseif (this in target.mail_notify[1])",
            "player:tell(\"You already receive notifications when \", target.name, \" receives mail.\");",
            "elseif (this in target.mail_notify[2])",
            "player:tell(\"You already asked to be notified when \", target.name, \" receives mail.\");",
            "else",
            "$mail_agent:send_message(player, {target}, \"mail notification request\", {tostr($string_utils:nn(this), \" would like to receive mail notifications when you get mail.\"), \"Please type:\", tostr(\"  @add-notify \", this.name, \" to me\"), \"if you wish to allow this action.\"});",
            "player:tell(\"Notifying \", $string_utils:nn(target), \" that you would like to be notified when \", target.ps, \" receives mail.\");",
            "target.mail_notify[2] = setadd(target.mail_notify[2], this);",
            "endif",
            "elseif (this == iobj)",
            "target = $string_utils:match_player(dobjstr);",
            "if ($command_utils:player_match_failed(target, dobjstr))",
            "return;",
            "elseif (target in this.mail_notify[2])",
            "this.mail_notify[1] = setadd(this.mail_notify[1], target);",
            "this.mail_notify[2] = setremove(this.mail_notify[2], target);",
            "player:tell(target.name, \" will be notified when you receive mail.\");",
            "else",
            "player:tell(\"It doesn't look like \", target.name, \" wants to be notified when you receive mail.\");",
            "endif",
            "else",
            "player:tell(\"Usage:  @add-notify me to player\");",
            "player:tell(\"        @add-notify player to me\");",
            "endif"
          ]
        },
        {
          "name": "mail_notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "if ((length(this.mail_notify) > 0) && (typeof(this.mail_notify[1]) == LIST))",
            "return this.mail_notify[1];",
            "else",
            "return this.mail_notify;",
            "endif"
          ]
        },
        {
          "name": "@unsend",
          "owner": 2,
          "perms": 89,
          "preps": 5,
          "object": 40,
          "code": [
            "\"USAGE: @unsend [message-sequence] from <player>\";",
            "\"Attempts to unsend messages you sent to <player>. Per *B:Unsend, messages may not be unsent if they have been read, have been netforwarded to the player (@mail-option +netmail), or if the player has set emself so that mail may not be unsent from em (@mail-option +no_unsend). In addition, mail sent to multiple players may not be unsent unless it can be unsent from each recipient.\";",
            "\"\";",
            "\"The following message sequences are the only ones allowed:\";",
            "\"\";",
            "\"  before:<date>    - Strictly before the given date.\";",
            "\"  after:<date>     - Strictly after the given date.\";",
            "\"  since:<date>     - On or after the given date.\";",
            "\"  until:<date>     - On or before the given date.\";",
            "\"  subject:<string> - The subject contains the given string.\";",
            "\"  body:<string>    - The message body contains the given string.\";",
            "\"  last:<number>    - The last <number> messages you sent.\";",
            "\"\";",
            "\"If you do not specify a sequence, the default sequence stored in @mail-option @unsend will be used.\";",
            "base = (dobjstr || this:mail_option(verb)) || $mail_agent.(\"player_default_@unsend\");",
            "if (player != this)",
            "return player:tell(E_PERM);",
            "elseif (typeof(base) == STR)",
            "seq = $string_utils:words(base);",
            "else",
            "seq = base;",
            "endif",
            "who = $string_utils:match_player(iobjstr);",
            "fail_msg = \"Message(s) were not removed as expected. As per *B:Unsend, I cannot elaborate on why.\";",
            "if ($command_utils:player_match_failed(who, iobjstr))",
            "return;",
            "elseif (typeof(res = $options[\"mail\"]:parse({verb, @seq})) == STR)",
            "return player:notify(res);",
            "elseif (who:mail_option(\"no_unsend\") || ($object_utils:has_callable_verb(who, \"do_unsend\") != {$mail_recipient_class}))",
            "\"Author's note: I'm not checking for +netmail. The player could have turned it on (or off) later. Netmailed messages are not saved on the player, so they can't be removed, anyway.\";",
            "return player:notify(fail_msg);",
            "endif",
            "\"The following loop weeds out `last:#' references, which need to be proccessed in a specific way.\";",
            "newseq = otherpeople = {};",
            "last = 0;",
            "for x in (seq)",
            "if (`x[1..5] == \"last:\" ! ANY')",
            "last = toint(x[6..$]);",
            "else",
            "newseq = {@newseq, x};",
            "endif",
            "endfor",
            "seq = {\"new\", \"unkept:\", tostr(\"from:\", player), @newseq};",
            "if (last > 0)",
            "seq = {@seq, tostr(\"last:\", last)};",
            "endif",
            "ok = who:parse_message_seq(seq, who:current_message());",
            "if (typeof(ok) != LIST)",
            "return player:notify(fail_msg);",
            "endif",
            "allmsgs = length($seq_utils:tolist(@ok));",
            "count = missed = 0;",
            "for position in ($list_utils:reverse($list_utils:range(allmsgs)))",
            "time = time() + 60;",
            "ok = (position == allmsgs) ? ok | who:parse_message_seq(seq, who:current_message());",
            "if ((typeof(ok) == STR) || (!ok[1]))",
            "break;",
            "elseif (time() > time)",
            "player:notify(\"Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.\");",
            "count && player:notify(tostr(count, \"message\", (count == 1) ? \"\" | \"s\", \" were unsent before the command was aborted.\"));",
            "return otherpeople && player:notify(tostr(\"Message(s) were also removed from \", $string_utils:nn(otherpeople), \".\"));",
            "endif",
            "x = $seq_utils:tolist(@ok)[$ - missed];",
            "ok = {x, x + 1};",
            "whomail = who.messages;",
            "bad = 0;",
            "possible = {};",
            "\"Check if a message was sent to multiple people and set them up for @unsend, too.\";",
            "if ((recips = $mail_agent:parse_address_field((msg = whomail[x][2])[3])) == {who})",
            "who:do_unsend(ok);",
            "\"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.\";",
            "who.messages_going = {};",
            "count = count + 1;",
            "((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(1);",
            "continue;",
            "else",
            "if (((ticks_left() / 5000) < length(recips)) || (seconds_left() < 2))",
            "suspend(1);",
            "endif",
            "\"This runs on the principle that the same message text will be sent to each person. If their .messages is in a non-standard format, this will probably bomb. Such people should set themselves +no_unsend, anyway.\";",
            "for y in (setremove(recips, who))",
            "time = time() + 60;",
            "if (((((!is_player(y)) || y:mail_option(\"no_unsend\")) || ($object_utils:has_callable_verb(y, \"do_unsend\") != {$mail_recipient_class})) || (typeof(z = y:parse_message_seq({\"new\", \"unkept:\"}, y:current_message())) == STR)) || (!z))",
            "bad = 1;",
            "elseif (time() > time)",
            "player:notify(\"Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.\");",
            "count && player:notify(tostr(count, \"message\", (count == 1) ? \"\" | \"s\", \" were unsent before the command was aborted.\"));",
            "return otherpeople && player:notify(tostr(\"Message(s) were also removed from \", $string_utils:nn(otherpeople), \".\"));",
            "else",
            "ymail = y.messages;",
            "numnum = 0;",
            "for post in ($seq_utils:tolist(@z))",
            "if (ymail[post][2] == msg)",
            "numnum = post;",
            "break;",
            "endif",
            "endfor",
            "if (!numnum)",
            "bad = 1;",
            "else",
            "z = {numnum, numnum + 1};",
            "endif",
            "endif",
            "possible = bad ? {} | {@possible, {y, z}};",
            "if (bad)",
            "break;",
            "endif",
            "endfor",
            "endif",
            "if (bad)",
            "missed = missed + 1;",
            "else",
            "for foo in ({{who, ok}, @possible})",
            "{person, sequence} = foo;",
            "person:do_unsend(sequence);",
            "\"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.\";",
            "person.messages_going = {};",
            "if (person != who)",
            "otherpeople = setadd(otherpeople, person);",
            "endif",
            "endfor",
            "count = count + 1;",
            "endif",
            "endfor",
            "if ((!count) || (count != allmsgs))",
            "player:notify(fail_msg);",
            "endif",
            "count && player:notify(tostr(count, \" message\", (count == 1) ? \"\" | \"s\", \" unsent.\"));",
            "otherpeople && player:notify(tostr(\"Message(s) were also removed from \", $string_utils:nn(otherpeople), \".\"));"
          ]
        },
        {
          "name": "do_unsend",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "\":do_unsend(seq) -> Remove the specified messages. Used by @unsend. Cannot be overridden by players or player classes; @unsend won't bother to call the verb.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "return $mail_agent:rm_message_seq(@args);"
          ]
        },
        {
          "name": "@annotate*mail",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 40,
          "code": [
            "\"@annotate <msg-sequence> [on <recipient>] with \\\"annotation\\\"\";",
            "\"prefix the specified messages with the given annotation.\";",
            "set_task_perms(player);",
            "if (!(p = this:parse_mailread_cmd(\"@annotate\", args, \"cur\", \"on\", 1)))",
            "\"...lose...\";",
            "elseif ((length(p[4]) != 2) || (p[4][1] != \"with\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" [<message numbers>] [on <folder>] with <annotation>\"));",
            "else",
            "{target, message_sequence, _, trailing_args} = p;",
            "annotation = trailing_args[2..$];",
            "annotation[1] = tostr(\"[\", player.name, \" (\", player, \"):  \", annotation[1], \"]\");",
            "if (typeof(e = target:annotate_message_seq(annotation, \"prepend\", message_sequence)) in {ERR, STR})",
            "player:notify(tostr(\"Annotation Failed:  \", e));",
            "else",
            "count = $seq_utils:size(message_sequence);",
            "player:notify(tostr(\"Annotating \", count, \" message\", (count == 1) ? \"\" | \"s\", \" on \", $mail_agent:name(target), \" with:\"));",
            "player:notify_lines(annotation);",
            "endif",
            "endif",
            "\"Copied from annotatetest (#87053):@annotate [verb author Puff (#1449)] at Mon Feb 14 14:45:41 2005 PST\";"
          ]
        },
        {
          "name": "annotate_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "return \"Cannot annotate player messages.\";"
          ]
        },
        {
          "name": "check_mail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 40,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "nm = this:length_all_msgs() - this:length_date_le(this:get_current_message()[2]);",
            "if (nm)",
            "this:notify(tostr(\"You have new mail (\", nm, \" message\", (nm == 1) ? \"\" | \"s\", \").\", this:mail_option(\"expert\") ? \"\" | \"  Type 'help mail' for info on reading it.\"));",
            "endif",
            "endif"
          ]
        }
      ],
      "propnames": [
        "_mail_task",
        "messages_going",
        "mail_lists",
        "mail_notify",
        "mail_forward",
        "mail_options",
        "message_keep_date",
        "messages_kept",
        "current_message",
        "messages"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            0,
            0
          ],
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 85,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Generic Mail Receiving Player"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            99754,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "41": {
      "id": 41,
      "name": "gender utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"$gender_utils:set(object,gender) --- sets the pronoun properties of object.\";",
            "\"gender is a string: one of the strings in $gender_utils.genders, the list of rcognized genders.  If the gender change is successful, the (full) name of the gender (e.g., \\\"male\\\") is returned.  E_NONE is returned if gender does not match any recognized gender.  Any other error encountered (e.g., E_PERM, E_PROPNF) is likewise returned and the object's pronoun properties are left unaltered.\";",
            "set_task_perms(caller_perms());",
            "{object, gender} = args;",
            "if (this == object)",
            "return E_DIV;",
            "elseif (gnum = $string_utils:find_prefix(gender, this.genders))",
            "gender = this.genders[gnum];",
            "else",
            "return E_NONE;",
            "endif",
            "save = {};",
            "prons = this.pronouns;",
            "for p in (prons)",
            "save = {@save, e = `object.(p) ! ANY'};",
            "if ((typeof(e) != STR) || (typeof(e = `object.(p) = this.(p)[gnum] ! ANY') == ERR))",
            "for i in [1..length(save) - 1]",
            "object.(prons[i]) = save[i];",
            "endfor",
            "return e;",
            "endif",
            "endfor",
            "return gender;"
          ]
        },
        {
          "name": "add",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"$gender_utils:add(object[,perms[,owner]])\";",
            "\"--- adds pronoun properties to object if they're not already there.\";",
            "\"    perms default to \\\"rc\\\", owner defaults to the object owner.\";",
            "set_task_perms(caller_perms());",
            "{object, ?perms = \"rc\", ?owner = object.owner} = args;",
            "prons = this.pronouns;",
            "e = 1;",
            "for p in (prons)",
            "if (!$object_utils:has_property(object, p))",
            "e = `add_property(object, p, \"\", {owner, perms}) ! ANY';",
            "if (typeof(e) == ERR)",
            "player:tell(\"Couldn't add \", object, \".\", p, \":  \", e);",
            "return;",
            "endif",
            "elseif ((typeof(object.(p)) != STR) && (typeof(e = `object.(p) = \"\" ! ANY') == ERR))",
            "player:tell(\"Couldn't reset \", object, \".\", p, \":  \", e);",
            "return;",
            "elseif (!object.(p))",
            "e = 0;",
            "endif",
            "endfor",
            "if ((!e) && (ERR == typeof(e = this:set(object, \"neuter\"))))",
            "player:tell(\"Couldn't initialize pronouns:  \", e);",
            "endif"
          ]
        },
        {
          "name": "get_pronoun",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"get_pronoun(key,object) => pronoun corresponding to object.\";",
            "\"key can be one of s,o,p,q,r,S,O,P,Q,R to refer to the pronoun properties relatively directly or it can be something of the form \\\"he/she\\\" or \\\"He/She\\\".\";",
            "\"Next the object is checked for the desired pronoun property.  If that doesn't exist, we look at object.gender and infer the pronoun from the corresponding $gender_utils property.  If .gender doesn't exist or the object itself is invalid, we use the corresponding property on $player.\";",
            "{key, ?object = player} = args;",
            "if (key[1] == \":\")",
            "key = key[2..$];",
            "endif",
            "if ((length(key) == 1) && (i = index(\"sopqrSOPQR\", key, 1)))",
            "prop = this.pronouns[i];",
            "else",
            "search = \"$1:he$s:she$1:he/she$2:him$2:him/her$3:his/her$4:hers$4:his/hers$5:himself$5:herself$5:himself/herself\";",
            "i = index(search, (\":\" + key) + \"$\");",
            "if (!i)",
            "return \"\";",
            "endif",
            "cap = strcmp(\"a\", key) > 0;",
            "prop = this.pronouns[toint(search[i - 1]) + (5 * cap)];",
            "endif",
            "if (!valid(object))",
            "return $player.(prop);",
            "elseif (STR == typeof(p = `object.(prop) ! ANY'))",
            "return p;",
            "elseif ((STR == typeof(g = `object.gender ! ANY')) && (i = g in this.genders))",
            "return this.(prop)[i];",
            "else",
            "return $player.(prop);",
            "endif"
          ]
        },
        {
          "name": "get_conj*ugation",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"get_conj(verbspec,object) => verb conjugated according to object.\";",
            "\"verbspec can be one of \\\"singular/plural\\\", \\\"singular\\\", \\\"singular/\\\", or \\\"/plural\\\", e.g., \\\"is/are\\\", \\\"is\\\", \\\"is/\\\", or \\\"/are\\\".\";",
            "\"The object is checked to see whether it is singular or plural.  This is inferred from its .gender property.  If .gender doesn't exist or the object itself is invalid, we assume singular.\";",
            "{spec, ?object = player} = args;",
            "i = index(spec + \"/\", \"/\");",
            "sing = spec[1..i - 1];",
            "if (i < length(spec))",
            "plur = spec[i + 1..$];",
            "else",
            "plur = \"\";",
            "endif",
            "cap = strcmp(\"a\", (i == 1) ? spec[2] | spec) > 0;",
            "if (((valid(object) && (STR == typeof(g = `object.gender ! ANY'))) && (i = g in this.genders)) && this.is_plural[i])",
            "vb = plur || this:_verb_plural(sing, i);",
            "else",
            "vb = sing || this:_verb_singular(plur, i);",
            "endif",
            "if (cap)",
            "return $string_utils:capitalize(vb);",
            "else",
            "return vb;",
            "endif"
          ]
        },
        {
          "name": "_verb_plural",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "{st, idx} = args;",
            "if (typeof(st) != STR)",
            "return E_INVARG;",
            "endif",
            "len = length(st);",
            "if ((len >= 3) && (rindex(st, \"n't\") == (len - 2)))",
            "return this:_verb_plural(st[1..len - 3], idx) + \"n't\";",
            "elseif (i = st in {\"has\", \"is\"})",
            "return this.({\"have\", \"be\"}[i])[idx];",
            "elseif (st == \"was\")",
            "return (idx > 6) ? \"were\" | st;",
            "elseif ((len <= 3) || (st[len] != \"s\"))",
            "return st;",
            "elseif (st[len - 1] != \"e\")",
            "return st[1..len - 1];",
            "\"elseif ((r = (rindex(st, \\\"sses\\\") || rindex(st, \\\"zzes\\\"))) && (r == (len - 3)))\";",
            "elseif ((r = rindex(st, \"zzes\")) && (r == (len - 3)))",
            "return st[1..len - 3];",
            "elseif ((((st[len - 2] == \"h\") && index(\"cs\", st[len - 3])) || index(\"ox\", st[len - 2])) || (st[len - 3..len - 2] == \"ss\"))",
            "return st[1..len - 2];",
            "\"washes => wash, belches => belch, boxes => box\";",
            "\"used to have || ((st[len - 2] == \\\"s\\\") && (!index(\\\"aeiouy\\\", st[len - 3])))\";",
            "\"so that <consonant>ses => <consonant>s\";",
            "\"known examples: none\";",
            "\"counterexample: browses => browse\";",
            "\"update of sorts--put in code to handle passes => pass\";",
            "elseif (st[len - 2] == \"i\")",
            "return st[1..len - 3] + \"y\";",
            "else",
            "return st[1..len - 1];",
            "endif"
          ]
        },
        {
          "name": "_verb_singular",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "{st, ?idx = 1} = args;",
            "if (typeof(st) != STR)",
            "return E_INVARG;",
            "endif",
            "len = length(st);",
            "if ((len >= 3) && (rindex(st, \"n't\") == (len - 2)))",
            "return this:_verb_singular(st[1..len - 3], idx) + \"n't\";",
            "elseif (i = st in {\"have\", \"are\"})",
            "return this.({\"have\", \"be\"}[i])[idx];",
            "elseif ((st[len] == \"y\") && (!index(\"aeiou\", st[len - 1])))",
            "return st[1..len - 1] + \"ies\";",
            "elseif (index(\"sz\", st[len]) && index(\"aeiou\", st[len - 1]))",
            "return (st + st[len]) + \"es\";",
            "elseif (index(\"osx\", st[len]) || ((len > 1) && (index(\"chsh\", st[len - 1..len]) % 2)))",
            "return st + \"es\";",
            "else",
            "return st + \"s\";",
            "endif"
          ]
        },
        {
          "name": "_do",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"_do(cap,object,modifiers...)\";",
            "{cap, object, modifiers} = args;",
            "if (!modifiers)",
            "if (typeof(object) != OBJ)",
            "return tostr(object);",
            "elseif (!valid(object))",
            "return (cap ? \"N\" | \"n\") + \"othing\";",
            "else",
            "return cap ? object:titlec() | object:title();",
            "endif",
            "elseif (modifiers[1] == \".\")",
            "if (i = index(modifiers[2..$], \".\"))",
            "i = i + 1;",
            "elseif (!(i = (index(modifiers, \":\") || index(modifiers, \"#\")) || index(modifiers, \"!\")))",
            "i = length(modifiers) + 1;",
            "endif",
            "if (typeof(o = `object.(modifiers[2..i - 1]) ! ANY') == ERR)",
            "return tostr(\"%(\", o, \")\");",
            "else",
            "return this:_do(cap || (strcmp(\"a\", modifiers[2]) > 0), o, modifiers[i..$]);",
            "endif",
            "elseif (modifiers[1] == \":\")",
            "if (typeof(object) != OBJ)",
            "return tostr(\"%(\", E_TYPE, \")\");",
            "elseif (p = this:get_pronoun(modifiers, object))",
            "return p;",
            "else",
            "return tostr(\"%(\", modifiers, \"??)\");",
            "endif",
            "elseif (modifiers[1] == \"#\")",
            "return tostr(object);",
            "elseif (modifiers[1] == \"!\")",
            "return this:get_conj(modifiers[2..$], object);",
            "else",
            "i = (((index(modifiers, \".\") || index(modifiers, \":\")) || index(modifiers, \"#\")) || index(modifiers, \"!\")) || (length(modifiers) + 1);",
            "s = modifiers[1..i - 1];",
            "if (j = s in {\"dobj\", \"iobj\", \"this\"})",
            "return this:_do(cap, {dobj, iobj, callers()[2][1]}[j], modifiers[i..$]);",
            "else",
            "return tostr(\"%(\", s, \"??)\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "pronoun_sub",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 41,
          "code": [
            "\"Experimental pronoun substitution. The official version is on $string_utils.\";",
            "\"syntax:  :pronoun_sub(text[,who])\";",
            "\"experimental version that accomodates Aladdin's style...\";",
            "set_task_perms($no_one);",
            "{old, ?who = player} = args;",
            "if (typeof(old) == LIST)",
            "plines = {};",
            "for line in (old)",
            "plines = {@plines, this:pronoun_sub(line, who)};",
            "endfor",
            "return plines;",
            "endif",
            "new = \"\";",
            "here = valid(who) ? who.location | $nothing;",
            "objspec = \"nditl\";",
            "objects = {who, dobj, iobj, caller, here};",
            "prnspec = \"sopqrSOPQR\";",
            "prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};",
            "oldlen = length(old);",
            "while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))",
            "cp_args = {};",
            "s = old[k = prcnt + 1];",
            "if (brace = index(\"([{\", s))",
            "if (!(w = index(old[k + 1..oldlen], \")]}\"[brace])))",
            "return new + old;",
            "elseif (brace == 3)",
            "s = this:_do(0, who, old[prcnt + 2..(k = k + w) - 1]);",
            "else",
            "p = old[prcnt + 2..(k = k + w) - 1];",
            "if (brace == 1)",
            "cp_args = {who, p};",
            "elseif (p[1] == \"#\")",
            "s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");",
            "elseif (!(o = index(objspec, p[1])))",
            "s = (\"[\" + p) + \"]\";",
            "else",
            "cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};",
            "endif",
            "endif",
            "elseif (o = index(objspec, s))",
            "cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};",
            "elseif (w = index(prnspec, s, 1))",
            "cp_args = {who, prprops[w]};",
            "elseif (s == \"#\")",
            "s = tostr(who);",
            "elseif (s != \"%\")",
            "s = \"%\" + s;",
            "endif",
            "new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));",
            "old = old[k + 1..oldlen];",
            "oldlen = oldlen - k;",
            "endwhile",
            "return new + old;"
          ]
        }
      ],
      "propnames": [
        "is_plural",
        "have",
        "be",
        "pronouns",
        "genders",
        "ps",
        "po",
        "pp",
        "pq",
        "pr",
        "psc",
        "poc",
        "ppc",
        "pqc",
        "prc"
      ],
      "propdefs": [
        {
          "value": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "has",
            "has",
            "has",
            "has",
            "has",
            "has",
            "have",
            "have",
            "have",
            "have",
            "have"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "is",
            "is",
            "is",
            "is",
            "is",
            "is",
            "are",
            "am",
            "are",
            "are",
            "are"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "ps",
            "po",
            "pp",
            "pq",
            "pr",
            "psc",
            "poc",
            "ppc",
            "pqc",
            "prc"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "neuter",
            "male",
            "female",
            "either",
            "Spivak",
            "splat",
            "plural",
            "egotistical",
            "royal",
            "2nd"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "it",
            "he",
            "she",
            "s/he",
            "e",
            "*e",
            "they",
            "I",
            "we",
            "you"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "it",
            "him",
            "her",
            "him/her",
            "em",
            "h*",
            "them",
            "me",
            "us",
            "you"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "its",
            "his",
            "her",
            "his/her",
            "eir",
            "h*",
            "their",
            "my",
            "our",
            "your"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "its",
            "his",
            "hers",
            "his/hers",
            "eirs",
            "h*s",
            "theirs",
            "mine",
            "ours",
            "yours"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "itself",
            "himself",
            "herself",
            "(him/her)self",
            "emself",
            "h*self",
            "themselves",
            "myself",
            "ourselves",
            "yourself"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "It",
            "He",
            "She",
            "S/He",
            "E",
            "*E",
            "They",
            "I",
            "We",
            "You"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "It",
            "Him",
            "Her",
            "Him/Her",
            "Em",
            "H*",
            "Them",
            "Me",
            "Us",
            "You"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Its",
            "His",
            "Her",
            "His/Her",
            "Eir",
            "H*",
            "Their",
            "My",
            "Our",
            "Your"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Its",
            "His",
            "Hers",
            "His/Hers",
            "Eirs",
            "H*s",
            "Theirs",
            "Mine",
            "Ours",
            "Yours"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Itself",
            "Himself",
            "Herself",
            "(Him/Her)self",
            "Emself",
            "H*self",
            "Themselves",
            "Myself",
            "Ourselves",
            "Yourself"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Defines the list of standard genders, the default pronouns for each, and routines for adding or setting pronoun properties on any gendered object.",
            "",
            "Properties:",
            "  .genders  -- list of standard genders",
            "  .pronouns -- list of pronoun properties",
            "  .ps .po .pp .pq .pr .psc .poc .ppc .pqc .prc ",
            "            -- lists of pronouns for each of the standard genders",
            "",
            "  If foo is of gender this.gender[n], ",
            "  then the default pronoun foo.p is this.p[n] ",
            "  (where p is one of ps/po/pp/pq...)",
            "",
            "Verbs:",
            "  :set(object,newgender) -- changes pronoun properties to match new gender.",
            "  :add(object[,perms[,owner]]) -- adds pronoun properties to object.",
            "",
            "  :get_pronoun     (which,object) -- return pronoun for a given object",
            "  :get_conj*ugation(verbspec,object) -- return appropriately conjugated verb"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Gender_Utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the gender utilities utility package.  See `help $gender_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            18117,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "42": {
      "id": 42,
      "name": "permissions utilities",
      "flags": 24,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "controls",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 42,
          "code": [
            "\"$perm_utils:controls(who, what)\";",
            "\"Is WHO allowed to hack on WHAT?\";",
            "{who, what} = args;",
            "return (valid(who) && valid(what)) && (who.wizard || (who == what.owner));"
          ]
        },
        {
          "name": "apply",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 42,
          "code": [
            "\":apply(permstring,mods) => new permstring.\";",
            "\"permstring is a permissions string, mods is a concatenation of strings of the form +<letters>, !<letters>, or -<letters>, where <letters> is a string of letters as might appear in a permissions string (`+' adds the specified permissions, `-' or `!' removes them; `-' and `!' are entirely equivalent).\";",
            "{perms, mods} = args;",
            "if ((!mods) || (!index(\"!-+\", mods[1])))",
            "return mods;",
            "endif",
            "i = 1;",
            "while (i <= length(mods))",
            "if (mods[i] == \"+\")",
            "while (((i = i + 1) <= length(mods)) && (!index(\"!-+\", mods[i])))",
            "if (!index(perms, mods[i]))",
            "perms = perms + mods[i];",
            "endif",
            "endwhile",
            "else",
            "\"mods[i] must be ! or -\";",
            "while (((i = i + 1) <= length(mods)) && (!index(\"!-+\", mods[i])))",
            "perms = strsub(perms, mods[i], \"\");",
            "endwhile",
            "endif",
            "endwhile",
            "return perms;"
          ]
        },
        {
          "name": "caller",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 42,
          "code": [
            "\":caller([include line numbers])\";",
            "\"  -- returns the first caller in the callers() stack distinct from `this'\";",
            "{?lineno = 0} = args;",
            "c = callers(lineno);",
            "{stage, lc, nono} = {1, length(c), {c[1][1], $nothing}};",
            "while (((stage = stage + 1) <= lc) && (c[stage][1] in nono))",
            "endwhile",
            "return c[stage];"
          ]
        },
        {
          "name": "controls_prop*erty controls_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 42,
          "code": [
            "\"Syntax:  controls_prop(OBJ who, OBJ what, STR propname)   => 0 | 1\";",
            "\"         controls_verb(OBJ who, OBJ what, STR verbname)   => 0 | 1\";",
            "\"\";",
            "\"Is WHO allowed to hack on WHAT's PROPNAME? Or VERBNAME?\";",
            "{who, what, name} = args;",
            "bi = (verb == \"controls_verb\") ? \"verb_info\" | \"property_info\";",
            "return who.wizard || (who == call_function(bi, what, name)[1]);"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "Miscellaneous routines for permissions checking",
            "",
            "For a complete description of a given verb, do `help $perm_utils:verbname'",
            "",
            ":controls(who,what) -- can who write on object what",
            ":controls_property(who,what,propname) -- can who write on what.propname",
            "These routines check write flags and also the wizardliness of `who'.",
            "",
            "(these last two probably belong on $code_utils)",
            "",
            ":apply(permstring,mods)",
            "  -- used by @chmod to apply changes (e.g., +x) ",
            "     to a given permissions string",
            "",
            ":caller()",
            "  -- returns the first caller in the callers() stack distinct from `this'"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the permissions utilities utility package.  See `help $perm_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            4950,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "43": {
      "id": 43,
      "name": "time utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "day",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Given a time() or ctime()-style date, this returns the full name of the day.\";",
            "if (typeof(args[1]) == INT)",
            "time = ctime(args[1]);",
            "elseif (typeof(args[1]) == STR)",
            "time = args[1];",
            "else",
            "return E_TYPE;",
            "endif",
            "dayabbr = $string_utils:explode(time)[1];",
            "return this.days[dayabbr in this.dayabbrs];"
          ]
        },
        {
          "name": "month",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Given a time() or ctime()-style date, this returns the full name\";",
            "\"of the month.\";",
            "if (typeof(args[1]) == INT)",
            "time = ctime(args[1]);",
            "elseif (typeof(args[1]) == STR)",
            "time = args[1];",
            "else",
            "return E_TYPE;",
            "endif",
            "monthabbr = $string_utils:explode(time)[2];",
            "return this.months[monthabbr in this.monthabbrs];"
          ]
        },
        {
          "name": "ampm",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Return a time in the form [h]h[:mm[:ss]] {a.m.|p.m.}.  Args are\";",
            "\"[1]   either a time()- or a ctime()-style date, and\";",
            "\"[2]   (optional) the precision desired--1 for hours, 2 for minutes,\";",
            "\"        3 for seconds.  If not given, precision defaults to minutes\";",
            "{time, ?precision = 2} = args;",
            "if (typeof(time) == INT)",
            "time = ctime(time);",
            "elseif (typeof(time) != STR)",
            "return E_TYPE;",
            "endif",
            "time = $string_utils:explode(time)[4];",
            "hour = toint(time[1..2]);",
            "if (hour == 0)",
            "time = (\"12\" + time[3..(precision * 3) - 1]) + \" a.m.\";",
            "elseif (hour == 12)",
            "time = time[1..(precision * 3) - 1] + \" p.m.\";",
            "elseif (hour > 12)",
            "time = (tostr(hour - 12) + time[3..(precision * 3) - 1]) + \" p.m.\";",
            "else",
            "time = (tostr(hour) + time[3..(precision * 3) - 1]) + \" a.m.\";",
            "endif",
            "return time;"
          ]
        },
        {
          "name": "to_seconds",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Given string hh:mm:ss ($string_utils:explode(ctime(time))[4]), this returns\";",
            "\"the number of seconds elapsed since 00:00:00.  I can't remember why I\";",
            "\"created this verb, but I'm sure it serves some useful purpose.\";",
            "return (((60 * 60) * toint(args[1][1..2])) + (60 * toint(args[1][4..5]))) + toint(args[1][7..8]);"
          ]
        },
        {
          "name": "sun",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "{?time = time()} = args;",
            "r = 10000;",
            "h = (r * r) + (r / 2);",
            "t = ((time + 120) % 86400) / 240;",
            "s = (5 * ((time - 14957676) % 31556952)) / 438291;",
            "phi = (s + t) + this.corr;",
            "cs = $trig_utils:cos(s);",
            "spss = ((($trig_utils:sin(phi) * $trig_utils:sin(s)) + h) / r) - r;",
            "cpcs = ((($trig_utils:cos(phi) * cs) + h) / r) - r;",
            "return (((((this.stsd * cs) - (this.ctcd * cpcs)) - (this.ct * spss)) + h) / r) - r;"
          ]
        },
        {
          "name": "from_ctime",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Given a string such as returned by ctime(), return the corresponding time-in-seconds-since-1970 time returned by time(), or E_DIV if the format is wrong in some essential way.\";",
            "words = $string_utils:explode(args[1]);",
            "if (length(words) == 5)",
            "\"Arrgh!  the old ctime() didn't return a time zone, yet it arbitrarily decides whether it's standard or daylight savings time.  URK!!!!!\";",
            "words = listappend(words, \"PST\");",
            "endif",
            "if ((((length(words) != 6) || (length(hms = $string_utils:explode(words[4], \":\")) != 3)) || (!(month = words[2] in this.monthabbrs))) || (!(zone = $list_utils:assoc(words[6], this.timezones))))",
            "return E_DIV;",
            "endif",
            "year = toint(words[5]);",
            "day = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + toint(words[3])) + (year * 366);",
            "zone = zone[2];",
            "return (((((((((((((day - ((day + 1038) / 1464)) - ((day + 672) / 1464)) - ((day + 306) / 1464)) - ((day + 109740) / 146400)) - ((day + 73140) / 146400)) - ((day + 36540) / 146400)) - 719528) * 24) + toint(hms[1])) + zone) * 60) + toint(hms[2])) * 60) + toint(hms[3]);"
          ]
        },
        {
          "name": "dhms dayshoursminutesseconds",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "s = args[1];",
            "if (s < 0)",
            "return \"-\" + this:(verb)(-s);",
            "endif",
            "m = s / 60;",
            "s = s % 60;",
            "if (m)",
            "ss = tostr((s < 10) ? \":0\" | \":\", s);",
            "h = m / 60;",
            "m = m % 60;",
            "if (h)",
            "ss = tostr((m < 10) ? \":0\" | \":\", m, ss);",
            "d = h / 24;",
            "h = h % 24;",
            "return tostr(@d ? {d, (h < 10) ? \":0\" | \":\"} | {}, h, ss);",
            "else",
            "return tostr(m, ss);",
            "endif",
            "else",
            "return tostr(s);",
            "endif"
          ]
        },
        {
          "name": "english_time",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"english_time(time [,reference time]): returns the time as a string of\";",
            "\"years, months, days, hours, minutes and seconds using the reference time as\";",
            "\"the start time and incrementing forwards. it can be given in either ctime()\";",
            "\"or time() format. if a reference time is not given, it is set to time().\";",
            "{_time, ?reftime = time()} = args;",
            "if (_time < 1)",
            "return \"0 seconds\";",
            "endif",
            "_ctime = (typeof(reftime) == INT) ? ctime(reftime) | reftime;",
            "seclist = {60, 60, 24};",
            "units = {\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"};",
            "timelist = {};",
            "for unit in (seclist)",
            "timelist = {_time % unit, @timelist};",
            "_time = _time / unit;",
            "endfor",
            "months = 0;",
            "month = _ctime[5..7] in $time_utils.monthabbrs;",
            "year = toint(_ctime[21..24]);",
            "\"attribution: the algorithm used is from the eminently eminent g7.\";",
            "while (_time >= (days = this.monthlens[month] + (((month == 2) && ((year % 4) == 0)) && (!((year % 400) in {100, 200, 300})))))",
            "_time = _time - days;",
            "months = months + 1;",
            "if ((month = month + 1) > 12)",
            "year = year + 1;",
            "month = 1;",
            "endif",
            "if (months > 2400)",
            "return tostr(\">\", months / 12, \" years\");",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "timelist = {months / 12, months % 12, _time, @timelist};",
            "for unit in (units)",
            "i = unit in units;",
            "if (timelist[i] > 0)",
            "units[i] = ((tostr(timelist[i]) + \" \") + units[i]) + ((timelist[i] == 1) ? \"\" | \"s\");",
            "else",
            "units = listdelete(units, i);",
            "timelist = listdelete(timelist, i);",
            "endif",
            "endfor",
            "return $string_utils:english_list(units);"
          ]
        },
        {
          "name": "from_day",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"from_day(day_of_week,which [,reference time])\";",
            "\"numeric time (seconds since 1970) corresponding to midnight (PST) of the given weekday.  Use either the name of the day or a 1..7 number (1==Sunday,...)\";",
            "\"  which==-1 => use most recent such day.\";",
            "\"  which==+1 => use first upcoming such day.\";",
            "\"  which==0  => use closest such day.\";",
            "\"larger (absolute) values for which specify a certain number of weeks into the future or past.\";",
            "{day, ?dir = 0, ?reftime = time()} = args;",
            "if (!(toint(day) || (day = $string_utils:find_prefix(day, this.days))))",
            "return E_DIV;",
            "endif",
            "delta = {288000, 374400, 460800, 547200, 28800, 115200, 201600}[toint(day)];",
            "time = reftime - delta;",
            "if (dir)",
            "time = (time / 604800) + ((dir > 0) ? dir | (dir + 1));",
            "else",
            "time = (time + 302400) / 604800;",
            "endif",
            "return (time * 604800) + delta;"
          ]
        },
        {
          "name": "from_month",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"from_month(month,which[,d])\";",
            "\"numeric time (seconds since 1970) corresponding to midnight (PST) of the dth (first) day of the given month.  Use either the month name or a 1..12 number (1==January,...)\";",
            "\"  which==-1 => use most recent such month.\";",
            "\"  which==+1 => use first upcoming such month.\";",
            "\"  which==0  => use closest such month.\";",
            "\"larger (absolute) values for which specify a certain number of years into the future or past.\";",
            "{month, ?dir = 0, ?dth = 1} = args;",
            "if (!(toint(month) || (month = $string_utils:find_prefix(month, this.months))))",
            "return E_DIV;",
            "endif",
            "delta = ({0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + dth) - 1;",
            "day = (time() - 28800) / 86400;",
            "day = (day - ((day + 672) / 1461)) - delta;",
            "if (dir)",
            "day = ((day / 365) + dir) + (dir <= 0);",
            "else",
            "day = ((2 * day) + 365) / 730;",
            "endif",
            "day = (day * 365) + delta;",
            "day = day + ((day + 671) / 1460);",
            "return (day * 86400) + 28800;"
          ]
        },
        {
          "name": "dst_midnight",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Takes a time that is midnight PST and converts it to the nearest PDT midnight time if it's during that part of the year where we use PDT.\";",
            "time = args[1];",
            "return time - (3600 * (((toint(ctime(time)[12..13]) + 12) % 24) - 12));"
          ]
        },
        {
          "name": "time_sub",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Works like pronoun substitution, but substitutes time stuff.\";",
            "\"Call with time_sub(string, time). returns a string.\";",
            "\"time is an optional integer in time() format.  If omitted, time() is used.\";",
            "\"Macros which are unknown are ignored. $Q -> the empty string.\";",
            "\"Terminal $ are ignored.\";",
            "\"$H -> hour #. $M -> min #. $S -> second #. 24-hour format, fixed width.\";",
            "\"$h, $m, $s same x/c have not-fixed format. 00:03:24 vs. 0:3:24\";",
            "\"$O/$o -> numeric hour in 12-hour format.\";",
            "\"$D -> long day name. $d -> short day name.\";",
            "\"$N -> long month name. $n -> short month name.\";",
            "\"$Y -> long year # (e.g. '1991'). $y -> short year # (e.g. '91')\";",
            "\"$Z -> the time zone    (added in by r'm later)\";",
            "\"$P/$p -> AM/PM, or am/pm.\";",
            "\"$T -> date number. $t -> date number with no extra whitespace etc.\";",
            "\"$1 -> Month in fixed-width numeric format (01-12)   (added by dpk)\";",
            "\"$2 -> Month in nonfixed numeric format (1-12)\";",
            "\"$3 -> Date in fixed-width format, 0-fill\";",
            "\"$$ -> $.\";",
            "\"\";",
            "\"This verb stolen from Ozymandias's #4835:time_subst.\";",
            "res = \"\";",
            "{thestr, ?thetime = time()} = args;",
            "if ((typeof(thestr) != STR) || (typeof(thetime) != INT))",
            "player:tell(\"Bad arguments to time_subst.\");",
            "return;",
            "endif",
            "itslength = length(thestr);",
            "if (!itslength)",
            "return \"\";",
            "endif",
            "done = 0;",
            "cctime = ctime(thetime);",
            "while (dollar = index(thestr, \"$\"))",
            "res = res + thestr[1..dollar - 1];",
            "if (dollar == length(thestr))",
            "return res;",
            "endif",
            "thechar = thestr[dollar + 1];",
            "thestr[1..dollar + 1] = \"\";",
            "if (thechar == \"$\")",
            "res = res + \"$\";",
            "elseif (!strcmp(thechar, \"h\"))",
            "res = res + $string_utils:trim(tostr(toint(cctime[12..13])));",
            "elseif (thechar == \"H\")",
            "res = res + cctime[12..13];",
            "elseif (!strcmp(thechar, \"m\"))",
            "res = res + $string_utils:trim(tostr(toint(cctime[15..16])));",
            "elseif (thechar == \"M\")",
            "res = res + cctime[15..16];",
            "elseif (!strcmp(thechar, \"s\"))",
            "res = res + $string_utils:trim(tostr(toint(cctime[18..19])));",
            "elseif (thechar == \"S\")",
            "res = res + cctime[18..19];",
            "elseif (!strcmp(thechar, \"D\"))",
            "res = res + $time_utils:day(thetime);",
            "elseif (thechar == \"d\")",
            "res = res + cctime[1..3];",
            "elseif (!strcmp(thechar, \"N\"))",
            "res = res + $time_utils:month(thetime);",
            "elseif (thechar == \"n\")",
            "res = res + cctime[5..7];",
            "elseif (!strcmp(thechar, \"T\"))",
            "res = res + cctime[9..10];",
            "elseif (thechar == \"t\")",
            "res = res + $string_utils:trim(cctime[9..10]);",
            "elseif (!strcmp(thechar, \"o\"))",
            "res = tostr(res, ((toint(cctime[12..13]) + 11) % 12) + 1);",
            "elseif (thechar == \"O\")",
            "res = res + $string_utils:right(tostr(((toint(cctime[12..13]) + 11) % 12) + 1), 2, \"0\");",
            "elseif (!strcmp(thechar, \"p\"))",
            "res = res + ((toint(cctime[12..13]) >= 12) ? \"pm\" | \"am\");",
            "elseif (thechar == \"P\")",
            "res = res + ((toint(cctime[12..13]) >= 12) ? \"PM\" | \"AM\");",
            "elseif (!strcmp(thechar, \"y\"))",
            "res = res + cctime[23..24];",
            "elseif (thechar == \"Y\")",
            "res = res + cctime[21..24];",
            "elseif (thechar == \"Z\")",
            "res = res + cctime[26..$];",
            "elseif (thechar == \"1\")",
            "res = res + $string_utils:right(tostr($string_utils:explode(cctime)[2] in this.monthabbrs), 2, \"0\");",
            "elseif (thechar == \"2\")",
            "res = res + tostr($string_utils:explode(cctime)[2] in this.monthabbrs);",
            "elseif (thechar == \"3\")",
            "res = res + $string_utils:subst(cctime[9..10], {{\" \", \"0\"}});",
            "endif",
            "endwhile",
            "return res + thestr;"
          ]
        },
        {
          "name": "mmddyy ddmmyy",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Copied from Archer (#52775):mmddyy Tue Apr  6 17:04:26 1993 PDT\";",
            "\"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YY or DD/MM/YY form of the date (depending on the verb called.)  The default seperator is '/'\";",
            "{time, ?divstr = \"/\"} = args;",
            "if (typeof(time) == INT)",
            "time = ctime(time);",
            "elseif (typeof(time) != STR)",
            "return E_TYPE;",
            "endif",
            "date = $string_utils:explode(time);",
            "day = toint(date[3]);",
            "month = date[2] in $time_utils.monthabbrs;",
            "year = date[5];",
            "daystr = (day < 10) ? \"0\" + tostr(day) | tostr(day);",
            "monthstr = (month < 10) ? \"0\" + tostr(month) | tostr(month);",
            "yearstr = tostr(year)[3..4];",
            "if (verb == \"mmddyy\")",
            "return tostr(monthstr, divstr, daystr, divstr, yearstr);",
            "else",
            "return tostr(daystr, divstr, monthstr, divstr, yearstr);",
            "endif"
          ]
        },
        {
          "name": "parse_english_time_interval",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"$time_utils:parse_english_time_interval(n1,u1,n2,u2,...)\";",
            "\"or $time_utils:parse_english_time_interval(\\\"n1 u1[,] [and] n2[,] u2 [and] ...\\\")\";",
            "\"There must be an even number of arguments, all of which must be strings,\";",
            "\" or there must be just one argument which is the entire string to be parsed.\";",
            "\"The n's are are numeric strings, and the u's are unit names.\";",
            "\"The known units are in $time_utils.time_units,\";",
            "\" which must be kept sorted with bigger times at the head.\";",
            "\"Returns the time represented by those words.\";",
            "\"For example,\";",
            "\" $time_utils:parse_english_time_interval(\\\"30\\\",\\\"secs\\\",\\\"2\\\",\\\"minutes\\\",\\\"31\\\",\\\"seconds\\\") => 181\";",
            "if ((length(args) == 1) && index(args[1], \" \"))",
            "return $time_utils:parse_english_time_interval(@$string_utils:words(args[1]));",
            "endif",
            "a = $list_utils:setremove_all(args, \"and\");",
            "nargs = length(a);",
            "if (nargs % 2)",
            "return E_ARGS;",
            "endif",
            "nsec = 0;",
            "n = 0;",
            "for i in [1..nargs]",
            "if ((i % 2) == 1)",
            "if ($string_utils:is_numeric(a[i]))",
            "n = toint(a[i]);",
            "elseif (a[i] in {\"a\", \"an\"})",
            "n = 1;",
            "elseif (a[i] in {\"no\"})",
            "n = 0;",
            "else",
            "return E_INVARG;",
            "endif",
            "else",
            "unit = a[i];",
            "if (unit[$] == \",\")",
            "unit = unit[1..$ - 1];",
            "endif",
            "ok = 0;",
            "for entry in ($time_utils.time_units)",
            "if ((!ok) && (unit in entry[2..$]))",
            "nsec = nsec + (entry[1] * n);",
            "ok = 1;",
            "endif",
            "endfor",
            "if (!ok)",
            "return E_INVARG;",
            "endif",
            "endif",
            "endfor",
            "return nsec;"
          ]
        },
        {
          "name": "seconds_until_date",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Copied from Ballroom Complex (#29992):from_date by Keelah! (#30246) Tue Jul 13 19:42:32 1993 PDT\";",
            "\":seconds_until_date(month,day,time,which)\";",
            "\"month is a string or the numeric representation of the month, day is a number, time is a string in the following format, hh:mm:ss.\";",
            "\"which==-1 => use most recent such month.\";",
            "\"which==+1 => use first upcoming such month.\";",
            "\"which==0 => use closest such month.\";",
            "\"This will return the number of seconds until the month, day and time given to it.\";",
            "\"Written by Keelah, on July 5, 1993.\";",
            "{month, day, time, which} = args;",
            "converted = 0;",
            "converted = converted + $time_utils:from_month(month, which, day);",
            "current = this:seconds_until_time(\"12:00:00\");",
            "get_seconds = this:seconds_until_time(time);",
            "if (get_seconds < 0)",
            "get_seconds = (get_seconds + 39600) - current;",
            "else",
            "get_seconds = (get_seconds + 39600) - current;",
            "endif",
            "converted = (converted + get_seconds) - time();",
            "return converted;"
          ]
        },
        {
          "name": "seconds_until_time",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Copied from Ballroom Complex (#29992):seconds_until by Keelah! (#30246) Tue Jul 13 19:42:37 1993 PDT\";",
            "\":seconds_until_time(hh:mm:ss)\";",
            "\"Given the string hh:mm:ss, this returns the number of seconds until that hh:mm:ss. If the hh:mm:ss is before the current time(), the number returned is a negative, else the number is a positive.\";",
            "\"Written by Keelah, on July 4, 1993.\";",
            "current = $time_utils:to_seconds(ctime()[12..19]);",
            "time = $time_utils:to_seconds(args[1]);",
            "return toint(time) - toint(current);"
          ]
        },
        {
          "name": "rfc822_ctime",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Just like ctime(), but rfc-822 compliant.  I hope.\";",
            "c = $string_utils:Explode(ctime(@args));",
            "return tostr(c[1], \", \", c[3], \" \", c[2], \" \", c[5], \" \", c[4], \" \", c[6]);",
            "\"Last modified Fri Oct 17 23:17:25 1997 EDT by neuro (#3642) on opal moo.\";"
          ]
        },
        {
          "name": "mmddyyyy ddmmyyyy",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 43,
          "code": [
            "\"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YYYY or DD/MM/YYYY form of the date (depending on the verb called.)  The default seperator is '/'\";",
            "{time, ?divstr = \"/\"} = args;",
            "if (typeof(time) == INT)",
            "time = ctime(time);",
            "elseif (typeof(time) != STR)",
            "return E_TYPE;",
            "endif",
            "date = $string_utils:explode(time);",
            "day = toint(date[3]);",
            "month = date[2] in $time_utils.monthabbrs;",
            "year = date[5];",
            "daystr = (day < 10) ? \"0\" + tostr(day) | tostr(day);",
            "monthstr = (month < 10) ? \"0\" + tostr(month) | tostr(month);",
            "yearstr = tostr(year);",
            "if (verb == \"mmddyyyy\")",
            "return tostr(monthstr, divstr, daystr, divstr, yearstr);",
            "else",
            "return tostr(daystr, divstr, monthstr, divstr, yearstr);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "monthlens",
        "timezones",
        "stsd",
        "ctcd",
        "ct",
        "corr",
        "dayabbrs",
        "days",
        "months",
        "monthabbrs",
        "zones",
        "time_units",
        "day",
        "hour",
        "minute",
        "week",
        "month"
      ],
      "propdefs": [
        {
          "value": [
            31,
            28,
            31,
            30,
            31,
            30,
            31,
            31,
            30,
            31,
            30,
            31
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              "AuEST",
              -10
            ],
            [
              "AuCST",
              -9
            ],
            [
              "AuWST",
              -8
            ],
            [
              "WET",
              -1
            ],
            [
              "GMT",
              0
            ],
            [
              "AST",
              4
            ],
            [
              "EDT",
              4
            ],
            [
              "EST",
              5
            ],
            [
              "CDT",
              5
            ],
            [
              "CST",
              6
            ],
            [
              "MDT",
              6
            ],
            [
              "MST",
              7
            ],
            [
              "PDT",
              7
            ],
            [
              "PST",
              8
            ],
            [
              "HST",
              10
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2427,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 7276,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 7934,
          "owner": 36,
          "perms": 5
        },
        {
          "value": -122,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              [
                "est",
                "edt",
                "Massachusetts",
                "MA"
              ],
              10800
            ],
            [
              [
                "cst",
                "cdt"
              ],
              7200
            ],
            [
              [
                "mst",
                "mdt"
              ],
              3600
            ],
            [
              [
                "pst",
                "pdt",
                "California",
                "CA",
                "Lambda"
              ],
              0
            ],
            [
              [
                "gmt"
              ],
              28800
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              31536000,
              "year",
              "years",
              "yr",
              "yrs"
            ],
            [
              2628000,
              "month",
              "months",
              "mo",
              "mos"
            ],
            [
              604800,
              "week",
              "weeks",
              "wk",
              "wks"
            ],
            [
              86400,
              "day",
              "days",
              "dy",
              "dys"
            ],
            [
              3600,
              "hour",
              "hours",
              "hr",
              "hrs"
            ],
            [
              60,
              "minute",
              "minutes",
              "min",
              "mins"
            ],
            [
              1,
              "second",
              "seconds",
              "sec",
              "secs"
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 86400,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 3600,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 60,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 604800,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "    Converting from seconds-since-1970    ",
            "dhms          (time)                 => string ...DD:HH:MM:SS",
            "english_time  (time[, reference time)=> string of y, m, d, h, m, s",
            "",
            "    Converting to seconds",
            "to_seconds    (\"hh:mm:ss\")           => seconds since 00:00:00",
            "from_ctime    (ctime)                => corresponding time-since-1970",
            "from_day      (day_of_week, which)   => time-since-1970 for the given day*",
            "from_month    (month, which)         => time-since-1970 for the given month*",
            "    (* the first midnight of that day/month)",
            "parse_english_time_interval(\"n1 u1 n2 u2...\")",
            "                                     => seconds in interval",
            "seconds_until_time(\"hh:mm:ss\")       => number of seconds from now until then",
            "seconds_until_date(\"month\",day,\"hh:mm:ss\",flag ",
            "                                     => number of seconds from now until then",
            "                                        (see verb help for details)",
            "",
            "    Converting to some standard English formats",
            "day           ([c]time)              => what day it is",
            "month         ([c]time)              => what month it is",
            "ampm          ([c]time[, precision]) => what time it is, with am or pm",
            "mmddyy        ([c]time)              => date in format MM/DD/YY",
            "ddmmyy        ([c]time)              => date in format DD/MM/YY",
            "",
            "    Substitution",
            "time_sub      (string, time)         => substitute time information",
            "",
            "    Miscellaneous",
            "sun           ([time])               => angle between sun and zenith",
            "dst_midnight  (time)                 "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "time utilities",
            "time"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the time utilities utility package.  See `help $time_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            31463,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "44": {
      "id": 44,
      "name": "Editor Help",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "summary",
        "edit-index",
        "emote",
        "say",
        "delete",
        "insert",
        "view",
        "depublish",
        "perish",
        "unpublish",
        "publish",
        "mode",
        "enter",
        "quit",
        "unsubscribe",
        "subscribe",
        "reply-to",
        "moo",
        "find",
        "edit",
        "compile",
        "save",
        "showlists",
        "subject",
        "to",
        "also-to",
        "who",
        "print",
        "send",
        "list",
        "next",
        "prev",
        "subst",
        "join",
        "fill",
        "move",
        "copy",
        "what",
        "abort",
        "done",
        "pause",
        "ranges",
        "cc",
        "uncc",
        "not-to"
      ],
      "propdefs": [
        {
          "value": [
            "You are inside an editor.  Do",
            "",
            "look          -- for list of commands",
            "what          -- to find out what you're editing.",
            "list          -- to list out some portion of the text",
            "say / emote   -- to add new text to whatever you're editing",
            "",
            "help edit-index -- for a full list of editor help topics",
            "help editors    -- for a general discussion about editors",
            "help moo        -- for the general MOO help summary (i.e., what you get by ",
            "                   typing `help' with no arguments from outside the editor)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Editor Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: emote <text>",
            "        :<text>",
            "",
            "(EDITOR)",
            "Appends <text> to the end of the line before the insertion point.",
            "The second form is equivalent to the first except that it doesn't strip leading blanks off of <text> (just as with the normal `emote' and `:' commands).",
            "The insertion point is left unmoved.",
            "",
            "    >list .",
            "    _37_ Hello there",
            "    ^38^ Oh, I'm fine.",
            "    >:, how are you",
            "    Appended to line 37.",
            "    >:?",
            "    Appended to line 37.",
            "    >list .",
            "    _37_ Hello there, how are you?",
            "    ^38^ Oh, I'm fine.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: say <text>",
            "        \"<text>",
            "",
            "(EDITOR)",
            "Adds <text> to whatever you are editing.",
            "The second form is equivalent to the first except in that it doesn't strip leading blanks off of <text> (just as with the normal `say' and `\"' commands).",
            "",
            "The added text appears as a new line at the insertion point.  The insertion point, in turn, gets moved so as to be after the added text.  For example:",
            "",
            "    >\"first line",
            "    Line 1 added.",
            "    >\"  second line\"",
            "    Line 2 added.",
            "    >list",
            "      1: first line",
            "    __2_   second line\"",
            "    ^^^^"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  del*ete [<range>] ",
            "",
            "(EDITOR)",
            "Deletes the specified range of lines",
            "<range> defaults to the line *before* the current insertion point."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ins*ert [<ins>] [\"<text>]",
            "         .                    (`.' == `insert' without arguments)",
            "",
            "(EDITOR)",
            "Many editor commands refer to an \"insertion point\" which is (usually) the place right below where the most recent line was inserted.  The insertion point should really be thought of as sitting *between* lines.  In listings, the line above the insertion point is marked with `_' while the one below is marked with `^'.",
            "",
            "The `insert' command, when given an argument, sets the insertion point.",
            "If <text> is provided, a new line will be created and inserted as with `say'.",
            "<ins>, both here and in other commands that require specifying an insertion point (e.g., copy/move), can be one of",
            "          ",
            "    ^n   above line n",
            "     n   above line n",
            "    _n   below line n",
            "     $   at the end",
            "    ^$   before the last line",
            "   n^$   n lines before the end",
            "     .   the current insertion point  (i.e., `insert .' is a no-op)",
            "    +n   n lines below the current insertion point.",
            "    -n   n lines above the current insertion point.",
            "",
            "For the truly perverse, there are other combinations that also work due to artifacts of the parsing process, but these might go away..."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  view <player> [<range>] [nonum]",
            "         view",
            "",
            "Prints some subset of the specified player's text.",
            "Said player must have previously made his text readable with `publish'.",
            "<ranges> are specified as in other commands (see `help ranges').",
            "References to the insertion point refer to wherever the other player has set his/her insertion point; you have no control over it.",
            "The default range is as in list.",
            "",
            "If no arguments are given, this lists all of the players that have published anything in this editor."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "unpublish"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "unpublish"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  unpub*lish",
            "         depub*lish",
            "         perish",
            "",
            "This command reverses the effects of `publish', making your text readable only by you."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  pub*lish",
            "",
            "By default, only you (and wizards) can read the text you are editing.",
            "This command makes your text readable by the entire world (see `help view').",
            "This is useful if you need help from someone or if you just want to show off your programming acumen.",
            "Use `unpublish' to make your text private again."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "(NOTE EDITOR)",
            "Syntax:  mode",
            "         mode string",
            "         mode list",
            "         ",
            "There are (currently) two modes the note editor can be in.",
            "One is string mode, in which if the text being edited is one line or less, ",
            "it will be saved as a single string (or an empty string) rather than as a list.",
            "The other is list mode, in which text is always saved as a list of strings.",
            "The mode is set when the text is first loaded (string mode if the text is a string, list mode otherwise), but can be changed using this command.",
            "",
            "The first form above (i.e., without any arguments) reports the current mode."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  enter",
            "",
            "(EDITOR)",
            "Enters a sequence of lines at the insertion point (see `help insert').",
            "This is similar to .program in that every line you type after the `enter' command is inserted verbatim into the text until you type a line with a single period (`.') on it.  This command is essentially for if you don't like the idea of putting \" at the beginning of each line you type.  The only exceptions, i.e., lines that are not entered verbatim (aside from the `.' line), are",
            "",
            " - If you type a line whose sole text is `@abort', ",
            "   that aborts this command without making any changes to the text.  ",
            " - Any line whose first nonblank character is `.' and has additional text",
            "   is entered but with its first `.' stripped off.  ",
            "",
            "Thus, to enter a line whose text is `@abort', you could enter it as `.@abort'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  q*uit",
            "         done",
            "         pause  ",
            "",
            "(EDITOR)",
            "Leaves the editor.  If you have unsaved text it will be there when you return (and in fact you will not be able to do anything else with this editor until you 'abort' or save the text).",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: unsubscribe from <list-name>",
            "        unsubscribe <name>... from <list-name>",
            "",
            "(MAILROOM)",
            "Remove yourself from the given mailing list.",
            "The second form removes arbitrary people from a mailing list.",
            "You can only do this if you own whatever is being removed or you own the list.",
            "",
            "Use the `who' command to determine if you are on a given mailing list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: subscribe to <list-name>",
            "        subscribe [<name>...] to <list-name>",
            "",
            "(MAILROOM)",
            "Add yourself to the given mailing list.  ",
            "The second form adds arbitrary people to a mailing list.",
            "You can only do this if you own the list or if it is listed as [Public] and you own whatever is being added.",
            "",
            "The first form of this command is probably obsolete since if <list-name> is public, you can already read it via `@mail on *<list-name>' and it's much better for the MOO if you do so.  `@mail-option +sticky' makes this even easier.",
            "",
            "Use the `who' command to determine if you are on a given mailing list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  reply-to [<recipients>]",
            "",
            "(MAIL ROOM)",
            "Reports the current contents of the Reply-to: field of your message.",
            "With arguments, adds (or changes) the Reply-to: field.",
            "",
            "When someone @answers a message, the Reply-to: field is checked first when determining to whom the reply should be sent --- see `help @answer'.",
            "",
            "To clear the Reply-to: field, do",
            "",
            "         reply-to \"\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*pass*",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  f*ind  /<str>[/[c][<ins>]]",
            "         /<str>[/[c][<ins>]]",
            "",
            "Searches for the first line after <ins> containing <str>.  <ins> defaults to  the current insertion point (see `help insert' for how to specify other places).  With the first form, any character (not just `/') may be used as a delimiter.",
            "For the second form, you must use '/'.",
            "",
            "The 'c' flag, if given, indicates that case is to be ignored while searching.",
            "",
            "[Bug: With the second form, there are problems if the search string contains quotes, backslashes or a run of spaces.  The first whitespace will always be treated as a single space.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the \"verb\") need to be escaped with `\\'.  Unfortunately it will not be possible to fix this until we get a new command parser.]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "(VERB EDITOR)",
            "Syntax:  edit <object>:<verb>",
            "",
            "Changes what verb you are editing and loads the code for that verb",
            "into the editor. ",
            "Equivalent to @edit <object>:<verb>.",
            "",
            "(NOTE EDITOR)",
            "Syntax:  edit <note-object>",
            "         edit <object>.<property>",
            "",
            "Changes to a different note or a different object text property and ",
            "loads its text into the editor.",
            "These are equivalent to @notedit <note> or @notedit <object>.<property>",
            "respectively.",
            "",
            "For both the verb-editor and note-editor commands, <object> will match on the room you came from, though if the room you came from was another editor, then all bets are off..."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  compile [as <object>:<verb>]",
            "",
            "(VERB EDITOR)",
            "Installs the new program into the system if there are no syntax errors.",
            "If a new object:verb is specified and actually turns out to exist, that <object>:<verb> becomes the default for subsequent compilations."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  save [<note-object>]",
            "         save [<object>.<property>]",
            "",
            "(NOTE EDITOR)",
            "Installs the freshly edited text.  If <note> or <object>.<property> is specified, text is installed on that note or property instead of the original one.  In addition the new note or property becomes the default for future save commands."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  showlists",
            "",
            "(MAIL ROOM)",
            "Print a list of the publically available mailing lists/archives and other non-player entities that can receive mail."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  subj*ect [<text>]",
            "",
            "(MAIL ROOM)",
            "Specifies a Subject: line for your message.  If <text> is \"\", the Subject: line is removed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  to [<recipients>]",
            "",
            "(MAIL ROOM)",
            "Specifies a new set of recipients (the To: line) for your message.",
            "Recipient names not beginning with * are matched against the list of players.",
            "Recipient names beginning with * are interpreted as mailing-lists/archives/other types of non-person addresses and are matched against all such publically available objects (see `help showlists').  If the list you want to use isn't in the database (i.e., isn't located in the database ($mail_agent)) you need to refer to it by object id."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  also-to [<recipients>]",
            "",
            "Synonym: cc",
            "",
            "(MAIL ROOM)",
            "Adds additional recipients to the To: line of your message.",
            "Same rules apply as for the `to' command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  who ",
            "         who <rcpt>...",
            "",
            "(MAIL ROOM)",
            "Invokes $mail_agent's mail-forwarding tracer and determines who (or what) is actually going to receive your message.  The resulting list will not include destinations that will simply forward the message without :receive_message()'ing a copy for themselves.",
            "",
            "The second form expands an arbitrary list of recipients, for if e.g., you're curious about the members of particular mailing list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  pri*nt",
            "",
            "Display your text without line numbers.",
            "",
            "(MAIL ROOM)",
            "Display your message including headers."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  send",
            "",
            "(MAIL ROOM)",
            "Send the message, then exit the mail room if all of the addresses on the To: line turn out to be valid and usable (you can use the `who' command to check these in advance, though the status of recipients may change without warning).",
            "If the To: line turns out to contain invalid recipients or recipients that are not usable by you, the message will not be sent and you will remain in the mail room.",
            "It may be, however, that valid addresses on your To: line will forward to other addresses that are bogus; you'll receive warnings about these, but in this case your message will still be delivered to those addresses that are valid.",
            "",
            "Note that there may be particularly long delays when sending to recipients with large forwarding/notification lists or when sending on occasions when the MOO is heavily loaded in general.  In such a case, it is possible to continue editing the message while the send is in progress; any such edits affect only the text in the editor.  In particular, the text of the message currently being sent remains as it was when you first typed the send command.  However, any editing will mark the text as \"changed\" meaning that you will need to explicitly `abort' or `quit' in order to leave the mail room even if the send concludes successfully."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  lis*t [<range>] [nonum]",
            "",
            "Prints some subset of the current verb text.",
            "The default range is some reasonable collection of lines around the current insertion point:  currently this is 8_-8^, ie., 8 lines above the insertion point to 8 lines below it unless this runs up against the beginning or end of file, in which case we just take the first or last 16 lines, or just 1-$ if there aren't that many.  (See `help ranges' for how to specify line numbers and ranges.)",
            "",
            "`nonum' prints without line numbers.",
            "",
            "Yes, window heights will be customizable some day."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  n*ext [n] [\"<text>]",
            "",
            "Moves the insertion point down n lines.  If <text> is provided, inserts a new line there just like `say'.",
            "Equivalent to `insert +n'.  As one might expect, n defaults to 1."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  p*rev [n] [\"<text>]",
            "",
            "Moves the insertion point up n lines.  If <text> is provided, a new line is inserted as with `say'.",
            "Equivalent to `insert -n'.  As one might expect, n defaults to 1."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  s*ubst/<str1>/<str2>[/[g][c][r][<range>]]",
            "",
            "Substitutes <str2> for <str1>, in all of the lines of <range>.",
            "Any character (not just `/') may be used to delimit the strings. ",
            "If <str1> is blank, <str2> is inserted at the beginning of the line.  ",
            "(For inserting a string at the end of a line use emote/:).",
            "",
            "Normally, only one substitution is done per line in the specified range, but if the 'g' flag is given, *all* instances of <str1> are replaced.",
            "The 'c' flag indicates that case is not significant when searching for substitution instances.",
            "",
            "The `r' flag means that the command will be grepped and matched using regular expressions. This is how you perform a regexp subst:",
            "",
            "The <str1> field will be understood as a regular expression. If you are unfamiliar with regexp protocol, read `help regular-expressions'.",
            "In cases where successful matches are made, the <str2> string will be run through the substitute() builtin, with the match() info as an argument, before replacing the old string.",
            "So, in short. If `match(line, <str1>)' returns something, then `substitute(<str2>, match result)' is subbed in its place. The `g' and `c' arguments are still applicable.",
            "",
            "<range> defaults to the line *before* the insertion point.",
            "",
            "You do *not* need a space between the verb and the delimeter before <str1>.",
            "[Bug: If you omit the space and the first whitespace in <str1> is a run of more than one space, those spaces get treated as one.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the \"verb\") need to be escaped with `\\'.  The fix on this will have to wait for a new command parser.]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  join        [<range>]",
            "         joinliteral [<range>]",
            "",
            "combines the lines in the specified range.  Normally, spaces are inserted and double space appears after periods and colons, but 'joinliteral' (abbreviates to 'joinl') supresses this and joins the lines as is.  <range> defaults to the two lines surrounding the insertion point."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  fill [<range>] [@ c]",
            "",
            "combines the specified lines as in join and then splits them so that no line is more than c characters (except in cases of pathological lines with very long words).  c defaults to 70.  <range> defaults to the single line preceding the insertion point."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  m*ove [<range>] to <ins>",
            "",
            "Moves the range of lines to place specified by <ins>.",
            "If <ins> happens to be the current insertion point, the insertion point is moved to the end of the freshly moved lines.  If the range of lines contains the insertion point, the insertion point is carried over to the range's new location.",
            "",
            "See `help insert' for a list of possibilities for <ins>."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  c*opy [<range>] to <ins>",
            "",
            "Copies the specified range of lines to place given by <ins>.",
            "If <ins> happens to be the current insertion point, the insertion ",
            "point moves to the end of the inserted lines.",
            "",
            "See `help insert' for a list of possibilities for <ins>."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  w*hat",
            "",
            "Prints information about the editing session."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  abort",
            "",
            "Abandons this editing session and any changes."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "quit"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "quit"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Most editor commands act upon a particular range of lines.",
            "Essentially, one needs to specify a first line and a last line.",
            "Line numbers may be given in any of the following forms",
            "  ",
            "  n      (i.e., the nth line of text)",
            "  n^     n-th line after/below  the current insertion point",
            "  n_     n-th line before/above the current insertion point",
            "  n$     n-th line before the end.",
            "",
            "In the latter three, n defaults to 1, so that `^' by itself refers to the line below the current (i.e., the line that gets `^' printed before it), and likewise for `_' while `$' refers to the last line.  Note that the usage depends on whether you are specifying a line or an insertion point (space between lines). `^5' is the space above/before line 5, while `5^' is the fifth line after/below the current insertion point.",
            "",
            "Ranges of lines may be specified in any of the",
            "following ways:",
            "",
            "  <line>                  just that line",
            "  from <line> to <line>   what it says; the following two forms are equivalent:",
            "  <line>-<line>            ",
            "  <line> <line>",
            "",
            "With the `from l to l' form, either the from or the to can be left off and it will default to whatever is usual for that command (usually a line above or below the insertion point).  Actually I was thinking of punting the `from'/`to' specifications entirely because they're so verbose.  Opinions?"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "also-to"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "not-to"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  not-to [<recipients>]",
            "",
            "Synonym: uncc",
            "",
            "(MAIL ROOM)",
            "Removes the specified recipients from the To: line of your message."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "edit-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Editor Help"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            26270,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "45": {
      "id": 45,
      "name": "Generic Mail Recipient",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        34,
        29,
        14,
        70,
        61
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set_aliases",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\"For changing mailing list aliases, we check to make sure that none of the aliases match existing mailing list aliases.  Aliases containing spaces are not used in addresses and so are not subject to this restriction ($mail_agent:match will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).\";",
            "\"  => E_PERM   if you don't own this\";",
            "{newaliases} = args;",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (this.location != $mail_agent)",
            "\"... we don't care...\";",
            "return pass(@args);",
            "elseif (length(newaliases) > $mail_agent.max_list_aliases)",
            "return E_QUOTA;",
            "else",
            "for a in (aliases = newaliases)",
            "if (index(a, \" \"))",
            "\"... we don't care...\";",
            "elseif (rp = $mail_agent:reserved_pattern(a))",
            "player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);",
            "aliases = setremove(aliases, a);",
            "elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != this) && (a in p.aliases)))",
            "player:tell(\"Mailing list name \\\"\", a, \"\\\" in use on \", p.name, \"(\", p, \")\");",
            "aliases = setremove(aliases, a);",
            "endif",
            "endfor",
            "return pass(aliases) && (newaliases == aliases);",
            "endif"
          ]
        },
        {
          "name": "look_self",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\"Returns full name and mail aliases for this list, read and write status by the player, and a short description. Calling :look_self(1) will omit the description.\";",
            "{?brief = 0} = args;",
            "namelist = \"*\" + ((names = this:mail_names()) ? $string_utils:from_list(names, \", *\") | tostr(this));",
            "if (typeof(fwd = this:mail_forward()) != LIST)",
            "fwd = {};",
            "endif",
            "if (this:is_writable_by(player))",
            "if (player in fwd)",
            "read = \" [Writable/Subscribed]\";",
            "else",
            "read = \" [Writable]\";",
            "endif",
            "elseif (this.readers == 1)",
            "read = tostr(\" [Public\", (player in fwd) ? \"/Subscribed]\" | \"]\");",
            "elseif (player in fwd)",
            "read = \" [Subscribed]\";",
            "elseif (this:is_readable_by(player))",
            "read = \" [Readable]\";",
            "else",
            "read = \"\";",
            "endif",
            "if (this:is_usable_by($no_one))",
            "mod = \"\";",
            "elseif (this:is_usable_by(player))",
            "mod = \" [Approved]\";",
            "else",
            "mod = \" [Moderated]\";",
            "endif",
            "player:tell(namelist, \"  (\", this, \")\", read, mod);",
            "if (!brief)",
            "d = this:description();",
            "if (typeof(d) == STR)",
            "d = {d};",
            "endif",
            "for l in (d)",
            "if (length(l) <= 75)",
            "ls = {l};",
            "else",
            "ls = $generic_editor:fill_string(l, 76);",
            "endif",
            "for line in (ls)",
            "player:tell(\"    \", line);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "is_writable_by is_annotatable_by",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "return $perm_utils:controls(who = args[1], this) || `who in this.writers ! E_TYPE';"
          ]
        },
        {
          "name": "is_readable_by",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "return (typeof(this.readers) != LIST) || (((who = args[1]) in this.readers) || (this:is_writable_by(who) || $mail_agent:sends_to(1, this, who)));"
          ]
        },
        {
          "name": "is_usable_by",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "who = args[1];",
            "if (this.moderated)",
            "return `who in this.moderated ! E_TYPE' || (this:is_writable_by(who) || who.wizard);",
            "else",
            "return this.guests_can_send_here || (!$object_utils:isa(who, $guest));",
            "endif"
          ]
        },
        {
          "name": "mail_notify",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))",
            "return this:moderator_notify(@args);",
            "else",
            "return this.(verb);",
            "endif"
          ]
        },
        {
          "name": "mail_forward",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))",
            "return this:moderator_forward(@args);",
            "elseif (typeof(mf = this.(verb)) == STR)",
            "return $string_utils:pronoun_sub(mf, @args);",
            "else",
            "return mf;",
            "endif"
          ]
        },
        {
          "name": "moderator_forward",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (typeof(mf = this.(verb)) == STR)",
            "return $string_utils:pronoun_sub(mf, args ? args[1] | $player);",
            "else",
            "return mf;",
            "endif"
          ]
        },
        {
          "name": "add_forward",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":add_forward(recip[,recip...]) adds new recipients to this list.  Returns a string error message or a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient, string => other kind of failure)\";",
            "if (caller == $mail_editor)",
            "perms = player;",
            "else",
            "perms = caller_perms();",
            "endif",
            "result = {};",
            "forward_self = (!this.mail_forward) || (this in this.mail_forward);",
            "for recip in (args)",
            "if ((!valid(recip)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))",
            "r = E_INVARG;",
            "elseif ($perm_utils:controls(perms, this) || ((typeof(this.readers) != LIST) && $perm_utils:controls(perms, recip)))",
            "this.mail_forward = setadd(this.mail_forward, recip);",
            "r = recip;",
            "else",
            "r = E_PERM;",
            "endif",
            "result = listappend(result, r);",
            "endfor",
            "if ((length(this.mail_forward) > 1) && ($nothing in this.mail_forward))",
            "this.mail_forward = setremove(this.mail_forward, $nothing);",
            "endif",
            "if (forward_self)",
            "this.mail_forward = setadd(this.mail_forward, this);",
            "endif",
            "return result;"
          ]
        },
        {
          "name": "delete_forward",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":delete_forward(recip[,recip...]) removes recipients to this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)\";",
            "if (caller == $mail_editor)",
            "perms = player;",
            "else",
            "perms = caller_perms();",
            "endif",
            "result = {};",
            "forward_self = (!this.mail_forward) || (this in this.mail_forward);",
            "for recip in (args)",
            "if (!(recip in this.mail_forward))",
            "r = E_INVARG;",
            "elseif (((!valid(recip)) || $perm_utils:controls(perms, recip)) || $perm_utils:controls(perms, this))",
            "if (recip == this)",
            "forward_self = 0;",
            "endif",
            "this.mail_forward = setremove(this.mail_forward, recip);",
            "r = recip;",
            "else",
            "r = E_PERM;",
            "endif",
            "result = listappend(result, r);",
            "endfor",
            "if (!(forward_self || this.mail_forward))",
            "this.mail_forward = {$nothing};",
            "elseif (this.mail_forward == {this})",
            "this.mail_forward = {};",
            "endif",
            "return result;"
          ]
        },
        {
          "name": "add_notify",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":add_notify(recip[,recip...]) adds new notifiees to this list.  Returns a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient)\";",
            "if (caller == $mail_editor)",
            "perms = player;",
            "else",
            "perms = caller_perms();",
            "endif",
            "result = {};",
            "for recip in (args)",
            "if ((!valid(recip)) || (recip == this))",
            "r = E_INVARG;",
            "elseif ($perm_utils:controls(perms, this) || (this:is_readable_by(perms) && $perm_utils:controls(perms, recip)))",
            "this.mail_notify = setadd(this.mail_notify, recip);",
            "r = recip;",
            "else",
            "r = E_PERM;",
            "endif",
            "result = listappend(result, r);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "delete_notify",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":delete_notify(recip[,recip...]) removes notifiees from this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)\";",
            "if (caller == $mail_editor)",
            "perms = player;",
            "else",
            "perms = caller_perms();",
            "endif",
            "result = {};",
            "rmthis = 0;",
            "for recip in (args)",
            "if (!(recip in this.mail_notify))",
            "r = E_INVARG;",
            "elseif ((!valid(recip)) || ($perm_utils:controls(perms, recip) || $perm_utils:controls(perms, this)))",
            "if (recip == this)",
            "rmthis = 1;",
            "endif",
            "this.mail_notify = setremove(this.mail_notify, recip);",
            "r = recip;",
            "else",
            "r = E_PERM;",
            "endif",
            "result = listappend(result, r);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "receive_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "else",
            "this.messages = {@this.messages, {new = this:new_message_num(), args[1]}};",
            "this.last_msg_date = args[1][1];",
            "this.last_used_time = time();",
            "return new;",
            "endif"
          ]
        },
        {
          "name": "ok",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":ok(caller,callerperms) => true iff caller can do read operations\";",
            "return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_readable_by(args[2]));"
          ]
        },
        {
          "name": "ok_write",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":ok_write(caller,callerperms) => true iff caller can do write operations\";",
            "return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_writable_by(args[2]));"
          ]
        },
        {
          "name": "parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":parse_message_seq(strings,cur) => {msg_seq,@unused_strings} or string error\";",
            "\"\";",
            "\":from_msg_seq(olist)     => msg_seq of messages from those people\";",
            "\":%from_msg_seq(strings)  => msg_seq of messages with strings in the From: line\";",
            "\":to_msg_seq(olist)       => msg_seq of messages to those people\";",
            "\":%to_msg_seq(strings)    => msg_seq of messages with strings in the To: line\";",
            "\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";",
            "\":body_msg_seq(target)    => msg_seq of messages with target in the body\";",
            "\":new_message_num()    => number that the next incoming message will receive.\";",
            "\":length_num_le(num)   => number of messages in folder numbered <= num\";",
            "\":length_date_le(date) => number of messages in folder dated <= date\";",
            "\":length_all_msgs()    => number of messages in folder\";",
            "\":exists_num_eq(num)   => index of message in folder numbered == num, or 0\";",
            "\"\";",
            "\":display_seq_headers(msg_seq[,cur])   display message summary lines\";",
            "\":display_seq_full(msg_seq[,preamble]) display entire messages\";",
            "\"            => number of final message displayed\";",
            "\":list_rmm() displays contents of .messages_going.\";",
            "\"            => the number of messages in .messages_going.\";",
            "\"\";",
            "\":messages_in_seq(msg_seq) => list of messages in msg_seq on folder\";",
            "\"\";",
            "\"See the corresponding routines on $mail_agent for more detail.\";",
            "return this:ok(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;"
          ]
        },
        {
          "name": "length_date_gt",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":length_date_le(date) => number of messages in folder dated > date\";",
            "\"\";",
            "if (this:ok(caller, caller_perms()))",
            "date = args[1];",
            "return (this.last_msg_date <= date) ? 0 | $mail_agent:(verb)(date);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "rm_message_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":rm_message_seq(msg_seq) removes the given sequence of from folder\";",
            "\"               => string giving msg numbers removed\";",
            "\"See the corresponding routine on $mail_agent.\";",
            "if (this:ok_write(caller, caller_perms()))",
            "return $mail_agent:(verb)(@args);",
            "elseif (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))",
            "return $mail_agent:(verb)(@listset(args, seq, 1));",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "undo_rmm expunge_rmm renumber keep_message_seq set_message_body_by_index",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":rm_message_seq(msg_seq) removes the given sequence of from folder\";",
            "\"               => string giving msg numbers removed\";",
            "\":list_rmm()    displays contents of .messages_going.\";",
            "\"               => number of messages in .messages_going.\";",
            "\":undo_rmm()    restores previously deleted messages from .messages_going.\";",
            "\"               => msg_seq of restored messages\";",
            "\":expunge_rmm() destroys contents of .messages_going once and for all.\";",
            "\"               => number of messages in .messages_going.\";",
            "\":renumber([cur])  renumbers all messages\";",
            "\"               => {number of messages,new cur}.\";",
            "\":set_message_body_by_index(i,newbody)\";",
            "\"               changes the body of the i-th message.\";",
            "\"\";",
            "\"See the corresponding routines on $mail_agent.\";",
            "return this:ok_write(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;"
          ]
        },
        {
          "name": "own_messages_filter",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":own_messages_filter(who,msg_seq) => subsequence of msg_seq consisting of those messages that <who> is actually allowed to remove (on the assumption that <who> is not one of the allowed writers of this folder.\";",
            "if (!this.rmm_own_msgs)",
            "return E_PERM;",
            "elseif ((typeof(seq = this:from_msg_seq({args[1]}, args[2])) != LIST) || (seq != args[2]))",
            "return {};",
            "else",
            "return seq;",
            "endif"
          ]
        },
        {
          "name": "messages",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\"NOTE:  this routine is obsolete, use :messages_in_seq()\";",
            "\":messages(num) => returns the message numbered num.\";",
            "\":messages()    => returns the entire list of messages (can be SLOW).\";",
            "if (!this:ok(caller, caller_perms()))",
            "return E_PERM;",
            "elseif (!args)",
            "return this:messages_in_seq({1, this:length_all_msgs() + 1});",
            "elseif (!(n = this:exists_num_eq(args[1])))",
            "return E_RANGE;",
            "else",
            "return this:messages_in_seq(n)[2];",
            "endif"
          ]
        },
        {
          "name": "date_sort",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "date_seq = {};",
            "for msg in (this.messages)",
            "date_seq = {@date_seq, msg[2][1]};",
            "endfor",
            "msg_order = $list_utils:sort($list_utils:range(n = length(msgs = this.messages)), date_seq);",
            "newmsgs = {};",
            "for i in [1..n]",
            "if ($command_utils:suspend_if_needed(0))",
            "player:tell(\"...\", i);",
            "endif",
            "newmsgs = {@newmsgs, {i, msgs[msg_order[i]][2]}};",
            "endfor",
            "if (length(this.messages) != n)",
            "\"...shit, new mail received,... start again...\";",
            "fork (0)",
            "this:date_sort();",
            "endfork",
            "else",
            "this.messages = newmsgs;",
            "this.last_used_time = newmsgs[$][2][1];",
            "endif"
          ]
        },
        {
          "name": "_fix_last_msg_date",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "mlen = this:length_all_msgs();",
            "this.last_msg_date = mlen && this:messages_in_seq(mlen)[2][1];"
          ]
        },
        {
          "name": "moderator_notify",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "return this.(verb);"
          ]
        },
        {
          "name": "msg_summary_line",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "return $mail_agent:msg_summary_line(@args);"
          ]
        },
        {
          "name": "__check",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "for m in (this.messages)",
            "$mail_agent:__convert_new(@m[2]);",
            "$command_utils:suspend_if_needed(0);",
            "endfor"
          ]
        },
        {
          "name": "__fix",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "msgs = {};",
            "i = 1;",
            "for m in (oldmsgs = this.messages)",
            "msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", i, \" \", this));",
            "suspend(0);",
            "if (oldmsgs != this.messages)",
            "return 0;",
            "endif",
            "endif",
            "i = i + 1;",
            "endfor",
            "this.messages = msgs;",
            "return 1;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "if (!(this in {$mail_recipient, $big_mail_recipient}))",
            "\"...generic mail recipients stay in #-1...\";",
            "move(this, $mail_agent);",
            "this:rm_message_seq($seq_utils:range(1, this:length_all_msgs()));",
            "this:expunge_rmm();",
            "this:_fix_last_msg_date();",
            "this.mail_forward = {};",
            "for p in ({\"mail_notify\", \"moderator_forward\", \"moderator_notify\", \"writers\", \"readers\", \"expire_period\", \"last_used_time\"})",
            "this.(p) = $mail_recipient.(p);",
            "endfor",
            "endif",
            "endif"
          ]
        },
        {
          "name": "initialize",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "this.mail_forward = {};",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "mail_name_old mail_name short_mail_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "return \"*\" + this.aliases[1];"
          ]
        },
        {
          "name": "mail_names",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "names = {};",
            "for a in (this.aliases)",
            "if (!index(a, \" \"))",
            "names = setadd(names, strsub(a, \"_\", \"-\"));",
            "endif",
            "endfor",
            "return names;"
          ]
        },
        {
          "name": "expire_old_messages",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (this:ok_write(caller, caller_perms()))",
            "if ($network.active)",
            "\"Passed security check...\";",
            "set_task_perms($wiz_utils:random_wizard());",
            "for x in (this.mail_notify)",
            "if (!$object_utils:has_verb(x, \"notify_mail\"))",
            "\"In theory I should call this:delete_notify but it's ugly and ticky as sin and I'm lazy.\";",
            "this.mail_notify = setremove(this.mail_notify, x);",
            "endif",
            "endfor",
            "if (this.expire_period && (rmseq = $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(time() - this.expire_period))))",
            "\"... i.e., everything not marked kept that is older than expire_period\";",
            "if (this.registered_email && this.email_validated)",
            "format = this.owner:format_for_netforward(this:messages_in_seq(rmseq), \" expired from \" + $mail_agent:name(this));",
            "$network:sendmail(this.registered_email, @{format[2], @format[1]});",
            "\"Do nothing if it bounces, etc.\";",
            "endif",
            "this:rm_message_seq(rmseq);",
            "return this:expunge_rmm();",
            "else",
            "return 0;",
            "endif",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "if (this:is_writable_by(caller_perms()) || this:is_writable_by(caller))",
            "pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "msg_full_text",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":msg_full_text(@msg) => list of strings.\";",
            "\"msg is a mail message (in the usual transmission format).\";",
            "\"display_seq_full calls this to obtain the actual list of strings to display.\";",
            "return player:msg_text(@args);",
            "\"default is to leave it up to the player how s/he wants it to be displayed.\";"
          ]
        },
        {
          "name": "@set_expire",
          "owner": 36,
          "perms": 109,
          "preps": 1,
          "object": 45,
          "code": [
            "\"Syntax:  @set_expire <recipient> to <time>\";",
            "\"         @set_expire <recipient> to\";",
            "\"\";",
            "\"Allows the list owner to set the expiration period of this mail recipient. This is the time messages will remain before they are removed from the list. The <time> given can be in english terms (e.g., 2 months, 45 days, etc.).\";",
            "\"Non-wizard mailing list owners are limited to a maximum expire period of 180 days. They are also prohibited from setting the list to non-expiring.\";",
            "\"Wizards may set the expire period to 0 for no expiration.\";",
            "\"The second form, leaving off the time specification, will tell you what the recipient's expire period is currently set to.\";",
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "return player:tell(E_PERM);",
            "elseif (!this:is_writable_by(player))",
            "return player:tell(E_PERM);",
            "elseif (!iobjstr)",
            "return player:tell(this.expire_period ? tostr(\"Messages will automatically expire from \", this:mail_name(), \" after \", $time_utils:english_time(this.expire_period), \".\") | tostr(\"Messages will not expire from \", this:mail_name()));",
            "elseif (typeof(time = $time_utils:parse_english_time_interval(iobjstr)) == ERR)",
            "return player:tell(time);",
            "elseif ((time == 0) && (!player.wizard))",
            "return player:tell(\"Only wizards may set a mailing list to not expire.\");",
            "elseif ((time > (180 * 86400)) && (!player.wizard))",
            "return player:tell(\"Only a wizard may set the expiration period on a mailing list to greater than 180 days.\");",
            "endif",
            "this.expire_period = time;",
            "player:tell(\"Messages will \", (time != 0) ? tostr(\"automatically expire from \", this:mail_name(), \" after \", $time_utils:english_time(time)) | tostr(\"not expire from \", this:mail_name()), \".\");"
          ]
        },
        {
          "name": "@register @netregister",
          "owner": 2,
          "perms": 109,
          "preps": 1,
          "object": 45,
          "code": [
            "\"Syntax:   @register <recipient> to <email-address>\";",
            "\"alias     @netregister <recipient> to <email-address>\";",
            "\"          @register <recipient> to\";",
            "\"\";",
            "\"The list owner may use this command to set a registered email address for the mail recipient. When set, mail messages that expire off of the mail recipient will be mailed to that address.\";",
            "\"If you leave the email address off of the command, it will return the current registration and expiration information for that recipient if you own it.\";",
            "\"The owner may register a mail recipient to any email address. However, if the address does not match his registered email address, then a password will be generated and sent to the address specified when this command is used. Then, the owner may retrieve that password and verify the address with the command:\";",
            "\"\";",
            "\"  @validate <recipient> with <password>\";",
            "\"\";",
            "\"See *B:MailingListReform #98087 for full details.\";",
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "return player:tell(E_PERM);",
            "elseif (!$perm_utils:controls(player, this))",
            "return player:tell(E_PERM);",
            "elseif (!iobjstr)",
            "if (this.registered_email)",
            "player:tell(this:mail_name(), \" is registered to \", this.registered_email, \". Messages will be sent there when they expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \".\");",
            "else",
            "player:tell(this:mail_name(), \" is not registered to any address. Messages will be deleted when they expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \".\");",
            "player:tell(\"Usage:  @register <recipient> to <email-address>\");",
            "endif",
            "return;",
            "elseif (iobjstr == $wiz_utils:get_email_address(player))",
            "this.registered_email = $wiz_utils:get_email_address(player);",
            "this.email_validated = 1;",
            "player:tell(\"Messages expired from \", this:mail_name(), \" after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \" will be emailed to \", this.registered_email, \" (which is your registered email address).\");",
            "elseif (reason = $network:invalid_email_address(iobjstr))",
            "return player:tell(reason, \".\");",
            "elseif (!$network.active)",
            "return player:tell(\"The network is not up at the moment. Please try again later or contact a wizard for help.\");",
            "else",
            "password = $wiz_utils:random_password(5);",
            "result = $network:sendmail(iobjstr, tostr($network.MOO_Name, \" mailing list verification\"), @$generic_editor:fill_string(tostr(\"The mailing list \", this:mail_name(), \" on \", $network.MOO_Name, \" has had this address designated as the recipient of expired mail messages. If this is not correct, then you need do nothing but ignore this message. If this is correct, you must log into the MOO and type:  `@validate \", this:mail_name(), \" with \", password, \"' to start receiving expired mail messages.\"), 75));",
            "if (result != 0)",
            "return player:tell(\"Mail sending did not work: \", result, \". Address not set.\");",
            "endif",
            "this.registered_email = iobjstr;",
            "this.email_validated = 0;",
            "this.validation_password = password;",
            "player:tell(\"Registration complete. Password sent to the address you specified. When you receive the email, log back in to validate it with the command:  @validate <recipient> with <password>. If you do not receive the password email, try again or notify a wizard if this is a recurring problem.\");",
            "endif"
          ]
        },
        {
          "name": "@validate",
          "owner": 36,
          "perms": 109,
          "preps": 0,
          "object": 45,
          "code": [
            "\"Syntax:  @validate <recipient> with <password>\";",
            "\"\";",
            "\"This command is used to validate an email address set to receive expired messages that did not match the list owner's registered email address. When using the @register command, a password was sent via email to the address specified. This command is to verify that the password was received properly.\";",
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "return player:tell(E_PERM);",
            "elseif (!$perm_utils:controls(player, this))",
            "return player:tell(E_PERM);",
            "elseif (!this.registered_email)",
            "return player:tell(\"No email address has even been set for \", this:mail_name(), \".\");",
            "elseif (this.email_validated)",
            "return player:tell(\"The email address for \", this:mail_name(), \" has already been validated.\");",
            "elseif (!iobjstr)",
            "return player:tell(\"Usage:  @validate <recipient> with <password>\");",
            "elseif (iobjstr != this.validation_password)",
            "return player:tell(\"That is not the correct password.\");",
            "else",
            "this.email_validated = 1;",
            "player:tell(\"Password validated. Messages that expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \" from \", this:mail_name(), \" will be emailed to \", this.registered_email, \".\");",
            "endif"
          ]
        },
        {
          "name": "set_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "{name} = args;",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (this.location != $mail_agent)",
            "\"... we don't care...\";",
            "return pass(@args);",
            "elseif (index(name, \" \"))",
            "\"... we don't care...\";",
            "elseif (rp = $mail_agent:reserved_pattern(name))",
            "player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);",
            "return 0;",
            "elseif (valid(p = $mail_agent:match(name, #-1)) && ((p != this) && (name in p.aliases)))",
            "player:tell(\"Mailing list name \\\"\", name, \"\\\" in use on \", p.name, \"(\", p, \")\");",
            "return 0;",
            "endif",
            "return pass(name);"
          ]
        },
        {
          "name": "ok_annotate",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\":ok_annotate(caller,callerperms) => true iff caller can do annotations\";",
            "return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_annotatable_by(args[2]));"
          ]
        },
        {
          "name": "annotate_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 45,
          "code": [
            "\"annotate_message_seq(note, \\\"append\\\"|\\\"prepend\\\", message_seq) ;\";",
            "\"\";",
            "\"Prepend or append (default is prepend) note (a list of strings) to each message in message_seq\";",
            "\"Recipient must be annotatable (:is_annotatable_by() returns 1) by the caller for this to work.\";",
            "{note, appendprepend, message_seq} = args;",
            "if (!this:ok_annotate(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "for i in ($seq_utils:tolist(message_seq))",
            "body = this:message_body_by_index(i);",
            "if (appendprepend == \"append\")",
            "body = {@body, \"\", @note};",
            "else",
            "body = {@note, \"\", @body};",
            "endif",
            "this:set_message_body_by_index(i, body);",
            "endfor",
            "return 1;",
            "\"Copied from annotatetest (#87053):annotate_message_seq [verb author Puff (#1449)] at Mon Feb 14 14:04:56 2005 PST\";"
          ]
        }
      ],
      "propnames": [
        "moderator_notify",
        "last_msg_date",
        "messages_going",
        "moderated",
        "moderator_forward",
        "writers",
        "readers",
        "mail_notify",
        "mail_forward",
        "expire_period",
        "last_used_time",
        "messages",
        "rmm_own_msgs",
        "guests_can_send_here",
        "messages_kept",
        "registered_email",
        "email_validated",
        "validation_password"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "%t (%[#t]) is a generic recipient.",
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "",
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 0
        },
        {
          "value": "",
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Mail Recipient"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "This can either be a mailing list or a mail folder, depending on what mood you're in...",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            45731,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "46": {
      "id": 46,
      "name": "Mail Distribution Center",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [
        17,
        29,
        34,
        61,
        70
      ],
      "verbs": [
        {
          "name": "resolve_addr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"resolve(name,from,seen,prevrcpts,prevnotifs) => {rcpts,notifs} or E_INVARG\";",
            "\"resolve(list,from,seen,prevrcpts,prevnotifs) => {bogus,rcpts,notifs}\";",
            "\"Given either an address (i.e., objectid) or a list of such, traces down all .mail_forward lists and .mail_notify to determine where a message should actually go and who should be told about it.  Both forms take previous lists of recipients/notifications and add only those addresses that weren't there before.  `seen' is the stack of addresses we are currently resolving (for detecting loops).  The first form returns E_INVARG if `name' is invalid.  The second form returns all invalid addresses in the `bogus' list but still does the appropriate search on the remaining addresses.\";",
            "{recip, from, ?seen = {}, ?prevrcpts = {}, ?prevnotifs = {}} = args;",
            "sofar = {prevrcpts, prevnotifs};",
            "if (typeof(recip) == LIST)",
            "bogus = {};",
            "for r in (recip)",
            "result = this:resolve_addr(r, from, seen, @sofar);",
            "if (result)",
            "sofar = result;",
            "else",
            "bogus = setadd(bogus, r);",
            "endif",
            "endfor",
            "return {bogus, @sofar};",
            "else",
            "fwd = include_recip = 0;",
            "if ((recip == $nothing) || (recip in seen))",
            "return sofar;",
            "elseif ((!valid(recip)) || ((!(is_player(recip) || $object_utils:isa(recip, $mail_recipient))) || (typeof(fwd = recip:mail_forward(from)) != LIST)))",
            "\"recip is a non-player non-mailing-list/folder or forwarding is screwed.\";",
            "if (typeof(fwd) == STR)",
            "player:tell(fwd);",
            "endif",
            "return E_INVARG;",
            "elseif (is_player(recip) && `recip:refuses_action(from, \"mail\") ! E_VERBNF')",
            "player:tell(recip:mail_refused_msg());",
            "return E_INVARG;",
            "elseif (fwd)",
            "if (r = recip in fwd)",
            "include_recip = 1;",
            "fwd = listdelete(fwd, r);",
            "endif",
            "result = this:resolve_addr(fwd, recip, setadd(seen, recip), @sofar);",
            "if (bogus = result[1])",
            "player:tell(recip.name, \"(\", recip, \")'s .mail_forward list includes the following bogus entr\", (length(bogus) > 1) ? \"ies:  \" | \"y:  \", $string_utils:english_list(bogus));",
            "endif",
            "sofar = result[2..3];",
            "else",
            "include_recip = 1;",
            "endif",
            "if ((ticks_left() < 1000) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "biffs = sofar[2];",
            "for n in (this:mail_notify(recip, from))",
            "if (valid(n))",
            "if (i = $list_utils:iassoc_suspended(n, biffs))",
            "biffs[i] = setadd(biffs[i], recip);",
            "else",
            "biffs = {{n, recip}, @biffs};",
            "endif",
            "endif",
            "if ((ticks_left() < 1000) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "return {include_recip ? setadd(sofar[1], recip) | sofar[1], biffs};",
            "endif"
          ]
        },
        {
          "name": "sends_to",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"sends_to(from,addr,rcpt[,seen]) ==> true iff mail sent to addr passes through rcpt.\";",
            "{from, addr, rcpt, ?seen = {}} = args;",
            "if (addr == rcpt)",
            "return 1;",
            "elseif (!(addr in seen))",
            "seen = {@seen, addr};",
            "for a in ((typeof(fwd = this:mail_forward(addr, @from ? {} | {from})) == LIST) ? fwd | {})",
            "if (this:sends_to(addr, a, rcpt, seen))",
            "return 1;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "send_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"send_message(from,rcpt-list,hdrs,msg) -- formats and sends a mail message.  hders is either the text of the subject line, or a {subject,{reply-to,...}} list.\";",
            "\"Return E_PERM if from isn't owned by the caller.\";",
            "\"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.\";",
            "\"Return {1, @actual_rcpts} if successful.\";",
            "{from, to, orig_hdrs, msg} = args;",
            "\"...\";",
            "\"... remove bogus Resent-To/Resent-By headers...\";",
            "\"...\";",
            "if ((typeof(orig_hdrs) == LIST) && (length(orig_hdrs) > 2))",
            "hdrs = orig_hdrs[1..2];",
            "orig_hdrs[1..2] = {};",
            "strip = {\"Resent-To\", \"Resent-By\"};",
            "for h in (orig_hdrs)",
            "(h[1] in strip) || (hdrs = {@hdrs, h});",
            "endfor",
            "else",
            "hdrs = orig_hdrs;",
            "endif",
            "\"...\";",
            "\"... send it...\";",
            "\"...\";",
            "if ($perm_utils:controls(caller_perms(), from))",
            "text = $mail_agent:make_message(from, to, hdrs, msg);",
            "return this:raw_send(text, to, from);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "raw_send",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"Copied from Mail Distribution Center (#6418):raw_send by Nosredna (#2487) Mon Feb 24 10:46:26 1997 PST\";",
            "\"WIZARDLY\";",
            "\"raw_send(text,rcpts,sender) -- does the actual sending of a message.  Assumes that text has already been formatted correctly.  Decides who to send it to and who wants to be notified about it and does so.\";",
            "\"Return {E_PERM} if the caller is not entitled to use this verb.\";",
            "\"Return {0, @invalid_rcpts} if rcpts contains any invalid addresses.  No mail is sent in this case.\";",
            "\"Return {1, @actual_rcpts} if successful.\";",
            "{text, rcpts, from} = args;",
            "if (typeof(rcpts) != LIST)",
            "rcpts = {rcpts};",
            "endif",
            "if (!(caller in {$mail_agent, $mail_editor}))",
            "return {E_PERM};",
            "elseif (bogus = (resolve = this:resolve_addr(rcpts, from))[1])",
            "return {0, bogus};",
            "else",
            "set_task_perms($wiz_utils:random_wizard());",
            "this:touch(rcpts);",
            "actual_rcpts = resolve[2];",
            "biffs = resolve[3];",
            "results = {};",
            "for recip in (actual_rcpts)",
            "if ((ticks_left() < 10000) || (seconds_left() < 2))",
            "player:notify(tostr(\"...\", recip));",
            "suspend(1);",
            "endif",
            "if (typeof(e = recip:receive_message(text, from)) in {ERR, STR})",
            "\"...receive_message bombed...\";",
            "player:notify(tostr(recip, \":receive_message:  \", e));",
            "e = 0;",
            "elseif ((!is_player(recip)) || (!e))",
            "\"...not a player or receive_message isn't giving out the message number\";",
            "\"...no need to force a notification...\";",
            "elseif (i = $list_utils:iassoc(recip, biffs))",
            "\"...player-recipient was already getting a notification...\";",
            "\"...make sure notification includes a mention of him/her/itself.\";",
            "if (!(recip in listdelete(biffs[i], 1)))",
            "biffs[i][2..1] = {recip};",
            "endif",
            "else",
            "\"...player-recipient wasn't originally being notified at all...\";",
            "biffs = {{recip, recip}, @biffs};",
            "endif",
            "results = {@results, e};",
            "endfor",
            "\"The following is because the scheduler can BITE ME. --Nosredna\";",
            "fork (0)",
            "for b in (biffs)",
            "if ((ticks_left() < 10000) || (seconds_left() < 2))",
            "suspend(1);",
            "endif",
            "if ($object_utils:has_callable_verb(b[1], \"notify_mail\"))",
            "mnums = {};",
            "for r in (listdelete(b, 1))",
            "mnums = {@mnums, (rn = r in actual_rcpts) && results[rn]};",
            "endfor",
            "b[1]:notify_mail(from, listdelete(b, 1), mnums);",
            "endif",
            "endfor",
            "endfork",
            "return {1, @actual_rcpts};",
            "endif"
          ]
        },
        {
          "name": "mail_forward mail_notify",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "who = args[1];",
            "if ($object_utils:has_verb(who, verb))",
            "return who:(verb)(@listdelete(args, 1));",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "touch",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"touch(name or list,seen) => does .last_used_time = time() if we haven't already touched this in the last hour\";",
            "{recip, ?seen = {}} = args;",
            "if (typeof(recip) == LIST)",
            "for r in (recip)",
            "result = this:touch(r, seen);",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "else",
            "if (((!valid(recip)) || (recip in seen)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))",
            "\"recip is neither a player nor a mailing list/folder\";",
            "else",
            "if (fwd = this:mail_forward(recip))",
            "this:touch(fwd, {@seen, recip});",
            "endif",
            "if (!is_player(recip))",
            "recip.last_used_time = time();",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "look_self",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "player:tell_lines(this.description);",
            "for c in (this.contents)",
            "$command_utils:suspend_if_needed(0);",
            "c:look_self();",
            "endfor"
          ]
        },
        {
          "name": "acceptable",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"Only allow mailing lists/folders in here and only if their names aren't already taken.\";",
            "what = args[1];",
            "return ($object_utils:isa(what, $mail_recipient) && this:check_names(what, @what.aliases)) && (what:description() != parent(what):description());"
          ]
        },
        {
          "name": "check_names",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"...make sure the list has at least one usable name.\";",
            "\"...make sure none of the aliases are already taken.\";",
            "{object, @aliases} = args;",
            "if (typeof(object) == STR)",
            "\"... legacy; old version of this verb did not take on OBJ argument\";",
            "aliases = args;",
            "endif",
            "ok = 0;",
            "if (length(aliases) > this.max_list_aliases)",
            "player:tell(\"Mailing lists may not have more than \", this.max_list_aliases, \" aliases.\");",
            "return 0;",
            "endif",
            "for a in (aliases)",
            "sub1 = strsub(a, \"_\", \"-\");",
            "sub2 = strsub(a, \"-\", \"_\");",
            "if (sub1 == sub2)",
            "check = 0;",
            "else",
            "check = 1;",
            "endif",
            "if (index(a, \" \"))",
            "elseif (rp = $mail_agent:reserved_pattern(a))",
            "player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);",
            "return 0;",
            "elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != object) && (a in p.aliases)))",
            "player:tell(\"Mailing list name \\\"\", a, \"\\\" in use on \", p.name, \"(\", p, \")\");",
            "return 0;",
            "elseif (check && (valid(p = $mail_agent:match(sub1, #-1)) && ((p != object) && (sub1 in p.aliases))))",
            "player:tell(\"Mailing list name \\\"\", sub1, \"\\\" in use on \", p.name, \"(\", p, \")\");",
            "return 0;",
            "elseif (check && (valid(p = $mail_agent:match(sub2, #-1)) && ((p != object) && (sub2 in p.aliases))))",
            "player:tell(\"Mailing list name \\\"\", sub2, \"\\\" in use on \", p.name, \"(\", p, \")\");",
            "return 0;",
            "else",
            "ok = 1;",
            "endif",
            "endfor",
            "return ok;"
          ]
        },
        {
          "name": "match_old match",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":match(string) => mailing list object in here that matches string.\";",
            "\":match(string,player) => similar but also matches against player's private mailing lists (as kept in .mail_lists).\";",
            "if (!(string = args[1]))",
            "return $nothing;",
            "elseif (string[1] == \"*\")",
            "string = string[2..$];",
            "endif",
            "if (valid(o = $string_utils:literal_object(string)) && ($mail_recipient in $object_utils:ancestors(o)))",
            "return o;",
            "elseif (rp = this:reserved_pattern(string))",
            "return rp[2]:match_mail_recipient(string);",
            "else",
            "if (valid(who = {@args, player}[2]) && (typeof(use = `who.mail_lists ! E_PROPNF, E_PERM') == LIST))",
            "use = {@this.contents, @use};",
            "else",
            "use = this.contents;",
            "endif",
            "partial = 1;",
            "string = strsub(string, \"_\", \"-\");",
            "for l in (use)",
            "if (string in l.aliases)",
            "return l;",
            "endif",
            "if (partial != $ambiguous_match)",
            "for a in (l.aliases)",
            "if ((index(a, string) == 1) && (!index(a, \" \")))",
            "if (partial)",
            "partial = l;",
            "elseif (partial != l)",
            "partial = $ambiguous_match;",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "endfor",
            "return partial && $failed_match;",
            "endif"
          ]
        },
        {
          "name": "match_recipient",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":match_recipient(string[,meobj]) => $player or $mail_recipient object that matches string.  Optional second argument (defaults to player) is returned in the case string==\\\"me\\\" and is also used to obtain a list of private $mail_recipients to match against.\";",
            "{string, ?me = player} = args;",
            "if (valid(me) && ($failed_match != (o = me:my_match_recipient(string))))",
            "return o;",
            "elseif (!string)",
            "return $nothing;",
            "elseif ((string[1] == \"*\") && (string != \"*\"))",
            "return this:match(@args);",
            "elseif (string[1] == \"`\")",
            "args[1][1..1] = \"\";",
            "return $string_utils:match_player(@args);",
            "elseif (valid(o = $string_utils:match_player(@args)) || (o == $ambiguous_match))",
            "return o;",
            "else",
            "return this:match(@args);",
            "endif"
          ]
        },
        {
          "name": "match_failed",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "{match_result, string, ?cmd_id = \"\"} = args;",
            "cmd_id = cmd_id || \"\";",
            "if (match_result == $nothing)",
            "player:tell(cmd_id, \"You must specify a valid mail recipient.\");",
            "elseif (match_result == $failed_match)",
            "player:tell(cmd_id, \"There is no mail recipient called \\\"\", string, \"\\\".\");",
            "elseif (match_result == $ambiguous_match)",
            "if ((nostar = index(string, \"*\") != 1) && (lst = $player_db:find_all(string)))",
            "player:tell(cmd_id, \"\\\"\", string, \"\\\" could refer to \", (length(lst) > 20) ? tostr(\"any of \", length(lst), \" players\") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", lst), \"no one\", \" or \"), \".\");",
            "else",
            "player:tell(cmd_id, \"I don't know which \\\"\", nostar ? \"*\" | \"\", string, \"\\\" you mean.\");",
            "endif",
            "elseif (!valid(match_result))",
            "player:tell(cmd_id, match_result, \" does not exist.\");",
            "else",
            "return 0;",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "make_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":make_message(sender,recipients,subject/replyto/additional-headers,body)\";",
            "\" => message in the form as it will get sent.\";",
            "{from, recips, hdrs, body} = args;",
            "try",
            "fromowner = from.owner;",
            "except (E_INVIND)",
            "raise(E_PERM);",
            "endtry",
            "fromline = this:name_list(from);",
            "if (typeof(recips) != LIST)",
            "recips = {recips};",
            "endif",
            "recips = this:name_list(@recips);",
            "others = {};",
            "replyto = 0;",
            "if (typeof(hdrs) != LIST)",
            "hdrs = {hdrs};",
            "endif",
            "subj = hdrs[1];",
            "if (!valid(from))",
            "others = {\"Probable-Sender:   \" + this:name(fromowner)};",
            "\"  others = {'Possible-Sender:   ' + this:name(player)}\";",
            "\"  if (caller_perms() != player)\";",
            "\"    others = {@others, 'Possible-Sender:   ' + this:name(caller_perms())}\";",
            "\"  endif\";",
            "elseif (!is_player(from))",
            "others = {\"Sender:   \" + this:name(from.owner)};",
            "endif",
            "replyto = {@hdrs, 0}[2] && this:name_list(@hdrs[2]);",
            "if (length(hdrs) > 2)",
            "hdrs[1..2] = {};",
            "for h in (hdrs)",
            "if (match(h[1], \"[a-z1-9-]+\"))",
            "others = {@others, $string_utils:left(h[1] + \": \", 15) + h[2]};",
            "endif",
            "endfor",
            "endif",
            "if (typeof(body) != LIST)",
            "body = body ? {body} | {};",
            "endif",
            "return {this:time(), fromline, recips, subj || \" \", @replyto ? {\"Reply-to: \" + replyto} | {}, @others, \"\", @body};"
          ]
        },
        {
          "name": "name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "what = args[1];",
            "if (!valid(what))",
            "name = \"???\";",
            "elseif ((!is_player(what)) && $object_utils:has_callable_verb(what, \"mail_name\"))",
            "name = what:mail_name();",
            "else",
            "name = what.name;",
            "endif",
            "while (m = match(name, \"(#[0-9]+)\"))",
            "{s, e} = m[1..2];",
            "name[s..e] = \"\";",
            "endwhile",
            "return tostr(name, \" (\", what, \")\");"
          ]
        },
        {
          "name": "name_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "return $string_utils:english_list($list_utils:map_arg(this, \"name\", args), \"no one\");"
          ]
        },
        {
          "name": "parse_address_field",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":parse_address_field(string) => list of objects\";",
            "\"This is the standard routine for parsing address lists that appear in From:, To: and Reply-To: lines\";",
            "objects = {};",
            "string = args[1];",
            "while (m = match(string, \"(#[0-9]+)\"))",
            "{s, e} = m[1..2];",
            "if (#0 != (o = toobj(string[s + 1..e - 1])))",
            "objects = {@objects, o};",
            "endif",
            "string = string[e + 1..$];",
            "endwhile",
            "return objects;"
          ]
        },
        {
          "name": "display_seq_full",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":display_seq_full(msg_seq[,preamble]) => {cur, last-read-date}\";",
            "\"This is the default message display routine.\";",
            "\"Prints entire messages on folder (caller) to player.  msg_seq is the handle returned by :parse_message_seq(...) and indicates which messages should be printed.  preamble, if given will precede the output of the message itself, in which case the message number will be substituted for \\\"%d\\\".  Returns the number of the final message in the sequence (which can be then used as the new current message number).\";",
            "set_task_perms(caller_perms());",
            "{msg_seq, ?preamble = \"\"} = args;",
            "cur = date = 0;",
            "for x in (msgs = caller:messages_in_seq(msg_seq))",
            "cur = x[1];",
            "date = x[2][1];",
            "player:display_message(preamble ? strsub(preamble, \"%d\", tostr(cur)) | {}, caller:msg_full_text(@x[2]));",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "return {cur, date};"
          ]
        },
        {
          "name": "display_seq_headers",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":display_seq_headers(msg_seq[,cur[,last_read_date]])\";",
            "\"This is the default header display routine.\";",
            "\"Prints a list of headers of messages on caller to player.  msg_seq is the handle returned by caller:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.\";",
            "set_task_perms(caller_perms());",
            "{msg_seq, ?cur = 0, ?last_old = $maxint} = args;",
            "keep_seq = {@$seq_utils:contract(caller:kept_msg_seq(), $seq_utils:complement(msg_seq, 1, caller:length_all_msgs())), $maxint};",
            "k = 1;",
            "mcount = 0;",
            "width = player:linelen() || 79;",
            "for x in (msgs = caller:messages_in_seq(msg_seq))",
            "if (keep_seq[k] <= (mcount = mcount + 1))",
            "k = k + 1;",
            "endif",
            "annot = ((d = x[2][1]) > last_old) ? \"+\" | ((k % 2) ? \" \" | \"=\");",
            "line = tostr($string_utils:right(x[1], 4, (cur == x[1]) ? \">\" | \" \"), \":\", annot, \" \", caller:msg_summary_line(@x[2]));",
            "player:tell(line[1..min(width, $)]);",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "player:tell(\"----+\");"
          ]
        },
        {
          "name": "rm_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":rm_message_seq(msg_seq)  removes the given sequence of from folder (caller)\";",
            "\"...removed messages are saved in .messages_going for possible restoration.\";",
            "set_task_perms(caller_perms());",
            "old = caller.messages;",
            "new = save = nums = {};",
            "next = 1;",
            "for i in [1..length(seq = args[1]) / 2]",
            "if ($command_utils:running_out_of_time())",
            "player:tell(\"... rmm \", old[next][1] - 1);",
            "suspend(0);",
            "endif",
            "start = seq[(2 * i) - 1];",
            "new = {@new, @old[next..start - 1]};",
            "save = {@save, {start - next, old[start..(next = seq[2 * i]) - 1]}};",
            "nums = {@nums, old[start][1], old[next - 1][1] + 1};",
            "endfor",
            "new = {@new, @old[next..$]};",
            "$command_utils:suspend_if_needed(0, \"... rmm ...\");",
            "save_kept = $seq_utils:intersection(caller.messages_kept, seq);",
            "$command_utils:suspend_if_needed(0, \"... rmm ...\");",
            "new_kept = $seq_utils:contract(caller.messages_kept, seq);",
            "$command_utils:suspend_if_needed(0, \"... rmm ...\");",
            "caller.messages_going = save_kept ? {save_kept, save} | save;",
            "caller.messages = new;",
            "caller.messages_kept = new_kept;",
            "if ($object_utils:has_callable_verb(caller, \"_fix_last_msg_date\"))",
            "caller:_fix_last_msg_date();",
            "endif",
            "return $seq_utils:tostr(nums);"
          ]
        },
        {
          "name": "undo_rmm",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":undo_rmm()  restores previously deleted messages in .messages_going to .messages.\";",
            "set_task_perms(caller_perms());",
            "old = caller.messages;",
            "going = caller.messages_going;",
            "new = seq = {};",
            "last = 0;",
            "next = 1;",
            "\"there are two possible formats here:\";",
            "\"OLD: {{n,msgs},{n,msgs},...}\";",
            "\"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}\";",
            "if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))",
            "kept = going[1];",
            "going = going[2];",
            "else",
            "kept = {};",
            "endif",
            "for s in (going)",
            "new = {@new, @old[last + 1..last + s[1]], @s[2]};",
            "last = last + s[1];",
            "seq = {@seq, next + s[1], next = length(new) + 1};",
            "endfor",
            "caller.messages = {@new, @old[last + 1..$]};",
            "caller.messages_going = {};",
            "caller.messages_kept = $seq_utils:union(kept, $seq_utils:expand(caller.messages_kept, seq));",
            "if ($object_utils:has_callable_verb(caller, \"_fix_last_msg_date\"))",
            "caller:_fix_last_msg_date();",
            "endif",
            "return seq;"
          ]
        },
        {
          "name": "expunge_rmm list_rmm",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":list_rmm()    displays contents of .messages_going.\";",
            "\":expunge_rmm() destroys contents of .messages_going once and for all.\";",
            "\"... both return the number of messages in .messages_going.\";",
            "set_task_perms(caller_perms());",
            "cmg = caller.messages_going;",
            "if (cmg && ((!cmg[1]) || (typeof(cmg[1][2]) == INT)))",
            "kept = cmg[1];",
            "cmg = cmg[2];",
            "else",
            "kept = {};",
            "endif",
            "if (verb == \"expunge_rmm\")",
            "caller.messages_going = {};",
            "count = 0;",
            "for s in (cmg)",
            "count = count + length(s[2]);",
            "endfor",
            "return count;",
            "elseif (!cmg)",
            "return 0;",
            "else",
            "msgs = seq = {};",
            "next = 1;",
            "for s in (cmg)",
            "msgs = {@msgs, @s[2]};",
            "seq = {@seq, next = next + s[1], next = next + length(s[2])};",
            "endfor",
            "kept = {@$seq_utils:contract(kept, $seq_utils:complement(seq, 1, $seq_utils:last(seq))), $maxint};",
            "k = 1;",
            "mcount = 0;",
            "for x in (msgs)",
            "if (kept[k] <= (mcount = mcount + 1))",
            "k = k + 1;",
            "endif",
            "player:tell($string_utils:right(x[1], 4), \":\", (k % 2) ? \"  \" | \"= \", caller:msg_summary_line(@x[2]));",
            "if ((ticks_left() < 500) || (seconds_left() < 2))",
            "suspend(0);",
            "endif",
            "endfor",
            "if (msgs)",
            "player:tell(\"----+\");",
            "endif",
            "return length(msgs);",
            "endif"
          ]
        },
        {
          "name": "renumber",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":renumber([cur]) -- assumes caller is a $mail_recipient or a $player.\";",
            "\"...renumbers caller.messages, doing a suspend() if necessary.\";",
            "\"...returns {number of messages,new cur}.\";",
            "set_task_perms(caller_perms());",
            "{?cur = 0} = args;",
            "caller.messages_going = {};",
            "\"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...\";",
            "msgs = caller.messages;",
            "if (cur)",
            "cur = $list_utils:iassoc_sorted(cur, msgs);",
            "endif",
            "while (1)",
            "\"...find first out-of-sequence message...\";",
            "l = 0;",
            "r = (len = length(msgs)) + 1;",
            "while ((r - 1) > l)",
            "if (msgs[i = (r + l) / 2][1] > i)",
            "r = i;",
            "else",
            "l = i;",
            "endif",
            "endwhile",
            "\"... r == first out-of-sequence, l == last in-sequence, l+1 == r ...\";",
            "if (l >= len)",
            "return {l, cur};",
            "endif",
            "\"...renumber as many messages as we have time for...\";",
            "chunk = {};",
            "while (((r <= len) && (ticks_left() > 3000)) && (seconds_left() > 2))",
            "for x in (msgs[r..min(r + 9, len)])",
            "chunk = {@chunk, {r, x[2]}};",
            "r = r + 1;",
            "endfor",
            "endwhile",
            "caller.messages = {@msgs[1..l], @chunk, @msgs[r..len]};",
            "if (chunk)",
            "player:tell(\"...(renumbering \", l + 1, \" -- \", r - 1, \")\");",
            "suspend(0);",
            "else",
            "player:tell(\"You lose.  This message collection is just too big.\");",
            "return;",
            "endif",
            "\"... have to be careful since new mail may be received at this point...\";",
            "msgs = caller.messages;",
            "endwhile"
          ]
        },
        {
          "name": "msg_summary_line",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":msg_summary_line(@msg) => date/from/subject as a single string.\";",
            "body = (\"\" in {@args, \"\"}) + 1;",
            "if ((body > length(args)) || (!(subject = args[body])))",
            "subject = \"(None.)\";",
            "endif",
            "if (args[1] < (time() - 31536000))",
            "c = player:ctime(args[1]);",
            "date = c[5..11] + c[21..25];",
            "else",
            "date = player:ctime(args[1])[5..16];",
            "endif",
            "from = args[2];",
            "if (args[4] != \" \")",
            "subject = args[4];",
            "endif",
            "return tostr(date, \"   \", $string_utils:left(from, 20), \"   \", subject);"
          ]
        },
        {
          "name": "parse_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"parse_message_seq(strings,cur[,last_old])\";",
            "\"This is the default <message-sequence> parsing routine for those mail commands that refer to sequences of messages (@mail, @read,...) on a folder.\";",
            "\"  caller (the folder) is assumed to be a $mail_recipient or a player.\";",
            "\"  strings is the <message-sequence> portion of the arg list.\";",
            "\"  cur is the number of the player's current message for this folder.\";",
            "\"Returns a string error message if the parse fails, otherwise\";",
            "\"returns a list {msg_seq, @unused_strings}, where\";",
            "\"   msg_seq is a handle understood by caller:display_seq_full/headers(), and \";",
            "\"   unused_strings is the list of remaining uninterpreted strings\";",
            "set_task_perms(caller_perms());",
            "{strings, ?cur = 0, ?last_old = 0} = args;",
            "if (!(nummsgs = caller:length_all_msgs()))",
            "return \"%f %<has> no messages.\";",
            "elseif (typeof(strings) != LIST)",
            "strings = {strings};",
            "endif",
            "seq = result = {};",
            "mode = #0;",
            "\"... changes to 0 if we start seeing message numbers, to 1 if we see masks...\";",
            "keywords = \":from:%from:to:%to:subject:body:before:after:since:until:first:last:kept:unkept\";",
            "keyalist = {{1, \"from\"}, {6, \"%from\"}, {12, \"to\"}, {15, \"%to\"}, {19, \"subject\"}, {27, \"body\"}, {32, \"before\"}, {39, \"after\"}, {45, \"since\"}, {51, \"until\"}, {57, \"first\"}, {63, \"last\"}, {68, \"kept\"}, {73, \"unkept\"}};",
            "strnum = 0;",
            "for string in (strings)",
            "strnum = strnum + 1;",
            "$command_utils:suspend_if_needed(0);",
            "if (string && ((c = index(string, \":\")) && ((k = index(keywords, \":\" + string[1..c - 1])) && (k == rindex(keywords, \":\" + string[1..c - 1])))))",
            "\"...we have a mask to apply...\";",
            "keywd = $list_utils:assoc(k, keyalist)[2];",
            "if (mode == #0)",
            "seq = {1, nummsgs + 1};",
            "endif",
            "mode = 1;",
            "if (k <= 27)",
            "\"...from, subject, to, body...\";",
            "pattern = string[c + 1..$];",
            "if (keywd in {\"subject\", \"body\"})",
            "elseif (keywd[1] == \"%\")",
            "pattern = $string_utils:explode(pattern, \"|\");",
            "else",
            "pattern = this:((keywd == \"to\") ? \"_parse_to\" | \"_parse_from\")(pattern);",
            "if (typeof(pattern) == STR)",
            "return pattern;",
            "endif",
            "endif",
            "seq = caller:(keywd + \"_msg_seq\")(pattern, seq);",
            "if (typeof(seq) == STR)",
            "if (strnum == 1)",
            "return seq;",
            "else",
            "seq = {};",
            "endif",
            "endif",
            "elseif (k <= 51)",
            "\"...before, since, after, until...\";",
            "if (typeof(date = this:_parse_date(string[c + 1..$])) != INT)",
            "return tostr(\"Bad date `\", string, \"':  \", date);",
            "endif",
            "s = caller:length_date_le((keywd in {\"before\", \"since\"}) ? date - 1 | (date + 86399));",
            "if (keywd in {\"before\", \"until\"})",
            "seq = $seq_utils:remove(seq, s + 1, nummsgs);",
            "else",
            "seq = $seq_utils:remove(seq, 1, s);",
            "endif",
            "elseif (k <= 63)",
            "\"...first, last...\";",
            "if (n = toint(string[c + 1..$]))",
            "seq = $seq_utils:(keywd + \"n\")(seq, n);",
            "else",
            "return tostr(\"Bad number in `\", string, \"'\");",
            "endif",
            "else",
            "\"...kept, unkept...\";",
            "if (c < length(string))",
            "return tostr(\"Unexpected junk after `\", keywd, \":'\");",
            "elseif ((!(seq = caller:(keywd + \"_msg_seq\")(seq))) && (strnum == 1))",
            "return tostr(\"%f %<has> no \", keywd, \" messages.\");",
            "endif",
            "endif",
            "else",
            "\"...continue building the present sequence...\";",
            "if (mode)",
            "seq && (result = $seq_utils:union(result, seq));",
            "seq = {};",
            "endif",
            "mode = 0;",
            "if (!string)",
            "\"...default case for @read: get the current message but skip to the next one if it's not there...\";",
            "if (cur)",
            "i = min(caller:length_num_le(cur - 1) + 1, nummsgs);",
            "seq = $seq_utils:add(seq, i, i);",
            "else",
            "return \"%f %<has> no current message.\";",
            "endif",
            "elseif ((index(string, \"next\") == 1) && (!index(string, \"-\")))",
            "string[1..4] = \"\";",
            "if ((n = string ? toint(string) | 1) <= 0)",
            "return tostr(\"Bad number `\", string, \"'\");",
            "elseif ((i = caller:length_num_le(cur) + 1) <= nummsgs)",
            "seq = $seq_utils:add(seq, i, min((i + n) - 1, nummsgs));",
            "else",
            "return \"%f %<has> no next message.\";",
            "endif",
            "elseif ((index(string, \"prev\") == 1) && (!index(string, \"-\")))",
            "string[1..4] = \"\";",
            "if ((n = string ? toint(string) | 1) <= 0)",
            "return tostr(\"Bad number `\", string, \"'\");",
            "elseif (i = caller:length_num_le(cur - 1))",
            "seq = $seq_utils:add(seq, max(1, (i - n) + 1), i);",
            "else",
            "return \"%f %<has> no previous message.\";",
            "endif",
            "elseif (string == \"new\")",
            "s = last_old ? caller:length_date_le(last_old) | caller:length_num_le(cur);",
            "if (s < nummsgs)",
            "seq = $seq_utils:add(seq, s + 1, nummsgs);",
            "else",
            "return \"%f %<has> no new messages.\";",
            "endif",
            "elseif (string == \"first\")",
            "seq = $seq_utils:add(seq, 1, 1);",
            "elseif (n = toint(string) || (((string in {\"last\", \"$\"}) && -1) || ((string == \"cur\") && cur)))",
            "if (n <= 0)",
            "seq = $seq_utils:add(seq, max(0, nummsgs + n) + 1, nummsgs);",
            "elseif (i = caller:exists_num_eq(n))",
            "seq = $seq_utils:add(seq, i, i);",
            "else",
            "return (string == \"cur\") ? \"%f's current message has been removed.\" | tostr(\"%f %<has> no message numbered `\", string, \"'.\");",
            "endif",
            "elseif (((i = index(string, \"..\")) > 1) || ((i = index(string, \"-\")) > 1))",
            "if ((start = toint(sst = string[1..i - 1])) > 0)",
            "s = caller:length_num_le(start - 1);",
            "elseif (sst in {\"next\", \"prev\", \"cur\"})",
            "s = max(0, caller:length_num_le(cur - (sst != \"next\")) - (sst == \"prev\"));",
            "elseif (sst in {\"last\", \"$\"})",
            "s = nummsgs - 1;",
            "elseif (sst == \"first\")",
            "s = 0;",
            "else",
            "return {$seq_utils:union(result, seq), @strings[strnum..$]};",
            "endif",
            "j = (string[i] == \".\") ? i + 2 | (i + 1);",
            "if ((end = toint(est = string[j..$])) > 0)",
            "e = caller:length_num_le(end);",
            "elseif (est in {\"next\", \"prev\", \"cur\"})",
            "e = min(nummsgs, caller:length_num_le(cur - (est == \"prev\")) + (est == \"next\"));",
            "elseif (est in {\"last\", \"$\"})",
            "e = nummsgs;",
            "elseif (est == \"first\")",
            "e = 1;",
            "else",
            "return {$seq_utils:union(result, seq), @strings[strnum..$]};",
            "endif",
            "if (s < e)",
            "seq = $seq_utils:add(seq, s + 1, e);",
            "else",
            "return tostr(\"%f %<has> no messages in range \", string, \".\");",
            "endif",
            "elseif (string == \"cur\")",
            "return \"%f %<has> no current message.\";",
            "else",
            "return {$seq_utils:union(result, seq), @strings[strnum..$]};",
            "endif",
            "endif",
            "endfor",
            "return {$seq_utils:union(result, seq)};"
          ]
        },
        {
          "name": "_parse_from _parse_to",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":_parse_from(string with |'s in it) => object list\";",
            "\":_parse_to(string with |'s in it) => object list\";",
            "\"  for from:string and to:string items in :parse_message_seq\";",
            "if (verb == \"_parse_to\")",
            "match_obj = fail_obj = this;",
            "match_verb = \"match_recipient\";",
            "fail_verb = \"match_failed\";",
            "else",
            "match_obj = $string_utils;",
            "match_verb = \"match_player\";",
            "fail_obj = $command_utils;",
            "fail_verb = \"player_match_failed\";",
            "endif",
            "plist = {};",
            "for w in ($string_utils:explode(args[1], \"|\"))",
            "if (fail_obj:(fail_verb)(p = match_obj:(match_verb)(w), w))",
            "p = $string_utils:literal_object(w);",
            "if ((p == $failed_match) || (!$command_utils:yes_or_no(\"Continue? \")))",
            "return \"Bad address list:  \" + args[1];",
            "endif",
            "endif",
            "plist = setadd(plist, p);",
            "endfor",
            "return plist;"
          ]
        },
        {
          "name": "_parse_date",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "words = $string_utils:explode(args[1], \"-\");",
            "if (length(words) == 1)",
            "if (index(\"yesterday\", words[1]) == 1)",
            "time = $time_utils:dst_midnight((time() - (time() % 86400)) - 86400);",
            "elseif (index(\"today\", words[1]) == 1)",
            "time = $time_utils:dst_midnight(time() - (time() % 86400));",
            "elseif (typeof(time = $time_utils:from_day(words[1], -1)) == ERR)",
            "time = \"weekday, `Today', `Yesterday', or date expected.\";",
            "endif",
            "elseif ((!words) || ((length(words) > 3) || ((!toint(words[1])) || (E_TYPE == (year = $code_utils:toint({@words, \"-1\"}[3]))))))",
            "time = \"Date should be of the form `5-Jan', `5-Jan-92', `Wed',`Wednesday'\";",
            "else",
            "day = toint(words[1]);",
            "time = $time_utils:dst_midnight($time_utils:from_month(words[2], -1, day));",
            "if (length(words) == 3)",
            "thisyear = toint(ctime(time)[21..24]);",
            "if (100 > year)",
            "year = (thisyear + 50) - (((thisyear - year) + 50) % 100);",
            "endif",
            "time = $time_utils:dst_midnight($time_utils:from_month(words[2], (year - thisyear) - (year <= thisyear), day));",
            "endif",
            "endif",
            "return time;"
          ]
        },
        {
          "name": "new_message_num",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":new_message_num() => number that the next incoming message will receive.\";",
            "set_task_perms(caller_perms());",
            "new = (msgs = caller.messages) ? msgs[$][1] + 1 | 1;",
            "if (rmsgs = caller.messages_going)",
            "if ((!rmsgs[1]) || (typeof(rmsgs[1][2]) == INT))",
            "rmsgs = rmsgs[2];",
            "endif",
            "lbrm = rmsgs[$][2];",
            "return max(new, lbrm[$][1] + 1);",
            "else",
            "return new;",
            "endif"
          ]
        },
        {
          "name": "length_all_msgs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "set_task_perms(caller_perms());",
            "return length(caller.messages);"
          ]
        },
        {
          "name": "length_date_le",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "set_task_perms(caller_perms());",
            "date = args[1];",
            "msgs = caller.messages;",
            "if ((r = length(caller.messages)) < 25)",
            "for l in [1..r]",
            "if (msgs[l][2][1] > date)",
            "return l - 1;",
            "endif",
            "endfor",
            "return r;",
            "else",
            "l = 1;",
            "while (l <= r)",
            "if (date < msgs[i = (r + l) / 2][2][1])",
            "r = i - 1;",
            "else",
            "l = i + 1;",
            "endif",
            "endwhile",
            "return r;",
            "endif"
          ]
        },
        {
          "name": "length_date_gt",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "set_task_perms(caller_perms());",
            "date = args[1];",
            "msgs = caller.messages;",
            "if ((len = length(caller.messages)) < 25)",
            "for r in [0..len - 1]",
            "if (msgs[len - r][2][1] <= date)",
            "return r;",
            "endif",
            "endfor",
            "return len;",
            "else",
            "l = 1;",
            "r = len;",
            "while (l <= r)",
            "if (date < msgs[i = (r + l) / 2][2][1])",
            "r = i - 1;",
            "else",
            "l = i + 1;",
            "endif",
            "endwhile",
            "return len - r;",
            "endif"
          ]
        },
        {
          "name": "length_num_le",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":length_num_le(num) => number of messages in folder numbered <= num\";",
            "set_task_perms(caller_perms());",
            "return $list_utils:iassoc_sorted(args[1], caller.messages);"
          ]
        },
        {
          "name": "exists_num_eq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":exists_num_eq(num) => index of message in folder numbered == num\";",
            "set_task_perms(caller_perms());",
            "return (i = $list_utils:iassoc_sorted(args[1], caller.messages)) && ((caller.messages[i][1] == args[1]) && i);"
          ]
        },
        {
          "name": "from_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":from_msg_seq(object or list[,mask])\";",
            "\" => msg_seq of messages from any of these senders\";",
            "set_task_perms(caller_perms());",
            "{plist, ?mask = {1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "i = 1;",
            "fseq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "fromline = msg[2][2];",
            "for f in ($mail_agent:parse_address_field(fromline))",
            "if (f in plist)",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "endfor",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%from_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":%from_msg_seq(string or list of strings[,mask])\";",
            "\" => msg_seq of messages with one of these strings in the from line\";",
            "set_task_perms(caller_perms());",
            "{nlist, ?mask = {1}} = args;",
            "if (typeof(nlist) != LIST)",
            "nlist = {nlist};",
            "endif",
            "i = 1;",
            "fseq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "fromline = \" \" + msg[2][2];",
            "for n in (nlist)",
            "if (index(fromline, n))",
            "fseq = $seq_utils:add(fseq, i, i);",
            "endif",
            "endfor",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "to_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people\";",
            "set_task_perms(caller_perms());",
            "{plist, ?mask = {1}} = args;",
            "if (typeof(plist) != LIST)",
            "plist = {plist};",
            "endif",
            "i = 1;",
            "seq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "toline = msg[2][3];",
            "for r in ($mail_agent:parse_address_field(toline))",
            "if (r in plist)",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "endfor",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "%to_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":%to_msg_seq(string or list of strings[,mask])\";",
            "\" => msg_seq of messages containing one of strings in the to line\";",
            "set_task_perms(caller_perms());",
            "{nlist, ?mask = {1}} = args;",
            "if (typeof(nlist) != LIST)",
            "nlist = {nlist};",
            "endif",
            "i = 1;",
            "seq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "toline = \" \" + msg[2][3];",
            "for n in (nlist)",
            "if (index(toline, n))",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "endfor",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"
          ]
        },
        {
          "name": "subject_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";",
            "set_task_perms(caller_perms());",
            "{target, ?mask = {1}} = args;",
            "i = 1;",
            "seq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ((length(mask) < 2) || (i < mask[2]))",
            "subject = msg[2][4];",
            "if (index(subject, target))",
            "seq = $seq_utils:add(seq, i, i);",
            "endif",
            "else",
            "mask = mask[3..$];",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return seq || ((\"%f %<has> no messages with subjects containing `\" + target) + \"'\");"
          ]
        },
        {
          "name": "body_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":body_msg_seq(target[,mask]) => msg_seq of messages with target in the body\";",
            "set_task_perms(caller_perms());",
            "{target, ?mask = {1}} = args;",
            "i = 1;",
            "seq = {};",
            "for msg in (caller.messages)",
            "if ((!mask) || (i < mask[1]))",
            "elseif ({@mask, $maxint}[2] <= i)",
            "mask = mask[3..$];",
            "\"Old code follows. Lets save ticks and munge up the whole message body into one big string and index it. Don't need to know where target is in there, just that it is or isn't there\";",
            "elseif (((bstart = \"\" in (msg = msg[2])) && (length(msg) > bstart)) && index(tostr(@msg[bstart + 1..$]), target))",
            "seq = $seq_utils:add(seq, i, i);",
            "\"elseif ((bstart = \\\"\\\" in (msg = msg[2])) && (l = length(msg)) > bstart)\";",
            "\"while (!index(msg[l], target) && (l = l - 1) > bstart)\";",
            "\"$command_utils:suspend_if_needed(0);\";",
            "\"endwhile\";",
            "\"if (l > bstart)\";",
            "\"seq = $seq_utils:add(seq, i, i);\";",
            "\"endif\";",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return seq || tostr(\"%f %<has> no messages containing `\", target, \"' in the body.\");"
          ]
        },
        {
          "name": "messages_in_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":messages_in_seq(msg_seq) => list of messages in msg_seq on folder (caller)\";",
            "set_task_perms(caller_perms());",
            "if (typeof(msgs = args[1]) != LIST)",
            "return caller.messages[msgs];",
            "elseif (length(msgs) == 2)",
            "return caller.messages[msgs[1]..msgs[2] - 1];",
            "else",
            "return $seq_utils:extract(msgs, caller.messages);",
            "endif"
          ]
        },
        {
          "name": "__convert_new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":__convert_new(@msg) => msg in new format (if it isn't already)\";",
            "\"               ^ don't forget the @ here.\";",
            "\"If the msg is already in the new format it passes through unchanged.\";",
            "\"If the msg format is unrecognizable, warnings are printed.\";",
            "if (typeof(date = args[1]) != INT)",
            "date = 0;",
            "start = 1;",
            "else",
            "start = 2;",
            "if (!((colon = index(args[2], \":\")) && (args[2][1..colon] in {\"From:\", \"To:\", \"Subject:\"})))",
            "return args;",
            "endif",
            "endif",
            "from = to = 0;",
            "subject = \" \";",
            "blank = \"\" in {@args, \"\"};",
            "newhdr = {};",
            "for line in (args[start..blank - 1])",
            "if (index(line, \"Date:\") == 1)",
            "if (date)",
            "player:notify(\"Warning: two dates?\");",
            "endif",
            "date = $time_utils:from_ctime(line[6..$]);",
            "elseif (index(line, \"From:\") == 1)",
            "if (from)",
            "player:notify(\"Warning: two from-lines?\");",
            "endif",
            "from = $string_utils:triml(line[6..$]);",
            "elseif (index(line, \"To:\") == 1)",
            "if (to)",
            "player:notify(\"Warning: two to-lines?\");",
            "endif",
            "to = $string_utils:triml(line[6..$]);",
            "elseif (index(line, \"Subject:\") == 1)",
            "subject = $string_utils:triml(line[9..$]);",
            "else",
            "newhdr = {@newhdr, line};",
            "endif",
            "endfor",
            "if (!from)",
            "player:notify(\"Warning: no from-line.\");",
            "endif",
            "if (!to)",
            "player:notify(\"Warning: no to-line.\");",
            "endif",
            "return {date, from, to, subject, @newhdr, @args[blank..$]};"
          ]
        },
        {
          "name": "to_text",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":to_text(@msg) => message in text form (suitable for printing)\";",
            "return {\"Date:     \" + player:ctime(args[1]), \"From:     \" + args[2], \"To:       \" + args[3], @(args[4] == \" \") ? {} | {\"Subject:  \" + args[4]}, @args[5..$]};"
          ]
        },
        {
          "name": "is_readable_by is_writable_by is_usable_by",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "what = args[1];",
            "if ($object_utils:isa(what, $mail_recipient))",
            "return what:(verb)(@listdelete(args, 1));",
            "else",
            "\"...it's a player:\";",
            "\"...  anyone can send mail to it.\";",
            "\"...  only the player itself or a wizard can read it.\";",
            "return (verb == \"is_usable_by\") || $perm_utils:controls(args[2], what);",
            "endif"
          ]
        },
        {
          "name": "reserved_pattern",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":reserved_pattern(string)\";",
            "\"  if string matches one of the reserved patterns for mailing list names, \";",
            "\"  we return that element of .reserved_patterns.\";",
            "string = args[1];",
            "for p in (this.reserved_patterns)",
            "if (match(string, p[1]))",
            "return p;",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "is_recipient",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "return valid(what = args[1]) && (($mail_recipient_class in (ances = $object_utils:ancestors(what))) || ($mail_recipient in ances));"
          ]
        },
        {
          "name": "keep_message_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":keep_message_seq(msg_seq)\";",
            "\"...If msg_seq nonempty {}, this marks the indicated messages on this folder (caller)\";",
            "\"...as immune from expiration.\";",
            "\"...If msg_seq == {}, this clears all such marks.\";",
            "set_task_perms(caller_perms());",
            "msg_seq = args[1];",
            "if (!msg_seq)",
            "caller.messages_kept = {};",
            "return 1;",
            "endif",
            "prev_kept = caller.messages_kept;",
            "caller.messages_kept = new_kept = $seq_utils:union(prev_kept, msg_seq);",
            "added = $seq_utils:intersection(new_kept, $seq_utils:complement(prev_kept));",
            "if (!added)",
            "return \"\";",
            "endif",
            "\"... urk.  now we need to get the actual numbers of the messages being kept.\";",
            "nums = {};",
            "start = 0;",
            "for a in (added)",
            "nums = {@nums, (start = !start) ? caller:messages_in_seq(a)[1] | (caller:messages_in_seq(a - 1)[1] + 1)};",
            "endfor",
            "return $seq_utils:tostr(nums);"
          ]
        },
        {
          "name": "kept_msg_seq unkept_msg_seq",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":kept_msg_seq([mask])\";",
            "\" => msg_seq of messages that are marked kept\";",
            "\":unkept_msg_seq([mask])\";",
            "\" => msg_seq of messages that are not marked kept\";",
            "set_task_perms(caller_perms());",
            "{?mask = {1}} = args;",
            "if (k = verb == \"kept_msg_seq\")",
            "kseq = $seq_utils:intersection(mask, caller.messages_kept);",
            "else",
            "kseq = $seq_utils:intersection(mask, $seq_utils:range(1, caller:length_all_msgs()), $seq_utils:complement(caller.messages_kept));",
            "endif",
            "return kseq;"
          ]
        },
        {
          "name": "msg_seq_to_msg_num_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":msg_seq_to_msg_num_string(msg_seq) => string giving the corresponding message numbers\";",
            "set_task_perms(caller_perms());",
            "return $seq_utils:tostr($seq_utils:from_list($list_utils:slice(caller:messages_in_seq(args[1]))));"
          ]
        },
        {
          "name": "msg_seq_to_msg_num_list",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":msg_seq_to_msg_num_list(msg_seq) => list of corresponding message numbers\";",
            "set_task_perms(caller_perms());",
            "return $list_utils:slice(caller:messages_in_seq(args[1]));"
          ]
        },
        {
          "name": "send_log_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"send_log_message(perms,from,rcpt-list,hdrs,msg) -- formats and sends a mail message. hders is either the text of the subject line, or a {subject,{reply-to,...}} list.\";",
            "\"KLUDGE.  this may go away.\";",
            "\"Send a message while supplying a different permission for use by :mail_forward to determine moderation action.\";",
            "\"Return E_PERM unless called by a wizard.\";",
            "\"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.\";",
            "\"Return {1, @actual_rcpts} if successful.\";",
            "{perms, from, to, hdrs, msg} = args;",
            "if (caller_perms().wizard)",
            "text = $mail_agent:make_message(from, to, hdrs, msg);",
            "return this:raw_send(text, to, perms);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "parse_misc_headers",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":parse_misc_headers(msg,@extract_names)\";",
            "\"Extracts the miscellaneous (i.e., not including Date: From: To: Subject:)\";",
            "\"from msg (a mail message in the usual transmission format).\";",
            "\"Extract_names is a list of header names\";",
            "\"=> {other_headers,bogus_headers,extract_texts,body}\";",
            "\"where each element of extract_texts is a string or 0\";",
            "\"  according as the corresponding header in extract_names is present.\";",
            "\"bogus_headers is a list of those headers that are undecipherable\";",
            "\"other_headers is a list of {header_name,header_text} for the remaining\";",
            "\"  miscellaneous headers.\";",
            "\"headers in msg\";",
            "msgtxt = args[1];",
            "extract_names = listdelete(args, 1);",
            "extract_texts = $list_utils:make(length(extract_names));",
            "heads = bogus = {};",
            "for h in (msgtxt[5..(bstart = \"\" in {@msgtxt, \"\"}) - 1])",
            "if (m = match(h, \"%([a-z1-9-]+%): +%(.*%)\"))",
            "hname = h[m[3][1][1]..m[3][1][2]];",
            "htext = h[m[3][2][1]..m[3][2][2]];",
            "if (i = hname in extract_names)",
            "extract_texts[i] = htext;",
            "else",
            "heads = {@heads, {hname, htext}};",
            "endif",
            "else",
            "bogus = {@bogus, h};",
            "endif",
            "endfor",
            "return {heads, bogus, extract_texts, msgtxt[bstart + 1..$]};"
          ]
        },
        {
          "name": "resend_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"resend_message(new_sender,new_rcpts,from,to,hdrs,body)\";",
            "\" -- reformats and resends a previously sent message to new recipients.\";",
            "\"msg is the previous message\";",
            "\"Return E_PERM if new_sender isn't owned by the caller.\";",
            "\"Return {0, @invalid_rcpts} if new_rcpts contains any invalid addresses.  No mail is sent in this case.\";",
            "\"Return {1, @actual_rcpts} if successful.\";",
            "{new_sender, new_rcpts, from, to, hdrs, body} = args;",
            "if (typeof(hdrs) != LIST)",
            "hdrs = {hdrs, 0};",
            "elseif (length(hdrs) < 2)",
            "hdrs = {@hdrs || {\"\"}, 0};",
            "endif",
            "hdrs[3..2] = {{\"Resent-By\", this:name_list(new_sender)}, {\"Resent-To\", this:name_list(@new_rcpts)}};",
            "if ($perm_utils:controls(caller_perms(), new_sender))",
            "text = $mail_agent:make_message(from, to, hdrs, body);",
            "return this:raw_send(text, new_rcpts, new_sender);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 46,
          "code": [
            "if (caller_perms().wizard)",
            "this.reserved_patterns = {};",
            "this.last_mail_time = 0;",
            "this.time_collisions = {0, 0};",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "time",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\"This was inspired by Xeric's port 4632 on *Core-DB-Issues\";",
            "now = time();",
            "return now;",
            "\"skipping the below for now because the mail system's clock is getting very out of sync. suspect someone's playing games to run up the clock. HTC 6 Jan 2003\";",
            "if (caller == this)",
            "if (now > this.last_mail_time)",
            "return this.last_mail_time = now;",
            "else",
            "this.time_collisions[2] = this.time_collisions[2] + 1;",
            "return this.last_mail_time = this.last_mail_time + 1;",
            "endif",
            "else",
            "return now;",
            "endif"
          ]
        },
        {
          "name": "set_message_body_by_index",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":set_message_body_by_index(i,newbody)\";",
            "\"Replaces the body of the i-th message on the (caller) recipient.\";",
            "\"i must be a message index (not a message number) in the range 1 .. number of messages,\";",
            "\"newbody must be a list of strings.\";",
            "set_task_perms(caller_perms());",
            "{i, body} = args;",
            "bstart = \"\" in caller.messages[i][2];",
            "if (bstart)",
            "caller.messages[i][2][bstart + 1..$] = body;",
            "else",
            "caller.messages[i][2][$ + 1..$] = {\"\", @body};",
            "endif"
          ]
        },
        {
          "name": "get_message_body_by_index",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": null
        },
        {
          "name": "message_body_by_index",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 46,
          "code": [
            "\":message_body_by_index(i)\";",
            "\"Return the body of the i-th message on the (caller) recipient.\";",
            "\"i must be a message index (not a message number) in the range 1 .. number of messages,\";",
            "set_task_perms(caller_perms());",
            "{i} = args;",
            "msg = caller:messages_in_seq({i, i + 1})[1][2];",
            "bstart = \"\" in msg;",
            "return msg[bstart ? bstart + 1 | ($ + 1)..$];"
          ]
        }
      ],
      "propnames": [
        "options",
        "reserved_patterns",
        "player_expire_time",
        "player_default_@mail",
        "max_mail_notify",
        "max_list_aliases",
        "player_default_@unsend",
        "last_mail_time",
        "time_collisions"
      ],
      "propdefs": [
        {
          "value": [
            "include",
            "noinclude",
            "all",
            "sender",
            "nosubject",
            "expert",
            "enter",
            "sticky",
            "@mail",
            "manymsgs",
            "replyto"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "last:15",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 15,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 8,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "last:1",
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            0,
            0
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Mail Distribution Center",
            "Postmaster"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the database of mailing-list/mail-folder objects.",
            "The basic procedure for creating a new list/folder is to create a child of $mail_recipient (Generic Mail Recipient) assign it a suitable name&aliases, set a suitable .mail_forward/.mail_notify (or create suitable :mail_forward() and :mail_notify() verbs) and then teleport it here.",
            "",
            "Avaliable aliases:",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            71767,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "47": {
      "id": 47,
      "name": "Mail Room",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        50
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "working_on",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "return this:ok(who = args[1]) && tostr(\"a letter \", this:sending(who) ? \"(in transit) \" | \"\", \"to \", this:recipient_names(who), (subject = `this.subjects[who] ! ANY') && tostr(\" entitled \\\"\", subject, \"\\\"\"));"
          ]
        },
        {
          "name": "parse_invoke",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "\"invoke(rcptstrings,verb[,subject]) for a @send\";",
            "\"invoke(1,verb,rcpts,subject,replyto,body) if no parsing is needed\";",
            "\"invoke(2,verb,msg,flags,replytos) for an @answer\";",
            "if (!(which = args[1]))",
            "player:tell_lines({tostr(\"Usage:  \", args[2], \" <list-of-recipients>\"), tostr(\"        \", args[2], \"                      to continue with a previous draft\")});",
            "elseif (typeof(which) == LIST)",
            "\"...@send...\";",
            "if (rcpts = this:parse_recipients({}, which))",
            "if (replyto = player:mail_option(\"replyto\"))",
            "replyto = this:parse_recipients({}, replyto, \".mail_options: \");",
            "endif",
            "if (0 == (subject = {@args, 0}[3]))",
            "if (player:mail_option(\"nosubject\"))",
            "subject = \"\";",
            "else",
            "player:tell(\"Subject:\");",
            "subject = $command_utils:read();",
            "endif",
            "endif",
            "return {rcpts, subject, replyto, {}};",
            "endif",
            "elseif (which == 1)",
            "return args[3..6];",
            "elseif (!(to_subj = this:parse_msg_headers(msg = args[3], flags = args[4])))",
            "else",
            "include = {};",
            "if (\"include\" in flags)",
            "prefix = \">            \";",
            "for line in ($mail_agent:to_text(@msg))",
            "if (!line)",
            "prefix = \">  \";",
            "include = {@include, prefix};",
            "else",
            "include = {@include, @this:fill_string(\">  \" + line, 70, prefix)};",
            "endif",
            "endfor",
            "endif",
            "return {@to_subj, args[5], include};",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "init_session",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "{who, recip, subj, replyto, msg} = args;",
            "if (this:ok(who))",
            "this.sending[who] = 0;",
            "this.recipients[who] = recip;",
            "this.subjects[who] = subj;",
            "this.replytos[who] = replyto || {};",
            "this:load(who, msg);",
            "this.active[who]:tell(\"Composing \", this:working_on(who));",
            "p = this.active[who];",
            "\"if (p:mail_option(\\\"enter\\\") && !args[5])\";",
            "\"Changed from above so that @reply can take advantage of @mailoption +enter. Ho_Yan 11/9/94\";",
            "if (p:mail_option(\"enter\"))",
            "if (typeof(lines = $command_utils:read_lines()) == ERR)",
            "p:tell(lines);",
            "else",
            "this:insert_line(p in this.active, lines, 0);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "pri*nt",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 47,
          "code": [
            "if (!dobjstr)",
            "plyr = player;",
            "elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(dobjstr), dobjstr)[1])",
            "return;",
            "endif",
            "if ((plyr != player) && (!this:readable(plyr in this.active)))",
            "player:tell(plyr.name, \"(\", plyr, \") has not published anything here.\");",
            "elseif (typeof(msg = this:message_with_headers(plyr in this.active)) != LIST)",
            "player:tell(msg);",
            "else",
            "player:display_message({((plyr == player) ? \"Your\" | tostr(plyr.name, \"(\", plyr, \")'s\")) + \" message so far:\", \"\"}, player:msg_text(@msg));",
            "endif"
          ]
        },
        {
          "name": "message_with_headers",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "return (this:readable(who = args[1]) || this:ok(who)) && $mail_agent:make_message(this.active[who], this.recipients[who], {this.subjects[who], this.replytos[who]}, this:text(who));"
          ]
        },
        {
          "name": "subj*ect:",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 47,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (!argstr)",
            "player:tell(this.subjects[who]);",
            "elseif (ERR == typeof(subj = this:set_subject(who, argstr)))",
            "player:tell(subj);",
            "else",
            "player:tell(subj ? (\"Setting the subject line for your message to \\\"\" + subj) + \"\\\".\" | \"Deleting the subject line for your message.\");",
            "endif"
          ]
        },
        {
          "name": "set_subject",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "else",
            "this.subjects[who] = subj = args[2];",
            "this:set_changed(who, 1);",
            "return subj;",
            "endif"
          ]
        },
        {
          "name": "sending",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "elseif ((!(task = this.sending[who])) || $code_utils:task_valid(task))",
            "return task;",
            "else",
            "\"... uh oh... sending task crashed...\";",
            "this:set_changed(who, 1);",
            "return this.sending[who] = 0;",
            "endif"
          ]
        },
        {
          "name": "to*:",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 47,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (!args)",
            "player:tell(\"Your message is currently to \", this:recipient_names(who), \".\");",
            "else",
            "this.recipients[who] = this:parse_recipients({}, args);",
            "this:set_changed(who, 1);",
            "player:tell(\"Your message is now to \", this:recipient_names(who), \".\");",
            "endif"
          ]
        },
        {
          "name": "also*-to: cc*:",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 47,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "this.recipients[who] = this:parse_recipients(this.recipients[who], args);",
            "this:set_changed(who, 1);",
            "player:tell(\"Your message is now to \", this:recipient_names(who), \".\");",
            "endif"
          ]
        },
        {
          "name": "not-to*: uncc*:",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 47,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "recips = this.recipients[who];",
            "nonmrs = {};",
            "mrs = {};",
            "for o in (recips)",
            "if ($object_utils:isa(o, $mail_recipient))",
            "mrs = {@mrs, o};",
            "else",
            "nonmrs = {@nonmrs, o};",
            "endif",
            "endfor",
            "for a in (args)",
            "if (!a)",
            "player:tell(\"\\\"\\\"?\");",
            "return;",
            "elseif (valid(aobj = $mail_agent:match_recipient(a)) && (aobj in recips))",
            "elseif ($failed_match != (aobj = $string_utils:literal_object(a)))",
            "if (!(aobj in recips))",
            "player:tell(aobj, \" was not a recipient.\");",
            "return;",
            "endif",
            "elseif ((a[1] == \"*\") && valid(aobj = $string_utils:match(a[2..$], mrs, \"aliases\")))",
            "elseif ((a[1] != \"*\") && valid(aobj = $string_utils:match(a, nonmrs, \"aliases\")))",
            "elseif (valid(aobj = $string_utils:match(a, recips, \"aliases\")))",
            "else",
            "player:tell(\"couldn't find \\\"\", a, \"\\\" in To: list.\");",
            "return;",
            "endif",
            "recips = setremove(recips, aobj);",
            "endfor",
            "this.recipients[who] = recips;",
            "this:set_changed(who, 1);",
            "player:tell(\"Your message is now to \", this:recipient_names(who), \".\");",
            "endif"
          ]
        },
        {
          "name": "parse_recipients",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "\"parse_recipients(prev_list,list_of_strings) -- parses list of strings and adds any resulting player objects to prev_list.  Optional 3rd arg is prefixed to any mismatch error messages\";",
            "{recips, l, ?cmd_id = \"\"} = args;",
            "cmd_id = cmd_id || \"\";",
            "for s in ((typeof(l) == LIST) ? l | {l})",
            "if (typeof(s) != STR)",
            "if ($mail_agent:is_recipient(s))",
            "recips = setadd(recips, s);",
            "else",
            "player:tell(cmd_id, s, \" is not a valid mail recipient.\");",
            "endif",
            "elseif (!$mail_agent:match_failed(md = $mail_agent:match_recipient(s), s, cmd_id))",
            "recips = setadd(recips, md);",
            "endif",
            "endfor",
            "return recips;"
          ]
        },
        {
          "name": "recipient_names",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "return this:ok(who = args[1]) && $mail_agent:name_list(@this.recipients[who]);"
          ]
        },
        {
          "name": "make_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "return $mail_agent:make_message(@args);"
          ]
        },
        {
          "name": "name_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "\"(obsolete verb... see $mail_agent:name_list)\";",
            "return $mail_agent:(verb)(@args[1]);"
          ]
        },
        {
          "name": "parse_msg_headers",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "\"parse_msg_headers(msg,flags)\";",
            "\"  parses msg to extract reply recipients and construct a subject line\";",
            "\"  if the \\\"all\\\" flag is present, reply goes to all of the original recipients\";",
            "\"  returns a list {recipients, subjectline} or 0 in case of error.\";",
            "{msg, flags} = args;",
            "replyall = \"all\" in flags;",
            "objects = {};",
            "if (\"followup\" in flags)",
            "\"...look for first non-player recipient in To: line...\";",
            "for o in ($mail_agent:parse_address_field(msg[3]))",
            "if (objects)",
            "break o;",
            "elseif ($object_utils:isa(o, $mail_recipient))",
            "objects = {o};",
            "endif",
            "endfor",
            "endif",
            "objects = objects || $mail_agent:parse_address_field(msg[2] + (replyall ? msg[3] | \"\"));",
            "for line in (msg[5..(\"\" in {@msg, \"\"}) - 1])",
            "if (rt = index(line, \"Reply-to:\") == 1)",
            "objects = $mail_agent:parse_address_field(line);",
            "endif",
            "endfor",
            "recips = {};",
            "for o in (objects)",
            "if (o == #0)",
            "player:tell(\"Sorry, but I can't parse the header of that message.\");",
            "return 0;",
            "elseif ((!valid(o)) || (!(is_player(o) || ($mail_recipient in $object_utils:ancestors(o)))))",
            "player:tell(o, \" is no longer a valid player or maildrop; ignoring that recipient.\");",
            "elseif (o != player)",
            "recips = setadd(recips, o);",
            "endif",
            "endfor",
            "subject = msg[4];",
            "if (subject == \" \")",
            "subject = \"\";",
            "elseif (subject && (index(subject, \"Re: \") != 1))",
            "subject = \"Re: \" + subject;",
            "endif",
            "return {recips, subject};"
          ]
        },
        {
          "name": "check_answer_flags",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "flags = {};",
            "for o in ({\"all\", \"include\", \"followup\"})",
            "if (player:mail_option(o))",
            "flags = {@flags, o};",
            "endif",
            "endfor",
            "reply_to = player:mail_option(\"replyto\") || {};",
            "flaglist = \"+1#include -1#noinclude +2#all -2#sender 0#replyto +3#followup \";",
            "for a in (args)",
            "if (i = index(a, \"=\"))",
            "value = a[i + 1..$];",
            "a = a[1..i - 1];",
            "else",
            "value = \"\";",
            "endif",
            "if ((typeof(a) != STR) || ((i = index(flaglist, \"#\" + a)) < 3))",
            "player:tell(\"Unrecognized answer/reply option:  \", a);",
            "return 0;",
            "elseif (i != rindex(flaglist, \"#\" + a))",
            "player:tell(\"Ambiguous answer/reply option:  \", a);",
            "return 0;",
            "elseif (j = index(\"0123456789\", flaglist[i - 1]) - 1)",
            "if (value)",
            "player:tell(\"Flag does not take a value:  \", a);",
            "return 0;",
            "endif",
            "f = {\"include\", \"all\", \"followup\"}[j];",
            "flags = (flaglist[i - 2] == \"+\") ? setadd(flags, f) | setremove(flags, f);",
            "if (f == \"all\")",
            "flags = setremove(flags, \"followup\");",
            "endif",
            "elseif ((!value) || (value = this:parse_recipients({}, $string_utils:explode(value), \"replyto flag:  \")))",
            "reply_to = value || {};",
            "endif",
            "endfor",
            "return {flags, reply_to};"
          ]
        },
        {
          "name": "reply-to*: replyto*:",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 47,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "if (args)",
            "this.replytos[who] = rt = this:parse_recipients({}, args);",
            "this:set_changed(who, 1);",
            "else",
            "rt = this.replytos[who];",
            "endif",
            "player:tell(rt ? (\"Replies will go to \" + $mail_agent:name_list(@this.replytos[who])) + \".\" | \"Reply-to field is empty.\");",
            "endif"
          ]
        },
        {
          "name": "send",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 47,
          "code": [
            "\"WIZARDLY\";",
            "if (!(who = this:loaded(player)))",
            "player:notify(this:nothing_loaded_msg());",
            "elseif (!(recips = this.recipients[who]))",
            "player:notify(\"Umm... your message isn't addressed to anyone.\");",
            "elseif (this:sending(who))",
            "player:notify(\"Again? ... relax... it'll get there eventually.\");",
            "else",
            "msg = this:message_with_headers(who);",
            "this.sending[who] = old_sending = task_id();",
            "this:set_changed(who, 0);",
            "player:notify(\"Sending...\");",
            "\"... this sucker can suspend BIG TIME...\";",
            "result = $mail_agent:raw_send(msg, recips, player);",
            "\"... the world changes...\";",
            "who = player in this.active;",
            "if (who && (this.sending[who] == old_sending))",
            "\"... same editing session; no problemo...\";",
            "previous = \"\";",
            "this.sending[who] = 0;",
            "else",
            "\"... uh oh, different session... tiptoe quietly out...\";",
            "\"... Don't mess with the session.\";",
            "previous = \"(prior send) \";",
            "endif",
            "if (!(e = result[1]))",
            "player:notify(tostr(previous, (typeof(e) == ERR) ? e | (\"Bogus recipients:  \" + $string_utils:from_list(result[2]))));",
            "player:notify(tostr(previous, \"Mail not sent.\"));",
            "previous || this:set_changed(who, 1);",
            "elseif (length(result) == 1)",
            "player:notify(tostr(previous, \"Mail not actually sent to anyone.\"));",
            "previous || this:set_changed(who, 1);",
            "else",
            "player:notify(tostr(previous, \"Mail actually sent to \", $mail_agent:name_list(@listdelete(result, 1))));",
            "if (previous)",
            "\"...don't even think about it...\";",
            "elseif (player.location == this)",
            "if (ticks_left() < 10000)",
            "suspend(0);",
            "endif",
            "this:done();",
            "elseif (!this:changed(who))",
            "\"... player is gone, no further edits...\";",
            "this:kill_session(who);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "who",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 47,
          "code": [
            "if (dobjstr)",
            "if (!(recips = this:parse_recipients({}, args)))",
            "\"parse_recipients has already complained about anything it doesn't like\";",
            "return;",
            "endif",
            "elseif (caller != player)",
            "return E_PERM;",
            "elseif (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "else",
            "recips = this.recipients[who];",
            "endif",
            "resolve = $mail_agent:resolve_addr(recips, player);",
            "if (resolve[1])",
            "player:tell(\"Bogus addresses:  \", $string_utils:english_list(resolve[1]));",
            "else",
            "player:tell(dobjstr ? (\"Mail to \" + $mail_agent:name_list(@recips)) + \" actually goes to \" | \"Your mail will actually go to \", $mail_agent:name_list(@resolve[2]));",
            "endif"
          ]
        },
        {
          "name": "showlists",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 47,
          "code": [
            "player:tell_lines({\"Available aliases:\", \"\"});",
            "for c in ((dobjstr == \"all\") ? $object_utils:descendants($mail_recipient) | $mail_agent.contents)",
            "if (c:is_usable_by(player) || c:is_readable_by(player))",
            "c:look_self();",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "unsubsc*ribe",
          "owner": 36,
          "perms": 89,
          "preps": 5,
          "object": 47,
          "code": [
            "if (!iobjstr)",
            "player:tell(\"Usage:  \", verb, \" [<list-of-people/lists>] from <list>\");",
            "return;",
            "elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))",
            "return;",
            "endif",
            "rstrs = dobjstr ? $string_utils:explode(dobjstr) | {\"me\"};",
            "recips = this:parse_recipients({}, rstrs);",
            "outcomes = iobj:delete_forward(@recips);",
            "if (typeof(outcomes) != LIST)",
            "player:tell(outcomes);",
            "return;",
            "endif",
            "removed = {};",
            "for r in [1..length(recips)]",
            "if (typeof(e = outcomes[r]) == ERR)",
            "player:tell(verb, \" \", recips[r].name, \" from \", iobj.name, \":  \", (e == E_INVARG) ? \"Not on list.\" | e);",
            "else",
            "removed = setadd(removed, recips[r]);",
            "endif",
            "endfor",
            "if (removed)",
            "player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%(name) (%#)\", removed)), \" removed from \", iobj.name, \" (\", iobj, \")\");",
            "endif"
          ]
        },
        {
          "name": "retain_session_on_exit",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "return this:ok(who = args[1]) && (this:sending(who) || pass(@args));"
          ]
        },
        {
          "name": "no_littering_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "\"recall that this only gets called if :retain_session_on_exit returns true\";",
            "return (this:ok(who = player in this.active) && (!this:changed(who))) ? {\"Your message is in transit.\"} | this.(verb);"
          ]
        },
        {
          "name": "local_editing_info",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 47,
          "code": [
            "lines = {\"To:       \" + (toline = $mail_agent:name_list(@args[1])), \"Subject:  \" + $string_utils:trim(subject = args[2])};",
            "if (args[3])",
            "lines = {@lines, \"Reply-to: \" + $mail_agent:name_list(@args[3])};",
            "endif",
            "lines = {@lines, \"\", @args[4]};",
            "return {tostr(\"MOOMail\", subject ? (\"(\" + subject) + \")\" | ((\"-to(\" + toline) + \")\")), lines, \"@@sendmail\", \"sendmail\", \"string-list\"};"
          ]
        }
      ],
      "propnames": [
        "replytos",
        "recipients",
        "subjects",
        "sending"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [
            [
              "say",
              "emote",
              "lis*t",
              "ins*ert",
              "n*ext,p*rev",
              "enter",
              "del*ete",
              "f*ind",
              "s*ubst",
              "m*ove,c*opy",
              "join*l",
              "fill"
            ],
            [
              "y*ank",
              "w*hat",
              "subj*ect",
              "to",
              "also-to",
              "reply-to",
              "showlists,unsubscribe",
              "who",
              "pri*nt",
              "send",
              "abort",
              "q*uit,done,pause"
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Message body is empty.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              "subj*ect",
              "[<text>]"
            ],
            [
              "to",
              "[<rcpt>..]"
            ],
            [
              "also-to",
              "[<rcpt>..]"
            ],
            [
              "reply-to",
              "[<rcpt>..]"
            ],
            [
              "who",
              "[<rcpt>..]"
            ],
            [
              "pri*nt",
              ""
            ],
            [
              "send",
              ""
            ],
            [
              "showlists,unsubscribe",
              ""
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 1
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You need to either SEND it or ABORT it before you can start another message.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              "sending",
              0
            ],
            [
              "replytos",
              []
            ],
            [
              "recipients",
              []
            ],
            [
              "subjects",
              ""
            ],
            [
              "texts",
              []
            ],
            [
              "changes",
              0
            ],
            [
              "inserting",
              1
            ],
            [
              "readable",
              0
            ]
          ],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%N flattens out into a largish postage stamp and floats away.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "A largish postage stamp floats into the room and fattens up into %n.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Saving your message so that you can finish it later.",
            "To come back, give the `@send' command with no arguments.",
            "Please come back and SEND or ABORT if you don't intend to be working on this",
            "message in the immediate future.  Keep Our MOO Clean!  No Littering!"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You're not editing anything!",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%L [mailing]",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            16500
          ],
          "owner": 36,
          "perms": 4
        },
        {
          "value": -1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 2043059065,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Mail Room"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            31309,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "48": {
      "id": 48,
      "name": "Note Editor",
      "flags": 16,
      "owner": 96,
      "location": -1,
      "parents": [
        50
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "e*dit",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 48,
          "code": [
            "if (this:changed(who = player in this.active))",
            "player:tell(\"You are still editing \", this:working_on(who), \".  Please type ABORT or SAVE first.\");",
            "elseif (spec = this:parse_invoke(dobjstr, verb))",
            "this:init_session(who, @spec);",
            "endif"
          ]
        },
        {
          "name": "save",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 48,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "if (!dobjstr)",
            "note = this.objects[who];",
            "elseif (1 == (note = this:note_match_failed(dobjstr)))",
            "return;",
            "else",
            "this.objects[who] = note;",
            "endif",
            "text = this:text(who);",
            "strmode = (length(text) <= 1) && this.strmode[who];",
            "if (strmode)",
            "text = text ? text[1] | \"\";",
            "endif",
            "if (ERR == typeof(result = this:set_note_text(note, text)))",
            "player:tell(\"Text not saved to \", this:working_on(who), \":  \", result);",
            "if ((result == E_TYPE) && (typeof(note) == OBJ))",
            "player:tell(\"Do `mode list' and try saving again.\");",
            "elseif (!dobjstr)",
            "player:tell(\"Use `save' with an argument to save the text elsewhere.\");",
            "endif",
            "else",
            "player:tell(\"Text written to \", this:working_on(who), strmode ? \" as a single string.\" | \".\");",
            "this:set_changed(who, 0);",
            "endif"
          ]
        },
        {
          "name": "init_session",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "if (this:ok(who = args[1]))",
            "this.strmode[who] = strmode = typeof(text = args[3]) == STR;",
            "this:load(who, strmode ? text ? {text} | {} | text);",
            "this.objects[who] = args[2];",
            "player:tell(\"Now editing \", this:working_on(who), \".\", strmode ? \"  [string mode]\" | \"\");",
            "endif"
          ]
        },
        {
          "name": "working_on",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "if (!(who = args[1]))",
            "return \"????\";",
            "endif",
            "spec = this.objects[who];",
            "if (typeof(spec) == LIST)",
            "object = spec[1];",
            "prop = spec[2];",
            "else",
            "object = spec;",
            "prop = 0;",
            "endif",
            "return valid(object) ? tostr(\"\\\"\", object.name, \"\\\"(\", object, \")\", prop ? \".\" + prop | \"\") | tostr(prop ? (\".\" + prop) + \" on \" | \"\", \"invalid object (\", object, \")\");"
          ]
        },
        {
          "name": "parse_invoke",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "\":parse_invoke(string,verb)\";",
            "\" string is the actual commandline string indicating what we are to edit\";",
            "\" verb is the command verb that is attempting to invoke the editor\";",
            "if (caller != this)",
            "raise(E_PERM);",
            "elseif (!(string = args[1]))",
            "player:tell_lines({(\"Usage:  \" + args[2]) + \" <note>   (where <note> is some note object)\", (\"        \" + args[2]) + \"          (continues editing an unsaved note)\"});",
            "elseif (1 == (note = this:note_match_failed(string)))",
            "elseif (ERR == typeof(text = this:note_text(note)))",
            "player:tell(\"Couldn't retrieve text:  \", text);",
            "elseif ((player:edit_option(\"local\") == 0) && $edit_utils:get_option(\"default_editor\", player))",
            "fork (0)",
            "text = $edit_utils:editor((!text) ? {} | text);",
            "result = $note_editor:set_note_text(note, text);",
            "if (typeof(result) == ERR)",
            "player:tell(\"Unable to set text: \", e[2]);",
            "else",
            "player:tell(\"Edited \", note[2], \" of \", $su:nn(note[1]), \".\");",
            "endif",
            "endfork",
            "kill_task(task_id());",
            "else",
            "return {note, text};",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "note_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "if (typeof(spec = args[1]) == OBJ)",
            "text = spec:text();",
            "else",
            "text = `spec[1].(spec[2]) ! ANY';",
            "endif",
            "if (typeof(text) in {ERR, STR, LIST})",
            "return text;",
            "else",
            "return E_TYPE;",
            "endif"
          ]
        },
        {
          "name": "set_note_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "attempt = E_NONE;",
            "if (typeof(spec = args[1]) == OBJ)",
            "return spec:set_text(args[2]);",
            "elseif ($object_utils:has_callable_verb(spec[1], \"set_\" + spec[2]))",
            "attempt = spec[1]:(\"set_\" + spec[2])(args[2]);",
            "endif",
            "if (typeof(attempt) == ERR)",
            "return `spec[1].(spec[2]) = args[2] ! ANY';",
            "else",
            "return attempt;",
            "endif"
          ]
        },
        {
          "name": "note_match_failed",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "if (pp = $code_utils:parse_propref(string = args[1]))",
            "object = pp[1];",
            "prop = pp[2];",
            "else",
            "object = string;",
            "prop = 0;",
            "endif",
            "if ($command_utils:object_match_failed(note = player:my_match_object(object, this:get_room(player)), object))",
            "elseif (prop)",
            "if (!$object_utils:has_property(note, prop))",
            "player:tell(object, \" has no \\\".\", prop, \"\\\" property.\");",
            "else",
            "return {note, prop};",
            "endif",
            "elseif ((!$object_utils:has_callable_verb(note, \"text\")) || (!$object_utils:has_callable_verb(note, \"set_text\")))",
            "return {note, \"description\"};",
            "\"... what we used to do.  but why barf?   that's no fun...\";",
            "player:tell(object, \"(\", note, \") doesn't look like a note.\");",
            "else",
            "return note;",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "w*hat",
          "owner": 96,
          "perms": 9,
          "preps": -1,
          "object": 48,
          "code": [
            "pass(@args);",
            "if ((who = this:loaded(player)) && this.strmode[who])",
            "player:tell(\"Text will be stored as a single string instead of a list when possible.\");",
            "endif"
          ]
        },
        {
          "name": "mode",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 48,
          "code": [
            "\"mode [string|list]\";",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "if (dobjstr && (index(\"string\", dobjstr) == 1))",
            "this.strmode[who] = mode = 1;",
            "player:tell(\"Now in string mode:\");",
            "elseif (dobjstr && (index(\"list\", dobjstr) == 1))",
            "this.strmode[who] = mode = 0;",
            "player:tell(\"Now in list mode:\");",
            "elseif (dobjstr)",
            "player:tell(\"Unrecognized mode:  \", dobjstr);",
            "player:tell(\"Should be one of `string' or `list'\");",
            "return;",
            "else",
            "player:tell(\"Currently in \", (mode = this.strmode[who]) ? \"string \" | \"list \", \"mode:\");",
            "endif",
            "if (mode)",
            "player:tell(\"  store text as a single string instead of a list when possible.\");",
            "else",
            "player:tell(\"  always store text as a list of strings.\");",
            "endif"
          ]
        },
        {
          "name": "local_editing_info",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "{what, text} = args;",
            "cmd = (typeof(text) == STR) ? \"@set-note-string\" | \"@set-note-text\";",
            "name = (typeof(what) == OBJ) ? what.name | tostr(what[1].name, \".\", what[2]);",
            "note = (typeof(what) == OBJ) ? what | tostr(what[1], \".\", what[2]);",
            "\"Check if the text is a list of strings. If so, edit it like text. Otherwise, parse values.\";",
            "type = \"str:\";",
            "for x in (text)",
            "if (typeof(x) != STR)",
            "type = \"val:\";",
            "break;",
            "endif",
            "endfor",
            "ref = tostr(type, (typeof(what) == OBJ) ? tostr(what, \".text\") | tostr(what[1], \".\", what[2]));",
            "return {name, text, tostr(cmd, \" \", note), ref, \"string-list\"};"
          ]
        },
        {
          "name": "set_*",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 48,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this))",
            "return pass(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "strmode",
        "objects"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [
            [
              "say",
              "emote",
              "lis*t",
              "ins*ert",
              "n*ext,p*rev",
              "enter",
              "del*ete",
              "f*ind",
              "s*ubst",
              "m*ove,c*opy",
              "join*l",
              "fill"
            ],
            [
              "y*ank",
              "w*hat",
              "mode",
              "e*dit",
              "save",
              "abort",
              "q*uit,done,pause"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Note is devoid of text.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "e*dit",
              "<note>"
            ],
            [
              "save",
              "[<note>]"
            ],
            [
              "mode",
              "[string|list]"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": "You need to ABORT or SAVE this note before editing any other.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "strmode",
              0
            ],
            [
              "objects",
              0
            ],
            [
              "texts",
              0
            ],
            [
              "changes",
              0
            ],
            [
              "inserting",
              1
            ],
            [
              "readable",
              0
            ]
          ],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "A small swarm of 3x5 index cards arrives, engulfs %n, and carries %o away.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "A small swarm of 3x5 index cards blows in and disperses, revealing %n.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            "Partially edited text will be here when you get back.",
            "To return, give the `@notedit' command with no arguments.",
            "Please come back and SAVE or ABORT if you don't intend to be working on this text in the immediate future.  Keep Our MOO Clean!  No Littering!"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Note has not been modified since the last save.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "There are changes.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Use the EDIT command to select a note.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%L [editing notes]",
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            5750
          ],
          "owner": 96,
          "perms": 4
        },
        {
          "value": -1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 2137271057,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": [
            "Note Editor",
            "nedit"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            15810,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "49": {
      "id": 49,
      "name": "Verb Editor",
      "flags": 16,
      "owner": 96,
      "location": -1,
      "parents": [
        50
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "e*dit",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 49,
          "code": [
            "if (!args)",
            "player:tell(\"edit what?\");",
            "else",
            "this:invoke(argstr, verb);",
            "endif"
          ]
        },
        {
          "name": "com*pile save",
          "owner": 96,
          "perms": 73,
          "preps": -2,
          "object": 49,
          "code": [
            "pas = {{}, {}};",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "elseif (!args)",
            "object = this.objects[who];",
            "vname = this.verbnames[who];",
            "if (typeof(vname) == LIST)",
            "vargs = listdelete(vname, 1);",
            "vname = vname[1];",
            "else",
            "vargs = {};",
            "endif",
            "changeverb = 0;",
            "elseif ((args[1] != \"as\") || ((length(args) < 2) || ((!(spec = $code_utils:parse_verbref(args[2]))) || ((typeof(pas = $code_utils:parse_argspec(@args[3..$])) != LIST) || pas[2]))))",
            "if (typeof(pas) != LIST)",
            "player:tell(pas);",
            "elseif (pas[2])",
            "player:tell(\"I don't understand \\\"\", $string_utils:from_list(pas[2], \" \"), \"\\\"\");",
            "endif",
            "player:tell(\"Usage: \", verb, \" [as <object>:<verb>]\");",
            "return;",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))",
            "return;",
            "else",
            "vname = spec[2];",
            "vargs = pas[1] && {@pas[1], \"none\", \"none\"}[1..3];",
            "if (vargs)",
            "vargs[2] = $code_utils:full_prep(vargs[2]) || vargs[2];",
            "endif",
            "changeverb = 1;",
            "endif",
            "if (vargs)",
            "vnum = $code_utils:find_verb_named(object, vname);",
            "while (vnum && (this:fetch_verb_args(object, vnum) != vargs))",
            "vnum = $code_utils:find_verb_named(object, vname, vnum + 1);",
            "endwhile",
            "if (!vnum)",
            "player:tell(\"There is no \", object, \":\", vname, \" verb with args (\", $string_utils:from_list(vargs, \" \"), \").\");",
            "if (!changeverb)",
            "player:tell(\"Use 'compile as ...' to write your code to another verb.\");",
            "endif",
            "return;",
            "endif",
            "objverbname = tostr(object, \":\", vname, \" (\", $string_utils:from_list(vargs, \" \"), \")\");",
            "else",
            "vnum = 0;",
            "objverbname = tostr(object, \":\", ($code_utils:toint(vname) == E_TYPE) ? vname | this:verb_name(object, vname));",
            "endif",
            "\"...\";",
            "\"...perform eval_subs on verb code if necessary...\";",
            "\"...\";",
            "if (player.eval_subs && player:edit_option(\"eval_subs\"))",
            "verbcode = {};",
            "for x in (this:text(who))",
            "verbcode = {@verbcode, $code_utils:substitute(x, player.eval_subs)};",
            "endfor",
            "else",
            "verbcode = this:text(who);",
            "endif",
            "\"...\";",
            "\"...write it out...\";",
            "\"...\";",
            "if (result = this:set_verb_code(object, vnum ? vnum | vname, verbcode))",
            "player:tell(objverbname, \" not compiled because:\");",
            "for x in (result)",
            "player:tell(\"  \", x);",
            "endfor",
            "elseif (typeof(result) == ERR)",
            "player:tell({result, (\"You do not have write permission on \" + objverbname) + \".\", (\"The verb \" + objverbname) + \" does not exist (!?!)\", (\"The object \" + tostr(object)) + \" does not exist (!?!)\"}[1 + (result in {E_PERM, E_VERBNF, E_INVARG})]);",
            "if (!changeverb)",
            "player:tell(\"Do 'compile as <object>:<verb>' to write your code to another verb.\");",
            "endif",
            "changeverb = 0;",
            "else",
            "player:tell(objverbname, verbcode ? \" successfully compiled.\" | \" verbcode removed.\");",
            "this:set_changed(who, 0);",
            "endif",
            "if (changeverb)",
            "this.objects[who] = object;",
            "this.verbnames[who] = vargs ? {vname, @vargs} | vname;",
            "endif"
          ]
        },
        {
          "name": "working_on",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "else",
            "object = this.objects[who];",
            "verbname = this.verbnames[who];",
            "if (typeof(verbname) == LIST)",
            "return tostr(object, \":\", verbname[1], \" (\", $string_utils:from_list(listdelete(verbname, 1), \" \"), \")\");",
            "else",
            "return tostr(object, \":\", this:verb_name(object, verbname), \" (\", this:verb_args(object, verbname), \")\");",
            "endif",
            "endif",
            "\"return this:ok(who = args[1]) && tostr(this.objects[who]) + \\\":\\\" + this.verbnames[who];\";"
          ]
        },
        {
          "name": "init_session",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "{who, object, vname, vcode} = args;",
            "if (this:ok(who))",
            "this:load(who, vcode);",
            "this.verbnames[who] = vname;",
            "this.objects[who] = object;",
            "this.active[who]:tell(\"Now editing \", this:working_on(who), \".\");",
            "\"this.active[who]:tell(\\\"Now editing \\\", object, \\\":\\\", vname, \\\".\\\");\";",
            "endif"
          ]
        },
        {
          "name": "parse_invoke",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\":parse_invoke(string,v,?code)\";",
            "\"  string is the commandline string to parse to obtain the obj:verb to edit\";",
            "\"  v is the actual command verb used to invoke the editor\";",
            "\" => {object, verbname, verb_code} or error\";",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "vref = $string_utils:words(args[1]);",
            "if ((!vref) || (!(spec = $code_utils:parse_verbref(vref[1]))))",
            "player:tell(\"Usage: \", args[2], \" object:verb\");",
            "return;",
            "endif",
            "if (argspec = listdelete(vref, 1))",
            "if (typeof(pas = $code_utils:parse_argspec(@argspec)) == LIST)",
            "if (pas[2])",
            "player:tell(\"I don't understand \\\"\", $string_utils:from_list(pas[2], \" \"), \"\\\"\");",
            "return;",
            "endif",
            "argspec = {@pas[1], \"none\", \"none\"}[1..3];",
            "argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];",
            "else",
            "player:tell(pas);",
            "return;",
            "endif",
            "endif",
            "if (!$command_utils:object_match_failed(match = player:my_match_object(spec[1], this:get_room(player)), spec[1]))",
            "ancestors = $object_utils:ancestors(match, 1);",
            "vname = spec[2];",
            "for object in (ancestors)",
            "vnum = $code_utils:find_verb_named(object, vname);",
            "if (argspec)",
            "while (vnum && (this:fetch_verb_args(object, vnum) != argspec))",
            "vnum = $code_utils:find_verb_named(object, vname, vnum + 1);",
            "endwhile",
            "endif",
            "if (length(args) > 2)",
            "code = args[3];",
            "elseif (vnum)",
            "code = this:fetch_verb_code(object, vnum);",
            "else",
            "code = E_VERBNF;",
            "endif",
            "if (typeof(code) != ERR)",
            "if ((object in ancestors) != 1)",
            "player:tell(\"Object \", ancestors[1], \" does not define that verb, but its ancestor \", object, \" does.\");",
            "endif",
            "if ((!player:edit_option(\"local\")) && $edit_utils:get_option(\"default_editor\", player))",
            "fork (0)",
            "$edit_utils:editor(code, tostr(\"[Edit your code; use \", $edit_utils:get_option(\"cmd_char\", player), \"compile' to compile.]\"), $edit_utils:get_option(\"cmd_char\", player), 1, {{object, vname}});",
            "endfork",
            "kill_task(task_id());",
            "else",
            "return {object, argspec ? {vname, @argspec} | vname, code};",
            "endif",
            "endif",
            "endfor",
            "endif",
            "player:tell((code != E_VERBNF) ? code | \"That object does not define that verb\", argspec ? \" with those args.\" | \".\");",
            "return 0;"
          ]
        },
        {
          "name": "fetch_verb_code",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))",
            "return E_PERM;",
            "else",
            "set_task_perms(player);",
            "return `verb_code(args[1], args[2], !player:edit_option(\"no_parens\")) ! ANY';",
            "endif"
          ]
        },
        {
          "name": "set_verb_code",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))",
            "return E_PERM;",
            "else",
            "set_task_perms(player);",
            "return `set_verb_code(args[1], args[2], args[3]) ! ANY';",
            "endif"
          ]
        },
        {
          "name": "local_editing_info",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "if (caller == $verb_editor)",
            "set_task_perms(player);",
            "endif",
            "{object, vname, code} = args;",
            "if (typeof(vname) == LIST)",
            "vargs = tostr(\" \", vname[2], \" \", $code_utils:short_prep(vname[3]), \" \", vname[4]);",
            "vname = vname[1];",
            "else",
            "vargs = \"\";",
            "endif",
            "name = tostr(object.name, \":\", vname);",
            "ref = tostr(object, \":\", vname);",
            "\"... so the next 2 lines are actually wrong, since verb_info won't\";",
            "\"... necessarily retrieve the correct verb if we have more than one\";",
            "\"... matching the given same name; anyway, if parse_invoke understood vname,\";",
            "\"... so will @program.  I suspect these were put here because in the\";",
            "\"... old scheme of things, vname was always a number.\";",
            "\"vname = strsub($string_utils:explode(verb_info(object, vname)[3])[1], \\\"*\\\", \\\"\\\")\";",
            "\"vargs = verb_args(object, vname)\";",
            "\"\";",
            "simpleedit = $mcp.registry:match_package(\"dns-org-mud-moo-simpleedit\");",
            "if ((simpleedit != $failed_match) && simpleedit.v_filter_out)",
            "code = simpleedit.v_filter_out[1]:(simpleedit.v_filter_out[2])(code);",
            "endif",
            "return {name, code, tostr(\"@program \", object, \":\", vname, vargs), ref, \"moo-code\"};"
          ]
        },
        {
          "name": "verb_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\"verb_name(object, vname)\";",
            "\"Find vname on object and return its full name (quoted).\";",
            "\"This is useful for when we're working with verb numbers.\";",
            "if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))",
            "return E_PERM;",
            "else",
            "set_task_perms(player);",
            "given = args[2];",
            "if (typeof(info = `verb_info(args[1], given) ! ANY') == ERR)",
            "return tostr(given, \"[\", info, \"]\");",
            "elseif (info[3] == given)",
            "return given;",
            "else",
            "return tostr(given, \"/\\\"\", info[3], \"\\\"\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "verb_args",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\"verb_name(object, vname)\";",
            "\"Find vname on object and return its full name (quoted).\";",
            "\"This is useful for when we're working with verb numbers.\";",
            "if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))",
            "return E_PERM;",
            "else",
            "set_task_perms(player);",
            "return $string_utils:from_list(`verb_args(args[1], args[2]) ! ANY', \" \");",
            "endif"
          ]
        },
        {
          "name": "comment",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 49,
          "code": [
            "\"Syntax: comment [<range>]\";",
            "\"\";",
            "\"Turns the specified range of lines, into comments.\";",
            "if ((caller != player) && (caller_perms() != player))",
            "return E_PERM;",
            "elseif (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\".\"}, @args)) != LIST)",
            "player:tell(tostr(range));",
            "elseif (range[3])",
            "player:tell_lines($code_utils:verb_documentation());",
            "else",
            "text = this.texts[who];",
            "{from, to, crap} = range;",
            "cut = $maxint;",
            "for line in [from..to]",
            "cut = min(cut, `match(text[line], \"[^ ]\")[1] ! E_RANGE => 1');",
            "endfor",
            "for line in [from..to]",
            "text[line] = toliteral(text[line][cut..$]) + \";\";",
            "endfor",
            "this.texts[who] = text;",
            "player:tell((to == from) ? \"Line\" | \"Lines\", \" changed.\");",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif"
          ]
        },
        {
          "name": "uncomment",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 49,
          "code": [
            "\"Syntax: uncomment [<range>]\";",
            "\"\";",
            "\"Turns the specified range of lines from comments to, uh, not comments.\";",
            "if ((caller != player) && (caller_perms() != player))",
            "return E_PERM;",
            "elseif (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\".\"}, @args)) != LIST)",
            "player:tell(tostr(range));",
            "elseif (range[3])",
            "player:tell_lines($code_utils:verb_documentation());",
            "else",
            "text = this.texts[who];",
            "{from, to, crap} = range;",
            "bogus = {};",
            "for line in [from..to]",
            "if (match(text[line], \"^ *\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))",
            "\"check from $code_utils:verb_documentation\";",
            "if (!bogus)",
            "text[line] = $no_one:eval(text[line])[2];",
            "endif",
            "else",
            "bogus = setadd(bogus, line);",
            "endif",
            "endfor",
            "if (bogus)",
            "player:tell((length(bogus) == 1) ? \"Line\" | \"Lines\", \" \", $string_utils:english_list(bogus), \" \", (length(bogus) == 1) ? \"is\" | \"are\", \" not comments.\");",
            "player:tell(\"No changes.\");",
            "return;",
            "endif",
            "this.texts[who] = text;",
            "player:tell((to == from) ? \"Line\" | \"Lines\", \" changed.\");",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif"
          ]
        },
        {
          "name": "fetch_verb_args",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 49,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))",
            "raise(E_PERM);",
            "else",
            "set_task_perms(player);",
            "return `verb_args(args[1], args[2]) ! ANY';",
            "endif"
          ]
        }
      ],
      "propnames": [
        "objects",
        "verbnames"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [
            [
              "say",
              "emote",
              "lis*t",
              "ins*ert",
              "n*ext,p*rev",
              "enter",
              "del*ete",
              "f*ind",
              "s*ubst",
              "m*ove,c*opy",
              "join*l",
              "fill"
            ],
            [
              "y*ank",
              "w*hat",
              "e*dit",
              "com*pile",
              "abort",
              "q*uit,done,pause"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Verb body is empty.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "e*dit",
              "<obj>:<verb>"
            ],
            [
              "com*pile",
              "[as <obj>:<verb>]"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": "You need to either COMPILE or ABORT this verb before you can start on another.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "objects",
              0
            ],
            [
              "verbnames",
              0
            ],
            [
              "texts",
              0
            ],
            [
              "changes",
              0
            ],
            [
              "inserting",
              1
            ],
            [
              "readable",
              0
            ]
          ],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "You hear the bips of keyclick, the sliding of mice and the hum of computers in the distance as %n fades slowly out of view, heading towards them.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "There are the light bips of keyclick and the sliding of mice as %n fades into view, shoving %r away from the console, which promptly fades away.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            "Keeping your verb for later work.  ",
            "To return, give the `@edit' command with no arguments.",
            "Please come back and COMPILE or ABORT if you don't intend to be working on this verb in the immediate future.  Keep Our MOO Clean!  No Littering!"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": "The verb has no pending changes.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "You have changed the verb since last successful compile.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "First, you have to select a verb to edit with the EDIT command.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%L [editing verbs]",
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            5749
          ],
          "owner": 96,
          "perms": 4
        },
        {
          "value": -1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 665095404,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": [
            "Verb Editor",
            "vedit",
            "verbedit",
            "verb edit"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            21037,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "50": {
      "id": 50,
      "name": "Generic Editor",
      "flags": 144,
      "owner": 96,
      "location": -1,
      "parents": [
        3
      ],
      "children": [
        49,
        48,
        47,
        95
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "say",
          "owner": 96,
          "perms": 93,
          "preps": -2,
          "object": 50,
          "code": [
            "if ((caller != player) && (caller_perms() != player))",
            "return E_PERM;",
            "endif",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "this:insert_line(who, argstr);",
            "endif"
          ]
        },
        {
          "name": "emote",
          "owner": 96,
          "perms": 93,
          "preps": -2,
          "object": 50,
          "code": [
            "if ((caller != player) && (caller_perms() != player))",
            "return E_PERM;",
            "endif",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "this:append_line(who, argstr);",
            "endif"
          ]
        },
        {
          "name": "enter",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!this:loaded(player))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "lines = $command_utils:read_lines();",
            "if (typeof(lines) == ERR)",
            "player:notify(tostr(lines));",
            "return;",
            "endif",
            "this:insert_line(this:loaded(player), lines, 0);",
            "endif"
          ]
        },
        {
          "name": "lis*t view",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "nonum = 0;",
            "if (verb == \"view\")",
            "if (!args)",
            "l = {};",
            "for i in [1..length(this.active)]",
            "if (this.readable[i])",
            "l = {@l, this.active[i]};",
            "endif",
            "endfor",
            "if (l)",
            "player:tell(\"Players having readable texts in this editor:  \", $string_utils:names_of(l));",
            "else",
            "player:tell(\"No one has published anything in this editor.\");",
            "endif",
            "return;",
            "elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(args[1]), args[1])[1])",
            "\"...no such player\";",
            "return;",
            "elseif ((!(who = this:loaded(plyr))) || (!this:readable(who)))",
            "player:tell(plyr.name, \"(\", plyr, \") has not published anything in this editor.\");",
            "return;",
            "endif",
            "args = listdelete(args, 1);",
            "elseif (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "len = length(this.texts[who]);",
            "ins = this.inserting[who];",
            "window = 8;",
            "if (len < (2 * window))",
            "default = {\"1-$\"};",
            "elseif (ins <= window)",
            "default = {tostr(\"1-\", 2 * window)};",
            "else",
            "default = {tostr(window, \"_-\", window, \"^\"), tostr(2 * window, \"$-$\")};",
            "endif",
            "if (typeof(range = this:parse_range(who, default, @args)) != LIST)",
            "player:tell(tostr(range));",
            "elseif (range[3] && (!(nonum = \"nonum\" == $string_utils:trim(range[3]))))",
            "player:tell(\"Don't understand this:  \", range[3]);",
            "elseif (nonum)",
            "player:tell_lines(this.texts[who][range[1]..range[2]]);",
            "else",
            "for line in [range[1]..range[2]]",
            "this:list_line(who, line);",
            "if ($command_utils:running_out_of_time())",
            "suspend(0);",
            "if (!(who = this:loaded(player)))",
            "player:tell(\"ack!  something bad happened during a suspend...\");",
            "return;",
            "endif",
            "endif",
            "endfor",
            "if ((ins > len) && (len == range[2]))",
            "player:tell(\"^^^^\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "ins*ert n*ext p*revious .",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 50,
          "code": [
            "if (i = index(argstr, \"\\\"\"))",
            "text = argstr[i + 1..$];",
            "argstr = argstr[1..i - 1];",
            "else",
            "text = 0;",
            "endif",
            "spec = $string_utils:trim(argstr);",
            "if (index(\"next\", verb) == 1)",
            "verb = \"next\";",
            "spec = \"+\" + (spec || \"1\");",
            "elseif (index(\"prev\", verb) == 1)",
            "verb = \"prev\";",
            "spec = \"-\" + (spec || \"1\");",
            "else",
            "spec = spec || \".\";",
            "endif",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (ERR == typeof(number = this:parse_insert(who, spec)))",
            "if (verb in {\"next\", \"prev\"})",
            "player:tell(\"Argument must be a number.\");",
            "else",
            "player:tell(\"You must specify an integer or `$' for the last line.\");",
            "endif",
            "elseif ((number > (max = length(this.texts[who]) + 1)) || (number < 1))",
            "player:tell(\"That would take you out of range (to line \", number, \"?).\");",
            "else",
            "this.inserting[who] = number;",
            "if (typeof(text) == STR)",
            "this:insert_line(who, text);",
            "else",
            "if (verb != \"next\")",
            "(number > 1) ? this:list_line(who, number - 1) | player:tell(\"____\");",
            "endif",
            "if (verb != \"prev\")",
            "(number < max) ? this:list_line(who, number) | player:tell(\"^^^^\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "del*ete",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @args)) != LIST)",
            "player:tell(range);",
            "elseif (range[3])",
            "player:tell(\"Junk at end of cmd:  \", range[3]);",
            "else",
            "player:tell_lines((text = this.texts[who])[from = range[1]..to = range[2]]);",
            "player:tell(\"---Line\", (to > from) ? \"s\" | \"\", \" deleted.  Insertion point is before line \", from, \".\");",
            "this.texts[who] = {@text[1..from - 1], @text[to + 1..$]};",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "this.inserting[who] = from;",
            "endif"
          ]
        },
        {
          "name": "f*ind",
          "owner": 96,
          "perms": 93,
          "preps": -2,
          "object": 50,
          "code": [
            "if (callers() && (caller != this))",
            "return E_PERM;",
            "endif",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(subst = this:parse_subst(argstr && (argstr[1] + argstr), \"c\", \"Empty search string?\")) != LIST)",
            "player:tell(tostr(subst));",
            "elseif (typeof(start = subst[4] ? this:parse_insert(who, subst[4]) | this.inserting[who]) == ERR)",
            "player:tell(\"Starting from where?\", subst[4] ? (\"  (can't parse \" + subst[4]) + \")\" | \"\");",
            "else",
            "search = subst[2];",
            "case = !index(subst[3], \"c\", 1);",
            "text = this.texts[who];",
            "tlen = length(text);",
            "while ((start <= tlen) && (!index(text[start], search, case)))",
            "start = start + 1;",
            "endwhile",
            "if (start > tlen)",
            "player:tell(\"`\", search, \"' not found.\");",
            "else",
            "this.inserting[who] = start + 1;",
            "this:list_line(who, start);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "m*ove c*opy",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "verb = (is_move = verb[1] == \"m\") ? \"move\" | \"copy\";",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "wargs = args;",
            "t = to_pos = 0;",
            "while (t = \"to\" in (wargs = wargs[t + 1..$]))",
            "to_pos = to_pos + t;",
            "endwhile",
            "range_args = args[1..to_pos - 1];",
            "if ((!to_pos) || (ERR == typeof(dest = this:parse_insert(who, $string_utils:from_list(wargs, \" \")))))",
            "player:tell(verb, \" to where? \");",
            "elseif ((dest < 1) || (dest > ((last = length(this.texts[who])) + 1)))",
            "player:tell(\"Destination (\", dest, \") out of range.\");",
            "elseif ((\"from\" in range_args) || (\"to\" in range_args))",
            "player:tell(\"Don't use that kind of range specification with this command.\");",
            "elseif (typeof(range = this:parse_range(who, {\"_\", \"^\"}, @args[1..to_pos - 1])) != LIST)",
            "player:tell(range);",
            "elseif (range[3])",
            "player:tell(\"Junk before `to':  \", range[3]);",
            "elseif ((is_move && (dest >= range[1])) && (dest <= (range[2] + 1)))",
            "player:tell(\"Destination lies inside range of lines to be moved.\");",
            "else",
            "from = range[1];",
            "to = range[2];",
            "ins = this.inserting[who];",
            "text = this.texts[who];",
            "if (!is_move)",
            "this.texts[who] = {@text[1..dest - 1], @text[from..to], @text[dest..last]};",
            "if (ins >= dest)",
            "this.inserting[who] = ((ins + to) - from) + 1;",
            "endif",
            "else",
            "\"oh shit... it's a move\";",
            "if (dest < from)",
            "newtext = {@text[1..dest - 1], @text[from..to], @text[dest..from - 1], @text[to + 1..last]};",
            "if ((ins >= dest) && (ins <= to))",
            "ins = (ins > from) ? (ins - from) + dest | (((ins + to) - from) + 1);",
            "endif",
            "else",
            "newtext = {@text[1..from - 1], @text[to + 1..dest - 1], @text[from..to], @text[dest..last]};",
            "if ((ins > from) && (ins < dest))",
            "ins = (ins <= to) ? ((ins + dest) - to) - 1 | (((ins - to) + from) - 1);",
            "endif",
            "endif",
            "this.texts[who] = newtext;",
            "this.inserting[who] = ins;",
            "endif",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "player:tell(\"Lines \", is_move ? \"moved.\" | \"copied.\");",
            "endif"
          ]
        },
        {
          "name": "join*literal",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\"_-^\", \"_\", \"^\"}, @args)) != LIST)",
            "player:tell(range);",
            "elseif (range[3])",
            "player:tell(\"Junk at end of cmd:  \", range[3]);",
            "elseif (!(result = this:join_lines(who, @range[1..2], length(verb) <= 4)))",
            "player:tell((result == 0) ? \"Need at least two lines to join.\" | result);",
            "else",
            "this:list_line(who, range[1]);",
            "endif"
          ]
        },
        {
          "name": "fill",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "fill_column = 70;",
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @args)) != LIST)",
            "player:tell(range);",
            "elseif (range[3] && ((range[3][1] != \"@\") || ((fill_column = toint(range[3][2..$])) < 10)))",
            "player:tell(\"Usage:  fill [<range>] [@ column]   (where column >= 10).\");",
            "else",
            "join = this:join_lines(who, @range[1..2], 1);",
            "newlines = this:fill_string((text = this.texts[who])[from = range[1]], fill_column);",
            "if (fill = ((nlen = length(newlines)) > 1) || (newlines[1] != text[from]))",
            "this.texts[who] = {@text[1..from - 1], @newlines, @text[from + 1..$]};",
            "if (((insert = this.inserting[who]) > from) && (nlen > 1))",
            "this.inserting[who] = (insert + nlen) - 1;",
            "endif",
            "endif",
            "if (fill || join)",
            "for line in [from..(from + nlen) - 1]",
            "this:list_line(who, line);",
            "endfor",
            "else",
            "player:tell(\"No changes.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "pub*lish perish unpub*lish depub*lish",
          "owner": 96,
          "perms": 9,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "if (typeof(e = this:set_readable(who, index(\"publish\", verb) == 1)) == ERR)",
            "player:tell(e);",
            "elseif (e)",
            "player:tell(\"Your text is now globally readable.\");",
            "else",
            "player:tell(\"Your text is read protected.\");",
            "endif"
          ]
        },
        {
          "name": "w*hat",
          "owner": 96,
          "perms": 13,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!(this:ok(who = player in this.active) && (typeof(this.texts[who]) == LIST)))",
            "player:tell(this:nothing_loaded_msg());",
            "else",
            "player:tell(\"You are editing \", this:working_on(who), \".\");",
            "player:tell(\"Your insertion point is \", (this.inserting[who] > length(this.texts[who])) ? \"after the last line: next line will be #\" | \"before line \", this.inserting[who], \".\");",
            "player:tell(this.changes[who] ? this:change_msg() | this:no_change_msg());",
            "if (this.readable[who])",
            "player:tell(\"Your text is globally readable.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "abort",
          "owner": 96,
          "perms": 9,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!this.changes[who = player in this.active])",
            "player:tell(\"No changes to throw away.  Editor cleared.\");",
            "else",
            "player:tell(\"Throwing away session for \", this:working_on(who), \".\");",
            "endif",
            "this:reset_session(who);",
            "if (this.exit_on_abort)",
            "this:done();",
            "endif"
          ]
        },
        {
          "name": "done q*uit pause",
          "owner": 96,
          "perms": 13,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!(caller in {this, player}))",
            "return E_PERM;",
            "elseif (!(who = player in this.active))",
            "player:tell(\"You are not actually in \", this.name, \".\");",
            "return;",
            "elseif (!valid(origin = this.original[who]))",
            "player:tell(\"I don't know where you came here from.\");",
            "else",
            "player:moveto(origin);",
            "if (player.location == this)",
            "player:tell(\"Hmmm... the place you came from doesn't want you back.\");",
            "else",
            "if (msg = this:return_msg())",
            "player.location:announce($string_utils:pronoun_sub(msg));",
            "endif",
            "return;",
            "endif",
            "endif",
            "player:tell(\"You'll have to use 'home' or a teleporter.\");"
          ]
        },
        {
          "name": "huh2",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.\";",
            "set_task_perms(caller_perms());",
            "if ((c = callers()) && ((c[1][1] != this) || (length(c) > 1)))",
            "return pass(@args);",
            "endif",
            "verb = args[1];",
            "v = 1;",
            "vmax = min(length(verb), 5);",
            "while ((v <= vmax) && (verb[v] == \"subst\"[v]))",
            "v = v + 1;",
            "endwhile",
            "argstr = $code_utils:argstr(verb, args[2]);",
            "if (((v > 1) && (v <= length(verb))) && (((vl = verb[v]) < \"A\") || (vl > \"Z\")))",
            "argstr = (verb[v..$] + (argstr && \" \")) + argstr;",
            "return this:subst();",
            "elseif (\"/\" == verb[1])",
            "argstr = (verb + (argstr && \" \")) + argstr;",
            "return this:find();",
            "else",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "insertion",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && this.inserting[who];"
          ]
        },
        {
          "name": "set_insertion",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && ((((ins = toint(args[2])) < 1) ? E_INVARG | ((ins <= (max = length(this.texts[who]) + 1)) || (ins = max))) && (this.inserting[who] = ins));"
          ]
        },
        {
          "name": "changed retain_session_on_exit",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && this.changes[who];"
          ]
        },
        {
          "name": "set_changed",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && (((unchanged = !args[2]) || (this.times[who] = time())) && (this.changes[who] = !unchanged));"
          ]
        },
        {
          "name": "origin",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && this.original[who];"
          ]
        },
        {
          "name": "set_origin",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && (((valid(origin = args[2]) && (origin != this)) || ((origin == $nothing) || E_INVARG)) && (this.original[who] = origin));"
          ]
        },
        {
          "name": "readable",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return (((who = args[1]) < 1) || (who > length(this.active))) ? E_RANGE | this.readable[who];"
          ]
        },
        {
          "name": "set_readable",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:ok(who = args[1]) && (this.readable[who] = !(!args[2]));"
          ]
        },
        {
          "name": "text",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "{?who = player in this.active} = args;",
            "return (this:readable(who) || this:ok(who)) && this.texts[who];"
          ]
        },
        {
          "name": "load",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "texts = args[2];",
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "elseif (typeof(texts) == STR)",
            "texts = {texts};",
            "elseif ((typeof(texts) != LIST) || (length(texts) && (typeof(texts[1]) != STR)))",
            "return E_TYPE;",
            "endif",
            "this.texts[who] = texts;",
            "this.inserting[who] = length(texts) + 1;",
            "this.changes[who] = 0;",
            "this.readable[who] = 0;",
            "this.times[who] = time();"
          ]
        },
        {
          "name": "working_on",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"Dummy routine.  The child editor should provide something informative\";",
            "return this:ok(who = args[1]) && ((\"something [in \" + this.name) + \"]\");"
          ]
        },
        {
          "name": "ok",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "who = args[1];",
            "if ((who < 1) || (who > length(this.active)))",
            "return E_RANGE;",
            "elseif ((length(c = callers()) < 2) ? player == this.active[who] | ((c[2][1] == this) || ($perm_utils:controls(c[2][3], this.active[who]) || (c[2][3] == $generic_editor.owner))))",
            "return 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "loaded",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return ((who = args[1] in this.active) && (typeof(this.texts[who]) == LIST)) && who;"
          ]
        },
        {
          "name": "list_line",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "$ansi_utils:add_noansi();",
            "if (this:ok(who = args[1]))",
            "f = 1 + ((line = args[2]) in {(ins = this.inserting[who]) - 1, ins});",
            "player:tell($string_utils:right(line, 3, \" _^\"[f]), \":_^\"[f], \" \", this.texts[who][line]);",
            "endif",
            "$ansi_utils:remove_noansi();"
          ]
        },
        {
          "name": "insert_line",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\":insert_line([who,] line or list of lines [,quiet])\";",
            "\"  inserts the given text at the insertion point.\";",
            "\"  returns E_NONE if the session has no text loaded yet.\";",
            "if (typeof(args[1]) != INT)",
            "args = {player in this.active, @args};",
            "endif",
            "{who, lines, ?quiet = this.active[who]:edit_option(\"quiet_insert\")} = args;",
            "if (!(fuckup = this:ok(who)))",
            "return fuckup;",
            "elseif (typeof(text = this.texts[who]) != LIST)",
            "return E_NONE;",
            "else",
            "if (typeof(lines) != LIST)",
            "lines = {lines};",
            "endif",
            "p = this.active[who];",
            "insert = this.inserting[who];",
            "this.texts[who] = {@text[1..insert - 1], @lines, @text[insert..$]};",
            "this.inserting[who] = insert + length(lines);",
            "if (lines)",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "if (!quiet)",
            "if (length(lines) != 1)",
            "p:tell(\"Lines \", insert, \"-\", (insert + length(lines)) - 1, \" added.\");",
            "else",
            "p:tell(\"Line \", insert, \" added.\");",
            "endif",
            "endif",
            "else",
            "p:tell(\"No lines added.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "append_line",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\":append_line([who,] string)\";",
            "\"  appends the given string to the line before the insertion point.\";",
            "\"  returns E_NONE if the session has no text loaded yet.\";",
            "if (typeof(args[1]) != INT)",
            "args = {player in this.active, @args};",
            "endif",
            "{who, string} = args;",
            "if (!(fuckup = this:ok(who)))",
            "return fuckup;",
            "elseif ((append = this.inserting[who] - 1) < 1)",
            "return this:insert_line(who, {string});",
            "elseif (typeof(text = this.texts[who]) != LIST)",
            "return E_NONE;",
            "else",
            "this.texts[who][append] = text[append] + string;",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "p = this.active[who];",
            "if (!p:edit_option(\"quiet_insert\"))",
            "p:tell(\"Appended to line \", append, \".\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "join_lines",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "{who, from, to, english} = args;",
            "if (!(fuckup = this:ok(who)))",
            "return fuckup;",
            "elseif (from >= to)",
            "return 0;",
            "else",
            "nline = \"\";",
            "for line in ((text = this.texts[who])[from..to])",
            "if (!english)",
            "nline = nline + line;",
            "else",
            "len = length(line) + 1;",
            "while ((len = len - 1) && (line[len] == \" \"))",
            "endwhile",
            "if (len > 0)",
            "nline = (nline + line) + (index(\".:\", line[len]) ? \"  \" | \" \");",
            "endif",
            "endif",
            "endfor",
            "this.texts[who] = {@text[1..from - 1], nline, @text[to + 1..$]};",
            "if ((insert = this.inserting[who]) > from)",
            "this.inserting[who] = (insert <= to) ? from + 1 | ((insert - to) + from);",
            "endif",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "return to - from;",
            "endif"
          ]
        },
        {
          "name": "parse_number",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"parse_number(who,string,before)   interprets string as a line number.  In the event that string is `.', `before' tells us which line to use.  Return 0 if string is bogus.\";",
            "{who, string, before} = args;",
            "if (!(fuckup = this:ok(who)))",
            "return fuckup;",
            "endif",
            "last = length(this.texts[who]);",
            "ins = this.inserting[who] - 1;",
            "after = !before;",
            "if (!string)",
            "return 0;",
            "elseif (\".\" == string)",
            "return ins + after;",
            "elseif (!(i = index(\"_^$\", string[slen = length(string)])))",
            "return toint(string);",
            "else",
            "start = {ins + 1, ins, last + 1}[i];",
            "n = 1;",
            "if ((slen > 1) && (!(n = toint(string[1..slen - 1]))))",
            "return 0;",
            "elseif (i % 2)",
            "return start - n;",
            "else",
            "return start + n;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "parse_range",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"parse_range(who,default,@args) => {from to rest}\";",
            "numargs = length(args);",
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "elseif (!(last = length(this.texts[who])))",
            "return this:no_text_msg();",
            "endif",
            "default = args[2];",
            "r = 0;",
            "while (default && (LIST != typeof(r = this:parse_range(who, {}, default[1]))))",
            "default = listdelete(default, 1);",
            "endwhile",
            "if (typeof(r) == LIST)",
            "from = r[1];",
            "to = r[2];",
            "else",
            "from = to = 0;",
            "endif",
            "saw_from_to = 0;",
            "not_done = 1;",
            "a = 2;",
            "while (((a = a + 1) <= numargs) && not_done)",
            "if (args[a] == \"from\")",
            "if ((a == numargs) || (!(from = this:parse_number(who, args[a = a + 1], 0))))",
            "return \"from ?\";",
            "endif",
            "saw_from_to = 1;",
            "elseif (args[a] == \"to\")",
            "if ((a == numargs) || (!(to = this:parse_number(who, args[a = a + 1], 1))))",
            "return \"to ?\";",
            "endif",
            "saw_from_to = 1;",
            "elseif (saw_from_to)",
            "a = a - 1;",
            "not_done = 0;",
            "elseif (i = index(args[a], \"-\"))",
            "from = this:parse_number(who, args[a][1..i - 1], 0);",
            "to = this:parse_number(who, args[a][i + 1..$], 1);",
            "not_done = 0;",
            "elseif (f = this:parse_number(who, args[a], 0))",
            "from = f;",
            "if ((a == numargs) || (!(to = this:parse_number(who, args[a + 1], 1))))",
            "to = from;",
            "else",
            "a = a + 1;",
            "endif",
            "not_done = 0;",
            "else",
            "a = a - 1;",
            "not_done = 0;",
            "endif",
            "endwhile",
            "if (from < 1)",
            "return tostr(\"from \", from, \"?  (out of range)\");",
            "elseif (to > last)",
            "return tostr(\"to \", to, \"?  (out of range)\");",
            "elseif (from > to)",
            "return tostr(\"from \", from, \" to \", to, \"?  (backwards range)\");",
            "else",
            "return {from, to, $string_utils:from_list(args[a..numargs], \" \")};",
            "endif"
          ]
        },
        {
          "name": "parse_insert",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"parse_ins(who,string)  interprets string as an insertion point, i.e., a position between lines and returns the number of the following line or 0 if bogus.\";",
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "endif",
            "{who, string} = args;",
            "if (length(string) == 0)",
            "return E_INVARG;",
            "endif",
            "last = length(this.texts[who]) + 1;",
            "ins = this.inserting[who];",
            "if (i = index(\"-+\", string[1]))",
            "rest = string[2..$];",
            "return ((n = toint(rest)) || (rest == \"0\")) ? {ins - n, ins + n}[i] | E_INVARG;",
            "else",
            "if (!(j = index(string, \"^\") || index(string, \"_\")))",
            "offset = 0;",
            "else",
            "offset = (j == 1) || toint(string[1..j - 1]);",
            "if (!offset)",
            "return E_INVARG;",
            "elseif (string[j] == \"^\")",
            "offset = -offset;",
            "endif",
            "endif",
            "rest = string[j + 1..$];",
            "if (i = rest in {\".\", \"$\"})",
            "return offset + {ins, last}[i];",
            "elseif (!(n = toint(rest)))",
            "return E_INVARG;",
            "else",
            "return (offset + (j && (string[j] == \"^\"))) + n;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "parse_subst",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "{cmd, ?recognized_flags = \"gcr\", ?null_subst_msg = \"Null substitution?\"} = args;",
            "if (!cmd)",
            "return \"s*ubst/<str1>/<str2>[/[g][c][r][<range>]] expected...\";",
            "endif",
            "bchar = cmd[1];",
            "cmd = cmd[2..$];",
            "fromstr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];",
            "cmd = cmd[b2 + 1..$];",
            "tostr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];",
            "cmd = cmd[b2 + 1..$];",
            "cmdlen = length(cmd);",
            "b2 = 0;",
            "while (((b2 = b2 + 1) <= cmdlen) && index(recognized_flags, cmd[b2]))",
            "endwhile",
            "return ((fromstr == \"\") && (tostr == \"\")) ? null_subst_msg | {fromstr, tostr, cmd[1..b2 - 1], cmd[b2..$]};"
          ]
        },
        {
          "name": "invoke",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\":invoke(...)\";",
            "\"to find out what arguments this verb expects,\";",
            "\"see this editor's parse_invoke verb.\";",
            "new = args[1];",
            "if ((!(caller in {this, player})) && (!$perm_utils:controls(caller_perms(), player)))",
            "\"...non-editor/non-player verb trying to send someone to the editor...\";",
            "return E_PERM;",
            "endif",
            "if ((who = this:loaded(player)) && this:changed(who))",
            "if (!new)",
            "if (this:suck_in(player))",
            "player:tell(\"You are working on \", this:working_on(who));",
            "endif",
            "return;",
            "elseif (player.location == this)",
            "player:tell(\"You are still working on \", this:working_on(who));",
            "if (msg = this:previous_session_msg())",
            "player:tell(msg);",
            "endif",
            "return;",
            "endif",
            "\"... we're not in the editor and we're about to start something new,\";",
            "\"... but there's still this pending session...\";",
            "player:tell(\"You were working on \", this:working_on(who));",
            "if (!$command_utils:yes_or_no(\"Do you wish to delete that session?\"))",
            "if (this:suck_in(player))",
            "player:tell(\"Continuing with \", this:working_on(player in this.active));",
            "if (msg = this:previous_session_msg())",
            "player:tell(msg);",
            "endif",
            "endif",
            "return;",
            "endif",
            "\"... note session number may have changed => don't trust `who'\";",
            "this:kill_session(player in this.active);",
            "endif",
            "spec = this:parse_invoke(@args);",
            "if (typeof(spec) == LIST)",
            "if ((player:edit_option(\"local\") && $object_utils:has_verb(this, \"local_editing_info\")) && (info = this:local_editing_info(@spec)))",
            "this:invoke_local_editor(@info);",
            "elseif (this:suck_in(player))",
            "this:init_session(player in this.active, @spec);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "suck_in",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"The correct way to move someone into the editor.\";",
            "if (((loc = (who_obj = args[1]).location) != this) && (caller == this))",
            "this.invoke_task = task_id();",
            "who_obj:moveto(this);",
            "if (who_obj.location == this)",
            "try",
            "\"...forked, just in case loc:announce is broken...\";",
            "\"changed to a try-endtry. Lets reduce tasks..Ho_Yan 12/20/96\";",
            "if (valid(loc) && (msg = this:depart_msg()))",
            "loc:announce($string_utils:pronoun_sub(msg));",
            "endif",
            "except (ANY)",
            "\"Just drop it and move on\";",
            "endtry",
            "else",
            "who_obj:tell(\"For some reason, I can't move you.   (?)\");",
            "this:exitfunc(who_obj);",
            "endif",
            "this.invoke_task = 0;",
            "endif",
            "return who_obj.location == this;"
          ]
        },
        {
          "name": "new_session",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"WIZARDLY\";",
            "{who_obj, from} = args;",
            "if ($object_utils:isa(from, $generic_editor))",
            "\"... never put an editor in .original, ...\";",
            "if (w = who_obj in from.active)",
            "from = from.original[w];",
            "else",
            "from = #-1;",
            "endif",
            "endif",
            "if (caller != this)",
            "return E_PERM;",
            "elseif (who = who_obj in this.active)",
            "\"... edit in progress here...\";",
            "if (valid(from))",
            "this.original[who] = from;",
            "endif",
            "return -1;",
            "else",
            "for p in ({{\"active\", who_obj}, {\"original\", valid(from) ? from | $nothing}, {\"times\", time()}, @this.stateprops})",
            "this.(p[1]) = {@this.(p[1]), p[2]};",
            "endfor",
            "return length(this.active);",
            "endif"
          ]
        },
        {
          "name": "kill_session",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"WIZARDLY\";",
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "else",
            "for p in ({@this.stateprops, {\"original\"}, {\"active\"}, {\"times\"}})",
            "this.(p[1]) = listdelete(this.(p[1]), who);",
            "endfor",
            "return who;",
            "endif"
          ]
        },
        {
          "name": "reset_session",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"WIZARDLY\";",
            "if (!(fuckup = this:ok(who = args[1])))",
            "return fuckup;",
            "else",
            "for p in (this.stateprops)",
            "this.(p[1])[who] = p[2];",
            "endfor",
            "this.times[who] = time();",
            "return who;",
            "endif"
          ]
        },
        {
          "name": "kill_all_sessions",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"WIZARDLY\";",
            "if ((caller != this) && (!caller_perms().wizard))",
            "return E_PERM;",
            "else",
            "for victim in (this.contents)",
            "victim:tell(\"Sorry, \", this.name, \" is going down.  Your editing session is hosed.\");",
            "victim:moveto(((who = victim in this.active) && valid(origin = this.original[who])) ? origin | (valid(victim.home) ? victim.home | $player_start));",
            "endfor",
            "for p in ({@this.stateprops, {\"original\"}, {\"active\"}, {\"times\"}})",
            "this.(p[1]) = {};",
            "endfor",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "acceptable",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return is_player(who_obj = args[1]) && (who_obj.wizard || pass(@args));"
          ]
        },
        {
          "name": "enterfunc",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "who_obj = args[1];",
            "if (who_obj.wizard && (!(who_obj in this.active)))",
            "this:accept(who_obj);",
            "endif",
            "pass(@args);",
            "if (this.invoke_task == task_id())",
            "\"Means we're about to load something, so be quiet.\";",
            "this.invoke_task = 0;",
            "elseif (who = this:loaded(who_obj))",
            "who_obj:tell(\"You are working on \", this:working_on(who), \".\");",
            "elseif (msg = this:nothing_loaded_msg())",
            "who_obj:tell(msg);",
            "endif"
          ]
        },
        {
          "name": "exitfunc",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "if (!(who = (who_obj = args[1]) in this.active))",
            "elseif (this:retain_session_on_exit(who))",
            "if (msg = this:no_littering_msg())",
            "who_obj:tell_lines(msg);",
            "endif",
            "else",
            "this:kill_session(who);",
            "endif",
            "pass(@args);"
          ]
        },
        {
          "name": "@flush",
          "owner": 96,
          "perms": 109,
          "preps": -2,
          "object": 50,
          "code": [
            "\"@flush <editor>\";",
            "\"@flush <editor> at <month> <day>\";",
            "\"@flush <editor> at <weekday>\";",
            "\"The first form removes all sessions from the editor; the other two forms remove everything older than the given date.\";",
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "raise(E_PERM);",
            "elseif (!$perm_utils:controls(player, this))",
            "player:tell(\"Only the owner of the editor can do a \", verb, \".\");",
            "return;",
            "endif",
            "if (!prepstr)",
            "player:tell(\"Trashing all sessions.\");",
            "this:kill_all_sessions();",
            "elseif (prepstr != \"at\")",
            "player:tell(\"Usage:  \", verb, \" \", dobjstr, \" [at [mon day|weekday]]\");",
            "else",
            "p = prepstr in args;",
            "if (t = $time_utils:from_day(iobjstr, -1))",
            "elseif (t = $time_utils:from_month(args[p + 1], -1))",
            "if (length(args) > (p + 1))",
            "if (!(n = toint(args[p + 2])))",
            "player:tell(args[p + 1], \" WHAT?\");",
            "return;",
            "endif",
            "t = t + ((n - 1) * 86400);",
            "endif",
            "else",
            "player:tell(\"couldn't parse date\");",
            "return;",
            "endif",
            "this:do_flush(t, \"noisy\");",
            "endif",
            "player:tell(\"Done.\");"
          ]
        },
        {
          "name": "@stateprop",
          "owner": 96,
          "perms": 153,
          "preps": 11,
          "object": 50,
          "code": [
            "if (!$perm_utils:controls(player, this))",
            "player:tell(E_PERM);",
            "return;",
            "endif",
            "if (i = index(dobjstr, \"=\"))",
            "default = dobjstr[i + 1..$];",
            "prop = dobjstr[1..i - 1];",
            "if (argstr[1 + index(argstr, \"=\")] == \"\\\"\")",
            "elseif (default[1] == \"#\")",
            "default = toobj(default);",
            "elseif (index(\"0123456789\", default[1]))",
            "default = toint(default);",
            "elseif (default == \"{}\")",
            "default = {};",
            "endif",
            "else",
            "default = 0;",
            "prop = dobjstr;",
            "endif",
            "if (typeof(result = this:set_stateprops(prop, default)) == ERR)",
            "player:tell((result == E_RANGE) ? tostr(\".\", prop, \" needs to hold a list of the same length as .active (\", length(this.active), \").\") | ((result != E_NACC) ? result | (prop + \" is already a property on an ancestral editor.\")));",
            "else",
            "player:tell(\"Property added.\");",
            "endif"
          ]
        },
        {
          "name": "@rmstateprop",
          "owner": 96,
          "perms": 153,
          "preps": 5,
          "object": 50,
          "code": [
            "if (!$perm_utils:controls(player, this))",
            "player:tell(E_PERM);",
            "elseif (typeof(result = this:set_stateprops(dobjstr)) == ERR)",
            "player:tell((result != E_NACC) ? result | (dobjstr + \" is already a property on an ancestral editor.\"));",
            "else",
            "player:tell(\"Property removed.\");",
            "endif"
          ]
        },
        {
          "name": "initialize",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this))",
            "pass(@args);",
            "this:kill_all_sessions();",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this:kill_all_sessions();",
            "if (this == $generic_editor)",
            "this.help = $help_db[\"editor\"];",
            "endif",
            "if ($object_utils:defines_verb(this, \"is_not_banned\"))",
            "delete_verb(this, \"is_not_banned\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "set_stateprops",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "remove = length(args) < 2;",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (!(length(args) in {1, 2}))",
            "return E_ARGS;",
            "elseif (typeof(prop = args[1]) != STR)",
            "return E_TYPE;",
            "elseif (i = $list_utils:iassoc(prop, this.stateprops))",
            "if (!remove)",
            "this.stateprops[i] = {prop, args[2]};",
            "elseif ($object_utils:has_property(parent(this), prop))",
            "return E_NACC;",
            "else",
            "this.stateprops = listdelete(this.stateprops, i);",
            "endif",
            "elseif (remove)",
            "elseif (prop in `properties(this) ! ANY => {}')",
            "if (this:_stateprop_length(prop) != length(this.active))",
            "return E_RANGE;",
            "endif",
            "this.stateprops = {{prop, args[2]}, @this.stateprops};",
            "else",
            "return $object_utils:has_property(this, prop) ? E_NACC | E_PROPNF;",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "description",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "is_look_self = 1;",
            "for c in (callers())",
            "if (is_look_self && (c[2] in {\"enterfunc\", \"confunc\"}))",
            "return {\"\", \"Do a 'look' to get the list of commands, or 'help' for assistance.\", \"\", @this.description};",
            "elseif ((c[2] != \"look_self\") && (c[2] != \"pass\"))",
            "is_look_self = 0;",
            "endif",
            "endfor",
            "d = {\"Commands:\", \"\"};",
            "col = {{}, {}};",
            "for c in [1..2]",
            "for cmd in (this.commands2[c])",
            "cmd = this:commands_info(cmd);",
            "col[c] = {cmdargs = $string_utils:left(cmd[1] + \" \", 12) + cmd[2], @col[c]};",
            "endfor",
            "endfor",
            "i1 = length(col[1]);",
            "i2 = length(col[2]);",
            "right = 0;",
            "while (i1 || i2)",
            "if (!((i1 && (length(col[1][i1]) > 35)) || (i2 && (length(col[2][i2]) > 35))))",
            "d = {@d, $string_utils:left(i1 ? col[1][i1] | \"\", 40) + (i2 ? col[2][i2] | \"\")};",
            "i1 && (i1 = i1 - 1);",
            "i2 && (i2 = i2 - 1);",
            "right = 0;",
            "elseif (right && i2)",
            "d = {@d, (length(col[2][i2]) > 35) ? $string_utils:right(col[2][i2], 75) | ($string_utils:space(40) + col[2][i2])};",
            "i2 = i2 - 1;",
            "right = 0;",
            "elseif (i1)",
            "d = {@d, col[1][i1]};",
            "i1 = i1 - 1;",
            "right = 1;",
            "else",
            "right = 1;",
            "endif",
            "endwhile",
            "return {@d, \"\", \"----  Do `help <cmdname>' for help with a given command.  ----\", \"\", \"  <ins> ::= $ (the end) | [^]n (above line n) | _n (below line n) | . (current)\", \"<range> ::= <lin> | <lin>-<lin> | from <lin> | to <lin> | from <lin> to <lin>\", \"  <lin> ::= n | [n]$ (n from the end) | [n]_ (n before .) | [n]^ (n after .)\", \"`help insert' and `help ranges' describe these in detail.\", @this.description};"
          ]
        },
        {
          "name": "commands_info",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "cmd = args[1];",
            "if (pc = $list_utils:assoc(cmd, this.commands))",
            "return pc;",
            "elseif (this == $generic_editor)",
            "return {cmd, \"<<<<<======= Need to add this to .commands\"};",
            "else",
            "return parent(this):commands_info(cmd);",
            "endif"
          ]
        },
        {
          "name": "match_object",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "{objstr, ?who = player} = args;",
            "origin = this;",
            "while ((where = player in origin.active) && ($recycler:valid(origin = origin.original[where]) && (origin != this)))",
            "if (!$object_utils:isa(origin, $generic_editor))",
            "return origin:match_object(objstr, who);",
            "endif",
            "endwhile",
            "return who:my_match_object(objstr, #-1);"
          ]
        },
        {
          "name": "who_location_msg",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "who = args[1];",
            "where = {#-1, @this.original}[1 + (who in this.active)];",
            "wherestr = `where:who_location_msg(who) ! ANY => \"An Editor\"';",
            "if (typeof(wherestr) != STR)",
            "wherestr = \"broken who_location_msg\";",
            "endif",
            "return strsub(this.who_location_msg, \"%L\", wherestr);",
            "return $string_utils:pronoun_sub(this.who_location_msg, who, this, where);"
          ]
        },
        {
          "name": "nothing_loaded_msg no_text_msg change_msg no_change_msg no_littering_msg depart_msg return_msg previous_session_msg",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return $code_utils:verb_or_property(player, verb, this) || this.(verb);"
          ]
        },
        {
          "name": "announce announce_all announce_all_but tell_contents",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return;"
          ]
        },
        {
          "name": "fill_string(noansi)",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"fill(string [, width [, prefix]])\";",
            "\"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.\";",
            "{string, ?width = 1 + player:linelen(), ?prefix = \"\"} = args;",
            "width = width + 1;",
            "if (width < (3 + length(prefix)))",
            "return E_INVARG;",
            "endif",
            "string = (\"$\" + string) + \" $\";",
            "len = length(string);",
            "if (len <= width)",
            "last = len - 1;",
            "next = len;",
            "else",
            "last = rindex(string[1..width], \" \");",
            "if (last < ((width + 1) / 2))",
            "last = width + index(string[width + 1..len], \" \");",
            "endif",
            "next = last;",
            "while (string[next = next + 1] == \" \")",
            "endwhile",
            "endif",
            "while (string[last = last - 1] == \" \")",
            "endwhile",
            "ret = {string[2..last]};",
            "width = width - length(prefix);",
            "minlast = (width + 1) / 2;",
            "while (next < len)",
            "string = \"$\" + string[next..len];",
            "len = (len - next) + 2;",
            "if (len <= width)",
            "last = len - 1;",
            "next = len;",
            "else",
            "last = rindex(string[1..width], \" \");",
            "if (last < minlast)",
            "last = width + index(string[width + 1..len], \" \");",
            "endif",
            "next = last;",
            "while (string[next = next + 1] == \" \")",
            "endwhile",
            "endif",
            "while (string[last = last - 1] == \" \")",
            "endwhile",
            "if (last > 1)",
            "ret = {@ret, prefix + string[2..last]};",
            "endif",
            "endwhile",
            "return ret;"
          ]
        },
        {
          "name": "here_huh",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.\";",
            "if ((caller != this) && (caller_perms() != player))",
            "return E_PERM;",
            "endif",
            "{verb, args} = args;",
            "v = 1;",
            "vmax = min(length(verb), 5);",
            "while ((v <= vmax) && (verb[v] == \"subst\"[v]))",
            "v = v + 1;",
            "endwhile",
            "argstr = $code_utils:argstr(verb, args);",
            "if ((v > 1) && ((v <= length(verb)) && (((vl = verb[v]) < \"A\") || (vl > \"Z\"))))",
            "argstr = (verb[v..$] + (argstr && \" \")) + argstr;",
            "this:subst();",
            "return 1;",
            "elseif (\"/\" == verb[1])",
            "argstr = (verb + (argstr && \" \")) + argstr;",
            "this:find();",
            "return 1;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "match",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return $failed_match;"
          ]
        },
        {
          "name": "get_room",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\":get_room([player])  => correct room to match in on invocation.\";",
            "{?who = player} = args;",
            "if (who.location != this)",
            "return who.location;",
            "else",
            "origin = this;",
            "while ((where = player in origin.active) && (valid(origin = origin.original[where]) && (origin != this)))",
            "if (!$object_utils:isa(origin, $generic_editor))",
            "return origin;",
            "endif",
            "endwhile",
            "return this;",
            "endif"
          ]
        },
        {
          "name": "invoke_local_editor",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"$generic_editor:invoke_local_editor(name, text, upload, reference, type)\";",
            "\"Spits out the magic text that invokes the local editor in the player's client.\";",
            "\"NAME is a good human-readable name for the local editor to use for this particular piece of text.\";",
            "\"TEXT is a string or list of strings, the initial body of the text being edited.\";",
            "\"UPLOAD, a string, is a MOO command that the local editor can use to save the text when the user is done editing.  The local editor is going to send that command on a line by itself, followed by the new text lines, followed by a line containing only `.'.  The UPLOAD command should therefore call $command_utils:read_lines() to get the new text as a list of strings.\";",
            "\"REFERENCE is a string representing the MCP/2.1 reference (usually <obj>.<prop> or <obj>:<verb>) for clients who speak MCP/2.1 simpleedit.\";",
            "\"TYPE is a string representing the MCP/2.1 type (moo-code, string...) for clients who speak MCP/2.1 simpleedit.\";",
            "if (caller != this)",
            "return;",
            "endif",
            "{name, text, upload, reference, type} = args;",
            "if (typeof(text) == STR)",
            "text = {text};",
            "endif",
            "session = $mcp:session_for(player);",
            "package = $mcp:match_package(\"dns-org-mud-moo-simpleedit\");",
            "if (session:handles_package(package) == {1, 0})",
            "package:send_content(session, reference, name, type, text);",
            "return;",
            "endif",
            "notify(player, tostr(\"#$# edit name: \", name, \" upload: \", upload));",
            "\":dump_lines() takes care of the final `.' ...\";",
            "for line in ($command_utils:dump_lines(text))",
            "notify(player, line);",
            "endfor"
          ]
        },
        {
          "name": "_stateprop_length",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"+c properties on children cannot necessarily be read, so we need this silliness...\";",
            "if (caller != this)",
            "return E_PERM;",
            "else",
            "return length(this.(args[1]));",
            "endif"
          ]
        },
        {
          "name": "print",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 50,
          "code": [
            "txt = this:text(player in this.active);",
            "if (typeof(txt) == LIST)",
            "player:tell_lines(txt);",
            "else",
            "player:tell(\"Text unreadable:  \", txt);",
            "endif",
            "player:tell(\"--------------------------\");"
          ]
        },
        {
          "name": "accept",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return this:acceptable(who_obj = args[1]) && this:new_session(who_obj, who_obj.location);"
          ]
        },
        {
          "name": "y*ank",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 50,
          "code": [
            "\"Usage: yank from <note>\";",
            "\"       yank <message-sequence> from <mail-recipient>\";",
            "\"       yank from <object>:<verb>\";",
            "\"       yank from <object>.<property>\";",
            "\"Grabs the specified text and inserts it at the cursor.\";",
            "set_task_perms(player);",
            "if (dobjstr)",
            "\"yank <message-sequence> from <mail-recipient>\";",
            "if (!(p = player:parse_mailread_cmd(verb, args, \"\", \"from\")))",
            "return;",
            "elseif ($seq_utils:size(sequence = p[2]) != 1)",
            "player:notify(tostr(\"You can only \", verb, \" one message at a time\"));",
            "return;",
            "else",
            "m = (folder = p[1]):messages_in_seq(sequence);",
            "msg = m[1];",
            "header = tostr(\"Message \", msg[1]);",
            "if (folder != player)",
            "header = tostr(header, \" on \", $mail_agent:name(folder));",
            "endif",
            "header = tostr(header, \":\");",
            "lines = {header, @player:msg_full_text(@msg[2])};",
            "this:insert_line(this:loaded(player), lines, 0);",
            "endif",
            "elseif (pr = $code_utils:parse_propref(iobjstr))",
            "o = player:my_match_object(pr[1]);",
            "if ($command_utils:object_match_failed(o, pr[1]))",
            "return;",
            "elseif ((lines = `o.(pr[2]) ! ANY') == E_PROPNF)",
            "player:notify(tostr(\"There is no `\", pr[2], \"' property on \", $string_utils:nn(o), \".\"));",
            "return;",
            "elseif (lines == E_PERM)",
            "player:notify(tostr(\"Error: Permission denied reading \", iobjstr));",
            "return;",
            "elseif (typeof(lines) == ERR)",
            "player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));",
            "return;",
            "elseif (typeof(lines) == STR)",
            "this:insert_line(this:loaded(player), lines, 0);",
            "return;",
            "elseif (typeof(lines) == LIST)",
            "for x in (lines)",
            "if (typeof(x) != STR)",
            "player:notify(tostr(\"Error: \", iobjstr, \" does not contain a \", verb, \"-able value.\"));",
            "return;",
            "endif",
            "endfor",
            "this:insert_line(this:loaded(player), lines, 0);",
            "return;",
            "else",
            "player:notify(tostr(\"Error: \", iobjstr, \" does not contain a \", verb, \"-able value.\"));",
            "return;",
            "endif",
            "elseif (pr = $code_utils:parse_verbref(iobjstr))",
            "o = player:my_match_object(pr[1]);",
            "if ($command_utils:object_match_failed(o, pr[1]))",
            "return;",
            "elseif (lines = `verb_code(o, pr[2], !player:edit_option(\"no_parens\")) ! ANY')",
            "this:insert_line(this:loaded(player), lines, 0);",
            "return;",
            "elseif (lines == E_PERM)",
            "player:notify(tostr(\"Error: Permission denied reading \", iobjstr));",
            "return;",
            "elseif (lines == E_VERBNF)",
            "player:notify(tostr(\"There is no `\", pr[2], \"' verb on \", $string_utils:nn(o), \".\"));",
            "else",
            "player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));",
            "return;",
            "endif",
            "elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))",
            "return;",
            "elseif ((lines = `iobj:text() ! ANY') == E_PERM)",
            "player:notify(tostr(\"Error: Permission denied reading \", iobjstr));",
            "return;",
            "elseif (lines == E_VERBNF)",
            "player:notify(tostr($string_utils:nn(iobj), \" doesn't seem to be a note.\"));",
            "elseif (typeof(lines) == ERR)",
            "player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));",
            "return;",
            "else",
            "this:insert_line(this:loaded(player), lines, 0);",
            "endif"
          ]
        },
        {
          "name": "do_flush",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"Flushes editor sessions older than args[1].  If args[2] is true, prints status as it runs.  If args[2] is false, runs silently.\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "else",
            "{t, noisy} = args;",
            "for i in [-length(this.active)..-1]",
            "if (this.times[-i] < t)",
            "if (noisy)",
            "player:tell($string_utils:nn(this.active[-i]), ctime(this.times[-i]));",
            "endif",
            "this:kill_session(-i);",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "s*ubst",
          "owner": 96,
          "perms": 93,
          "preps": -2,
          "object": 50,
          "code": [
            "if (callers() && (caller != this))",
            "return E_PERM;",
            "elseif (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(subst = this:parse_subst(argstr)) != LIST)",
            "player:tell(tostr(subst));",
            "elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @$string_utils:explode(subst[4]))) != LIST)",
            "player:tell(range);",
            "elseif (range[3])",
            "player:tell(\"Junk at end of cmd:  \", range[3]);",
            "else",
            "{fromstr, tostr, specs, dummy} = subst;",
            "global = index(specs, \"g\", 1);",
            "regexp = index(specs, \"r\", 1);",
            "case = !index(specs, \"c\", 1);",
            "munged = {};",
            "text = this.texts[who];",
            "changed = {};",
            "{from, to} = range[1..2];",
            "for line in [from..to]",
            "t = t0 = text[line];",
            "if (!fromstr)",
            "t = tostr + t;",
            "elseif (global)",
            "if (regexp)",
            "while (new = this:subst_regexp(t, fromstr, tostr, case))",
            "t = new;",
            "endwhile",
            "else",
            "t = strsub(t, fromstr, tostr, case);",
            "endif",
            "else",
            "if (regexp)",
            "(new = this:subst_regexp(t, fromstr, tostr, case)) && (t = new);",
            "else",
            "(i = index(t, fromstr, case)) && (t = (t[1..i - 1] + tostr) + t[i + length(fromstr)..length(t)]);",
            "endif",
            "endif",
            "if (strcmp(t0, t))",
            "changed = {@changed, line};",
            "endif",
            "munged = {@munged, t};",
            "endfor",
            "if (!changed)",
            "player:tell(\"No changes in line\", (from == to) ? tostr(\" \", from) | tostr(\"s \", from, \"-\", to), \".\");",
            "else",
            "this.texts[who] = {@text[1..from - 1], @munged, @text[to + 1..$]};",
            "if (!this.changes[who])",
            "this.changes[who] = 1;",
            "this.times[who] = time();",
            "endif",
            "for line in (changed)",
            "this:list_line(who, line);",
            "endfor",
            "endif",
            "endif"
          ]
        },
        {
          "name": "subst_regexp",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "\"Copied from Domain (#8111):subst_regexp by Mooshie (#106469) Mon Jan  5 19:27:26 1998 PST\";",
            "\"Usage: subst_regexp(STR text, STR from string, STR to string, INT case)\";",
            "{text, from, to, case} = args;",
            "if (m = match(text, from, case))",
            "{start, end} = m[1..2];",
            "text[start..end] = substitute(to, m);",
            "return text;",
            "else",
            "return m;",
            "endif"
          ]
        },
        {
          "name": "include_for_core",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 50,
          "code": [
            "return (this == $generic_editor) ? {\"owner\"} | {};"
          ]
        },
        {
          "name": "fill_string",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 50,
          "code": [
            "if (valid(au = $ansi_utils) && au.active)",
            "return au:(verb)(@args);",
            "else",
            "return this:(verb + \"(noansi)\")(@args);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "readable",
        "times",
        "commands2",
        "help",
        "no_text_msg",
        "commands",
        "invoke_task",
        "exit_on_abort",
        "previous_session_msg",
        "stateprops",
        "depart_msg",
        "return_msg",
        "no_littering_msg",
        "no_change_msg",
        "change_msg",
        "nothing_loaded_msg",
        "texts",
        "active",
        "changes",
        "inserting",
        "original"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [
            [
              "say",
              "emote",
              "lis*t",
              "ins*ert",
              "n*ext,p*rev",
              "del*ete",
              "f*ind",
              "s*ubst",
              "m*ove,c*opy",
              "join*l",
              "fill"
            ],
            [
              "y*ank",
              "w*hat",
              "abort",
              "q*uit,done,pause"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": 44,
          "owner": 96,
          "perms": 5
        },
        {
          "value": "There are no lines of text.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "say",
              "<text>"
            ],
            [
              "emote",
              "<text>"
            ],
            [
              "lis*t",
              "[<range>] [nonum]"
            ],
            [
              "ins*ert",
              "[<ins>] [\"<text>]"
            ],
            [
              "n*ext,p*rev",
              "[n] [\"<text>]"
            ],
            [
              "del*ete",
              "[<range>]"
            ],
            [
              "f*ind",
              "/<str>[/[c][<range>]]"
            ],
            [
              "s*ubst",
              "/<str1>/<str2>[/[g][c][r][<range>]]"
            ],
            [
              "m*ove,c*opy",
              "[<range>] to <ins>"
            ],
            [
              "join*l",
              "[<range>]"
            ],
            [
              "fill",
              "[<range>] [@<col>]"
            ],
            [
              "w*hat",
              ""
            ],
            [
              "abort",
              ""
            ],
            [
              "q*uit,done,pause",
              ""
            ],
            [
              "enter",
              ""
            ],
            [
              "y*ank",
              "from <text-source>"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 5
        },
        {
          "value": "",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "texts",
              0
            ],
            [
              "changes",
              0
            ],
            [
              "inserting",
              1
            ],
            [
              "readable",
              0
            ]
          ],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%N heads off to the Generic Editing Room.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "%N comes back from the Generic Editing Room.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Keeping your [whatever] for later work.  Since this the Generic Editor, you have to do your own :set_changed(0) so that we'll know to get rid of whatever it you're working on when you leave.  Please don't litter... especially in the Generic Editor.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "There have been no changes since the last save.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "Text has been altered since the last save.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "You're not currently editing anything.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%L [editing]",
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            5751
          ],
          "owner": 96,
          "perms": 4
        },
        {
          "value": -1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 1399008566,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": [
            "Generic Editor",
            "gedit",
            "edit"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            77149,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "51": {
      "id": 51,
      "name": "matching utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "match",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\":match(string, object-list)\";",
            "\"Return object in 'object-list' aliased to 'string'.\";",
            "\"Matches on a wide variety of syntax, including:\";",
            "\" \\\"5th axe\\\" -- The fifth object matching \\\"axe\\\" in the object list.\";",
            "\" \\\"where's sai\\\" -- The only object contained in 'where' matching \\\"sai\\\" (possible $ambiguous_match).\";",
            "\" \\\"where's second staff\\\" -- The second object contained in 'where' matching \\\"staff\\\".\";",
            "\" \\\"my third dagger\\\" -- The third object in your inventory matching \\\"dagger\\\".\";",
            "\"Ordinal matches are determined according to the match's position in 'object-list' or, if a possessive (such as \\\"where\\\" above) is given, then the ordinal is the nth match in that object's inventory.\";",
            "\"In the matching room (#3879@LambdaMOO), the 'object-list' consists of first the player's contents, then the room's, and finally all exits leading from the room.\";",
            "{string, olist} = args;",
            "if (!string)",
            "return $nothing;",
            "elseif (string == \"me\")",
            "return player;",
            "elseif (string == \"here\")",
            "return player.location;",
            "elseif (valid(object = $string_utils:literal_object(string)))",
            "return object;",
            "elseif (valid(object = $string_utils:match(string, olist, \"aliases\")))",
            "return object;",
            "elseif (parsed = this:parse_ordinal_reference(string))",
            "return this:match_nth(parsed[2], olist, parsed[1]);",
            "elseif (parsed = this:parse_possessive_reference(string))",
            "{whostr, objstr} = parsed;",
            "if (valid(whose = this:match(whostr, olist)))",
            "return this:match(objstr, whose.contents);",
            "else",
            "return whose;",
            "endif",
            "else",
            "return object;",
            "endif",
            "\"Profane (#30788) - Sat Jan  3, 1998 - Changed so literals get returned ONLY if in the passed object list.\";",
            "\"Profane (#30788) - Sat Jan  3, 1998 - OK, that broke lots of stuff, so changed it back.\";"
          ]
        },
        {
          "name": "match_nth",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\":match_nth(string, objlist, n)\";",
            "\"Find the nth object in 'objlist' that matches 'string'.\";",
            "{what, where, n} = args;",
            "for v in (where)",
            "z = 0;",
            "for q in (v.aliases)",
            "z = z || (index(q, what) == 1);",
            "endfor",
            "if (z && (!(n = n - 1)))",
            "return v;",
            "endif",
            "endfor",
            "return $failed_match;"
          ]
        },
        {
          "name": "match_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\"$match_utils:match_verb(verbname, object) => Looks for a command-line style verb named <verbname> on <object> with current values of prepstr, dobjstr, dobj, iobjstr, and iobj.  If a match is made, the verb is called with @args[3] as arguments and 1 is returned.  Otherwise, 0 is returned.\";",
            "{vrb, what, rest} = args;",
            "if (where = $object_utils:has_verb(what, vrb))",
            "if ((vargs = verb_args(where[1], vrb)) != {\"this\", \"none\", \"this\"})",
            "if (((((((vargs[2] == \"any\") || ((!prepstr) && (vargs[2] == \"none\"))) || index((\"/\" + vargs[2]) + \"/\", (\"/\" + prepstr) + \"/\")) && (((vargs[1] == \"any\") || ((!dobjstr) && (vargs[1] == \"none\"))) || ((dobj == what) && (vargs[1] == \"this\")))) && (((vargs[3] == \"any\") || ((!iobjstr) && (vargs[3] == \"none\"))) || ((iobj == what) && (vargs[3] == \"this\")))) && index(verb_info(where[1], vrb)[2], \"x\")) && verb_code(where[1], vrb))",
            "set_task_perms(caller_perms());",
            "what:(vrb)(@rest);",
            "return 1;",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "match_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\":match_list(string, object_list) -> List of all matches.\";",
            "{what, where} = args;",
            "if (!what)",
            "return {};",
            "endif",
            "r = {};",
            "for v in (where)",
            "if (!(v in r))",
            "z = 0;",
            "for q in (v.aliases)",
            "z = z || (q && (index(q, what) == 1));",
            "endfor",
            "if (z)",
            "\"r = listappend(r, v);\";",
            "r = {@r, v};",
            "endif",
            "endif",
            "endfor",
            "return r;",
            "\"Hydros (#106189) - Sun Jul 3, 2005 - Changed listappend to a splice to save ticks. Old code commented above.\";"
          ]
        },
        {
          "name": "parse_ordinal_reference parse_ordref",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\":parse_ordref(string)\";",
            "\"Parses strings referring to an 'nth' object.\";",
            "\"=> {INT n, STR object} Where 'n' is the number the ordinal represents, and 'object' is the rest of the string.\";",
            "\"=> 0 If the given string is not an ordinal reference.\";",
            "\"  Example:\";",
            "\":parse_ordref(\\\"second broadsword\\\") => {2, \\\"broadsword\\\"}\";",
            "\":parse_ordref(\\\"second\\\") => 0\";",
            "\"  Note that there must be more to the string than the ordinal alone.\";",
            "if (m = match(args[1], (\"^\" + this.ordinal_regexp) + \" +%([^ ].+%)$\"))",
            "o = substitute(\"%1\", m);",
            "n = (o in this.ordn) || (o in this.ordw);",
            "return n && {n, substitute(\"%2\", m)};",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "parse_possessive_reference",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "\":parse_possessive_reference(string)\";",
            "\"Parses strings in a possessive format.\";",
            "\"=> {STR whose, STR object}  Where 'whose' is the possessor of 'object'.\";",
            "\"If the string consists only of a possessive string (ie: \\\"my\\\", or \\\"yduJ's\\\"), then 'object' will be an empty string.\";",
            "\"=> 0 If the given string is not a possessive reference.\";",
            "\"  Example:\";",
            "\":parse_possessive_reference(\\\"joe's cat\\\") => {\\\"joe\\\", \\\"cat\\\"}\";",
            "\":parse_possessive_reference(\\\"sis' fish\\\") => {\\\"sis\\\", \\\"fish\\\"}\";",
            "\"  Strings are returned as a value suitable for a :match routine, thus 'my' becoming 'me'.\";",
            "\":parse_possessive_reference(\\\"my dog\\\") => {\\\"me\\\", \\\"dog\\\"}\";",
            "string = args[1];",
            "if (m = match(string, \"^my$%|^my +%(.+%)?\"))",
            "return {\"me\", substitute(\"%1\", m)};",
            "elseif (m = match(string, \"^%(.+s?%)'s? *%(.+%)?\"))",
            "return {substitute(\"%1\", m), substitute(\"%2\", m)};",
            "else",
            "return 0;",
            "endif",
            "\"Profane (#30788) - Sun Jun 21, 1998 - changed first parenthetical match bit from %([^ ]+s?%) to %(.+s?%)\";"
          ]
        },
        {
          "name": "object_match_failed",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 51,
          "code": [
            "\"Usage: object_match_failed(object, string[, ambigs])\";",
            "\"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).\";",
            "\"ambigs is an optional list of the objects that were matched upon.  If given, the message printed will list the ambiguous among them as choices.\";",
            "{match_result, string, ?ambigs = 0} = args;",
            "tell = (0 && $perm_utils:controls(caller_perms(), player)) ? \"notify\" | \"tell\";",
            "if ((index(string, \"#\") == 1) && ($code_utils:toobj(string) != E_TYPE))",
            "\"...avoid the `I don't know which `#-2' you mean' message...\";",
            "if (!valid(match_result))",
            "player:(tell)(tostr(\"There is no \\\"\", string, \"\\\" that you can see.\"));",
            "endif",
            "return !valid(match_result);",
            "elseif (match_result == $nothing)",
            "player:(tell)(\"You must give the name of some object.\");",
            "elseif (match_result == $failed_match)",
            "player:(tell)(tostr(\"There is no \\\"\", string, \"\\\" that you can see.\"));",
            "elseif (match_result == $ambiguous_match)",
            "if (typeof(ambigs) != LIST)",
            "player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.\"));",
            "return 1;",
            "endif",
            "ambigs = $match_utils:match_list(string, ambigs);",
            "ambigs = $list_utils:map_property(ambigs, \"name\");",
            "if ((length($list_utils:remove_duplicates(ambigs)) == 1) && $object_utils:isa(player.location, this.matching_room))",
            "player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.  Try using \\\"first \", string, \"\\\", \\\"second \", string, \"\\\", etc.\"));",
            "else",
            "player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean: \", $string_utils:english_list(ambigs, \"nothing\", \" or \"), \".\"));",
            "endif",
            "return 1;",
            "elseif (!valid(match_result))",
            "player:(tell)(tostr(\"The object you specified does not exist.  Seeing ghosts?\"));",
            "else",
            "return 0;",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 51,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.matching_room = $nothing;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "ordn",
        "ordw",
        "ordinal_regexp",
        "matching_room"
      ],
      "propdefs": [
        {
          "value": [
            "first",
            "second",
            "third",
            "fourth",
            "fifth",
            "sixth",
            "seventh",
            "eighth",
            "ninth",
            "tenth"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "1st",
            "2nd",
            "3rd",
            "4th",
            "5th",
            "6th",
            "7th",
            "8th",
            "9th",
            "10th"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%<%(first%|second%|third%|fourth%|fifth%|sixth%|seventh%|eighth%|ninth%|tenth%|1st%|2nd%|3rd%|4th%|5th%|6th%|7th%|8th%|9th%|10th%)%>",
          "owner": 36,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "$match_utils defines the following verbs:",
            "",
            "match",
            "match_nth",
            "match_verb",
            "match_list",
            "parse_ordinal_reference (alias parse_ordref)",
            "parse_possessive_reference",
            "object_match_failed",
            "",
            "For more documentation, see help $match_utils:<specific verb>."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "matching utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            12908,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "52": {
      "id": 52,
      "name": "object utilities",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "has_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Syntax:  has_property(OBJ, STR) => INT 0|1\";",
            "\"\";",
            "\"Does object have the specified property? Returns true if it is defined on the object or a parent.\";",
            "{object, prop} = args;",
            "try",
            "object.(prop);",
            "return 1;",
            "except (E_PROPNF, E_INVIND)",
            "return 0;",
            "endtry",
            "\"Old code...Ho_Yan 10/22/96\";",
            "if (prop in $code_utils.builtin_props)",
            "return valid(object);",
            "else",
            "return !(!property_info(object, prop));",
            "endif"
          ]
        },
        {
          "name": "all_properties all_verbs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Syntax:  all_properties (OBJ what)\";",
            "\"         all_verbs      (OBJ what)\";",
            "\"\";",
            "\"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms.\";",
            "what = args[1];",
            "if (what.owner != caller_perms())",
            "set_task_perms(caller_perms());",
            "endif",
            "bif = (verb == \"all_verbs\") ? \"verbs\" | \"properties\";",
            "res = `call_function(bif, what) ! E_PERM => {}';",
            "while (valid(what = parent(what)))",
            "res = {@`call_function(bif, what) ! E_PERM => {}', @res};",
            "endwhile",
            "return res;"
          ]
        },
        {
          "name": "has_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":has_verb(OBJ object, STR verbname)\";",
            "\"Find out if an object has a verb matching the given verbname.\";",
            "\"Returns {location} if so, 0 if not, where location is the object or the ancestor on which the verb is actually defined.\";",
            "{object, verbname} = args;",
            "while (valid(object))",
            "try",
            "if (verb_info(object, verbname))",
            "return {object};",
            "endif",
            "except (E_VERBNF)",
            "object = parent(object);",
            "endtry",
            "endwhile",
            "return 0;",
            "\"OLD CODE BELOW:\";",
            "while (E_VERBNF == (vi = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))",
            "object = parent(object);",
            "endwhile",
            "return vi ? {object} | 0;"
          ]
        },
        {
          "name": "has_callable_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Usage:  has_callable_verb(object, verb)\";",
            "\"See if an object has a verb that can be called by another verb (i.e., that has its x permission bit set).\";",
            "\"Return {location}, where location is the object that defines the verb, or 0 if the object doesn't have the verb.\";",
            "{object, verbname} = args;",
            "if (typeof(object) == WAIF)",
            "object = object.class;",
            "verbname = \":\" + verbname;",
            "endif",
            "return `{respond_to(object, verbname)[1]} ! ANY => 0';"
          ]
        },
        {
          "name": "match_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":match_verb(OBJ object, STR verb)\";",
            "\"Find out if an object has a given verb, and some information about it.\";",
            "\"Returns {OBJ location, STR verb} if matched, 0 if not.\";",
            "\"Location is the object on which it is actually defined, verb is a name\";",
            "\"for the verb which can subsequently be used in verb_info (i.e., no\";",
            "\"asterisks).\";",
            "verbname = strsub(args[2], \"*\", \"\");",
            "object = args[1];",
            "while (E_VERBNF == (info = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))",
            "object = parent(object);",
            "endwhile",
            "return info ? {object, verbname} | 0;"
          ]
        },
        {
          "name": "isa",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "{what, targ, ?return_parent = 0} = args;",
            "if ((typeof(what) == OBJ) && (typeof(targ) in {OBJ, LIST}))",
            "return isa(@args);",
            "elseif ((typeof(what) == WAIF) && (typeof(targ) in {OBJ, LIST}))",
            "return isa(what.class, targ, return_parent);",
            "elseif ((typeof(what) == WAIF) && (typeof(targ) == WAIF))",
            "return isa(what.class, targ.class, return_parent);",
            "elseif ((typeof(what) == OBJ) && (typeof(targ) == WAIF))",
            "return isa(targ.class, what, return_parent);",
            "else",
            "raise(E_INVARG);",
            "endif"
          ]
        },
        {
          "name": "ancestors",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Usage:  ancestors(object[, object...])\";",
            "\"Return a list of all ancestors of the object(s) in args, with no duplicates.\";",
            "\"If called with a single object, the result will be in order ascending up the inheritance hierarchy.  If called with multiple objects, it probably won't.\";",
            "return ancestors(@args);"
          ]
        },
        {
          "name": "ordered_descendants",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "r = {what = args[1]};",
            "for k in (children(what))",
            "if (children(k))",
            "r = {@r, @this:(verb)(k)};",
            "else",
            "r = {@r, k};",
            "endif",
            "endfor",
            "return r;"
          ]
        },
        {
          "name": "contains",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"$object_utils:contains(obj1, obj2) -- does obj1 contain obj2?\";",
            "\"\";",
            "\"Return true iff obj2 is under obj1 in the containment hierarchy; that is, if obj1 is obj2's location, or its location's location, or ...\";",
            "{loc, what} = args;",
            "while (valid(what))",
            "what = what.location;",
            "if (what == loc)",
            "return valid(loc);",
            "endif",
            "endwhile",
            "return 0;"
          ]
        },
        {
          "name": "all_contents",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"all_contents(object)\";",
            "\"Return a list of all objects contained (at some level) by object.\";",
            "for y in (res = args[1].contents)",
            "y.contents && (res = {@res, @this:all_contents(y)});",
            "endfor",
            "return res;"
          ]
        },
        {
          "name": "findable_properties",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"findable_properties(object)\";",
            "\"Return a list of properties on those members of object's ancestor list that are readable or are owned by the caller (or all properties if the caller is a wizard).\";",
            "what = args[1];",
            "props = {};",
            "who = caller_perms();",
            "while (what != $nothing)",
            "if ((what.r || (who == what.owner)) || who.wizard)",
            "props = {@properties(what), @props};",
            "endif",
            "what = parent(what);",
            "endwhile",
            "return props;"
          ]
        },
        {
          "name": "owned_properties",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"owned_properties(what[, who])\";",
            "\"Return a list of all properties on WHAT owned by WHO.\";",
            "\"Only wizardly verbs can specify WHO; mortal verbs can only search for properties owned by their own owners.  For more information, talk to Gary_Severn.\";",
            "what = anc = args[1];",
            "who = ((c = caller_perms()).wizard && (length(args) > 1)) ? args[2] | c;",
            "props = {};",
            "while (anc != $nothing)",
            "for k in (properties(anc))",
            "if (property_info(what, k)[1] == who)",
            "props = listappend(props, k);",
            "endif",
            "endfor",
            "anc = parent(anc);",
            "endwhile",
            "return props;"
          ]
        },
        {
          "name": "property_conflicts",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":property_conflicts(object,newparent)\";",
            "\"Looks for propertyname conflicts that would keep chparent(object,newparent)\";",
            "\"  from working.\";",
            "\"Returns a list of elements of the form {<propname>, @<objectlist>}\";",
            "\"where <objectlist> is list of descendents of object defining <propname>.\";",
            "if (!valid(object = args[1]))",
            "return E_INVARG;",
            "elseif (!valid(newparent = args[2]))",
            "return (newparent == #-1) ? {} | E_INVARG;",
            "elseif (!($perm_utils:controls(caller_perms(), object) && (newparent.f || $perm_utils:controls(caller_perms(), newparent))))",
            "\"... if you couldn't chparent anyway, you don't need to know...\";",
            "return E_PERM;",
            "endif",
            "\"... properties existing on newparent\";",
            "\"... cannot be present on object or any descendent...\";",
            "props = conflicts = {};",
            "for o in ({object, @$object_utils:descendents_suspended(object)})",
            "for p in (properties(o))",
            "if (`property_info(newparent, p) ! E_PROPNF => 0')",
            "if (i = p in props)",
            "conflicts[i] = {@conflicts[i], o};",
            "else",
            "props = {@props, p};",
            "conflicts = {@conflicts, {p, o}};",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return conflicts;"
          ]
        },
        {
          "name": "descendants_with_property_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":descendants_with_property_suspended(object,property)\";",
            "\" => list of descendants of object on which property is defined.\";",
            "\"calls suspend(0) as needed\";",
            "{object, prop} = args;",
            "if ((caller == this) || (object.w || $perm_utils:controls(caller_perms(), object)))",
            "$command_utils:suspend_if_needed(0);",
            "if (`property_info(object, prop) ! E_PROPNF => 0')",
            "return {object};",
            "endif",
            "r = {};",
            "for c in (children(object))",
            "r = {@r, @this:descendants_with_property_suspended(c, prop)};",
            "endfor",
            "return r;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "locations",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Usage:  locations(object)\";",
            "\"Return a listing of the location hierarchy above object.\";",
            "return locations(@args);"
          ]
        },
        {
          "name": "all_properties_suspended all_verbs_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Syntax:  all_properties_suspended (OBJ what)\";",
            "\"         all_verbs_suspended      (OBJ what)\";",
            "\"\";",
            "\"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms. Suspends as necessary\";",
            "what = args[1];",
            "if (what.owner != caller_perms())",
            "set_task_perms(caller_perms());",
            "endif",
            "bif = (verb == \"all_verbs_suspended\") ? \"verbs\" | \"properties\";",
            "res = `call_function(bif, what) ! E_PERM => {}';",
            "while (valid(what = parent(what)))",
            "res = {@`call_function(bif, what) ! E_PERM => {}', @res};",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "return res;"
          ]
        },
        {
          "name": "connected",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":connected(object) => true if object is a connected player.\";",
            "\"equivalent to (object in connected_players()) for valid players, perhaps with less server overhead.\";",
            "\"use object:is_listening() if you want to allow for puppets and other non-player objects that still 'care' about what's said.\";",
            "return typeof(`connected_seconds(@args) ! E_INVARG') == INT;"
          ]
        },
        {
          "name": "isoneof",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":isoneof(x,y) = x isa z, for some z in list y\";",
            "{what, targ} = args;",
            "while (valid(what))",
            "if (what in targ)",
            "return 1;",
            "endif",
            "what = parent(what);",
            "endwhile",
            "return 0;"
          ]
        },
        {
          "name": "defines_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"Returns 1 if the verb is actually *defined* on this object, 0 else.\";",
            "\"Use this instead of :has_verb if your aim is to manipulate that verb code or whatever.\";",
            "return `verb_info(@args) ! ANY => 0' && 1;",
            "\"Old code below...Ho_Yan 10/22/96\";",
            "info = verb_info(@args);",
            "return typeof(info) != ERR;"
          ]
        },
        {
          "name": "defines_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":defines_property(OBJ object, STR property name) => Returns 1 if the property is actually *defined* on the object given\";",
            "if (!valid(o = args[1]))",
            "return 0;",
            "elseif (!valid(p = parent(o)))",
            "return this:has_property(o, args[2]);",
            "else",
            "return (!this:has_property(p, args[2])) && this:has_property(o, args[2]);",
            "endif"
          ]
        },
        {
          "name": "has_any_verb has_any_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":has_any_verb(object) / :has_any_property(object)\";",
            "\" -- does `object' have any verbs/properties?\";",
            "return !(!`(verb == \"has_any_verb\") ? verbs(args[1]) | properties(args[1]) ! E_INVARG => 0');"
          ]
        },
        {
          "name": "has_readable_prop*erty hrp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":has_readable_property(OBJ object, STR property name) => 1 if property exists and is publically readable (has the r flag set true).\";",
            "{object, prop} = args;",
            "try",
            "pinfo = property_info(object, prop);",
            "return index(pinfo[2], \"r\") != 0;",
            "except (E_PROPNF)",
            "return (prop in $code_utils.builtin_props) > 0;",
            "endtry"
          ]
        },
        {
          "name": "descendants descendents",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":descendants (OBJ object) => {OBJs} all nested children of <object>\";",
            "return descendants(@args);"
          ]
        },
        {
          "name": "leaves",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":leaves (OBJ object) => {OBJs} descendants of <object> that have no children\";",
            "r = {args[1]};",
            "i = 1;",
            "while (i <= length(r))",
            "if (kids = children(r[i]))",
            "r[i..i] = kids;",
            "else",
            "i = i + 1;",
            "endif",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "branches",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":branches (OBJ object) => {OBJs} descendants of <object> that have children\";",
            "r = args[1..1];",
            "i = 1;",
            "while (i <= length(r))",
            "if (kids = children(r[i]))",
            "r[i + 1..i] = kids;",
            "i = i + 1;",
            "else",
            "r[i..i] = {};",
            "endif",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "descendants_suspended descendents_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":descendants_suspended (OBJ object) => {OBJs} all nested children of <object>\";",
            "set_task_perms(caller_perms());",
            "r = children(args[1]);",
            "i = 1;",
            "while (i <= length(r))",
            "if (kids = children(r[i]))",
            "r = {@r, @kids};",
            "endif",
            "i = i + 1;",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "leaves_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":leaves_suspended (OBJ object) => {OBJs} descendants of <object> that have\";",
            "\"                                         no children\";",
            "set_task_perms(caller_perms());",
            "r = {args[1]};",
            "i = 1;",
            "while (i <= length(r))",
            "if (kids = children(r[i]))",
            "r[i..i] = kids;",
            "else",
            "i = i + 1;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "branches_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":branches_suspended (OBJ object) => {OBJs} all descendants of <object> that\";",
            "\"                                           have children.\";",
            "set_task_perms(caller_perms());",
            "r = args[1..1];",
            "i = 1;",
            "while (i <= length(r))",
            "if (kids = children(r[i]))",
            "r[i + 1..i] = kids;",
            "i = i + 1;",
            "else",
            "r[i..i] = {};",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "return r;"
          ]
        },
        {
          "name": "disown disinherit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\":disown(object) / :disinherit(object)\";",
            "\" => 1 (for a successful disinheritance)\";",
            "\" raises E_PERM, E_INVARG, E_ARGS\";",
            "cp = caller_perms();",
            "\"     no set_task_perms() because we need to be able to\";",
            "\"     chparent() an object we don't own\";",
            "{victim} = args;",
            "parent = parent(victim);",
            "if ($perm_utils:controls(cp, victim))",
            "raise(E_INVARG, tostr(victim.name, \" (\", victim, \") is yours.  Use @chparent.\"));",
            "elseif (!valid(parent))",
            "raise(E_INVARG, tostr(victim.name, \" (\", victim, \") is already an orphan.\"));",
            "elseif (!$perm_utils:controls(cp, parent))",
            "raise(E_PERM, tostr(parent.name, \" (\", parent, \"), the parent of \", victim.name, \" (\", victim, \"), is not yours.\"));",
            "elseif (!valid(grandparent = parent(parent)))",
            "\"... still not sure about this... do we care?  --Rog...\";",
            "raise(E_INVARG, tostr(victim.name, \" (\", victim, \") has no grandparent to take custody.\"));",
            "else",
            "chparent(victim, grandparent);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "accessible_verbs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\"  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of readability of object\";",
            "{thing} = args;",
            "valid(thing) || raise(E_INVARG, \"Invalid object argument\");",
            "{num_verbs, verbs} = {length(verbs(thing)), {}};",
            "set_task_perms(caller_perms());",
            "\"... caching num of verbs before for loop saves us ticks ...\";",
            "for i in [1..num_verbs]",
            "verbs = {@verbs, `verb_info(thing, i)[3] ! E_PERM'};",
            "endfor",
            "return verbs;"
          ]
        },
        {
          "name": "accessible_prop*erties accessible_props",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 52,
          "code": [
            "\" :accessible_props(object)   => a list of property names (or E_PERM), regardless of the readability of the object.\";",
            "thing = args[1];",
            "all = properties(thing);",
            "props = {};",
            "set_task_perms(caller_perms());",
            "for i in (all)",
            "$command_utils:suspend_if_needed(0);",
            "if ((info = `property_info(thing, i) ! ANY') != E_PROPNF)",
            "props = {@props, info ? i | E_PERM};",
            "endif",
            "endfor",
            "return props;",
            "\"Last modified Mon Nov 28 06:19:35 2005 PST, by Roebare (#109000).\";"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "These routines are useful for finding out information about individual objects.",
            "",
            "Examining everything an object has defined on it:",
            "  all_verbs          (object) => like it says",
            "  all_properties     (object) => likewise",
            "  findable_properties(object) => tests to see if caller can \"find\" them",
            "  owned_properties   (object[, owner]) => tests for ownership",
            "",
            "Investigating inheritance:",
            "  ancestors(object[,object...]) => all ancestors",
            "  descendants      (object)     => all descendants",
            "  ordered_descendants(object)   => descendants, in a different order",
            "  leaves           (object)     => descendants with no children",
            "  branches         (object)     => descendants with children ",
            "  isa        (object,class) => true iff object is a descendant of class (or ==)",
            "  property_conflicts (object,newparent) => can object chparent to newparent?",
            "  isoneof     (object,list)     => true if object :isa class in list of parents",
            "",
            "Considering containment:",
            "  contains      (obj1, obj2) => Does obj1 contain obj2 (nested)?",
            "  all_contents      (object) => return all the (nested) contents of object",
            "  locations         (object) => list of location hierarchy above object",
            "",
            "Verifying verbs and properties:",
            "  has_property(object,pname) => false/true   according as object.(pname) exists",
            "  has_readable_property(object,pname) => false/true if prop exists and is +r",
            "  defines_property(object,pname) => does object *define* this property",
            "  has_verb    (object,vname) => false/{#obj} according as object:(vname) exists",
            "  has_callable_verb          => same, but verb must be callable from a program",
            "  defines_verb(object,vname) => does this object *define* this verb",
            "  match_verb  (object,vname) => false/{location, newvname}",
            "                               (identify location and usable name of verb)",
            "  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of ",
            "                                readability of object",
            "",
            "Player checking:",
            "  connected         (object) => true if object is a player and is connected",
            "",
            "Suspending:",
            "  Many of the above verbs have ..._suspended versions to assist with very large object hierarchies.  The following exist:",
            "   descendants_suspended              ",
            "   branches_suspended                 ",
            "   leaves_suspended                   ",
            "   all_properties_suspended           ",
            "   descendants_with_property_suspended"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "object utilities"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the object utilities utility package.  See `help $object_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            31061,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "53": {
      "id": 53,
      "name": "lock utilities",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_scanner",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "this.input_string = args[1];",
            "this.input_length = length(args[1]);",
            "this.input_index = 1;",
            "this.index_incremented = 0;"
          ]
        },
        {
          "name": "scan_token",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "string = this.input_string;",
            "len = this.input_length;",
            "i = this.input_index;",
            "while ((i <= len) && (string[i] == \" \"))",
            "i = i + 1;",
            "endwhile",
            "if (i > len)",
            "this.index_incremented = 0;",
            "return \"\";",
            "elseif ((ch = string[i]) in {\"(\", \")\", \"!\", \"?\"})",
            "this.input_index = i + 1;",
            "this.index_incremented = 1;",
            "return ch;",
            "elseif (ch in {\"&\", \"|\"})",
            "this.input_index = i = i + 1;",
            "this.index_incremented = 1;",
            "if ((i <= len) && (string[i] == ch))",
            "this.input_index = i + 1;",
            "this.index_incremented = 2;",
            "endif",
            "return ch + ch;",
            "else",
            "start = i;",
            "while ((i <= len) && (!((ch = string[i]) in {\"(\", \")\", \"!\", \"?\", \"&\", \"|\"})))",
            "i = i + 1;",
            "endwhile",
            "this.input_index = i;",
            "i = i - 1;",
            "while (string[i] == \" \")",
            "i = i - 1;",
            "endwhile",
            "this.index_incremented = (i - start) + 1;",
            "return this:canonicalize_spaces(string[start..i]);",
            "endif"
          ]
        },
        {
          "name": "canonicalize_spaces",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "name = args[1];",
            "while (index(name, \"  \"))",
            "name = strsub(name, \"  \", \" \");",
            "endwhile",
            "return name;"
          ]
        },
        {
          "name": "parse_keyexp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "\"parse_keyexp(STRING keyexpression, OBJ player) => returns a list containing the coded key, or a string containing an error message if the attempt failed.\";",
            "\"\";",
            "\"Grammar for key expressions:\";",
            "\"\";",
            "\"    E ::= A       \";",
            "\"       |  E || A  \";",
            "\"       |  E && A  \";",
            "\"    A ::= ( E )   \";",
            "\"       |  ! A     \";",
            "\"       |  object  \";",
            "\"       |  ? object  \";",
            "this:init_scanner(args[1]);",
            "this.player = args[2];",
            "return this:parse_E();"
          ]
        },
        {
          "name": "parse_E",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "exp = this:parse_A();",
            "if (typeof(exp) != STR)",
            "while ((token = this:scan_token()) in {\"&&\", \"||\"})",
            "rhs = this:parse_A();",
            "if (typeof(rhs) == STR)",
            "return rhs;",
            "endif",
            "exp = {token, exp, rhs};",
            "endwhile",
            "\"The while loop above always eats a token. Reset it back so the iteration can find it again. Always losing `)'. Ho_Yan 3/9/95\";",
            "this.input_index = this.input_index - this.index_incremented;",
            "endif",
            "return exp;"
          ]
        },
        {
          "name": "parse_A",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "token = this:scan_token();",
            "if (token == \"(\")",
            "exp = this:parse_E();",
            "if ((typeof(exp) != STR) && (this:scan_token() != \")\"))",
            "return \"Missing ')'\";",
            "else",
            "return exp;",
            "endif",
            "elseif (token == \"!\")",
            "exp = this:parse_A();",
            "if (typeof(exp) == STR)",
            "return exp;",
            "else",
            "return {\"!\", exp};",
            "endif",
            "elseif (token == \"?\")",
            "next = this:scan_token();",
            "if (next in {\"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})",
            "return (\"Missing object-name before '\" + token) + \"'\";",
            "elseif (next == \"\")",
            "return \"Missing object-name at end of key expression\";",
            "else",
            "what = this:match_object(next);",
            "if (typeof(what) == OBJ)",
            "return {\"?\", this:match_object(next)};",
            "else",
            "return what;",
            "endif",
            "endif",
            "elseif (token in {\"&&\", \"||\"})",
            "return (\"Missing expression before '\" + token) + \"'\";",
            "elseif (token == \"\")",
            "return \"Missing expression at end of key expression\";",
            "else",
            "return this:match_object(token);",
            "endif"
          ]
        },
        {
          "name": "eval_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "\"eval_key(LIST|OBJ coded key, OBJ testobject) => returns true if testobject will solve the provided key.\";",
            "{key, who} = args;",
            "type = typeof(key);",
            "if (!(type in {LIST, OBJ}))",
            "return 1;",
            "elseif (typeof(key) == OBJ)",
            "return (who == key) || $object_utils:contains(who, key);",
            "endif",
            "op = key[1];",
            "if (op == \"!\")",
            "return !this:eval_key(key[2], who);",
            "elseif (op == \"?\")",
            "return key[2]:is_unlocked_for(who);",
            "elseif (op == \"&&\")",
            "return this:eval_key(key[2], who) && this:eval_key(key[3], who);",
            "elseif (op == \"||\")",
            "return this:eval_key(key[2], who) || this:eval_key(key[3], who);",
            "else",
            "raise(E_DIV);",
            "endif"
          ]
        },
        {
          "name": "match_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "\"used by $lock_utils to unparse a key expression so one can use `here' and `me' as well as doing the regular object matching.\";",
            "token = args[1];",
            "if (token == \"me\")",
            "return this.player;",
            "elseif (token == \"here\")",
            "if (valid(this.player.location))",
            "return this.player.location;",
            "else",
            "return (\"'here' has no meaning where \" + this.player.name) + \" is\";",
            "endif",
            "else",
            "what = this.player.location:match_object(token);",
            "if (what == $failed_match)",
            "return (\"Can't find an object named '\" + token) + \"'\";",
            "elseif (what == $ambiguous_match)",
            "return (\"Multiple objects named '\" + token) + \"'\";",
            "else",
            "return what;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "unparse_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "\":unparse_key(LIST|OBJ coded key) => returns a string describing the key in english/moo-code terms.\";",
            "\"Example:\";",
            "\"$lock_utils:unparse_key({\\\"||\\\", $hacker, $housekeeper}) => \\\"#18105[Hacker] || #36830[housekeeper]\\\"\";",
            "key = args[1];",
            "type = typeof(key);",
            "if (!(type in {LIST, OBJ}))",
            "return \"(None.)\";",
            "elseif (type == OBJ)",
            "if (valid(key))",
            "return tostr(key, \"[\", key.name, \"]\");",
            "else",
            "return tostr(key);",
            "endif",
            "else",
            "op = key[1];",
            "arg1 = this:unparse_key(key[2]);",
            "if (op == \"?\")",
            "return \"?\" + arg1;",
            "elseif (op == \"!\")",
            "if (typeof(key[2]) == LIST)",
            "return (\"!(\" + arg1) + \")\";",
            "else",
            "return \"!\" + arg1;",
            "endif",
            "elseif (op in {\"&&\", \"||\"})",
            "other = (op == \"&&\") ? \"||\" | \"&&\";",
            "lhs = arg1;",
            "rhs = this:unparse_key(key[3]);",
            "if ((typeof(key[2]) == OBJ) || (key[2][1] != other))",
            "exp = lhs;",
            "else",
            "exp = (\"(\" + lhs) + \")\";",
            "endif",
            "exp = ((exp + \" \") + op) + \" \";",
            "if ((typeof(key[3]) == OBJ) || (key[3][1] != other))",
            "exp = exp + rhs;",
            "else",
            "exp = ((exp + \"(\") + rhs) + \")\";",
            "endif",
            "return exp;",
            "else",
            "raise(E_DIV);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "eval_key_new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "set_task_perms($no_one);",
            "{key, who} = args;",
            "type = typeof(key);",
            "if (!(type in {LIST, OBJ}))",
            "return 1;",
            "elseif (typeof(key) == OBJ)",
            "return (who == key) || $object_utils:contains(who, key);",
            "endif",
            "op = key[1];",
            "if (op == \"!\")",
            "return !this:eval_key(key[2], who);",
            "elseif (op == \"?\")",
            "return key[2]:is_unlocked_for(who);",
            "elseif (op == \"&&\")",
            "return this:eval_key(key[2], who) && this:eval_key(key[3], who);",
            "elseif (op == \"||\")",
            "return this:eval_key(key[2], who) || this:eval_key(key[3], who);",
            "elseif (op == \".\")",
            "if ($object_utils:has_property(who, key[2]) && who.(key[2]))",
            "return 1;",
            "else",
            "for thing in ($object_utils:all_contents(who))",
            "if ($object_utils:has_property(thing, key[2]) && thing.(key[2]))",
            "return 1;",
            "endif",
            "endfor",
            "endif",
            "return 0;",
            "elseif (op == \":\")",
            "if ($object_utils:has_verb(who, key[2]) && who:(key[2])())",
            "return 1;",
            "else",
            "for thing in ($object_utils:all_contents(who))",
            "if ($object_utils:has_verb(thing, key[2]) && thing:(key[2])())",
            "return 1;",
            "endif",
            "endfor",
            "endif",
            "return 0;",
            "else",
            "raise(E_DIV);",
            "endif"
          ]
        },
        {
          "name": "parse_A_new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 53,
          "code": [
            "token = this:scan_token();",
            "if (token == \"(\")",
            "exp = this:parse_E();",
            "if ((typeof(exp) != STR) && (this:scan_token() != \")\"))",
            "return \"Missing ')'\";",
            "else",
            "return exp;",
            "endif",
            "elseif (token == \"!\")",
            "exp = this:parse_A();",
            "if (typeof(exp) == STR)",
            "return exp;",
            "else",
            "return {\"!\", exp};",
            "endif",
            "elseif (token == \"?\")",
            "next = this:scan_token();",
            "if (next in {\":\", \".\", \"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})",
            "return (\"Missing object-name before '\" + token) + \"'\";",
            "elseif (next == \"\")",
            "return \"Missing object-name at end of key expression\";",
            "else",
            "what = this:match_object(next);",
            "if (typeof(what) == OBJ)",
            "return {\"?\", this:match_object(next)};",
            "else",
            "return what;",
            "endif",
            "endif",
            "elseif (token in {\":\", \".\"})",
            "next = this:scan_token();",
            "if (next in {\":\", \".\", \"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})",
            "return (\"Missing verb-or-property-name before '\" + token) + \"'\";",
            "elseif (next == \"\")",
            "return \"Missing verb-or-property-name at end of key expression\";",
            "elseif (typeof(next) != STR)",
            "return \"Non-string verb-or-property-name at end of key expression\";",
            "else",
            "return {token, next};",
            "endif",
            "elseif (token in {\"&&\", \"||\"})",
            "return (\"Missing expression before '\" + token) + \"'\";",
            "elseif (token == \"\")",
            "return \"Missing expression at end of key expression\";",
            "else",
            "return this:match_object(token);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "player",
        "input_index",
        "input_length",
        "input_string",
        "index_incremented"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "These routines are used when locking objects, and when testing an object's lock before allowing use (such as in an exit).",
            "",
            ":parse_keyexp   (string keyexpression, object player)",
            "        => returns an object or list for the new key as defined by the",
            "           keyexpression or a string describing the error if it failed.",
            "",
            ":eval_key       (LIST|OBJ key, testobject)",
            "        => returns true if the given testobject satisfies the key.",
            "",
            ":unparse_key    (LIST|OBJ key)",
            "        => returns a string describing the key in english/moo-code terms.",
            "",
            "For more information on keys and locking, read `help locking', `help keys', and `help @lock'."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "lock utilities"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "This the lock utilities package, used by the MOOwide locking mechanisms. See `help $lock_utils' for more details.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            13652,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "54": {
      "id": 54,
      "name": "generic letter",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        9
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "burn",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 54,
          "code": [
            "who = valid(caller_perms()) ? caller_perms() | player;",
            "if ($perm_utils:controls(who, this) || this:is_readable_by(who))",
            "result = this:do_burn();",
            "else",
            "result = 0;",
            "endif",
            "player:tell(result ? this:burn_succeeded_msg() | this:burn_failed_msg());",
            "if (msg = result ? this:oburn_succeeded_msg() | this:oburn_failed_msg())",
            "player.location:announce(player.name, \" \", msg);",
            "endif"
          ]
        },
        {
          "name": "burn_succeeded_msg oburn_succeeded_msg burn_failed_msg oburn_failed_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 54,
          "code": [
            "return (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | \"\";"
          ]
        },
        {
          "name": "do_burn",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 54,
          "code": [
            "if ((this != $letter) && ((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "fork (0)",
            "$recycler:_recycle(this);",
            "endfork",
            "return 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "oburn_succeeded_msg",
        "oburn_failed_msg",
        "burn_failed_msg",
        "burn_succeeded_msg"
      ],
      "propdefs": [
        {
          "value": "stares at %t; %[tps] bursts into flame and disappears, leaving no ash.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%T might be damp.  In any case, %[tps] won't burn.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%T burns with a smokeless flame and leaves no ash.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is a private letter.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "generic letter"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Some writing on the letter explains that you should 'read letter', and when you've finished, 'burn letter'.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            3699,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "55": {
      "id": 55,
      "name": "list utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "make",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":make(n[,elt]) => a list of n elements, each of which == elt. elt defaults to 0.\";",
            "{n, ?elt = 0} = args;",
            "if (n < 0)",
            "return E_INVARG;",
            "endif",
            "ret = {};",
            "build = {elt};",
            "while (1)",
            "if (n % 2)",
            "ret = {@ret, @build};",
            "endif",
            "if (n = n / 2)",
            "build = {@build, @build};",
            "else",
            "return ret;",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "range",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":range([m,]n) => {m,m+1,...,n}\";",
            "{?m = 1, n} = args;",
            "ret = {};",
            "for k in [m..n]",
            "ret = {@ret, k};",
            "endfor",
            "return ret;"
          ]
        },
        {
          "name": "map_prop*erty",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "set_task_perms(caller_perms());",
            "{objs, prop} = args;",
            "if (length(objs) > 50)",
            "return {@this:map_prop(objs[1..$ / 2], prop), @this:map_prop(objs[($ / 2) + 1..$], prop)};",
            "endif",
            "strs = {};",
            "for foo in (objs)",
            "strs = {@strs, foo.(prop)};",
            "endfor",
            "return strs;"
          ]
        },
        {
          "name": "map_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "set_task_perms(caller_perms());",
            "{objs, vrb, @rest} = args;",
            "if (length(objs) > 50)",
            "return {@this:map_verb(@listset(args, objs[1..$ / 2], 1)), @this:map_verb(@listset(args, objs[($ / 2) + 1..$], 1))};",
            "endif",
            "strs = {};",
            "for o in (objs)",
            "strs = {@strs, o:(vrb)(@rest)};",
            "endfor",
            "return strs;"
          ]
        },
        {
          "name": "map_arg*s",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"map_arg([n,]object,verb,@args) -- assumes the nth element of args is a list, calls object:verb(@args) with each element of the list substituted in turn, returns the list of results.  n defaults to 1.\";",
            "\"map_verb_arg(o,v,{a...},a2,a3,a4,a5)={o:v(a,a2,a3,a4,a5),...}\";",
            "\"map_verb_arg(4,o,v,a1,a2,a3,{a...},a5)={o:v(a1,a2,a3,a,a5),...}\";",
            "set_task_perms(caller_perms());",
            "if (n = args[1])",
            "{object, verb, @rest} = args[2..$];",
            "else",
            "object = n;",
            "n = 1;",
            "{verb, @rest} = args[2..$];",
            "endif",
            "results = {};",
            "for a in (rest[n])",
            "results = listappend(results, object:(verb)(@listset(rest, a, n)));",
            "endfor",
            "return results;"
          ]
        },
        {
          "name": "map_builtin",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":map_builtin(objectlist,func) applies func to each of the objects in turn and returns the corresponding list of results.  This function is mainly here for completeness -- in the vast majority of situations, a simple for loop is better.\";",
            "set_task_perms(caller_perms());",
            "{objs, builtin} = args;",
            "if (!`function_info(builtin) ! E_INVARG => 0')",
            "return E_INVARG;",
            "endif",
            "if (length(objs) > 100)",
            "return {@this:map_builtin(objs[1..$ / 2], builtin), @this:map_builtin(objs[($ / 2) + 1..$], builtin)};",
            "endif",
            "strs = {};",
            "for foo in (objs)",
            "strs = {@strs, call_function(builtin, foo)};",
            "endfor",
            "return strs;"
          ]
        },
        {
          "name": "find_insert",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"find_insert(sortedlist,key) => index of first element in sortedlist > key\";",
            "\"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 1 to length(sortedlist)+1, inclusive.\";",
            "{lst, key} = args;",
            "if ((r = length(lst)) < 25)",
            "for l in [1..r]",
            "if (lst[l] > key)",
            "return l;",
            "endif",
            "endfor",
            "return r + 1;",
            "else",
            "l = 1;",
            "while (r >= l)",
            "if (key < lst[i = (r + l) / 2])",
            "r = i - 1;",
            "else",
            "l = i + 1;",
            "endif",
            "endwhile",
            "return l;",
            "endif"
          ]
        },
        {
          "name": "remove_duplicates",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"remove_duplicates(list) => list as a set, i.e., all repeated elements removed.\";",
            "out = {};",
            "for x in (args[1])",
            "out = setadd(out, x);",
            "endfor",
            "return out;"
          ]
        },
        {
          "name": "arrayset",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"arrayset(list,value,pos1,...,posn) -- returns list modified such that\";",
            "\"  list[pos1][pos2][...][posn] == value\";",
            "if (length(args) > 3)",
            "return listset(@listset(args[1..3], this:arrayset(@listset(listdelete(args, 3), args[1][args[3]], 1)), 2));",
            "\"... Rog's entry in the Obfuscated MOO-Code Contest...\";",
            "else",
            "return listset(@args);",
            "endif"
          ]
        },
        {
          "name": "setremove_all",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":setremove_all(set,elt) => set with *all* occurences of elt removed\";",
            "{set, what} = args;",
            "while (w = what in set)",
            "set[w..w] = {};",
            "endwhile",
            "return set;"
          ]
        },
        {
          "name": "append",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"append({a,b,c},{d,e},{},{f,g,h},...) =>  {a,b,c,d,e,f,g,h}\";",
            "if (length(args) > 50)",
            "return {@this:append(@args[1..$ / 2]), @this:append(@args[($ / 2) + 1..$])};",
            "endif",
            "l = {};",
            "for a in (args)",
            "l = {@l, @a};",
            "endfor",
            "return l;"
          ]
        },
        {
          "name": "reverse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"reverse(list) => reversed list\";",
            "return this:_reverse(@args[1]);"
          ]
        },
        {
          "name": "_reverse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":_reverse(@list) => reversed list\";",
            "if (length(args) > 50)",
            "return {@this:_reverse(@args[($ / 2) + 1..$]), @this:_reverse(@args[1..$ / 2])};",
            "endif",
            "l = {};",
            "for a in (args)",
            "l = listinsert(l, a);",
            "endfor",
            "return l;"
          ]
        },
        {
          "name": "compress",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"compress(list) => list with consecutive repeated elements removed, e.g.,\";",
            "\"compress({a,b,b,c,b,b,b,d,d,e}) => {a,b,c,b,d,e}\";",
            "if (l = args[1])",
            "out = {last = l[1]};",
            "for x in (listdelete(l, 1))",
            "if (x != last)",
            "out = listappend(out, x);",
            "last = x;",
            "endif",
            "endfor",
            "return out;",
            "else",
            "return l;",
            "endif"
          ]
        },
        {
          "name": "sort",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"sort(list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.\";",
            "\"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}\";",
            "set_thread_mode(0);",
            "return sort(@args);"
          ]
        },
        {
          "name": "sort_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":sort_suspended(interval,list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.\";",
            "\"Note: For compatibility with LambdaCore, the interval argument hasn't been removed. In ToastStunt, however, it's not used. Instead, the task will suspend until the sort thread has finished.\";",
            "set_task_perms(caller_perms());",
            "return sort(@args[2..$]);"
          ]
        },
        {
          "name": "slice",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"slice(alist[,index]) returns a list of the index-th elements of the elements of alist, e.g., \";",
            "\"    slice({{\\\"z\\\",1},{\\\"y\\\",2},{\\\"x\\\",5}},2) => {1,2,5}.\";",
            "\"index defaults to 1 and may also be a nonempty list, e.g., \";",
            "\"    slice({{\\\"z\\\",1,3},{\\\"y\\\",2,4}},{2,1}) => {{1,\\\"z\\\"},{2,\\\"y\\\"}}\";",
            "\"For compatibility with LambdaCore, threading is disabled by default.\";",
            "set_thread_mode(0);",
            "return slice(@args);"
          ]
        },
        {
          "name": "assoc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"assoc(target,list[,index]) returns the first element of `list' whose own index-th element is target.  Index defaults to 1.\";",
            "\"returns {} if no such element is found\";",
            "{target, thelist, ?indx = 1} = args;",
            "for t in (thelist)",
            "if ((typeof(t) == LIST) && `t[indx] == target ! E_RANGE => 0')",
            "return t;",
            "endif",
            "endfor",
            "return {};"
          ]
        },
        {
          "name": "iassoc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Moo_tilities (#332):iassoc by Mooshie (#106469) Wed Mar 18 19:27:51 1998 PST\";",
            "\"Usage: iassoc(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.\";",
            "\"Returns 0 if no such element is found.\";",
            "{target, thelist, ?indx = 1} = args;",
            "for element in (thelist)",
            "if (`element[indx] == target ! E_RANGE, E_TYPE => 0')",
            "if (typeof(element) == LIST)",
            "return element in thelist;",
            "endif",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "iassoc_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Moo_tilities (#332):iassoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:53 1998 PST\";",
            "\"Usage: iassoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ]]) => Returns the index of the first element of `list' whose own index-th element is target. Index defaults to 1.\";",
            "\"Returns 0 if no such element is found.\";",
            "\"Suspends as needed. Suspend length defaults to 0.\";",
            "set_task_perms(caller_perms());",
            "{target, thelist, ?indx = 1, ?suspend_for = 0} = args;",
            "cu = $command_utils;",
            "for element in (thelist)",
            "if (`element[indx] == target ! E_RANGE, E_TYPE => 0' && (typeof(element) == LIST))",
            "return element in thelist;",
            "endif",
            "cu:suspend_if_needed(suspend_for);",
            "endfor",
            "return 0;",
            "\"Mooshie (#106469) - Tue Feb 10, PST - :assoc_suspended does a set_task_perms, why shouldn't this?\";"
          ]
        },
        {
          "name": "assoc_prefix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"assoc_prefix(target,list[,index]) returns the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.\";",
            "{target, thelist, ?indx = 1} = args;",
            "for t in (thelist)",
            "if ((typeof(t) == LIST) && ((length(t) >= indx) && (index(t[indx], target) == 1)))",
            "return t;",
            "endif",
            "endfor",
            "return {};"
          ]
        },
        {
          "name": "iassoc_prefix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"iassoc_prefix(target,list[,index]) returns the index of the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.\";",
            "{target, lst, ?indx = 1} = args;",
            "for i in [1..length(lst)]",
            "if ((typeof(lsti = lst[i]) == LIST) && ((length(lsti) >= indx) && (index(lsti[indx], target) == 1)))",
            "return i;",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "iassoc_sorted",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"iassoc_sorted(target,sortedlist[,i]) => index of last element in sortedlist whose own i-th element is <= target.  i defaults to 1.\";",
            "\"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 0 to length(sortedlist), inclusive.\";",
            "{target, lst, ?indx = 1} = args;",
            "if ((r = length(lst)) < 25)",
            "for l in [1..r]",
            "if (target < lst[l][indx])",
            "return l - 1;",
            "endif",
            "endfor",
            "return r;",
            "else",
            "l = 0;",
            "r = r + 1;",
            "while ((r - 1) > l)",
            "if (target < lst[i = (r + l) / 2][indx])",
            "r = i;",
            "else",
            "l = i;",
            "endif",
            "endwhile",
            "return l;",
            "endif"
          ]
        },
        {
          "name": "sort_alist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":sort_alist(alist[,n]) sorts a list of tuples by n-th (1st) element.\";",
            "{alist, ?sort_on = 1} = args;",
            "if ((alist_length = length(alist)) < 25)",
            "\"use insertion sort on short lists\";",
            "return this:sort(alist, this:slice(@args));",
            "endif",
            "left_index = alist_length / 2;",
            "right_index = (alist_length + 1) / 2;",
            "left_sublist = this:sort_alist(alist[1..left_index], sort_on);",
            "right_sublist = this:sort_alist(alist[left_index + 1..alist_length], sort_on);",
            "\"...\";",
            "\"... merge ...\";",
            "\"...\";",
            "left_key = left_sublist[left_index][sort_on];",
            "right_key = right_sublist[right_index][sort_on];",
            "if (left_key > right_key)",
            "merged_list = {};",
            "else",
            "\"... alist_length >= 25 implies right_index >= 2...\";",
            "\"... move right_index downward until left_key > right_key...\";",
            "r = right_index - 1;",
            "while (left_key <= (right_key = right_sublist[r][sort_on]))",
            "if (r = r - 1)",
            "else",
            "return {@left_sublist, @right_sublist};",
            "endif",
            "endwhile",
            "merged_list = right_sublist[r + 1..right_index];",
            "right_index = r;",
            "endif",
            "while (l = left_index - 1)",
            "\"... left_key > right_key ...\";",
            "\"... move left_index downward until left_key <= right_key...\";",
            "while ((left_key = left_sublist[l][sort_on]) > right_key)",
            "if (l = l - 1)",
            "else",
            "return {@right_sublist[1..right_index], @left_sublist[1..left_index], @merged_list};",
            "endif",
            "endwhile",
            "merged_list[1..0] = left_sublist[l + 1..left_index];",
            "left_index = l;",
            "\"... left_key <= right_key ...\";",
            "if (r = right_index - 1)",
            "\"... move right_index downward until left_key > right_key...\";",
            "while (left_key <= (right_key = right_sublist[r][sort_on]))",
            "if (r = r - 1)",
            "else",
            "return {@left_sublist[1..left_index], @right_sublist[1..right_index], @merged_list};",
            "endif",
            "endwhile",
            "merged_list[1..0] = right_sublist[r + 1..right_index];",
            "right_index = r;",
            "else",
            "return {@left_sublist[1..left_index], right_sublist[1], @merged_list};",
            "endif",
            "endwhile",
            "return {@right_sublist[1..right_index], left_sublist[1], @merged_list};"
          ]
        },
        {
          "name": "sort_alist_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"sort_alist_suspended(interval,alist[,n]) sorts a list of tuples by n-th element.  n defaults to 1.  Calls suspend(interval) as necessary.\";",
            "set_task_perms(caller_perms());",
            "\"... so it can be killed...\";",
            "{interval, alist, ?sort_on = 1} = args;",
            "if ((alist_length = length(alist)) < 10)",
            "\"insertion sort on short lists\";",
            "$command_utils:suspend_if_needed(interval);",
            "return this:sort(alist, this:slice(@listdelete(args, 1)));",
            "endif",
            "\"variables specially expanded for the anal-retentive\";",
            "left_index = alist_length / 2;",
            "right_index = (alist_length + 1) / 2;",
            "left_sublist = this:sort_alist_suspended(interval, alist[1..left_index], sort_on);",
            "right_sublist = this:sort_alist_suspended(interval, alist[left_index + 1..alist_length], sort_on);",
            "left_element = left_sublist[left_index];",
            "right_element = right_sublist[right_index];",
            "merged_list = {};",
            "while (1)",
            "$command_utils:suspend_if_needed(interval);",
            "if (left_element[sort_on] > right_element[sort_on])",
            "merged_list = {left_element, @merged_list};",
            "if (left_index = left_index - 1)",
            "left_element = left_sublist[left_index];",
            "else",
            "return {@right_sublist[1..right_index], @merged_list};",
            "endif",
            "else",
            "merged_list = {right_element, @merged_list};",
            "if (right_index = right_index - 1)",
            "right_element = right_sublist[right_index];",
            "else",
            "return {@left_sublist[1..left_index], @merged_list};",
            "endif",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "randomly_permute",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":randomly_permute(list) => list with its elements randomly permuted\";",
            "\"  each of the length(list)! possible permutations is equally likely\";",
            "plist = {};",
            "for i in [1..length(ulist = args[1])]",
            "plist = listinsert(plist, ulist[i], random(i));",
            "endfor",
            "return plist;"
          ]
        },
        {
          "name": "count",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"$list_utils:count(item, list)\";",
            "\"Returns the number of occurrences of item in list.\";",
            "{x, xlist} = args;",
            "if (typeof(xlist) != LIST)",
            "return E_INVARG;",
            "endif",
            "counter = 0;",
            "while (loc = x in xlist)",
            "counter = counter + 1;",
            "xlist = xlist[loc + 1..$];",
            "endwhile",
            "return counter;"
          ]
        },
        {
          "name": "flatten",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST\";",
            "\":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'\";",
            "newlist = {};",
            "for elm in (args[1])",
            "if (typeof(elm) == LIST)",
            "newlist = {@newlist, @this:flatten(elm)};",
            "else",
            "newlist = {@newlist, elm};",
            "endif",
            "endfor",
            "return newlist;"
          ]
        },
        {
          "name": "longest shortest",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from APHiD (#33119):longest Sun May  9 21:00:18 1993 PDT\";",
            "\"$list_utils:longest(<list>)\";",
            "\"$list_utils:shortest(<list>)\";",
            "\"             - Returns the shortest or longest element in the list.  Elements may be either strings or lists.  Returns E_TYPE if passed a non-list or a list containing non-string/list elements.  Returns E_RANGE if passed an empty list.\";",
            "if (typeof(all = args[1]) != LIST)",
            "return E_TYPE;",
            "elseif (all == {})",
            "return E_RANGE;",
            "else",
            "result = all[1];",
            "for things in (all)",
            "if ((typeof(things) != LIST) && (typeof(things) != STR))",
            "return E_TYPE;",
            "else",
            "result = (((verb == \"longest\") && (length(result) < length(things))) || ((verb == \"shortest\") && (length(result) > length(things)))) ? things | result;",
            "endif",
            "endfor",
            "endif",
            "return result;"
          ]
        },
        {
          "name": "reverse_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"reverse(list) => reversed list.  Does suspend(0) as necessary.\";",
            "set_task_perms(caller_perms());",
            "\"^^^For suspend task.\";",
            "return this:_reverse_suspended(@args[1]);"
          ]
        },
        {
          "name": "_reverse_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":_reverse(@list) => reversed list\";",
            "set_task_perms(caller_perms());",
            "$command_utils:suspend_if_needed(0);",
            "if (length(args) > 50)",
            "return {@this:_reverse_suspended(@args[($ / 2) + 1..$]), @this:_reverse_suspended(@args[1..$ / 2])};",
            "endif",
            "l = {};",
            "for a in (args)",
            "l = listinsert(l, a);",
            "endfor",
            "return l;"
          ]
        },
        {
          "name": "randomly_permute_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":randomly_permute_suspended(list) => list with its elements randomly permuted\";",
            "\"  each of the length(list)! possible permutations is equally likely\";",
            "set_task_perms(caller_perms());",
            "plist = {};",
            "for i in [1..length(ulist = args[1])]",
            "plist = listinsert(plist, ulist[i], random(i));",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return plist;"
          ]
        },
        {
          "name": "swap_elements",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"swap_elements -- exchange two elements in a list\";",
            "\"Usage:  $list_utils:swap_elements(<list/LIST>,<index/INT>,<index/INT>)\";",
            "\"        $list_utils:swap_elements({\\\"a\\\",\\\"b\\\"},1,2);\";",
            "{l, i, j} = args;",
            "if (((typeof(l) == LIST) && (typeof(i) == INT)) && (typeof(j) == INT))",
            "ll = length(l);",
            "if (((i > 0) && (i <= ll)) && ((j > 0) && (j <= ll)))",
            "t = l[i];",
            "l[i] = l[j];",
            "l[j] = t;",
            "return l;",
            "else",
            "return E_RANGE;",
            "endif",
            "else",
            "return E_TYPE;",
            "endif"
          ]
        },
        {
          "name": "random_item random_element",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"random_item -- returns a random element of the input list.\";",
            "if (length(args) == 1)",
            "if (typeof(l = args[1]) == LIST)",
            "if (length(l) > 0)",
            "return l[random($)];",
            "else",
            "return E_RANGE;",
            "endif",
            "else",
            "return E_TYPE;",
            "endif",
            "else",
            "return E_ARGS;",
            "endif"
          ]
        },
        {
          "name": "assoc_suspended",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Moo_tilities (#332):assoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:54 1998 PST\";",
            "\"Usage: assoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ])) => Returns the first element of `list' whose own index-th element is target.  Index defaults to 1.\";",
            "\"Returns {} if no such element is found.\";",
            "\"Suspends as necessary. Suspend length defaults to 0.\";",
            "set_task_perms(caller_perms());",
            "{target, thelist, ?indx = 1, ?suspend_for = 0} = args;",
            "cu = $command_utils;",
            "for t in (thelist)",
            "if (`t[indx] == target ! E_TYPE => 0')",
            "if ((typeof(t) == LIST) && (length(t) >= indx))",
            "return t;",
            "endif",
            "endif",
            "cu:suspend_if_needed(suspend_for);",
            "endfor",
            "return {};"
          ]
        },
        {
          "name": "amerge",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Uther's_Ghost (#93141):amerge Tue May 27 20:28:18 1997 PDT\";",
            "\"amerge(list[,tindex[,dindex]]) returns an associated list such that all the tuples in the original list with the same tindex-th element are merged. Useful for merging alists ( amerge({@alist1, @alist2, ...}) ) and for ensuring that each tuple has a unique index. Tindex defaults to 1. Dindex defaults to 1 and refers to the position in the tuple where the tindex-th element will land in the new tuple.\";",
            "{alist, ?tidx = 1, ?didx = 1} = args;",
            "if (alist)",
            "alist = this:sort_alist(alist, tidx);",
            "i = 1;",
            "res = {{cur = alist[1][tidx]}};",
            "for tuple in (alist)",
            "if (tuple[tidx] == cur)",
            "res[i] = {@res[i], @listdelete(tuple, tidx)};",
            "else",
            "if (didx != 1)",
            "res[i] = this:swap_elements(res[i], 1, min(didx, length(res[i])));",
            "endif",
            "i = i + 1;",
            "res = {@res, {cur = tuple[tidx], @listdelete(tuple, tidx)}};",
            "endif",
            "endfor",
            "return res;",
            "endif",
            "return alist;"
          ]
        },
        {
          "name": "passoc",
          "owner": 36,
          "perms": 165,
          "preps": -1,
          "object": 55,
          "code": [
            "\"passoc(key,list1,list2)\";",
            "\"passoc() behaves rather similarly to assoc, with the exception that it's intended for\";",
            "\"parallel lists.  given a key from list1, it returns a list containing the key and the\";",
            "\"corresponding item from list2 (\\\"corresponding\\\", in the case of parallel lists, means\";",
            "\"having the same index.)\";",
            "indx = args[1] in args[2];",
            "if (indx)",
            "return {args[1], args[3][indx]};",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "setmove",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Moo_tilities (#332):setmove by Mooshie (#106469) Mon Sep 22 21:07:25 1997 PDT\";",
            "\"Usage: setmove(LIST elements, INT from, INT to)\";",
            "\"Moves element in list from one position in list to another.\";",
            "\"\";",
            "\"Example: setmove({x, y, z}, 1, 3) => {y, z, x}\";",
            "\"         setmove({x, y, z}, 2, 1} => {y, x, z}\";",
            "{start, from, to} = args;",
            "what = start[from];",
            "return listinsert(listdelete(start, from), what, to);",
            "\"  Written by Mooshie (#106469) @ Lambda - Mon Sep 22 21:03:26 1997 PDT -  \";"
          ]
        },
        {
          "name": "iassoc_new",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from Moo_tilities (#332):iassoc_new by Mooshie (#106469) Wed Mar 18 19:27:52 1998 PST\";",
            "\"Usage: iassoc_new(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.\";",
            "\"Returns 0 if no such element is found.\";",
            "\"NOTE: expects that each index in the given list will be a list with at least as many elements as the indicated `index' argument. Otherwise will return E_RANGE\";",
            "{target, thelist, ?indx = 1} = args;",
            "try",
            "for element in (thelist)",
            "if (element[indx] == target)",
            "if (typeof(element) == LIST)",
            "return element in thelist;",
            "endif",
            "endif",
            "endfor",
            "except e (ANY)",
            "return e[1];",
            "endtry",
            "return 0;"
          ]
        },
        {
          "name": "build_alist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Syntax:  build_alist(list, N) =>\";",
            "\"{list[1..N], list[N+1..N*2], list[N*2+1..N*3], ..., list[N*(N-1)+1..N*N]}\";",
            "\"\";",
            "\"Creates an associated list from a flat list at every Nth interval. If the list doesn't have a multiple of N elements, E_RANGE is returned.\";",
            "\"Example:  build_alist({a,b,c,d,e,f,g,h,i},3)=>{{a,b,c},{d,e,f},{g,h,i}}\";",
            "{olist, interval} = args;",
            "if ((tot = length(olist)) % interval)",
            "return E_RANGE;",
            "endif",
            "nlist = {};",
            "d = 1;",
            "while (d <= tot)",
            "nlist = {@nlist, olist[1..interval]};",
            "olist[1..interval] = {};",
            "d = d + interval;",
            "endwhile",
            "return nlist;"
          ]
        },
        {
          "name": "flatten_suspended",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\"Copied from list utilities (#372):flatten [verb author Hacker (#18105)] at Sun Jul  3 07:46:47 2011 PDT\";",
            "\"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST\";",
            "\":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'\";",
            "newlist = {};",
            "for elm in (args[1])",
            "if (typeof(elm) == LIST)",
            "$command_utils:suspend_if_needed(0);",
            "newlist = {@newlist, @this:flatten_suspended(elm)};",
            "else",
            "$command_utils:suspend_if_needed(0);",
            "newlist = {@newlist, elm};",
            "endif",
            "endfor",
            "return newlist;"
          ]
        },
        {
          "name": "max_length",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 55,
          "code": [
            "\":max_length(strings-or-lists[, default])\";",
            "\"Return the maximum length of a set of strings or lists.\";",
            "\"default is the minimum length that can be returned; 0 is a safe bet.\";",
            "max = args[2] || 0;",
            "for item in (args[1])",
            "max = max(max, length(item));",
            "endfor",
            "return max;"
          ]
        },
        {
          "name": "make_alist",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 55,
          "code": [
            "\":make_alist(lists[, pad])\";",
            "\"Make an alist out of n parallel lists (basically a matrix transpose).\";",
            "\"If the lists are of uneven length, fill the remaining tuples with pad (defaults to 0).\";",
            "alist = {};",
            "pad = (length(args) > 1) ? args[2] | 0;",
            "for i in [1..$list_utils:max_length(args[1])]",
            "tuple = {};",
            "for l in (args[1])",
            "tuple = {@tuple, (i > length(l)) ? pad | l[i]};",
            "endfor",
            "alist = {@alist, tuple};",
            "endfor",
            "return alist;"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "append            (list,list,..) => result of concatenating the given lists",
            "reverse           (list)         => reversed list",
            "remove_duplicates (list)         => list with all duplicates removed",
            "compress          (list)         => list with consecutive duplicates removed",
            "setremove_all     (list,elt)     => list with all occurrences of elt removed",
            "find_insert       (sortedlist,e) => index of first element > e in sortedlist",
            "sort              (list[,keys])  => sorted list",
            "count             (elt,list)     => count of elt found in list.",
            "flatten           (list)         => flatten all recursive lists into one list",
            "randomly_permute  (list)         => list with elements randomly permuted",
            "longest           (list)         => longest in list (consisting of str or list)",
            "shortest          (list)         => shortest in list (as above)",
            "",
            "make              (n[,e])        => list of n copies of e",
            "range             (m,n)          => {m,m+1,...,n}",
            "",
            "arrayset   (list,val,i[,j,k...]) => array modified so that list[i][j][k]==val",
            "",
            "-- Mapping functions (take a list and do something to each element):",
            "",
            "map_prop ({o...},prop)              => list of o.(prop)            for all o",
            "map_verb ({o...},verb[,args])        => list of o:(verb)(@args)     for all o",
            "map_arg  ([n,]obj,verb,{a...},args) => list of obj:(verb)(a,@args) for all a",
            "map_builtin (objectlist, function)  => applies function to all in objectlist",
            "",
            "-- Association list functions --",
            "",
            "An association list (alist) is a list of pairs (2-element lists), though the following functions have been generalized for lists of n-tuples (n-element lists).  In each case i defaults to 1.",
            "",
            "assoc        (targ,alist[,i]) => 1st tuple in alist whose i-th element is targ",
            "iassoc       (targ,alist[,i]) => index of same.",
            "assoc_prefix (targ,alist[,i]) => ... whose i-th element has targ as a prefix",
            "iassoc_prefix(targ,alist[,i]) => index of same.",
            "iassoc_sorted(targ,slist[,i]) => index of last element in sortedlist <= targ",
            "slice             (alist[,i]) => list of i-th elements",
            "sort_alist        (alist[,i]) => alist sorted on i-th elements.",
            "amerge  (alist,[tind,[dind]]) => merges tuples of alist with matching i-th elt",
            "build_alist          (list,N) => make an alist of N-intervals from list",
            "",
            "-- Functions that suspend --",
            "",
            "Each of these either suspends(0) as needed or takes an interval in seconds for the suspend as a first argument. See help $list_utils:<verb>.",
            "",
            "sort_suspended          iassoc_suspended          sort_alist_suspended",
            "reverse_suspended       randomly_permute_suspended"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "list_utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the list utilities utility package.  See `help $list_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            42043,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "56": {
      "id": 56,
      "name": "command utilities",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "object_match_failed",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"Usage: object_match_failed(object, string, allow invalid)\";",
            "\"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).\";",
            "\"If allow invalid is true, invalid objects > #0 are not considered a failure.\";",
            "{match_result, string, ?allow_invalid = 0} = args;",
            "tell = $perm_utils:controls(caller_perms(), player) ? \"notify\" | \"tell\";",
            "if ((index(string, \"#\") == 1) && ($code_utils:toobj(string) != E_TYPE))",
            "\"...avoid the `I don't know which `#-2' you mean' message...\";",
            "if ((allow_invalid && (match_result > #0)) && (!valid(match_result)))",
            "return 0;",
            "elseif (!valid(match_result))",
            "player:(tell)(tostr(string, \" does not exist.\"));",
            "endif",
            "return !valid(match_result);",
            "elseif (match_result == $nothing)",
            "player:(tell)(\"You must give the name of some object.\");",
            "elseif (match_result == $failed_match)",
            "player:(tell)(tostr(\"I see no \\\"\", string, \"\\\" here.\"));",
            "elseif (match_result == $ambiguous_match)",
            "player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.\"));",
            "elseif ((!allow_invalid) && (!valid(match_result)))",
            "player:(tell)(tostr(match_result, \" does not exist.\"));",
            "else",
            "return 0;",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "player_match_result player_match_failed",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\":player_match_failed(result,string)\";",
            "\"  is exactly like :object_match_failed(result,string)\";",
            "\"  except that its messages are more suitable for player searches.\";",
            "\":player_match_result(results,strings)\";",
            "\"  handles a list of results, also presumably from $string_utils:match_player(strings), printing messages to player for *each* of the nonmatching strings.  It returns a list, an overall result (true if some string didn't match --- just like player_match_failed), followed by the list players that matched.\";",
            "\"\";",
            "\"An optional 3rd arg gives an identifying string to prefix to each of the nasty messages.\";",
            "if (valid(player))",
            "tell = $perm_utils:controls(caller_perms(), player) ? \"notify\" | \"tell\";",
            "plyr = player;",
            "else",
            "tell = \"notify\";",
            "plyr = $login;",
            "endif",
            "\"...\";",
            "{match_results, strings, ?cmdid = \"\"} = args;",
            "pmf = verb == \"player_match_failed\";",
            "if (typeof(match_results) == OBJ)",
            "match_results = {match_results};",
            "strings = {strings};",
            "endif",
            "pset = {};",
            "bombed = 0;",
            "for i in [1..length(match_results)]",
            "if (valid(result = match_results[i]))",
            "pset = setadd(pset, match_results[i]);",
            "elseif (result == $nothing)",
            "\"... player_match_result quietly skips over blank strings\";",
            "if (pmf)",
            "plyr:(tell)(\"You must give the name of some player.\");",
            "bombed = 1;",
            "endif",
            "elseif (result == $failed_match)",
            "plyr:(tell)(tostr(cmdid, \"\\\"\", strings[i], \"\\\" is not the name of any player.\"));",
            "bombed = 1;",
            "elseif (result == $ambiguous_match)",
            "lst = $player_db:find_all(strings[i]);",
            "plyr:(tell)(tostr(cmdid, \"\\\"\", strings[i], \"\\\" could refer to \", (length(lst) > 20) ? tostr(\"any of \", length(lst), \" players\") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", lst), \"no one\", \" or \"), \".\"));",
            "bombed = 1;",
            "else",
            "plyr:(tell)(tostr(result, \" does not exist.\"));",
            "bombed = 1;",
            "endif",
            "endfor",
            "if ((!bombed) && (!pset))",
            "\"If there were NO valid results, but not any actual 'error', fail anyway.\";",
            "plyr:(tell)(\"You must give the name of some player.\");",
            "bombed = 1;",
            "endif",
            "return pmf ? bombed | {bombed, @pset};"
          ]
        },
        {
          "name": "read",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"$command_utils:read() -- read a line of input from the player and return it\";",
            "\"Optional argument is a prompt portion to replace `a line of input' in the prompt.\";",
            "\"\";",
            "\"Returns E_PERM if the current task is not the most recent task spawned by a command from player.\";",
            "{?prompt = \"a line of input\"} = args;",
            "c = callers();",
            "p = c[$][5];",
            "p:notify(tostr(\"[Type \", prompt, \" or `@abort' to abort the command.]\"));",
            "try",
            "ans = read();",
            "if ($string_utils:trim(ans) == \"@abort\")",
            "p:notify(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "endif",
            "return ans;",
            "except error (ANY)",
            "return error[1];",
            "endtry"
          ]
        },
        {
          "name": "read_lines",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"$command_utils:read_lines([max]) -- read zero or more lines of input\";",
            "\"\";",
            "\"Returns a list of strings, the (up to MAX, if given) lines typed by the player.  Returns E_PERM if the current task is not a command task that has never called suspend().\";",
            "\"In order that one may enter arbitrary lines, including \\\"@abort\\\" or \\\".\\\", if the first character in an input line is `.' and there is some nonwhitespace afterwords, the `.' is dropped and the rest of the line is taken verbatim, so that, e.g., \\\".@abort\\\" enters as \\\"@abort\\\" and \\\"..\\\" enters as \\\".\\\".\";",
            "\"--- Inline editor ---\";",
            "return $edit_utils:editor();",
            "\"--- Inline editor ---\";",
            "\"(Remove the above line if you wish for normal read_lines prompts.)\";",
            "{?max = 0} = args;",
            "c = callers();",
            "p = c[$][5];",
            "p:notify(tostr(\"[Type\", max ? tostr(\" up to \", max) | \"\", \" lines of input; use `.' to end or `@abort' to abort the command.]\"));",
            "ans = {};",
            "while (1)",
            "try",
            "line = read();",
            "if ((line[1..min(6, $)] == \"@abort\") && ((tail = line[7..$]) == $string_utils:space(tail)))",
            "p:notify(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "elseif ((!line) || (line[1] != \".\"))",
            "ans = {@ans, line};",
            "elseif ((tail = line[2..$]) == $string_utils:space(tail))",
            "return ans;",
            "else",
            "ans = {@ans, tail};",
            "endif",
            "if (max && (length(ans) >= max))",
            "return ans;",
            "endif",
            "except error (ANY)",
            "return error[1];",
            "endtry",
            "endwhile"
          ]
        },
        {
          "name": "yes_or_no",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\":yes-or-no([prompt]) -- prompts the player for a yes or no answer and returns a true value iff the player enters a line of input that is some prefix of \\\"yes\\\"\";",
            "\"\";",
            "\"Returns E_NONE if the player enters a blank line, E_INVARG, if the player enters something that isn't a prefix of \\\"yes\\\" or \\\"no\\\", and E_PERM if the current task is not a command task that has never called suspend().\";",
            "c = callers();",
            "p = c[$][5];",
            "p:notify(tostr(args ? args[1] + \" \" | \"\", \"[Enter `yes' or `no']\"));",
            "try",
            "ans = read(@((caller == p) || $perm_utils:controls(caller_perms(), p)) ? {p} | {});",
            "if (ans = $string_utils:trim(ans))",
            "if (ans == \"@abort\")",
            "p:notify(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "endif",
            "return (index(\"yes\", ans) == 1) || ((index(\"no\", ans) != 1) && E_INVARG);",
            "else",
            "return E_NONE;",
            "endif",
            "except error (ANY)",
            "return error[1];",
            "endtry"
          ]
        },
        {
          "name": "read_lines_escape",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"$command_utils:read_lines_escape(escapes[,help]) -- read zero or more lines of input\";",
            "\"\";",
            "\"Similar to :read_lines() except that help is available and one may specify other escape sequences to terminate the read.\";",
            "\"  escapes should be either a string or list of strings; this specifies which inputs other from `.' or `@abort' should terminate the read (... don't use anything beginning with a `.').\";",
            "\"  help should be a string or list of strings to be printed in response to the player typing `?'; the first line of the help text should be a general comment about what the input text should be used for.  Successive lines should describe the effects of the alternative escapes.\";",
            "\"Returns {end,list-of-strings-input} where end is the particular line that terminated this input or 0 if input terminated normally with `.'.  Returns E_PERM if the current task is not a command task that has never called suspend().  \";",
            "\"@abort and lines beginning with `.' are treated exactly as with :read_lines()\";",
            "{escapes, ?help = \"You are currently in a read loop.\"} = args;",
            "c = callers();",
            "p = c[$][5];",
            "escapes = {\".\", \"@abort\", @(typeof(escapes) == LIST) ? escapes | {escapes}};",
            "p:notify(tostr(\"[Type lines of input; `?' for help; end with `\", $string_utils:english_list(escapes, \"\", \"' or `\", \"', `\", \"\"), \"'.]\"));",
            "ans = {};",
            "escapes[1..0] = {\"?\"};",
            "\"... set up the help text...\";",
            "if (typeof(help) != LIST)",
            "help = {help};",
            "endif",
            "help[2..1] = {\"Type `.' on a line by itself to finish.\", \"Anything else with a leading period is entered with the period removed.\", \"Type `@abort' to abort the command completely.\"};",
            "while (1)",
            "try",
            "line = read();",
            "if ((trimline = $string_utils:trimr(line)) in escapes)",
            "if (trimline == \".\")",
            "return {0, ans};",
            "elseif (trimline == \"@abort\")",
            "p:notify(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "elseif (trimline == \"?\")",
            "p:notify_lines(help);",
            "else",
            "return {trimline, ans};",
            "endif",
            "else",
            "if (line && (line[1] == \".\"))",
            "line[1..1] = \"\";",
            "endif",
            "ans = {@ans, line};",
            "endif",
            "except error (ANY)",
            "return error[1];",
            "endtry",
            "endwhile"
          ]
        },
        {
          "name": "suspend",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"Suspend, using output_delimiters() in case a client needs to keep track\";",
            "\"of the output of the current command.\";",
            "\"Args are TIME, amount of time to suspend, and optional (misnamed) OUTPUT.\";",
            "\"If given no OUTPUT, just do a suspend.\";",
            "\"If OUTPUT is neither list nor string, suspend and return output_delimiters\";",
            "\"If OUTPUT is a list, it should be in the output_delimiters() format:\";",
            "\"  {PREFIX, SUFFIX}.  Use these to handle that client stuff.\";",
            "\"If OUTPUT is a string, it should be SUFFIX (output_delimiters[2])\";",
            "\"\";",
            "\"Proper usage:\";",
            "\"The first time you want to suspend, use\";",
            "\"  output_delimiters = $command_utils:suspend(time, x);\";",
            "\"where x is some non-zero number.\";",
            "\"Following, use\";",
            "\"  $command_utils:suspend(time, output_delimiters);\";",
            "\"To wrap things up, use\";",
            "\"  $command_utils:suspend(time, output_delimiters[2]);\";",
            "\"You'll probably want time == 0 most of the time.\";",
            "\"Note: Using this from verbs called by other verbs could get pretty weird.\";",
            "{time, ?output = 0} = args;",
            "set_task_perms(caller_perms());",
            "value = 0;",
            "if (!output)",
            "suspend(time);",
            "else",
            "if (typeof(output) == LIST)",
            "PREFIX = output[1];",
            "SUFFIX = output[2];",
            "if (PREFIX)",
            "player:tell(output[2]);",
            "endif",
            "suspend(time);",
            "if (SUFFIX)",
            "player:tell(output[1]);",
            "endif",
            "elseif (typeof(output) == STR)",
            "if (output)",
            "player:tell(output);",
            "endif",
            "else",
            "output = output_delimiters(player);",
            "suspend(time);",
            "if (output != {\"\", \"\"})",
            "player:tell(output[1]);",
            "endif",
            "value = output;",
            "endif",
            "endif",
            "return output;"
          ]
        },
        {
          "name": "running_out_of_time",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"Return true if we're running out of ticks or seconds.\";",
            "return (ticks_left() < 4000) || (seconds_left() < 2);",
            "\"If this verb is changed make sure to change :suspend_if_needed as well.\";"
          ]
        },
        {
          "name": "suspend_if_needed",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"Usage:  $command_utils:suspend_if_needed(<time>[, @<announcement>])\";",
            "\"See if we're running out of ticks or seconds, and if so suspend(<time>) and return true.  If more than one arg is given, print the remainder with player:tell.\";",
            "if ((ticks_left() < 4000) || (seconds_left() < 2))",
            "\"Note: above computation should be the same as :running_out_of_time.\";",
            "{?time = 10, @ann} = args;",
            "if (ann && valid(player))",
            "player:tell(tostr(@ann));",
            "endif",
            "amount = max(time, min($login:current_lag(), 10));",
            "set_task_perms(caller_perms());",
            "\"this is trying to back off according to lag...\";",
            "suspend(amount);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "dump_lines",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\":dump_lines(text) => text `.'-quoted for :read_lines()\";",
            "\"  text is assumed to be a list of strings\";",
            "\"Returns a corresponding list of strings which, when read via :read_lines, \";",
            "\"produces the original list of strings (essentially, any strings beginning \";",
            "\"with a period \\\".\\\" have the period doubled).\";",
            "\"The list returned includes a final \\\".\\\"\";",
            "text = args[1];",
            "newtext = {};",
            "i = lasti = 0;",
            "for line in (text)",
            "if (match(line, \"^%(%.%| *@abort *$%)\"))",
            "newtext = {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, \".\" + line};",
            "lasti = i = i + 1;",
            "else",
            "i = i + 1;",
            "endif",
            "endfor",
            "return {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, \".\"};"
          ]
        },
        {
          "name": "explain_syntax",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\":explain_syntax(here,verb,args)\";",
            "verb = args[2];",
            "for x in ({player, args[1], @valid(dobj) ? {dobj} | {}, @valid(iobj) ? {iobj} | {}})",
            "what = x;",
            "while (hv = $object_utils:has_verb(what, verb))",
            "what = hv[1];",
            "i = 1;",
            "while (i = $code_utils:find_verb_named(what, verb, i))",
            "if (evs = $code_utils:explain_verb_syntax(x, verb, @verb_args(what, i)))",
            "player:tell(\"Try this instead:  \", evs);",
            "return 1;",
            "endif",
            "i = i + 1;",
            "endwhile",
            "what = parent(what);",
            "endwhile",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "do_huh",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 56,
          "code": [
            "\":do_huh(verb,args)  what :huh should do by default.\";",
            "{verb, args} = args;",
            "if ($perm_utils:controls(caller_perms(), player) || (caller_perms() == player))",
            "this.feature_task = {task_id(), verb, args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr};",
            "endif",
            "set_task_perms(cp = caller_perms());",
            "notify = $perm_utils:controls(cp, player) ? \"notify\" | \"tell\";",
            "if (verb == \"\")",
            "\"should only happen if a player types backslash\";",
            "player:(notify)(\"I don't understand that.\");",
            "return;",
            "endif",
            "if (player:my_huh(verb, args))",
            "\"... the player found something funky to do ...\";",
            "elseif (caller:here_huh(verb, args))",
            "\"... the room found something funky to do ...\";",
            "elseif (player:last_huh(verb, args))",
            "\"... player's second round found something to do ...\";",
            "elseif (dobj == $ambiguous_match)",
            "if (iobj == $ambiguous_match)",
            "player:(notify)(tostr(\"I don't understand that (\\\"\", dobjstr, \"\\\" and \\\"\", iobjstr, \"\\\" are both ambiguous names).\"));",
            "else",
            "player:(notify)(tostr(\"I don't understand that (\\\"\", dobjstr, \"\\\" is an ambiguous name).\"));",
            "endif",
            "elseif (iobj == $ambiguous_match)",
            "player:(notify)(tostr(\"I don't understand that (\\\"\", iobjstr, \"\\\" is an ambiguous name).\"));",
            "else",
            "player:(notify)(\"I don't understand that.\");",
            "player:my_explain_syntax(caller, verb, args) || (caller:here_explain_syntax(caller, verb, args) || this:explain_syntax(caller, verb, args));",
            "endif"
          ]
        },
        {
          "name": "task_info",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"task_info(task id)\";",
            "\"Return info (the same info supplied by queued_tasks()) about a given task id, or E_INVARG if there's no such task queued.\";",
            "\"WIZARDLY\";",
            "set_task_perms(caller_perms());",
            "tasks = queued_tasks();",
            "task_id = args[1];",
            "for task in (tasks)",
            "if (task[1] == task_id)",
            "return task;",
            "endif",
            "endfor",
            "return E_INVARG;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.lag_samples = {};",
            "this.feature_task = \"hey, neat, no feature verbs have been run yet!\";",
            "endif"
          ]
        },
        {
          "name": "kill_if_laggy",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"Kills this task if the current lag is greater than args[1].  Args[2..n] will be passed to player:tell.\";",
            "cutoff = args[1];",
            "if ($login:current_lag() > cutoff)",
            "player:tell(@listdelete(args, 1));",
            "kill_task(task_id());",
            "endif"
          ]
        },
        {
          "name": "validate_feature",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\":validate_feature(verb, args)\";",
            "\"  (where `verb' and `args' are the arguments passed to :my_huh)\";",
            "\"  returns true or false based on whether this is the same command typed by the user (comparing it against $command_utils.feature_task, set by $command_utils:do_huh).\";",
            "\"  assumes that the :my_huh parsing has not suspended\";",
            "return {task_id(), @args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr} == this.feature_task;"
          ]
        },
        {
          "name": "reading_input",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 56,
          "code": [
            "\"While input is being read() from a player, return 1. Otherwise return 0.\";",
            "{who} = args;",
            "return `who.reading_input ! ANY => 0';"
          ]
        }
      ],
      "propnames": [
        "lag_samples",
        "feature_task"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            813814921,
            "@generics",
            [],
            "",
            -1,
            "",
            "",
            -1,
            ""
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [
            "$command_utils is the repository for verbs that are of general usefulness to authors of all sorts of commands.  For more details about any of these verbs, use `help $command_utils:<verb-name>'.",
            "",
            "Detecting and Handling Failures in Matching",
            "-------------------------------------------",
            ":object_match_failed(match_result, name)",
            "    Test whether or not a :match_object() call failed and print messages if so.",
            ":player_match_failed(match_result, name)",
            "    Test whether or not a :match_player() call failed and print messages if so.",
            ":player_match_result(match_results, names)",
            "    ...similar to :player_match_failed, but does a whole list at once.",
            "",
            "Reading Input from the Player",
            "-----------------------------",
            ":read()         -- Read one line of input from the player and return it.",
            ":yes_or_no([prompt])",
            "                -- Prompt for and read a `yes' or `no' answer.",
            ":read_lines()   -- Read zero or more lines of input from the player.",
            ":dump_lines(lines) ",
            "                -- Return list of lines quoted so that feeding them to ",
            "                   :read_lines() will reproduce the original lines.",
            ":read_lines_escape(escapes[,help])",
            "                -- Like read_lines, except you can provide more escapes",
            "                   to terminate the read.",
            "",
            "Feature Objects",
            "---------------",
            ":validate_feature -- compare command line against feature verb argument spec",
            "",
            "Utilities for Suspending",
            "------------------------",
            ":running_out_of_time()",
            "                -- Return true if we're low on ticks or seconds.",
            ":suspend_if_needed(time)",
            "                -- Suspend (and return true) if we're running out of time.",
            "",
            "Client Support for Lengthy Commands",
            "-----------------------------------",
            ":suspend(args)  -- Handle PREFIX and SUFFIX for clients in long commands."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "This is the command utilities utility package.  See `help $command_utils' for more details."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            26184,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "57": {
      "id": 57,
      "name": "generic wizard",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        58
      ],
      "children": [
        2
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@chown*#",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "if ((!player.wizard) || (player != this))",
            "player:notify(\"Sorry.\");",
            "return;",
            "endif",
            "set_task_perms(player);",
            "args = setremove(args, \"to\");",
            "if ((length(args) != 2) || (!args[2]))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb> <owner>\"));",
            "return;",
            "endif",
            "what = args[1];",
            "owner = $string_utils:match_player(args[2]);",
            "bynumber = verb == \"@chown#\";",
            "if ($command_utils:player_match_result(owner, args[2])[1])",
            "elseif (spec = $code_utils:parse_verbref(what))",
            "object = this:my_match_object(spec[1]);",
            "if (!$command_utils:object_match_failed(object, spec[1]))",
            "vname = spec[2];",
            "if (bynumber)",
            "vname = $code_utils:toint(vname);",
            "if (vname == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || (vname > length(verbs(object))))",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "endif",
            "info = `verb_info(object, vname) ! ANY';",
            "if (info == E_VERBNF)",
            "player:notify(\"That object does not define that verb.\");",
            "elseif (typeof(info) == ERR)",
            "player:notify(tostr(info));",
            "else",
            "try",
            "result = set_verb_info(object, vname, listset(info, owner, 1));",
            "player:notify(\"Verb owner set.\");",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "endif",
            "elseif (bynumber)",
            "player:notify(\"@chown# can only be used with verbs.\");",
            "elseif (index(what, \".\") && (spec = $code_utils:parse_propref(what)))",
            "object = this:my_match_object(spec[1]);",
            "if (!$command_utils:object_match_failed(object, spec[1]))",
            "pname = spec[2];",
            "e = $wiz_utils:set_property_owner(object, pname, owner);",
            "if (e == E_NONE)",
            "player:notify(\"+c Property owner set.  Did you really want to do that?\");",
            "else",
            "player:notify(tostr(e && \"Property owner set.\"));",
            "endif",
            "endif",
            "else",
            "object = this:my_match_object(what);",
            "if (!$command_utils:object_match_failed(object, what))",
            "player:notify(tostr($wiz_utils:set_owner(object, owner) && \"Object ownership changed.\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@shout",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "set_task_perms(player);",
            "if ((length(args) == 1) && (argstr[1] == \"\\\"\"))",
            "argstr = args[1];",
            "endif",
            "shout = $gender_utils:get_conj(\"shouts\", player);",
            "for person in (connected_players())",
            "if (person != player)",
            "person:notify(tostr(player.name, \" \", shout, \", \\\"\", argstr, \"\\\"\"));",
            "endif",
            "endfor",
            "player:notify(tostr(\"You shout, \\\"\", argstr, \"\\\"\"));"
          ]
        },
        {
          "name": "@grant @grants* @transfer",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 57,
          "code": [
            "\"@grant <object> to <player>\";",
            "\"@grants <object> to <player>   --- same as @grant but may suspend.\";",
            "\"@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer, and modifies quota.\";",
            "\"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).\";",
            "if ((!player.wizard) || (player != this))",
            "player:notify(\"Sorry.\");",
            "return;",
            "endif",
            "set_task_perms(player);",
            "if ((!iobjstr) || (!dobjstr))",
            "return player:notify(tostr(\"Usage:  \", verb, \" <object> to <player>\"));",
            "endif",
            "if ($command_utils:player_match_failed(newowner = $string_utils:match_player(iobjstr), iobjstr))",
            "\"...newowner is bogus...\";",
            "return;",
            "endif",
            "if (verb == \"@transfer\")",
            "objlist = player:eval_cmd_string(dobjstr, 0);",
            "if (!objlist[1])",
            "player:notify(tostr(\"Had trouble reading `\", dobjstr, \"': \"));",
            "player:notify_lines(@objlist[2]);",
            "return;",
            "elseif (typeof(objlist[2]) == OBJ)",
            "objlist = objlist[2..2];",
            "elseif (typeof(objlist[2]) != LIST)",
            "player:notify(tostr(\"Value of `\", dobjstr, \"' is not an object or list:  \", toliteral(objlist[2])));",
            "return;",
            "else",
            "objlist = objlist[2];",
            "endif",
            "elseif ($command_utils:object_match_failed(object = this:my_match_object(dobjstr), dobjstr))",
            "\"...object is bogus...\";",
            "return;",
            "else",
            "objlist = {object};",
            "endif",
            "\"Used to check for quota of newowner, but doesn't anymore, cuz the quota check doesn't work\";",
            "suspendok = verb != \"@grant\";",
            "player:tell(\"Transferring \", toliteral(objlist), \" to \", $string_utils:nn(newowner));",
            "for object in (objlist)",
            "$command_utils:suspend_if_needed(0);",
            "same = object.owner == newowner;",
            "for vnum in [1..length(verbs(object))]",
            "info = verb_info(object, vnum);",
            "if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))",
            "same = same && (info[1] == newowner);",
            "set_verb_info(object, vnum, listset(info, newowner, 1));",
            "endif",
            "endfor",
            "for prop in (properties(object))",
            "if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))",
            "suspend(0);",
            "endif",
            "info = property_info(object, prop);",
            "if (!(index(info[2], \"c\") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))",
            "same = same && (info[1] == newowner);",
            "$wiz_utils:set_property_owner(object, prop, newowner, suspendok);",
            "endif",
            "endfor",
            "if (suspendok)",
            "suspend(0);",
            "endif",
            "$wiz_utils:set_owner(object, newowner, suspendok);",
            "if (same)",
            "player:notify(tostr(newowner.name, \" already owns everything \", newowner.ps, \" is entitled to on \", object.name, \".\"));",
            "else",
            "player:notify(tostr(\"Ownership changed on \", $string_utils:nn(object), \", verb, properties and descendants' properties.\"));",
            "endif",
            "endfor",
            "player:notify(tostr(verb, \" complete.\"));"
          ]
        },
        {
          "name": "@programmer",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "dobj = $string_utils:match_player(dobjstr);",
            "if (dobj == $nothing)",
            "player:notify(tostr(\"Usage:  \", verb, \" <playername>\"));",
            "elseif ($command_utils:player_match_result(dobj, dobjstr)[1])",
            "elseif ($wiz_utils:check_prog_restricted(dobj))",
            "return player:notify(tostr(\"Sorry, \", dobj.name, \" is not allowed to be a programmer.\"));",
            "elseif ((dobj.description == $player.description) && (!$command_utils:yes_or_no($string_utils:pronoun_sub(\"@Programmer %d despite %[dpp] lack of description?\"))))",
            "player:notify(tostr(\"Okay, leaving \", dobj.name, \" !programmer.\"));",
            "return;",
            "elseif (result = $wiz_utils:set_programmer(dobj))",
            "player:notify(tostr(dobj.name, \" (\", dobj, \") is now a programmer.  \", dobj.ppc, \" quota is currently \", $quota_utils:get_quota(dobj), \".\"));",
            "player:notify(tostr(dobj.name, \" and the other wizards have been notified.\"));",
            "if (msg = this:programmer_victim_msg())",
            "dobj:notify(msg);",
            "endif",
            "if ($object_utils:isa(dobj.location, $room) && (msg = this:programmer_msg()))",
            "dobj.location:announce_all_but({dobj}, msg);",
            "endif",
            "elseif (result == E_NONE)",
            "player:notify(tostr(dobj.name, \" (\", dobj, \") is already a programmer...\"));",
            "else",
            "player:notify(tostr(result));",
            "endif"
          ]
        },
        {
          "name": "make-core-database",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 57,
          "code": [
            "{?core_variant_name = \"\"} = args;",
            "if (!player.wizard)",
            "player:notify(\"Nice try, but permission denied.\");",
            "return;",
            "elseif (length(connected_players()) > 1)",
            "player:notify(\"You need to @boot everybody else before I'll believe this isn't the real MOO.\");",
            "abort = 1;",
            "elseif (`boot_player(open_network_connection(\"localhost\", 666)) ! ANY' != E_PERM)",
            "player:notify(\"Why are outbound connections enabled?  I bet this is the real MOO.\");",
            "abort = 1;",
            "else",
            "abort = (!$command_utils:yes_or_no(\"Continuing with this command will destroy all but the central core of the database.  Are you sure you want to do this?  \")) || (!$command_utils:yes_or_no(\"Really sure? \"));",
            "endif",
            "if (abort)",
            "player:notify(\"Core database extraction aborted.\");",
            "return;",
            "endif",
            "\"----------------------------------------\";",
            "player:notify(\"Messing with server options...\");",
            "spi = {};",
            "for p in ({\"protect_recycle\", \"protect_set_property_info\", \"protect_add_property\", \"protect_chparent\", \"bg_ticks\"})",
            "spi = {@spi, {p, $server_options.(p)}};",
            "$server_options.(p) = 0;",
            "endfor",
            "$server_options.bg_ticks = 1000000;",
            "add_property($server_options, \"bg_seconds\", 7, {player, \"r\"});",
            "`load_server_options() ! ANY';",
            "add_property($server_options, \"__mcd__savesopt\", spi, {player, \"r\"});",
            "\"----------------------------------------\";",
            "player:notify(\"Killing all queued tasks ...\");",
            "for t in (queued_tasks())",
            "kill_task(t[1]);",
            "endfor",
            "suspend(0);",
            "\"----------------------------------------\";",
            "player:notify(tostr(\"Identifying objects to be saved\", @core_variant_name ? {\" for core variant '\", core_variant_name, \"'\"} | {}, \" ...\"));",
            "\"... TODO --- core variant name lookup?\";",
            "core_variant = {{\"name\", core_variant_name}};",
            "{saved, saved_props, skipped_parents, proxy_original, proxy_incore, namespaces} = $core_object_info(core_variant, 1);",
            "if (!(player in saved))",
            "player:notify(\"Sorry, but this won't work unless you yourself are on the list of objects to be saved.\");",
            "player:notify(\"Core database extraction aborted.\");",
            "return;",
            "endif",
            "for ops in (saved_props)",
            "{o, o_props} = ops;",
            "for p in (o_props)",
            "if (i = o.(p) in proxy_original)",
            "o.(p) = proxy_incore[i];",
            "endif",
            "endfor",
            "endfor",
            "\"... TODO --- why isn't this on #0:init_for_core ? --Rog\";",
            "$player_class = $mail_recipient_class;",
            "\"----------------------------------------\";",
            "player:notify(\"Stripping you of any personal verbs and/or properties ...\");",
            "for i in [1..length(verbs(player))]",
            "delete_verb(player, 1);",
            "endfor",
            "for p in (properties(player))",
            "delete_property(player, p);",
            "endfor",
            "chparent(player, $wiz);",
            "for p in ($object_utils:all_properties(player))",
            "clear_property(player, p);",
            "endfor",
            "player:set_name(\"Wizard\");",
            "player:set_aliases({\"Wizard\"});",
            "player.description = \"\";",
            "player.key = 0;",
            "player.ownership_quota = 100;",
            "player.password = 0;",
            "player.last_password_time = 0;",
            "$gender_utils:set(player, \"neuter\");",
            "\"----------------------------------------\";",
            "suspend(0);",
            "owners_original = owners_incore = {};",
            "for i in [1..length(proxy_original)]",
            "o = proxy_original[i];",
            "if (is_player(o) && (o != $no_one))",
            "owners_original = {@owners_original, o};",
            "owners_incore = {@owners_incore, proxy_incore[i]};",
            "endif",
            "endfor",
            "for o in (saved)",
            "if (is_player(o) && (o != $no_one))",
            "owners_original = {@owners_original, o};",
            "owners_incore = {@owners_incore, o};",
            "endif",
            "endfor",
            "player:notify(tostr(\"Chowning every saved object, verb and property to one of \", $string_utils:nn(owners_incore), \"...\"));",
            "for o in (saved)",
            "$command_utils:suspend_if_needed(0, \"... \", length(saved) - (o in saved), \" to go\");",
            "if (i = o.owner in owners_original)",
            "o.owner = owners_incore[i];",
            "elseif (valid(o.owner) && o.owner.wizard)",
            "o.owner = player;",
            "else",
            "o.owner = $hacker;",
            "endif",
            "old_verbs = {};",
            "for j in [1..length(verbs(o))]",
            "$command_utils:suspend_if_needed(0, \"... \", length(saved) - (o in saved), \" to go\");",
            "info = verb_info(o, j);",
            "if (i = info[1] in owners_original)",
            "info[1] = owners_incore[i];",
            "elseif (valid(info[1]) && info[1].wizard)",
            "info[1] = player;",
            "else",
            "info[1] = $hacker;",
            "endif",
            "set_verb_info(o, j, info);",
            "if (index(info[3], \"(old)\"))",
            "old_verbs = {j, @old_verbs};",
            "endif",
            "endfor",
            "for vname in (old_verbs)",
            "delete_verb(o, vname);",
            "endfor",
            "for p in ($object_utils:all_properties(o))",
            "$command_utils:suspend_if_needed(0, \"... \", length(saved) - (o in saved), \" to go\");",
            "info = property_info(o, p);",
            "if (i = info[1] in owners_original)",
            "info[1] = owners_incore[i];",
            "elseif (valid(info[1]) && info[1].wizard)",
            "info[1] = player;",
            "else",
            "info[1] = $hacker;",
            "endif",
            "set_property_info(o, p, info);",
            "endfor",
            "endfor",
            "\"----------------------------------------\";",
            "player:notify(\"Removing all unsaved :recycle, :exitfunc, and :recycle verbs ...\");",
            "for o in [#0..max_object()]",
            "$command_utils:suspend_if_needed(0, \"... \", o);",
            "if (valid(o) && (!(o in saved)))",
            "for v in ({\"recycle\", \"exitfunc\", \"recycle\"})",
            "while ($object_utils:defines_verb(o, v))",
            "delete_verb(o, v);",
            "endwhile",
            "endfor",
            "endif",
            "endfor",
            "\"----------------------------------------\";",
            "player:notify(\"Recycling unsaved objects ...\");",
            "add_property(this, \"__mcd__pos\", toint(max_object()), {player, \"r\"});",
            "add_property(this, \"__mcd__save\", {core_variant, saved, saved_props, skipped_parents, namespaces}, {player, \"r\"});",
            "suspend(0);",
            "try",
            "this:mcd_2(core_variant, saved, saved_props, skipped_parents, namespaces);",
            "finally",
            "if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')",
            "\"...use raw notify since we have no idea what will be b0rken\";",
            "notify(player, \"Core database extraction failed.\");",
            "endif",
            "endtry"
          ]
        },
        {
          "name": "@shutdown",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "if (!player.wizard)",
            "player:notify(\"Sorry.\");",
            "return;",
            "elseif ($code_utils:task_valid($wiz_utils.shutdown_task))",
            "player:notify(tostr(\"Shutdown already in progress.  The MOO will be shut down in \", $time_utils:english_time($server[\"shutdown_time\"] - time()), \", by \", $wiz_utils.shutdown_message));",
            "return;",
            "endif",
            "if (s = match(argstr, \"^in +%([0-9]+%)%( +%|$%)\"))",
            "bounds = s[3][1];",
            "delay = toint(argstr[bounds[1]..bounds[2]]);",
            "argstr = argstr[s[2] + 1..$];",
            "else",
            "delay = 2;",
            "endif",
            "if (!$command_utils:yes_or_no(tostr(\"Do you really want to shut down the server in \", delay, \" minutes?\")))",
            "player:notify(\"Aborted.\");",
            "return;",
            "endif",
            "announce_times = {};",
            "if (delay > 0)",
            "while (delay > 0)",
            "announce_times = {@announce_times, delay * 60};",
            "delay = delay / 2;",
            "endwhile",
            "announce_times = {@announce_times, 30, 10};",
            "$server[\"shutdown_time\"] = time() + announce_times[1];",
            "endif",
            "$wiz_utils.shutdown_message = tostr(player.name, \" (\", player, \"): \", argstr);",
            "$wiz_utils.shutdown_task = task_id();",
            "for i in [1..length(announce_times)]",
            "base_msg = tostr(\"*** The server will be shut down by \", player.name, \" (\", player, \") in \", $time_utils:english_time(announce_times[i]), \":\");",
            "msg = {base_msg, @$generic_editor:fill_string(\"*** \" + argstr, length(base_msg) - 4, \"*** \")};",
            "\"...use raw notify() since :notify() verb could be broken...\";",
            "for p in (connected_players())",
            "for line in (msg)",
            "notify(p, line);",
            "endfor",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "suspend(announce_times[i] - {@announce_times, 0}[i + 1]);",
            "endfor",
            "for p in (connected_players())",
            "notify(p, tostr(\"*** Server shutdown by \", $wiz_utils.shutdown_message, \" ***\"));",
            "boot_player(p);",
            "endfor",
            "suspend(0);",
            "$wiz_utils.shutdown_task = E_NONE;",
            "set_task_perms(player);",
            "shutdown(argstr);"
          ]
        },
        {
          "name": "@dump-d*atabase",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "dump_database();",
            "player:notify(\"Dumping...\");"
          ]
        },
        {
          "name": "@who-calls",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "if (argstr[1] != \":\")",
            "argstr = \":\" + argstr;",
            "endif",
            "player:notify(tostr(\"Searching for verbs that appear to call \", argstr, \" ...\"));",
            "player:notify(\"\");",
            "$code_utils:find_verbs_containing(argstr + \"(\");"
          ]
        },
        {
          "name": "mcd_2",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 57,
          "code": [
            "if (!caller_perms().wizard)",
            "return;",
            "elseif (length(connected_players()) > 1)",
            "return;",
            "elseif (`boot_player(open_network_connection(\"localhost\", 666)) ! ANY' != E_PERM)",
            "return;",
            "elseif (!(\"__mcd__pos\" in properties(this)))",
            "return;",
            "endif",
            "end = this.__mcd__pos;",
            "{core_variant, saved, saved_props, skipped_parents, namespaces} = args;",
            "player:notify(tostr(\"*** Recycling from #\", end, \" ...\"));",
            "suspend(0);",
            "fork (0)",
            "try",
            "this:mcd_2(core_variant, saved, saved_props, skipped_parents, namespaces);",
            "finally",
            "if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')",
            "\"...use raw notify since we have no idea what will be b0rken\";",
            "notify(player, \"Core database extraction failed.\");",
            "endif",
            "endtry",
            "endfork",
            "for i in [0..end]",
            "this.__mcd__pos = end - i;",
            "o = toobj(end - i);",
            "if ($command_utils:running_out_of_time())",
            "return;",
            "endif",
            "if (valid(o) && (!(o in saved)))",
            "for x in (o.contents)",
            "move(x, #-1);",
            "endfor",
            "if (is_player(o))",
            "\"o.features = {}\";",
            "set_player_flag(o, 0);",
            "endif",
            "if (!(o in skipped_parents))",
            "chparent(o, #-1);",
            "endif",
            "recycle(o);",
            "endif",
            "endfor",
            "delete_property(this, \"__mcd__pos\");",
            "spi = $server_options.__mcd__savesopt;",
            "delete_property($server_options, \"__mcd__savesopt\");",
            "delete_property($server_options, \"bg_seconds\");",
            "for pv in (spi)",
            "$server_options.(pv[1]) = pv[2];",
            "endfor",
            "load_server_options();",
            "\"----------------------------------------\";",
            "suspend(0);",
            "player:notify(\"Killing queued tasks ...\");",
            "for t in (queued_tasks())",
            "kill_task(t[1]);",
            "endfor",
            "\"----------------------------------------\";",
            "player:notify(\"Compacting object numbers ...\");",
            "old_oids = new_oids = {player};",
            "for o_ps in (saved_props)",
            "$command_utils:suspend_if_needed(0);",
            "{o, o_props} = o_ps;",
            "\"Oh geeze. 'o' could have already been renumbered!\";",
            "if (ind = o in old_oids)",
            "o = new_oids[ind];",
            "endif",
            "for p in (o_props)",
            "if ((p == \"owner\") || (p == \"location\"))",
            "\"...renumber() takes care of these\";",
            "elseif (i = (old = o.(p)) in old_oids)",
            "o.(p) = new_oids[i];",
            "elseif (valid(old))",
            "new_oids[1..0] = {o.(p) = renumber(old)};",
            "old_oids[1..0] = {old};",
            "endif",
            "endfor",
            "endfor",
            "for o in (saved)",
            "if (valid(o) && (o != player))",
            "renumber(o);",
            "endif",
            "endfor",
            "player:notify(\"Compacting namespaces ...\");",
            "for ns in (namespaces)",
            "{o, o_prop, o_map} = ns;",
            "for value, key in (o_map)",
            "if (index = value in old_oids)",
            "o.(o_prop)[key] = new_oids[index];",
            "elseif (valid(value))",
            "new_oids[1..0] = {o.(o_prop)[key] = renumber(value)};",
            "old_oids[1..0] = {value};",
            "endif",
            "endfor",
            "endfor",
            "reset_max_object();",
            "\"...rebuild saved list so that parents come before children...\";",
            "saved = {};",
            "for o in [#0..max_object()]",
            "os = {};",
            "while (valid(o) && (!(o in saved)))",
            "os = {o, @os};",
            "o = parent(o);",
            "endwhile",
            "saved = {@saved, @os};",
            "endfor",
            "\"----------------------------------------\";",
            "player:notify(\"Performing miscellaneous cleanups ...\");",
            "succeeded = 1;",
            "for o in [#0..max_object()]",
            "$command_utils:suspend_if_needed(0);",
            "try",
            "move(o, #-1);",
            "except e (ANY)",
            "player:notify(tostr(\"Couldn't move \", o, \" => \", e[2]));",
            "player:notify(toliteral(e[4]));",
            "succeeded = 0;",
            "endtry",
            "endfor",
            "for o in (saved)",
            "$command_utils:suspend_if_needed(0);",
            "if ($object_utils:has_callable_verb(o, \"init_for_core\"))",
            "try",
            "o:init_for_core(core_variant);",
            "except e (ANY)",
            "player:notify(tostr(\"Error from \", o, \":init_for_core => \", e[2]));",
            "player:notify(toliteral(e[4]));",
            "succeeded = 0;",
            "endtry",
            "endif",
            "endfor",
            "player:notify(\"Re-measuring everything ...\");",
            "for o in [#0..max_object()]",
            "$command_utils:suspend_if_needed(0);",
            "if (valid(o))",
            "$byte_quota_utils:object_bytes(o);",
            "endif",
            "endfor",
            "$wiz_utils:initialize_owned();",
            "$byte_quota_utils:summarize_one_user(player);",
            "delete_property(this, \"__mcd__save\");",
            "player:notify(\"Core database extraction \" + (succeeded ? \"is complete.\" | \"failed.\"));",
            "if (succeeded)",
            "boot_player(player);",
            "shutdown();",
            "endif"
          ]
        },
        {
          "name": "@toad @toad! @toad!!",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@toad[!][!] <player> [blacklist|redlist|graylist] [commentary]\";",
            "whostr = args[1];",
            "comment = $string_utils:first_word(argstr)[2];",
            "if (verb == \"@toad!!\")",
            "listname = \"redlist\";",
            "elseif (verb == \"@toad!\")",
            "listname = \"blacklist\";",
            "elseif ((ln = {@args, \"\"}[2]) && (index(listname = $login:listname(ln), ln) == 1))",
            "\"...first word of coment is one of the magic words...\";",
            "comment = $string_utils:first_word(comment)[2];",
            "else",
            "listname = \"\";",
            "endif",
            "if ((!player.wizard) || (player != this))",
            "player:notify(\"Yeah, right... you wish.\");",
            "return;",
            "elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))",
            "return;",
            "elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))",
            "player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));",
            "return;",
            "elseif (who == player)",
            "player:notify(\"If you want to toad yourself, you have to do it by hand.\");",
            "return;",
            "endif",
            "dobj = who;",
            "if (msg = player:toad_victim_msg())",
            "notify(who, msg);",
            "endif",
            "if ($wiz_utils:rename_all_instances(who, \"disfunc\", \"toad_disfunc\"))",
            "player:notify(tostr(who, \":disfunc renamed.\"));",
            "endif",
            "if ($wiz_utils:rename_all_instances(who, \"recycle\", \"toad_recycle\"))",
            "player:notify(tostr(who, \":recycle renamed.\"));",
            "endif",
            "\"MOO-specific cleanup while still a player object.\";",
            "this:toad_cleanup(who);",
            "e = $wiz_utils:unset_player(who, $hacker);",
            "player:notify(e ? tostr(who.name, \"(\", who, \") is now a toad.\") | tostr(e));",
            "if (e && ($object_utils:isa(who.location, $room) && (msg = player:toad_msg())))",
            "who.location:announce_all_but({who}, msg);",
            "endif",
            "if (listname && (!$login:(listname + \"ed\")(cname = $string_utils:connection_hostname(who.last_connect_place))))",
            "$login:(listname + \"_add\")(cname);",
            "player:notify(tostr(\"Site \", cname, \" \", listname, \"ed.\"));",
            "else",
            "cname = \"\";",
            "endif",
            "if (!comment)",
            "player:notify(\"So why is this person being toaded?\");",
            "comment = $command_utils:read();",
            "endif",
            "$mail_agent:send_message(player, $toad_log, tostr(\"@toad \", who.name, \" (\", who, \")\"), {$string_utils:from_list(who.all_connect_places, \" \"), @cname ? {$string_utils:capitalize(listname + \"ed:  \") + cname} | {}, @comment ? {comment} | {}});",
            "player:notify(tostr(\"Mail sent to \", $mail_agent:name($toad_log), \".\"));",
            "`$local.waitlist:note_reapee(who, tostr(\"@toaded by \", player.name)) ! ANY';"
          ]
        },
        {
          "name": "@untoad @detoad",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@untoad <object> [as namespec]\";",
            "\"Turns object into a player.  Anything that isn't a guest is chowned to itself.\";",
            "if (!player.wizard)",
            "player:notify(\"Yeah, right... you wish.\");",
            "elseif (prepstr && (prepstr != \"as\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object> [as name,alias,alias...]\"));",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "elseif (prepstr && (!(e = $building_utils:set_names(dobj, iobjstr))))",
            "player:notify(tostr(\"Initial rename failed:  \", e));",
            "elseif (e = $wiz_utils:set_player(dobj, g = $object_utils:isa(dobj, $guest)))",
            "player:notify(tostr(dobj.name, \"(\", dobj, \") is now a \", g ? \"usable guest.\" | \"player.\"));",
            "elseif (e == E_INVARG)",
            "player:notify(tostr(dobj.name, \"(\", dobj, \") is not of an appropriate player class.\"));",
            "player:notify(\"@chparent it to $player or some descendant.\");",
            "elseif (e == E_NONE)",
            "player:notify(tostr(dobj.name, \"(\", dobj, \") is already a player.\"));",
            "elseif (e == E_NACC)",
            "player:notify(\"Wait until $player_db is finished updating...\");",
            "elseif (e == E_RECMOVE)",
            "player:notify(tostr(\"The name `\", dobj.name, \"' is currently unavailable.\"));",
            "player:notify(tostr(\"Try again with   \", verb, \" \", dobj, \" as <newname>\"));",
            "else",
            "player:notify(tostr(e));",
            "endif"
          ]
        },
        {
          "name": "@quota",
          "owner": 2,
          "perms": 89,
          "preps": 12,
          "object": 57,
          "code": [
            "\"@quota <player> is [public] <number> [<reason>]\";",
            "\"  changes a player's quota.  sends mail to the wizards.\";",
            "if (player != this)",
            "return player:notify(\"Permission denied.\");",
            "endif",
            "set_task_perms(player);",
            "dobj = $string_utils:match_player(dobjstr);",
            "if ($command_utils:player_match_result(dobj, dobjstr)[1])",
            "return;",
            "elseif (!valid(dobj))",
            "player:notify(\"Set whose quota?\");",
            "return;",
            "endif",
            "if (iobjstr[1..min(7, $)] == \"public \")",
            "iobjstr[1..7] = \"\";",
            "if ($object_utils:has_property($local, \"public_quota_log\"))",
            "recipients = {$quota_log, $local.public_quota_log};",
            "else",
            "player:tell(\"No public quota log.\");",
            "return E_INVARG;",
            "endif",
            "else",
            "recipients = {$quota_log};",
            "endif",
            "old = $quota_utils:get_quota(dobj);",
            "qstr = iobjstr[1..(n = index(iobjstr + \" \", \" \")) - 1];",
            "new = $code_utils:toint((qstr[1] == \"+\") ? qstr[2..$] | qstr);",
            "reason = iobjstr[n + 1..$] || \"(none)\";",
            "if (typeof(new) != INT)",
            "player:notify(tostr(\"Set \", dobj.name, \"'s quota to what?\"));",
            "return;",
            "elseif (qstr[1] == \"+\")",
            "new = old + new;",
            "endif",
            "result = $quota_utils:set_quota(dobj, new);",
            "if (typeof(result) == ERR)",
            "player:notify(tostr(result));",
            "else",
            "player:notify(tostr(dobj.name, \"'s quota set to \", new, \".\"));",
            "endif",
            "$mail_agent:send_message(player, recipients, tostr(\"@quota \", dobj.name, \" (\", dobj, \") \", new, \" (from \", old, \")\"), tostr(\"Reason for quota \", ((new - old) < 0) ? \"decrease: \" | \"increase: \", reason, index(\"?.!\", reason[$]) ? \"\" | \".\"));"
          ]
        },
        {
          "name": "@players",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "\"The time below is Oct. 1, 1990, roughly the birthdate of the LambdaMOO server.\";",
            "start = 654768000;",
            "now = time();",
            "day = (24 * 60) * 60;",
            "week = 7 * day;",
            "month = 30 * day;",
            "days_objects = days_players = {0, 0, 0, 0, 0, 0, 0};",
            "weeks_objects = weeks_players = {0, 0, 0, 0};",
            "months_objects = months_players = {};",
            "nonplayer_objects = invalid_objects = 0;",
            "always_objects = always_players = 0;",
            "never_objects = never_players = 0;",
            "numo = 0;",
            "if (argstr)",
            "if (((!dobjstr) && (prepstr == \"with\")) && (index(\"objects\", iobjstr) == 1))",
            "with_objects = 1;",
            "else",
            "player:notify(tostr(\"Usage:  \", verb, \" [with objects]\"));",
            "return;",
            "endif",
            "else",
            "with_objects = 0;",
            "players = players();",
            "endif",
            "for i in [1..with_objects ? toint(max_object()) + 1 | length(players)]",
            "if (with_objects)",
            "o = toobj(i - 1);",
            "else",
            "o = players[i];",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"... \", o));",
            "suspend(0);",
            "endif",
            "if (valid(o))",
            "numo = numo + 1;",
            "p = is_player(o) ? o | o.owner;",
            "if (!valid(p))",
            "invalid_objects = invalid_objects + 1;",
            "elseif (!$object_utils:isa(p, $player))",
            "nonplayer_objects = nonplayer_objects + 1;",
            "else",
            "seconds = now - p.last_connect_time;",
            "days = seconds / day;",
            "weeks = seconds / week;",
            "months = seconds / month;",
            "if (seconds < 0)",
            "if (is_player(o))",
            "always_players = always_players + 1;",
            "else",
            "always_objects = always_objects + 1;",
            "endif",
            "elseif (seconds > (now - start))",
            "if (is_player(o))",
            "never_players = never_players + 1;",
            "else",
            "never_objects = never_objects + 1;",
            "endif",
            "elseif (months > 0)",
            "while (months > length(months_players))",
            "months_players = {@months_players, 0};",
            "months_objects = {@months_objects, 0};",
            "endwhile",
            "if (is_player(o))",
            "months_players[months] = months_players[months] + 1;",
            "endif",
            "months_objects[months] = months_objects[months] + 1;",
            "elseif (weeks > 0)",
            "if (is_player(o))",
            "weeks_players[weeks] = weeks_players[weeks] + 1;",
            "endif",
            "weeks_objects[weeks] = weeks_objects[weeks] + 1;",
            "else",
            "if (is_player(o))",
            "days_players[days + 1] = days_players[days + 1] + 1;",
            "endif",
            "days_objects[days + 1] = days_objects[days + 1] + 1;",
            "endif",
            "endif",
            "endif",
            "endfor",
            "player:notify(\"\");",
            "player:notify(tostr(\"Last connected\"));",
            "player:notify(tostr(\"at least this     Num.     Cumul.   Cumul. %\", with_objects ? \"     Num.     Cumul.   Cumul. %\" | \"\"));",
            "player:notify(tostr(\"long ago        players   players   players \", with_objects ? \"   objects   objects   objects\" | \"\"));",
            "player:notify(tostr(\"---------------------------------------------\", with_objects ? \"--------------------------------\" | \"\"));",
            "su = $string_utils;",
            "col1 = 14;",
            "col2 = 7;",
            "col3 = 10;",
            "col4 = 9;",
            "col5 = 11;",
            "col6 = 11;",
            "col7 = 10;",
            "nump = length(players());",
            "totalp = totalo = 0;",
            "for x in ({{days_players, days_objects, \"day\", 1}, {weeks_players, weeks_objects, \"week\", 0}, {months_players, months_objects, \"month\", 0}})",
            "pcounts = x[1];",
            "ocounts = x[2];",
            "unit = x[3];",
            "offset = x[4];",
            "for i in [1..length(pcounts)]",
            "$command_utils:suspend_if_needed(0);",
            "j = i - offset;",
            "player:notify(tostr(su:left(tostr(j, \" \", unit, (j == 1) ? \":\" | \"s:\"), col1), su:right(pcounts[i], col2), su:right(totalp = totalp + pcounts[i], col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(ocounts[i], col5), su:right(totalo = totalo + ocounts[i], col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));",
            "endfor",
            "player:notify(\"\");",
            "endfor",
            "player:notify(tostr(su:left(\"Never:\", col1), su:right(never_players, col2), su:right(totalp = totalp + never_players, col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(never_objects, col5), su:right(totalo = totalo + never_objects, col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));",
            "player:notify(tostr(su:left(\"Always:\", col1), su:right(always_players, col2), su:right(totalp = totalp + always_players, col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(always_objects, col5), su:right(totalo = totalo + always_objects, col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));",
            "with_objects && player:notify(tostr(su:left(\"Non-player owner:\", (((col1 + col2) + col3) + col4) + 1), su:right(nonplayer_objects, col5), su:right(totalo = totalo + nonplayer_objects, col6), su:right((totalo * 100) / numo, col7), \"%\"));",
            "with_objects && player:notify(tostr(su:left(\"Invalid owner:\", (((col1 + col2) + col3) + col4) + 1), su:right(invalid_objects, col5), su:right(totalo = totalo + invalid_objects, col6), su:right((totalo * 100) / numo, col7), \"%\"));",
            "player:notify(\"\");"
          ]
        },
        {
          "name": "kill_aux_wizard_parse",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "\"Auxiliary verb for parsing @kill soon [#-of-seconds] [player | everyone]\";",
            "\"Args[1] is either # of seconds or player/everyone.\";",
            "\"Args[2], if it exists, is player/everyone, and forces args[1] to have been # of seconds.\";",
            "\"Return value: {# of seconds [default 60] , 1 for all, object for player.}\";",
            "set_task_perms(caller_perms());",
            "nargs = length(args);",
            "soon = toint(args[1]);",
            "if (nargs > 1)",
            "everyone = args[2];",
            "elseif (soon <= 0)",
            "everyone = args[1];",
            "else",
            "everyone = 0;",
            "endif",
            "if (everyone == \"everyone\")",
            "everyone = 1;",
            "elseif (typeof(everyone) == STR)",
            "result = $string_utils:match_player(everyone);",
            "if ($command_utils:player_match_failed(result, everyone))",
            "player:notify(tostr(\"Usage:  \", callers()[1][2], \" soon [number of seconds] [\\\"everyone\\\" | player name]\"));",
            "return {-1, -1};",
            "else",
            "return {soon ? soon | 60, result};",
            "endif",
            "endif",
            "return {soon ? soon | 60, everyone ? everyone | player};"
          ]
        },
        {
          "name": "@grepcore @egrepcore",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "if (!args)",
            "player:notify(tostr(\"Usage:  \", verb, \" <pattern>\"));",
            "return;",
            "endif",
            "pattern = argstr;",
            "regexp = verb == \"@egrepcore\";",
            "player:notify(tostr(\"Searching for core verbs \", regexp ? \"matching the regular expression \" | \"containing the string \", toliteral(pattern), \" ...\"));",
            "player:notify(\"\");",
            "$code_utils:(regexp ? \"find_verbs_matching\" | \"find_verbs_containing\")(pattern, $core_objects());"
          ]
        },
        {
          "name": "@net-who @@who",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@net-who prints all connected users and hosts.\";",
            "\"@net-who player player player prints specified users and current or most recent connected host.\";",
            "\"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.\";",
            "set_task_perms(player);",
            "su = $string_utils;",
            "if ((prepstr == \"from\") && dobjstr)",
            "player:notify(tostr(\"Usage:  \", verb, \" from <host string>\"));",
            "elseif (((prepstr != \"from\") || dobjstr) || (!iobjstr))",
            "\"Not parsing 'from' here...  Instead printing connected/recent users.\";",
            "if (!(pstrs = args))",
            "unsorted = connected_players();",
            "else",
            "unsorted = listdelete($command_utils:player_match_result(su:match_player(pstrs), pstrs), 1);",
            "endif",
            "if (!unsorted)",
            "return;",
            "endif",
            "$wiz_utils:show_netwho_listing(player, unsorted);",
            "else",
            "$wiz_utils:show_netwho_from_listing(player, iobjstr);",
            "endif"
          ]
        },
        {
          "name": "@make-player",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"Creates a player.\";",
            "\"Syntax:  @make-player name email-address comments....\";",
            "\"Generates a random password for the player.\";",
            "if ((!player.wizard) || callers())",
            "return E_PERM;",
            "elseif (length(args) < 2)",
            "player:tell(\"Syntax:  @make-player name email-address comments....\");",
            "return;",
            "elseif (args[2] == \"for\")",
            "\"common mistake: @make-player <name> for <email-address> ...\";",
            "args = listdelete(args, 2);",
            "endif",
            "return $wiz_utils:do_make_player(@args);"
          ]
        },
        {
          "name": "@abort-sh*utdown",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "if (!player.wizard)",
            "player:notify(\"Sorry.\");",
            "elseif (!$code_utils:task_valid($wiz_utils.shutdown_task))",
            "player:notify(\"No server shutdown in progress.\");",
            "$wiz_utils.shutdown_task = E_NONE;",
            "else",
            "\"... Reset time so that $login:check_for_shutdown shuts up...\";",
            "kill_task($wiz_utils.shutdown_task);",
            "$wiz_utils.shutdown_task = E_NONE;",
            "$server[\"shutdown_time\"] = time() - 1;",
            "for p in (connected_players())",
            "notify(p, tostr(\"*** Server shutdown ABORTED by \", player.name, \" (\", player, \")\", argstr && (\":  \" + argstr), \" ***\"));",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "toad_msg toad_victim_msg programmer_msg programmer_victim_msg newt_msg newt_victim_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "\"This is the canonical doing-something-to-somebody message.\";",
            "\"The corresponding property can either be\";",
            "\"   string             msg for all occasions\";",
            "\"   list of 2 strings  {we-are-there-msg,we-are-elsewhere-msg}\";",
            "m = this.(verb);",
            "if (typeof(m) != LIST)",
            "return $string_utils:pronoun_sub(m);",
            "elseif ((this.location == dobj.location) || (length(m) < 2))",
            "return $string_utils:pronoun_sub(m[1]);",
            "else",
            "return $string_utils:pronoun_sub(m[2]);",
            "endif"
          ]
        },
        {
          "name": "moveto",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "set_task_perms((caller in {this, $generic_editor, $verb_editor, $mail_editor, $note_editor}) ? this.owner | caller_perms());",
            "return `move(this, args[1]) ! ANY';"
          ]
        },
        {
          "name": "@newt",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@newt <player> [commentary]\";",
            "\"turns a player into a newt.  It can get better...\";",
            "\"adds player to $login.newted, they will not be allowed to log in.\";",
            "\"Sends mail to $newt_log giving .all_connect_places and commentary.\";",
            "whostr = args[1];",
            "comment = $string_utils:first_word(argstr)[2];",
            "if (!player.wizard)",
            "player:notify(\"Yeah, right.\");",
            "elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))",
            "return;",
            "elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))",
            "player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));",
            "return;",
            "elseif (who == player)",
            "player:notify(\"If you want to newt yourself, you have to do it by hand.\");",
            "return;",
            "elseif (who in $login.newted)",
            "player:notify(tostr(who.name, \" appears to already be a newt.\"));",
            "return;",
            "else",
            "$wiz_utils:newt_player(who, comment);",
            "endif"
          ]
        },
        {
          "name": "@unnewt @denewt @get-better",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@denewt <player> [commentary]\";",
            "\"Remove the player from $Login.newted\";",
            "\"Sends mail to $newt_log with commentary.\";",
            "whostr = args[1];",
            "comment = $string_utils:first_word(argstr)[2];",
            "if (!player.wizard)",
            "player:notify(\"Yeah, right.\");",
            "elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))",
            "return;",
            "else",
            "\"Should parse email address and register user in some clever way.  Ick.\";",
            "if (!(who in $login.newted))",
            "player:notify(tostr(who.name, \" does not appear to be a newt.\"));",
            "else",
            "$login.newted = setremove($login.newted, who);",
            "if (entry = $list_utils:assoc(who, $login.temporary_newts))",
            "$login.temporary_newts = setremove($login.temporary_newts, entry);",
            "endif",
            "player:notify(tostr(who.name, \" (\", who, \") got better.\"));",
            "$mail_agent:send_message(player, $newt_log, tostr(\"@denewt \", who.name, \" (\", who, \")\"), comment ? {comment} | {});",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@register",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"Registers a player.\";",
            "\"Syntax:  @register name email-address [additional commentary]\";",
            "\"Email-address is stored in $registration_db and on the player object.\";",
            "if (!player.wizard)",
            "return player:tell(E_PERM);",
            "endif",
            "$wiz_utils:do_register(@args);"
          ]
        },
        {
          "name": "@new-password @newpassword",
          "owner": 2,
          "perms": 89,
          "preps": 12,
          "object": 57,
          "code": [
            "\"@newpassword player is [string]\";",
            "\"Set's a player's password; omit string to have one randomly generated.\";",
            "\"Offer to email the password.\";",
            "if (!player.wizard)",
            "return E_PERM;",
            "elseif ($command_utils:player_match_failed(dobj = $string_utils:match_player(dobjstr), dobjstr))",
            "return;",
            "elseif (!(dobjstr in {@dobj.aliases, tostr(dobj)}))",
            "player:notify(tostr(\"Must be a full name or an object number: \", dobj.name, \" (\", dobj, \")\"));",
            "else",
            "$wiz_utils:do_new_password(dobj, iobjstr);",
            "endif"
          ]
        },
        {
          "name": "@log",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@log [<string>]    enters a comment in the server log.\";",
            "\"If no string is given, you are prompted to enter one or more lines for an extended comment.\";",
            "set_task_perms(player);",
            "whostr = tostr(\"from \", player.name, \" (\", player, \")\");",
            "if ((!player.wizard) || (player != caller))",
            "player:notify(\"Yeah, right.\");",
            "elseif (argstr)",
            "server_log(tostr(\"COMMENT: [\", whostr, \"]  \", argstr));",
            "player:notify(\"One-line comment logged.\");",
            "elseif (lines = $command_utils:read_lines())",
            "server_log(tostr(\"COMMENT: [\", whostr, \"]\"));",
            "for l in (lines)",
            "server_log(l);",
            "endfor",
            "server_log(tostr(\"END_COMMENT.\"));",
            "player:notify(tostr(length(lines), \" lines logged as extended comment.\"));",
            "endif"
          ]
        },
        {
          "name": "@guests",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 57,
          "code": [
            "set_task_perms(player);",
            "n = (dobjstr == \"all\") ? 0 | $code_utils:toint(dobjstr || \"20\");",
            "if (caller != this)",
            "player:notify(\"You lose.\");",
            "elseif ((n == E_TYPE) && (index(\"now\", dobjstr) != 1))",
            "player:notify(tostr(\"Usage:  \", verb, \" <number>  (where <number> indicates how many entries to look at in the guest log)\"));",
            "player:notify(tostr(\"Usage:  \", verb, \" now (to see information about currently connected guests only)\"));",
            "elseif ((!dobjstr) || (index(\"now\", dobjstr) != 1))",
            "$guest_log:last(n);",
            "else",
            "\"*way* too much copied code in here from @who...  Sorry.  --yduJ\";",
            "su = $string_utils;",
            "conn = connected_players();",
            "unsorted = {};",
            "for g in ($object_utils:leaves($guest))",
            "if (g in conn)",
            "unsorted = {@unsorted, g};",
            "endif",
            "endfor",
            "if (!unsorted)",
            "player:tell(\"No guests found.\");",
            "return;",
            "endif",
            "footnotes = {};",
            "alist = {};",
            "nwidth = length(\"Player name\");",
            "for u in (unsorted)",
            "pref = u.programmer ? \"% \" | \"  \";",
            "u.programmer && (footnotes = setadd(footnotes, \"prog\"));",
            "u3 = {tostr(pref, u.name, \" (\", u, \")\"), su:from_seconds(connected_seconds(u)), su:from_seconds(idle_seconds(u)), where = $string_utils:connection_hostname(u)};",
            "nwidth = max(length(u3[1]), nwidth);",
            "if ($login:blacklisted(where))",
            "where = \"(*) \" + where;",
            "footnotes = setadd(footnotes, \"black\");",
            "elseif ($login:graylisted(where))",
            "where = \"(+) \" + where;",
            "footnotes = setadd(footnotes, \"gray\");",
            "endif",
            "alist = {@alist, u3};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "alist = $list_utils:sort_alist_suspended(0, alist, 3);",
            "$command_utils:suspend_if_needed(0);",
            "headers = {\"Player name\", \"Connected\", \"Idle Time\", \"From Where\"};",
            "time_width = length(\"59 minutes\") + 2;",
            "before = {0, w1 = nwidth + 3, w2 = w1 + time_width, w3 = w2 + time_width};",
            "tell1 = \"  \" + headers[1];",
            "tell2 = \"  \" + su:space(headers[1], \"-\");",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + headers[j];",
            "tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");",
            "endfor",
            "player:notify(tell1);",
            "player:notify(tell2);",
            "active = 0;",
            "for a in (alist)",
            "$command_utils:suspend_if_needed(0);",
            "tell1 = a[1];",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + tostr(a[j]);",
            "endfor",
            "player:notify(tell1[1..min($, 79)]);",
            "endfor",
            "if (footnotes)",
            "player:notify(\"\");",
            "if (\"prog\" in footnotes)",
            "player:notify(\" %  == programmer.\");",
            "endif",
            "if (\"black\" in footnotes)",
            "player:notify(\"(*) == blacklisted site.\");",
            "endif",
            "if (\"gray\" in footnotes)",
            "player:notify(\"(+) == graylisted site.\");",
            "endif",
            "endif",
            "player:tell(\"@guests display complete.\");",
            "endif"
          ]
        },
        {
          "name": "@rn mail_catch_up check_mail_lists current_message set_current_message get_current_message make_current_message kill_current_message @nn",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 57,
          "code": [
            "if (caller != this)",
            "set_task_perms(valid(caller_perms()) ? caller_perms() | player);",
            "endif",
            "use = this.mail_identity;",
            "if (valid(use) && (use != this))",
            "return use:(verb)(@args);",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "@blacklist @graylist @redlist @unblacklist @ungraylist @unredlist @spooflist @unspooflist",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@[un]blacklist [<site or subnet>  [for <duration>] [commentary]]\";",
            "\"@[un]graylist  [<site or subnet>  [for <duration>] [commentary]]\";",
            "\"@[un]redlist   [<site or subnet>  [for <duration>] [commentary]]\";",
            "\"@[un]spooflist [<site of subnet>  [for <duration>] [commentary]]\";",
            "\"The `for <duration>' is for temporary colorlisting a site only. The duration should be in english time units:  for 1 hour, for 1 day 2 hours 15 minutes, etc. The commentary should be after all durations. Note, if you are -not- using a duration, do not start your commentary with the word `for'.\";",
            "set_task_perms(player);",
            "if ((player != this) || (!player.wizard))",
            "player:notify(\"Ummm.  no.\");",
            "return;",
            "endif",
            "undo = verb[2..3] == \"un\";",
            "which = $login:listname(verb[undo ? 4 | 2]);",
            "downgrade = {\"\", \"graylist\", \"blacklist\"}[1 + index(\"br\", which[1])];",
            "if (!(fw = $string_utils:first_word(argstr)))",
            "\"... Just print the list...\";",
            "this:display_list(which);",
            "return;",
            "endif",
            "target = fw[1];",
            "if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])",
            "if ((typeof(parse[3]) == ERR) || (!parse[3]))",
            "player:notify(tostr(\"Could not parse the duration for @\", which, \"ing site \\\"\", target, \"\\\"\"));",
            "return;",
            "endif",
            "start = parse[2];",
            "duration = parse[3];",
            "comment = parse[4] ? {parse[4]} | {};",
            "comment = {tostr(\"for \", $time_utils:english_time(duration)), @comment};",
            "elseif (fw[2])",
            "comment = {fw[2]};",
            "else",
            "\"Get the right vars set up as though parse had been called\";",
            "parse = {0, \"\"};",
            "comment = {};",
            "endif",
            "player:tell(\"comment is currently \", toliteral(comment));",
            "if (is_literal = $site_db:domain_literal(target))",
            "if (target[$] == \".\")",
            "target = target[1..$ - 1];",
            "endif",
            "fullname = \"subnet \" + target;",
            "else",
            "if (target[1] == \".\")",
            "target[1..1] = \"\";",
            "endif",
            "fullname = (\"domain `\" + target) + \"'\";",
            "endif",
            "entrylist = $login.(which)[1 + (!is_literal)];",
            "if ((!undo) && (target in entrylist))",
            "player:notify(tostr(fullname, \" is already \", which, \"ed.\"));",
            "return;",
            "endif",
            "entrylist = setremove(entrylist, target);",
            "if (!(result = this:check_site_entries(undo, which, target, is_literal, entrylist))[1])",
            "return;",
            "endif",
            "rm = result[2];",
            "namelist = $string_utils:english_list(rm);",
            "downgraded = {};",
            "if (rm)",
            "ntries = (length(rm) == 1) ? \"ntry\" | \"ntries\";",
            "if ($command_utils:yes_or_no(tostr(\"Remove e\", ntries, \" for \", namelist, \"?\")))",
            "dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + \" them?\"));",
            "for s in (rm)",
            "$login:(which + \"_remove\")(s);",
            "dg && ($login:(downgrade + \"_add\")(s) && (downgraded = {@downgraded, s}));",
            "endfor",
            "player:notify(tostr(\"E\", ntries, \" removed\", @dg ? {\" and \", downgrade, \"ed.\"} | {\".\"}));",
            "else",
            "player:notify(tostr(namelist, \" will continue to be \", which, \"ed.\"));",
            "rm = {};",
            "endif",
            "endif",
            "if (downgraded)",
            "comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(downgraded), \".\")};",
            "endif",
            "tempentrylist = $login.(\"temporary_\" + which)[1 + (!is_literal)];",
            "if ((!undo) && (target in $list_utils:slice(tempentrylist)))",
            "player:notify(tostr(fullname, \" is already temporarily \", which, \"ed.\"));",
            "return;",
            "endif",
            "if (en = $list_utils:assoc(target, tempentrylist))",
            "tempentrylist = setremove(tempentrylist, en);",
            "endif",
            "if (!(result = this:check_site_entries(undo, which, target, is_literal, $list_utils:slice(tempentrylist)))[1])",
            "return;",
            "endif",
            "rmtemp = result[2];",
            "tempnamelist = $string_utils:english_list(rmtemp);",
            "tempdowngraded = {};",
            "if (rmtemp)",
            "ntries = (length(rmtemp) == 1) ? \"ntry\" | \"ntries\";",
            "if ($command_utils:yes_or_no(tostr(\"Remove e\", ntries, \" for \", tempnamelist, \"?\")))",
            "dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + \" them?\"));",
            "for s in (rmtemp)",
            "old = $list_utils:assoc(s, tempentrylist);",
            "$login:(which + \"_remove_temp\")(s);",
            "dg && ($login:(downgrade + \"_add_temp\")(s, old[2], old[3]) && (tempdowngraded = {@tempdowngraded, s}));",
            "endfor",
            "player:notify(tostr(\"E\", ntries, \" removed\", @dg ? {\" and \", downgrade, \"ed with durations transferred.\"} | {\".\"}));",
            "else",
            "player:notify(tostr(tempnamelist, \" will continue to be temporarily \", which, \"ed.\"));",
            "rmtemp = {};",
            "endif",
            "endif",
            "if (tempdowngraded)",
            "comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(tempdowngraded), \".\")};",
            "endif",
            "if (!undo)",
            "if (parse[1])",
            "$login:(which + \"_add_temp\")(target, start, duration);",
            "player:notify(tostr(fullname, \" \", which, \"ed for \", $time_utils:english_time(duration)));",
            "else",
            "$login:(which + \"_add\")(target);",
            "player:notify(tostr(fullname, \" \", which, \"ed.\"));",
            "endif",
            "if (rm)",
            "comment[1..0] = {tostr(\"Subsumes \", which, \"ing for \", namelist, \".\")};",
            "endif",
            "if (rmtemp)",
            "comment[1..0] = {tostr(\"Subsumes temporary \", which, \"ing for \", tempnamelist, \".\")};",
            "endif",
            "elseif ($login:(which + \"_remove\")(target))",
            "player:notify(tostr(fullname, \" un\", which, \"ed.\"));",
            "if (!downgrade)",
            "elseif ($command_utils:yes_or_no(downgrade + \" it?\"))",
            "$login:(downgrade + \"_add\")(target) && (downgraded = {target, @downgraded});",
            "player:notify(tostr(fullname, \" \", downgrade, \"ed.\"));",
            "else",
            "player:notify(tostr(fullname, \" not \", downgrade, \"ed.\"));",
            "endif",
            "if (downgraded)",
            "player:tell(\"Comment currently: \", toliteral(comment), \" ; downgrade = \", toliteral(downgrade), \" ; downgraded = \", toliteral(downgraded));",
            "comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(downgraded), \".\")};",
            "endif",
            "if (rm)",
            "comment[1..0] = {tostr(\"Also removed \", namelist, \".\")};",
            "endif",
            "elseif ((old = $list_utils:assoc(target, $login.(\"temporary_\" + which)[1 + (!is_literal)])) && $login:(which + \"_remove_temp\")(target))",
            "player:notify(tostr(fullname, \" un\", which, \"ed.\"));",
            "if (!downgrade)",
            "elseif ($command_utils:yes_or_no(downgrade + \" it?\"))",
            "$login:(downgrade + \"_add_temp\")(target, old[2], old[3]) && (tempdowngraded = {target, @tempdowngraded});",
            "player:notify(tostr(fullname, \" \", downgrade, \"ed, currently for \", $time_utils:english_time(old[3]), \" from \", $time_utils:time_sub(\"$1/$3\", old[2])));",
            "else",
            "player:notify(tostr(fullname, \" not \", downgrade, \"ed.\"));",
            "endif",
            "if (tempdowngraded)",
            "comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(tempdowngraded), \"with durations transferred.\")};",
            "endif",
            "if (rmtemp)",
            "comment[1..0] = {tostr(\"Also removed \", tempnamelist, \".\")};",
            "endif",
            "elseif (rm || rmtemp)",
            "player:notify(tostr(fullname, \" itself was never actually \", which, \"ed.\"));",
            "comment[1..0] = {tostr(\"Removed \", namelist, \" from regular and \", tempnamelist, \" from temporary.\")};",
            "else",
            "player:notify(tostr(fullname, \" was not \", which, \"ed before.\"));",
            "return;",
            "endif",
            "subject = tostr(undo ? \"@un\" | \"@\", which, \" \", fullname);",
            "$mail_agent:send_message(player, $site_log, subject, comment);",
            "\"...\";",
            "\"... make sure we haven't screwed ourselves...\";",
            "uhoh = {};",
            "for site in (player.all_connect_places)",
            "if (index(site, target) && $login:(which + \"ed\")(site))",
            "uhoh = {@uhoh, site};",
            "endif",
            "endfor",
            "if (uhoh)",
            "player:notify(tostr(\"WARNING:  \", $string_utils:english_list(uhoh), \" are now \", which, \"ed!\"));",
            "endif"
          ]
        },
        {
          "name": "@corify",
          "owner": 2,
          "perms": 89,
          "preps": 13,
          "object": 57,
          "code": [
            "\"Usage:  @corify <object> as <propname>\";",
            "\"Adds <object> to the core, as $<propname>\";",
            "\"Reminds the wizard to write an :init_for_core verb, if there isn't one already.\";",
            "if (!player.wizard)",
            "player:tell(\"Sorry, the core is wizardly territory.\");",
            "return;",
            "endif",
            "if (dobj == $failed_match)",
            "dobj = player:my_match_object(dobjstr);",
            "endif",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "if (!iobjstr)",
            "player:tell(\"Usage:  @corify <object> as <propname>\");",
            "return;",
            "elseif (iobjstr[1] == \"$\")",
            "iobjstr = iobjstr[2..$];",
            "endif",
            "try",
            "add_property(#0, iobjstr, dobj, {player, \"r\"});",
            "except e (ANY)",
            "return player:tell(e[1], \":\", e[2]);",
            "endtry",
            "if (!(\"init_for_core\" in verbs(dobj)))",
            "player:tell(dobj:titlec(), \" has no :init_for_core verb.  Strongly consider adding one before doing anything else.\");",
            "else",
            "player:tell(\"Corified \", $string_utils:nn(dobj), \" as $\", iobjstr, \".\");",
            "endif"
          ]
        },
        {
          "name": "@make-guest",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 57,
          "code": [
            "\"Usage:  @make-guest <guestname>\";",
            "\"Creates a player called <guestname>_Guest owned by $hacker and a child of $guest. Or, if $local.guest exists, make a child of that, assuming that all other guests are children of it too.\";",
            "if (!player.wizard)",
            "player:tell(\"If you think this MOO needs more guests, you should contact a wizard.\");",
            "return E_PERM;",
            "endif",
            "if (length(args) != 1)",
            "player:tell(\"Usage: \", verb, \" <guest name>\");",
            "return;",
            "endif",
            "guest_parent = (($object_utils:has_property($local, \"guest\") && valid($local.guest)) && $object_utils:isa($local.guest, $guest)) ? $local.guest | $guest;",
            "i = length(children(guest_parent));",
            "while (!$player_db:available(guestnum = tostr(\"Guest\", i = i + 1)))",
            "endwhile",
            "guestname = args[1] + \"_Guest\";",
            "guestaliases = {guestname, adj = args[1], guestnum};",
            "if (!player.wizard)",
            "return;",
            "elseif ($player_db.frozen)",
            "player:tell(\"Sorry, the player db is frozen, so no players can be made right now.  Please try again in a few minutes.\");",
            "return;",
            "elseif (!$player_db:available(guestname))",
            "player:tell(\"\\\"\", guestname, \"\\\" is not an available name.\");",
            "return;",
            "elseif (!$player_db:available(adj))",
            "player:Tell(\"\\\"\", adj, \"\\\" is not an available name.\");",
            "return;",
            "else",
            "new = $quota_utils:bi_create(guest_parent, $hacker);",
            "new:set_name(guestname);",
            "new:set_aliases(guestaliases);",
            "if (!(e = $wiz_utils:set_player(new, 1)))",
            "player:Tell(\"Unable to make \", new.name, \" (\", new, \") a player.\");",
            "player:Tell(tostr(e));",
            "else",
            "player:Tell(\"Guest: \", new.name, \" (\", new, \") made.\");",
            "new.default_description = {\"By definition, guests appear nondescript.\"};",
            "new.description = new.default_description;",
            "new.last_connect_time = $maxint;",
            "new.last_disconnect_time = time();",
            "new.password = 0;",
            "new.size_quota = new.size_quota;",
            "new:set_gender(new.default_gender);",
            "move(new, $player_start);",
            "player:tell(\"Now don't forget to @describe \", new, \" as something.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@temp-newt",
          "owner": 2,
          "perms": 89,
          "preps": 11,
          "object": 57,
          "code": [
            "if (!player.wizard)",
            "return player:tell(\"Permission denied.\");",
            "elseif (!valid(who = $string_utils:match_player(dobjstr)))",
            "return $command_utils:player_match_failed(who, dobjstr);",
            "elseif (((dobjstr != who.name) && (!(dobjstr in who.aliases))) && (dobjstr != tostr(who)))",
            "return player:tell(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));",
            "elseif (who == player)",
            "player:notify(\"If you want to newt yourself, you have to do it by hand.\");",
            "return;",
            "elseif (!(howlong = $time_utils:parse_english_time_interval(iobjstr)))",
            "return player:tell(\"Can't parse time: \", howlong);",
            "else",
            "if (who in $login.newted)",
            "player:notify(tostr(who.name, \" appears to already be a newt.\"));",
            "else",
            "$wiz_utils:newt_player(who, \"\", (\"For \" + iobjstr) + \".  \");",
            "endif",
            "if (index = $list_utils:iassoc(who, $login.temporary_newts))",
            "$login.temporary_newts[index][2] = time();",
            "$login.temporary_newts[index][3] = howlong;",
            "else",
            "$login.temporary_newts = {@$login.temporary_newts, {who, time(), howlong}};",
            "endif",
            "player:tell(who.name, \" (\", who, \") will be a newt until \", ctime(time() + howlong));",
            "endif"
          ]
        },
        {
          "name": "@deprog*rammer",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"@deprogrammer victim [for <duration>] [reason]\";",
            "\"\";",
            "\"Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'.\";",
            "set_task_perms(player);",
            "if ((player != this) || (!player.wizard))",
            "player:notify(\"No go.\");",
            "return;",
            "endif",
            "if (!args)",
            "player:notify(tostr(\"Usage:  \", verb, \" <playername> [for <duration>] [reason]\"));",
            "endif",
            "fw = $string_utils:first_word(argstr);",
            "if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])",
            "if ((typeof(parse[3]) == ERR) || (!parse[3]))",
            "player:notify(tostr(\"Could not parse the duration for restricting programming for \", fw[1], \".\"));",
            "return;",
            "endif",
            "start = parse[2];",
            "duration = parse[3];",
            "reason = parse[4] ? {parse[4]} | {};",
            "else",
            "start = duration = 0;",
            "reason = fw[2] ? {fw[2]} | {};",
            "endif",
            "if (!reason)",
            "reason = {$command_utils:read(\"reason for resetting programmer flag\")};",
            "endif",
            "if (duration)",
            "reason = {tostr(\"for \", $time_utils:english_time(duration)), @reason};",
            "endif",
            "if ($command_utils:player_match_failed(victim = $string_utils:match_player(fw[1]), fw[1]))",
            "\"...done...\";",
            "elseif (result = $wiz_utils:unset_programmer(victim, reason, @start ? {start, duration} | {}))",
            "player:notify(tostr(victim.name, \" (\", victim, \") is no longer a programmer.\", duration ? tostr(\"  This restriction will be lifted in \", $string_utils:from_seconds(duration), \".\") | \"\"));",
            "elseif (result == E_NONE)",
            "player:notify(tostr(victim.name, \" (\", victim, \") was already a nonprogrammer...\"));",
            "else",
            "player:notify(tostr(result));",
            "endif"
          ]
        },
        {
          "name": "display_list",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "if ((caller != this) && (!caller_perms().wizard))",
            "return E_PERM;",
            "endif",
            "which = args[1];",
            "slist = {};",
            "if (s = $login.(which)[1])",
            "slist = {@slist, \"--- Subnets ---\", @s};",
            "endif",
            "if (s = $login.(which)[2])",
            "slist = {@slist, \"--- Domains ---\", @s};",
            "endif",
            "if (s = $login.(\"temporary_\" + which)[1])",
            "slist = {@slist, \"--- Temporary Subnets ---\"};",
            "for d in (s)",
            "slist = {@slist, tostr(d[1], \" until \", $time_utils:time_sub(\"$1/$3 $H:$M\", d[2] + d[3]))};",
            "$command_utils:suspend_if_needed(2);",
            "endfor",
            "endif",
            "if (s = $login.(\"temporary_\" + which)[2])",
            "slist = {@slist, \"--- Temporary Domains ---\"};",
            "for d in (s)",
            "slist = {@slist, tostr(d[1], \" until \", $time_utils:time_sub(\"$1/$3 $H:$M\", d[2] + d[3]))};",
            "$command_utils:suspend_if_needed(2);",
            "endfor",
            "endif",
            "if (slist)",
            "player:notify_lines($string_utils:columnize(slist, 2));",
            "else",
            "player:notify(tostr(\"The \", which, \" is empty.\"));",
            "endif"
          ]
        },
        {
          "name": "parse_templist_duration",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "\"parses out the time interval at the beginning of the args[1], assumes rest is commentary.\";",
            "if ((fw = $string_utils:first_word(args[1]))[1] == \"for\")",
            "words = $string_utils:words(fw[2]);",
            "try_ = {};",
            "ind = cont = 1;",
            "while (cont)",
            "word = words[ind];",
            "cont = ind;",
            "if (toint(word))",
            "try_ = {@try_, word};",
            "ind = ind + 1;",
            "else",
            "for set in ($time_utils.time_units)",
            "if (word in set)",
            "try_ = {@try_, word};",
            "ind = ind + 1;",
            "endif",
            "endfor",
            "endif",
            "if ((cont == ind) || (ind > length(words)))",
            "cont = 0;",
            "endif",
            "endwhile",
            "dur = $time_utils:parse_english_time_interval(@try_);",
            "rest = $string_utils:from_list(words[ind..$], \" \");",
            "return {1, time(), dur, rest};",
            "else",
            "return {0, argstr};",
            "endif"
          ]
        },
        {
          "name": "check_site_entries",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "\"Called by @[un]<color>list to check existence of the target site.\";",
            "\"=> {done okay, LIST of sites to remove}\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{undo, which, target, is_literal, entrylist} = args;",
            "rm = {};",
            "confirm = 0;",
            "if (is_literal)",
            "for s in (entrylist)",
            "if ((i = index(s, target + \".\")) == 1)",
            "\"... target is a prefix of s, s should probably go...\";",
            "rm = {@rm, s};",
            "elseif (index(target + \".\", s + \".\") != 1)",
            "\"... s is not a prefix of target...\";",
            "elseif (undo)",
            "player:notify(tostr(\"You will need to un\", which, \" subnet \", s, \" as well.\"));",
            "elseif (confirm)",
            "player:notify(tostr(\"...Subnet \", s, \" already \", which, \"ed...\"));",
            "else",
            "player:notify(tostr(\"Subnet \", s, \" already \", which, \"ed.\"));",
            "if (!(confirm = $command_utils:yes_or_no(tostr(which, \" \", target, \" anyway?\"))))",
            "return {0, {}};",
            "endif",
            "endif",
            "endfor",
            "else",
            "for s in (entrylist)",
            "if ((i = rindex(s, \".\" + target)) && (i == (length(s) - length(target))))",
            "\"... target is a suffix of s, s should probably go...\";",
            "rm = {@rm, s};",
            "elseif ((!(i = rindex(\".\" + target, \".\" + s))) || (i < ((length(target) - length(s)) + 1)))",
            "\"... s is not a suffix of target...\";",
            "elseif (undo)",
            "player:notify(tostr(\"You will need to un\", which, \" domain `\", s, \"' as well.\"));",
            "elseif (confirm)",
            "player:notify(tostr(\"...Domain `\", s, \"' already \", which, \"ed...\"));",
            "else",
            "player:notify(tostr(\"Domain `\", s, \"' already \", which, \"ed.\"));",
            "if (!(confirm = $command_utils:yes_or_no(tostr(which, \" \", target, \" anyway?\"))))",
            "return {0, {}};",
            "endif",
            "endif",
            "endfor",
            "endif",
            "return {1, rm};"
          ]
        },
        {
          "name": "@lock-login @unlock-login @lock-login!",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"Syntax:  @lock-login <message>\";",
            "\"         @lock-login! <message>\";",
            "\"         @unlock-login\";",
            "\"\";",
            "\"The @lock-login calls prevent all non-wizard users from logging in, displaying <message> to them when they try.  (The second syntax, with @lock-login!, additionally boots any nonwizards who are already connected.)  @unlock-login turns this off.\";",
            "if (caller != this)",
            "raise(E_PERM);",
            "elseif (verb[2] == \"u\")",
            "$login.no_connect_message = 0;",
            "player:notify(\"Login restrictions removed.\");",
            "elseif (!argstr)",
            "player:notify(\"You must provide some message to display to users who attempt to login:  @lock-login <message>\");",
            "else",
            "$login.no_connect_message = argstr;",
            "player:notify(tostr(\"Logins are now blocked for non-wizard players.  Message displayed when attempted:  \", $login.no_connect_message));",
            "if (verb == \"@lock-login!\")",
            "wizards = $wiz_utils:all_wizards_unadvertised();",
            "for x in (connected_players())",
            "if (!(x in wizards))",
            "boot_player(x);",
            "endif",
            "endfor",
            "player:notify(\"All nonwizards have been booted.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "__fix",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "\"...was on $player, now archived here for posterity...\";",
            "\"Runs the old->new format conversion on every message in this.messages.\";",
            "\" => 1 if successful\";",
            "\" => 0 if anything toward happened during a suspension\";",
            "\"      (e.g., new message received, someone deleted stuff) \";",
            "\"      in which case this.messages is left as if this routine were never run.\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "endif",
            "msgs = {};",
            "i = 1;",
            "for m in (oldmsgs = this.messages)",
            "msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", i, \" \", this));",
            "suspend(0);",
            "if (oldmsgs != this.messages)",
            "return 0;",
            "endif",
            "endif",
            "i = i + 1;",
            "endfor",
            "this.messages = msgs;",
            "return 1;"
          ]
        },
        {
          "name": "toad_cleanup",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 57,
          "code": [
            "if ((!player.wizard) || (caller != this))",
            "raise(E_PERM);",
            "endif",
            "\"Noop. Placeholder verb for MOO-specific cleanups.\";"
          ]
        },
        {
          "name": "@code-replace",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 57,
          "code": [
            "if (!player.wizard)",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "player:tell(\"What string are you replacing?\");",
            "old = $command_utils:read();",
            "if (old == \"\")",
            "return player:tell(\"You can't replace an empty string.\");",
            "endif",
            "player:tell(\"What string are you replacing it with?\");",
            "new = $command_utils:read();",
            "if (new == \"\")",
            "return player:tell(\"You can't replace it with an empty string.\");",
            "endif",
            "if ($command_utils:yes_or_no(tostr(\"You are about to replace \", old, \" with \", new, \" in all verbs. Are you sure you want to do this? Be very sure.\")) == 1)",
            "player:tell(\"Working...\");",
            "total = 0;",
            "for o in [#0..max_object()]",
            "yin();",
            "if (!valid(o))",
            "continue;",
            "endif",
            "verbs = verbs(o);",
            "if (verbs == {})",
            "continue;",
            "endif",
            "for v in (verbs)",
            "code = verb_code(o, v);",
            "replaced = 0;",
            "old_line = new_line = {};",
            "for l in [1..length(code)]",
            "yin();",
            "if (!index(code[l], old))",
            "continue;",
            "endif",
            "old_line = {@old_line, code[l]};",
            "code[l] = strsub(code[l], old, new);",
            "new_line = {@new_line, code[l]};",
            "replaced = replaced + 1;",
            "endfor",
            "\"Try to compile the new code if it has any replaced lines.\";",
            "if (replaced)",
            "result = set_verb_code(o, v, code);",
            "if (typeof(result) == ERR)",
            "player:tell(\"Could not compile code for \", $string_utils:nn(o), \":\", v, \". \", toliteral(result));",
            "else",
            "player:tell(\"... replaced code in \", o, \":\", v, \":\");",
            "for pew in [1..length(old_line)]",
            "player:tell(\"   \", old_line[pew]);",
            "player:tell(\"   \", new_line[pew]);",
            "endfor",
            "total = total + 1;",
            "endif",
            "endif",
            "yin();",
            "endfor",
            "yin();",
            "endfor",
            "player:tell(\"Done. \", total, \" verbs replaced.\");",
            "else",
            "return player:tell(\"Aborted.\");",
            "endif"
          ]
        },
        {
          "name": "@update-toaststunt-help",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 57,
          "code": [
            "\"Automatically updates ToastStunt documentation to the latest version.\";",
            "\"Optional arguments:\";",
            "\"   -y: Answer yes to all prompts that update the help database.\";",
            "\"   <database>: The name, or object number, of the help database object that you want to update. The verb itself typically finds, or creates, an appropriate database for you, so this argument is generally not necessary.\";",
            "if (player != this)",
            "return E_PERM;",
            "endif",
            "\"Check prerequisites:\";",
            "if (typeof(`function_info(\"curl\") ! E_INVARG') == ERR)",
            "return player:tell(\"This verb relies on the curl builtin function to retrieve up-to-date documentation. Please ensure that the server has been compiled with the function enabled. You may need to install a supporting library, such as libcurl. Further information may be available here: https://github.com/lisdude/toaststunt/blob/master/docs/README.md#build-instructions\");",
            "endif",
            "required_verbs = {{$object_utils, \"has_property\"}, {$player, \"my_match_object\"}, {$command_utils, \"object_match_failed\"}, {$string_utils, \"nn\"}, {$command_utils, \"yes_or_no\"}, {$recycler, \"_create\"}, {$string_utils, \"english_list\"}, {$list_utils, \"map_builtin\"}};",
            "required_props = {{$sysobj, \"generic_help\"}, {$sysobj, \"prog\"}};",
            "for x in (required_verbs)",
            "if (typeof(`verb_info(@x) ! E_VERBNF') == ERR)",
            "return player:tell(\"This verb relies on several LambdaCore verbs being present. It seems your database is missing: \", x[1], \":\", x[2]);",
            "endif",
            "endfor",
            "for x in (required_props)",
            "if (typeof(`property_info(@x) ! E_PROPNF') == ERR)",
            "return player:tell(\"This verb relies on several LambdaCore properties being present. It seems your database is missing: \", x[1], \".\", x[2]);",
            "endif",
            "endfor",
            "\"Now do a special test for builtin_function help. Standard LambdaCore stores this in a property on $sysobj. ToastCore stores it in a map on $sysobj.\";",
            "if ($object_utils:has_property($sysobj, \"builtin_function_help\"))",
            "builtin_function_help = $builtin_function_help;",
            "elseif ($object_utils:has_property($sysobj, \"help_db\") && maphaskey($help_db, \"builtin_function\"))",
            "builtin_function_help = $help_db[\"builtin_function\"];",
            "else",
            "\"Not a fatal error, but we won't be able to check our priority\";",
            "builtin_function_help = $failed_match;",
            "endif",
            "\"In lieu of proper flag parsing, we'll simply look for the only flag(s) we know exist.\";",
            "yes_to_all = 0;",
            "pcre_yes_match = \"\\\\s?-y\\\\s?\";",
            "pcre_yes_replacement = tostr(\"s/\", pcre_yes_match, \"//g\");",
            "if (args && pcre_match(argstr, pcre_yes_match))",
            "yes_to_all = 1;",
            "argstr = pcre_replace(argstr, pcre_yes_replacement);",
            "if (argstr == \"\")",
            "args = 0;",
            "endif",
            "endif",
            "\"Check if the update verb itself needs updated. (This does its own prerequisite checking because these functions aren't, strictly speaking, required for the main help update to succeed.)\";",
            "if ((typeof(`verb_info($list_utils, \"setremove_all\") ! E_VERBNF') != ERR) && (typeof(`verb_info($object_utils, \"has_verb\") ! E_VERBNF') != ERR))",
            "verb_loc = $object_utils:has_verb(this, verb)[1];",
            "if (player.wizard || (verb_info(verb_loc, verb)[1] == player))",
            "update_url = \"https://raw.githubusercontent.com/lisdude/toaststunt-documentation/master/update_verb.moo\";",
            "downloaded_data = call_function(\"curl\", update_url);",
            "if (typeof(downloaded_data) == MAP)",
            "player:tell(\"Update check failed: \", downloaded_data[\"message\"]);",
            "elseif (!index(downloaded_data, \"@update-toaststunt-help\"))",
            "player:tell(\"Update check failed: The update data does not appear to be valid.\");",
            "else",
            "new_verb = $list_utils:setremove_all(decode_binary(downloaded_data), 10)[3..$ - 1];",
            "if (((new_verb != {}) && (new_verb != verb_code(verb_loc, verb))) && ($command_utils:yes_or_no(tostr(\"There is an update available for this verb. Would you like to apply it? You can review the updated code here: \", update_url)) == 1))",
            "set_verb_code(verb_loc, verb, new_verb);",
            "return player:tell(\"This verb has been updated. Please run it again.\");",
            "endif",
            "endif",
            "endif",
            "endif",
            "\"Try to identify an existing help database either by name or by input from the wizard.\";",
            "db = 0;",
            "if (!args)",
            "for x in (children($generic_help))",
            "if (x.name == \"ToastStunt Help Database\")",
            "db = x;",
            "break;",
            "endif",
            "endfor",
            "else",
            "match = player:my_match_object(argstr);",
            "if ($command_utils:object_match_failed(match, argstr))",
            "return;",
            "elseif (isa(match, $generic_help))",
            "db = match;",
            "else",
            "return player:tell($string_utils:nn(match), \" doesn't appear to be a help database.\");",
            "endif",
            "endif",
            "\"If we failed, create a new database and add it to $prog help.\";",
            "if (db == 0)",
            "if ($command_utils:yes_or_no(\"No existing help database could be found. Would you like to create one?\") == 1)",
            "db = $recycler:_create($generic_help);",
            "db:set_name(\"ToastStunt Help Database\");",
            "if (player.wizard && ($command_utils:yes_or_no(\"Would you like to add the new database to $prog.help?\") == 1))",
            "$prog.help = setadd($prog.help, db);",
            "endif",
            "else",
            "return player:tell(\"Not creating a new database.\");",
            "endif",
            "endif",
            "\"Test if our help database has a higher priority than the LambdaCore builtin function help database. If not, offer to make it so.\";",
            "if ((builtin_function_help != $failed_match) && ((db in $prog.help) > (builtin_function_help in $prog.help)))",
            "if ($command_utils:yes_or_no(\"Would you like the ToastStunt help to take priority over LambdaCore help? This means that duplicate help files (such as move()) will prefer the ToastStunt version over the LambdaCore version.\") == 1)",
            "$prog.help = setremove($prog.help, db);",
            "$prog.help = {db, @$prog.help};",
            "endif",
            "endif",
            "\"Finally, actually update the help files.\";",
            "if ((!yes_to_all) && ($command_utils:yes_or_no(tostr(\"Do you want to update the help database \", $string_utils:nn(db), \"?\")) != 1))",
            "return player:tell(\"Not updating.\");",
            "endif",
            "if ((!player.wizard) && (db.owner != player))",
            "return player:tell(\"You don't have permission to update \", $string_utils:nn(db), \".\");",
            "endif",
            "url = \"https://raw.githubusercontent.com/lisdude/toaststunt-documentation/master/function_help.moo\";",
            "data = call_function(\"curl\", url);",
            "if (typeof(data) == MAP)",
            "return player:tell(\"Error retrieving help text: \", data[\"message\"]);",
            "else",
            "regex = \"^;;#123\\\\.\\\\(\\\"(?<property>.+)\\\"\\\\) = (?<value>.+)$\";",
            "data = decode_binary(data);",
            "added = removed = updated = {};",
            "properties = [];",
            "for x in (data)",
            "if (typeof(x) != STR)",
            "continue;",
            "endif",
            "if (match = pcre_match(x, regex))",
            "\"As there's no guarantee that to_value will suspend (and, in the core, it will not), and since we have no way of knowing how many ticks any given help entry will require to parse, we give ourselves the best possible chance of having enough ticks by staring over for each entry. Fortunately, speed is not a requirement.\";",
            "suspend(0);",
            "{property, value} = {match[1][\"property\"][\"match\"], $string_utils:to_value(match[1][\"value\"][\"match\"])};",
            "if (value[1] != 1)",
            "player:tell(\"Error parsing value for `\", property, \"'.\");",
            "continue;",
            "else",
            "value = value[2];",
            "endif",
            "properties[property] = value;",
            "endif",
            "endfor",
            "\"Check for properties that no longer exist in the remote.\";",
            "for local_prop in (properties(db))",
            "yin();",
            "if (!maphaskey(properties, local_prop))",
            "if (yes_to_all || ($command_utils:yes_or_no(tostr(\"The property `\", local_prop, \"' no longer exists in the remote repository. Do you wish to delete the local version?\")) == 1))",
            "removed = setadd(removed, local_prop);",
            "delete_property(db, local_prop);",
            "endif",
            "endif",
            "endfor",
            "for value, property in (properties)",
            "if ($object_utils:has_property(db, property))",
            "if (db.(property) != value)",
            "updated = setadd(updated, property);",
            "db.(property) = value;",
            "endif",
            "else",
            "add_property(db, property, value, {db.owner, \"rc\"});",
            "added = setadd(added, property);",
            "endif",
            "endfor",
            "player:tell(\"Done! \", (((added == {}) && (updated == {})) && (removed == {})) ? \"No changes found.\" | tostr(\"Added: \", $string_utils:english_list(added), \". Updated: \", $string_utils:english_list(updated), \".\", (removed == {}) ? \"\" | tostr(\" Removed: \", $string_utils:english_list(removed), \".\")));",
            "endif"
          ]
        }
      ],
      "propnames": [
        "newt_victim_msg",
        "newt_msg",
        "public_identity",
        "programmer_msg",
        "programmer_victim_msg",
        "toad_victim_msg",
        "toad_msg",
        "mail_identity",
        "advertised"
      ],
      "propdefs": [
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n @newts %d (%[#d])",
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%d is now a programmer.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "You are now a programmer.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Have a nice life...",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n @toads %d (%[#d])",
          "owner": 2,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 2,
          "perms": 4
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 23,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "really impossible password to type",
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "player"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "You see a wizard who chooses not to reveal its true appearance.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            85474,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "58": {
      "id": 58,
      "name": "generic programmer",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        4
      ],
      "children": [
        57,
        36,
        71,
        98
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@prop*erty",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (!player.programmer)",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "elseif (!$quota_utils:property_addition_permitted(player))",
            "player:tell(\"Property addition not permitted because quota exceeded.\");",
            "return;",
            "endif",
            "nargs = length(args);",
            "usage = tostr(\"Usage:  \", verb, \" <object>.<prop-name> [<init_value> [<perms> [<owner>]]]\");",
            "if ((nargs < 1) || (!(spec = $code_utils:parse_propref(args[1]))))",
            "player:notify(usage);",
            "return;",
            "endif",
            "object = player:my_match_object(spec[1]);",
            "name = spec[2];",
            "if ($command_utils:object_match_failed(object, spec[1]))",
            "return;",
            "endif",
            "if (nargs < 2)",
            "value = 0;",
            "else",
            "q = $string_utils:prefix_to_value(argstr[$string_utils:word_start(argstr)[2][1]..$]);",
            "if (q[1] == 0)",
            "player:notify(tostr(\"Syntax error in initial value:  \", q[2]));",
            "return;",
            "endif",
            "value = q[2];",
            "args = {args[1], value, @$string_utils:words(q[1])};",
            "nargs = length(args);",
            "endif",
            "default = player:prog_option(\"@prop_flags\");",
            "if (!default)",
            "default = \"rc\";",
            "endif",
            "perms = (nargs < 3) ? default | $perm_utils:apply(default, args[3]);",
            "if (nargs < 4)",
            "owner = player;",
            "else",
            "owner = $string_utils:match_player(args[4]);",
            "if ($command_utils:player_match_result(owner, args[4])[1])",
            "return;",
            "endif",
            "endif",
            "if (nargs > 4)",
            "player:notify(usage);",
            "return;",
            "endif",
            "try",
            "add_property(object, name, value, {owner, perms});",
            "player:notify(tostr(\"Property added with value \", toliteral(object.(name)), \".\"));",
            "except (E_INVARG)",
            "if ($object_utils:has_property(object, name))",
            "player:notify(tostr(\"Property \", object, \".\", name, \" already exists.\"));",
            "else",
            "for i in [1..length(perms)]",
            "if (!index(\"rcw\", perms[i]))",
            "player:notify(tostr(\"Unknown permission bit:  \", perms[i]));",
            "return;",
            "endif",
            "endfor",
            "\"...the only other possibility...\";",
            "player:notify(\"Property is already defined on one or more descendents.\");",
            "player:notify(tostr(\"Try @check-prop \", args[1]));",
            "endif",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry"
          ]
        },
        {
          "name": "@chmod*#",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "bynumber = verb == \"@chmod#\";",
            "if (length(args) != 2)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb> <permissions>\"));",
            "return;",
            "endif",
            "{what, perms} = args;",
            "if (spec = $code_utils:parse_verbref(what))",
            "if (!player.programmer)",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "endif",
            "if (valid(object = player:my_match_object(spec[1])))",
            "vname = spec[2];",
            "if (bynumber)",
            "vname = $code_utils:toint(vname);",
            "if (vname == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "endif",
            "try",
            "info = verb_info(object, vname);",
            "if (!valid(owner = info[1]))",
            "player:notify(tostr(\"That verb is owned by an invalid object (\", owner, \"); it needs to be @chowned.\"));",
            "elseif (!is_player(owner))",
            "player:notify(tostr(\"That verb is owned by a non-player object (\", owner.name, \", \", owner, \"); it needs to be @chowned.\"));",
            "else",
            "info[2] = perms = $perm_utils:apply(info[2], perms);",
            "try",
            "result = set_verb_info(object, vname, info);",
            "player:notify(tostr(\"Verb permissions set to \\\"\", perms, \"\\\".\"));",
            "except (E_INVARG)",
            "player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for a verb.\"));",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif",
            "except (E_VERBNF)",
            "player:notify(\"That object does not define that verb.\");",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "return;",
            "endif",
            "elseif (bynumber)",
            "return player:notify(\"@chmod# can only be used for verbs.\");",
            "elseif (index(what, \".\") && (spec = $code_utils:parse_propref(what)))",
            "if (valid(object = player:my_match_object(spec[1])))",
            "pname = spec[2];",
            "try",
            "info = property_info(object, pname);",
            "info[2] = perms = $perm_utils:apply(info[2], perms);",
            "try",
            "result = set_property_info(object, pname, info);",
            "player:notify(tostr(\"Property permissions set to \\\"\", perms, \"\\\".\"));",
            "except (E_INVARG)",
            "player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for a property.\"));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "except (E_PROPNF)",
            "player:notify(\"That object does not have that property.\");",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "return;",
            "endif",
            "elseif (valid(object = player:my_match_object(what)))",
            "perms = $perm_utils:apply(((object.r ? \"r\" | \"\") + (object.w ? \"w\" | \"\")) + (object.f ? \"f\" | \"\"), perms);",
            "r = w = f = 0;",
            "for i in [1..length(perms)]",
            "if (perms[i] == \"r\")",
            "r = 1;",
            "elseif (perms[i] == \"w\")",
            "w = 1;",
            "elseif (perms[i] == \"f\")",
            "f = 1;",
            "else",
            "player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for an object.\"));",
            "return;",
            "endif",
            "endfor",
            "try",
            "object.r = r;",
            "object.w = w;",
            "object.f = f;",
            "player:notify(tostr(\"Object permissions set to \\\"\", perms, \"\\\".\"));",
            "except (E_PERM)",
            "player:notify(\"Permission denied.\");",
            "endtry",
            "return;",
            "endif",
            "$command_utils:object_match_failed(object, what);"
          ]
        },
        {
          "name": "@args*#",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "if (player != caller)",
            "return;",
            "endif",
            "set_task_perms(player);",
            "if (!player.programmer)",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "endif",
            "if (!(args && (spec = $code_utils:parse_verbref(args[1]))))",
            "player:notify(tostr(args ? (\"\\\"\" + args[1]) + \"\\\"?  \" | \"\", \"<object>:<verb>  expected.\"));",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "\"...can't find object...\";",
            "else",
            "if (verb == \"@args#\")",
            "name = $code_utils:toint(spec[2]);",
            "if (name == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((name < 1) || `name > length(verbs(object)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "else",
            "name = spec[2];",
            "endif",
            "try",
            "info = verb_args(object, name);",
            "if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)",
            "\"...arg spec is bogus...\";",
            "player:notify(tostr(pas));",
            "elseif (!(newargs = pas[1]))",
            "player:notify($string_utils:from_list(info, \" \"));",
            "elseif (pas[2])",
            "player:notify(tostr(\"\\\"\", pas[2][1], \"\\\" unexpected.\"));",
            "else",
            "info[2] = info[2][1..index(info[2] + \"/\", \"/\") - 1];",
            "info = {@newargs, @info[length(newargs) + 1..$]};",
            "try",
            "result = set_verb_args(object, name, info);",
            "player:notify(\"Verb arguments changed.\");",
            "except (E_INVARG)",
            "player:notify(tostr(\"\\\"\", info[2], \"\\\" is not a valid preposition (?)\"));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "endif",
            "except (E_VERBNF)",
            "player:notify(\"That object does not have a verb with that name.\");",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "eval*-d",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"A MOO-code evaluator.  Type `;CODE' or `eval CODE'.\";",
            "\"Calls player:eval_cmd_string to first transform CODE in any way appropriate (e.g., prefixing .eval_env) and then do the actual evaluation.  See documentation for this:eval_cmd_string\";",
            "\"If you set your .eval_time property to 1, you find out how many ticks and seconds you used.\";",
            "\"If eval-d is used, the evaluation is performed as if the debug flag were unset.\";",
            "if (player != this)",
            "player:tell(\"I don't understand that.\");",
            "return;",
            "elseif (!player.programmer)",
            "player:tell(\"You need to be a programmer to eval code.\");",
            "return;",
            "endif",
            "set_task_perms(player);",
            "result = player:eval_cmd_string(argstr, verb != \"eval-d\");",
            "if (result[1])",
            "player:notify(this:eval_value_to_string(result[2]));",
            "if (player:prog_option(\"eval_time\") && (!`output_delimiters(player)[2] ! ANY'))",
            "player:notify(tostr(\"[used \", result[3], \" tick\", (result[3] != 1) ? \"s, \" | \", \", result[4], \" second\", (result[4] != 1) ? \"s\" | \"\", \".]\"));",
            "endif",
            "else",
            "player:notify_lines(result[2]);",
            "nerrors = length(result[2]);",
            "player:notify(tostr(nerrors, \" error\", (nerrors == 1) ? \".\" | \"s.\"));",
            "endif"
          ]
        },
        {
          "name": "@rmprop*erty",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if ((length(args) != 1) || (!(spec = $code_utils:parse_propref(args[1]))))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>.<property>\"));",
            "return;",
            "endif",
            "object = player:my_match_object(spec[1]);",
            "pname = spec[2];",
            "if ($command_utils:object_match_failed(object, spec[1]))",
            "return;",
            "endif",
            "try",
            "result = delete_property(object, pname);",
            "player:notify(\"Property removed.\");",
            "except (E_PROPNF)",
            "player:notify(\"That object does not define that property.\");",
            "except res (ANY)",
            "player:notify(res[2]);",
            "endtry"
          ]
        },
        {
          "name": "@verb",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (!player.programmer)",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "elseif (!$quota_utils:verb_addition_permitted(player))",
            "player:tell(\"Verb addition not permitted because quota exceeded.\");",
            "return;",
            "endif",
            "if (!(args && (spec = $code_utils:parse_verbref(args[1]))))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb-name(s)> [<dobj> [<prep> [<iobj> [<permissions> [<owner>]]]]]\"));",
            "return;",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "return;",
            "endif",
            "name = spec[2];",
            "\"...Adding another verb of the same name is often a mistake...\";",
            "namelist = $string_utils:explode(name);",
            "for n in (namelist)",
            "if (i = index(n, \"*\"))",
            "n = n[1..i - 1] + n[i + 1..$];",
            "endif",
            "if ((hv = $object_utils:has_verb(object, n)) && (hv[1] == object))",
            "player:notify(tostr(\"Warning:  Verb `\", n, \"' already defined on that object.\"));",
            "endif",
            "endfor",
            "if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)",
            "player:notify(tostr(pas));",
            "return;",
            "endif",
            "verbargs = pas[1] || (player:prog_option(\"verb_args\") || {});",
            "verbargs = {@verbargs, \"none\", \"none\", \"none\"}[1..3];",
            "rest = pas[2];",
            "if (verbargs == {\"this\", \"none\", \"this\"})",
            "perms = player:prog_option(\"verb_perms\") || \"rxd\";",
            "if (!index(perms, \"x\"))",
            "perms = perms + \"x\";",
            "endif",
            "else",
            "perms = player:prog_option(\"verb_perms\") || \"rd\";",
            "endif",
            "if (rest)",
            "perms = $perm_utils:apply(perms, rest[1]);",
            "endif",
            "if (length(rest) < 2)",
            "owner = player;",
            "elseif (length(rest) > 2)",
            "player:notify(tostr(\"\\\"\", rest[3], \"\\\" unexpected.\"));",
            "return;",
            "elseif ($command_utils:player_match_result(owner = $string_utils:match_player(rest[2]), rest[2])[1])",
            "return;",
            "elseif (owner == $nothing)",
            "player:notify(\"Verb can't be owned by no one!\");",
            "return;",
            "endif",
            "try",
            "x = add_verb(object, {owner, perms, name}, verbargs);",
            "player:notify(tostr(\"Verb added (\", (x > 0) ? x | length($object_utils:accessible_verbs(object)), \").\"));",
            "except (E_INVARG)",
            "player:notify(tostr(rest ? tostr(\"\\\"\", perms, \"\\\" is not a valid set of permissions.\") | tostr(\"\\\"\", verbargs[2], \"\\\" is not a valid preposition (?)\")));",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry"
          ]
        },
        {
          "name": "@rmverb*#",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (!(args && (spec = $code_utils:parse_verbref(args[1]))))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb>\"));",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "\"...bogus object...\";",
            "elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)",
            "player:notify(tostr(argspec));",
            "elseif (argspec[2])",
            "player:notify($string_utils:from_list(argspec[2], \" \") + \"??\");",
            "elseif (length(argspec = argspec[1]) in {1, 2})",
            "player:notify({\"Missing preposition\", \"Missing iobj specification\"}[length(argspec)]);",
            "else",
            "verbname = spec[2];",
            "if (verb == \"@rmverb#\")",
            "loc = $code_utils:toint(verbname);",
            "if (loc == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((loc < 1) || (loc > `length(verbs(object)) ! E_PERM => 0'))",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "else",
            "if (index(verbname, \"*\") > 1)",
            "verbname = strsub(verbname, \"*\", \"\");",
            "endif",
            "loc = $code_utils:find_last_verb_named(object, verbname);",
            "if (argspec)",
            "argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];",
            "while ((loc != -1) && (`verb_args(object, loc) ! ANY' != argspec))",
            "loc = $code_utils:find_last_verb_named(object, verbname, loc - 1);",
            "endwhile",
            "endif",
            "if (loc < 0)",
            "player:notify(tostr(\"That object does not define that verb\", argspec ? \" with those args.\" | \".\"));",
            "return;",
            "endif",
            "endif",
            "info = `verb_info(object, loc) ! ANY';",
            "vargs = `verb_args(object, loc) ! ANY';",
            "vcode = `verb_code(object, loc, 1, 1) ! ANY';",
            "try",
            "delete_verb(object, loc);",
            "if (info)",
            "player:notify(tostr(\"Verb \", object, \":\", info[3], \" (\", loc, \") {\", $string_utils:from_list(vargs, \" \"), \"} removed.\"));",
            "if (player:prog_option(\"rmverb_mail_backup\"))",
            "$mail_agent:send_message(player, player, tostr(object, \":\", info[3], \" (\", loc, \") {\", $string_utils:from_list(vargs, \" \"), \"}\"), vcode);",
            "endif",
            "else",
            "player:notify(tostr(\"Unreadable verb \", object, \":\", loc, \" removed.\"));",
            "endif",
            "except e (ANY)",
            "player:notify(e[2]);",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "@forked*-verbose",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"Syntax:  @forked [player]\";",
            "\"         @forked all wizards\";",
            "\"\";",
            "\"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. @forked-v*erbose will show the full callers() stack for each task that has suspended (not a fresh fork).\";",
            "\"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.\";",
            "set_task_perms(player);",
            "verbose = $code_utils:verbname_match(\"@forked-v*erbose\", verb);",
            "if (!dobjstr)",
            "tasks = queued_tasks();",
            "elseif ((dobjstr == \"all wizards\") && player.wizard)",
            "tasks = {};",
            "for t in (queued_tasks())",
            "if (valid(t[5]) && t[5].wizard)",
            "tasks = {@tasks, t};",
            "endif",
            "$command_utils:suspend_if_needed(1);",
            "endfor",
            "elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])",
            "return;",
            "elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)",
            "player:notify(tostr(verb, \" \", dobj.name, \"(\", dobj, \"):  \", tasks));",
            "return;",
            "endif",
            "if (tasks)",
            "su = $string_utils;",
            "player:notify(\"Queue ID    Start Time            Owner         {Size} Verb (Line) [This]\");",
            "player:notify(\"--------    ----------            -----         -----------------\");",
            "now = time();",
            "for task in (tasks)",
            "$command_utils:suspend_if_needed(0);",
            "{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;",
            "if (typeof(start) == STR)",
            "time = start;",
            "else",
            "time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? \"Reading input ...\" | tostr(now - start, \" seconds ago...\"), 20);",
            "endif",
            "owner_name = valid(owner) ? owner.name | tostr(\"Dead \", owner);",
            "player:notify(tostr(su:left(tostr(q_id), 10), \"  \", time, \"  \", su:left(owner_name, 12), \"  {\", $building_utils:size_string(size), \"} \", vloc, \":\", vname, \" (\", lineno, \")\", (this != vloc) ? tostr(\" [\", this, \"]\") | \"\"));",
            "if (verbose || (index(vname, \"suspend\") && (vloc == $command_utils)))",
            "\"Display the first (or, if verbose, every) line of the callers() list, which is gotten by taking the second through last elements of task_stack().\";",
            "stack = `task_stack(q_id, 1) ! E_INVARG => {}';",
            "for frame in (stack[2..verbose ? $ | 2])",
            "{sthis, svname, sprogger, svloc, splayer, slineno} = frame;",
            "player:notify(tostr(\"                    Called By...  \", su:left(valid(sprogger) ? sprogger.name | tostr(\"Dead \", sprogger), 19), \"  \", svloc, \":\", svname, (sthis != svloc) ? tostr(\" [\", sthis, \"]\") | \"\", \" (\", slineno, \")\"));",
            "endfor",
            "endif",
            "endfor",
            "player:notify(\"-----------------------------------------------------------------\");",
            "else",
            "player:notify(\"No tasks.\");",
            "endif"
          ]
        },
        {
          "name": "@kill @killq*uiet",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"Kills one or more tasks.\";",
            "\"Arguments:\";",
            "\"   object:verb -- kills all tasks which were started from that object and verb.\";",
            "\"   all -- kills all tasks owned by invoker\";",
            "\"   all player-name -- wizard variant:  kills all tasks owned by player.\";",
            "\"   all everyone -- wizard variant:  really kills all tasks.\";",
            "\"   Integer taskid -- kills the specifically named task.\";",
            "\"   soon [integer] -- kills all tasks scheduled to run in the next [integer] seconds, which defaults to 60.\";",
            "\"   %integer -- kills all tasks which end in the digits contained in integer.\";",
            "\"   The @killquiet alias kills tasks without the pretty printout if more than one task is being killed.\";",
            "set_task_perms(player);",
            "quiet = index(verb, \"q\");",
            "if (length(args) == 0)",
            "player:notify_lines({tostr(\"Usage:  \", verb, \" [object]:[verb]\"), tostr(\"        \", verb, \" task_id\"), tostr(\"        \", verb, \" soon [number-of-seconds]\", player.wizard ? \" [everyone|<player name>]\" | \"\"), tostr(\"        \", verb, \" all\", player.wizard ? \" [everyone|<player name>]\" | \"\")});",
            "return;",
            "elseif (taskid = toint(args[1]))",
            "elseif (all = args[1] == \"all\")",
            "everyone = 0;",
            "realplayer = player;",
            "if (player.wizard && (length(args) > 1))",
            "realplayer = $string_utils:match_player(args[2]);",
            "everyone = args[2] == \"everyone\";",
            "if ((!valid(realplayer)) && (!everyone))",
            "$command_utils:player_match_result(realplayer, args[2]);",
            "return;",
            "elseif (!everyone)",
            "set_task_perms(realplayer);",
            "endif",
            "endif",
            "elseif (soon = args[1] == \"soon\")",
            "realplayer = player;",
            "if (length(args) > 1)",
            "soon = toint(args[2]);",
            "if ((soon <= 0) && (!player.wizard))",
            "player:notify(tostr(\"Usage:  \", verb, \" soon [positive-number-of-seconds]\"));",
            "return;",
            "elseif (player.wizard)",
            "result = this:kill_aux_wizard_parse(@args[2..$]);",
            "soon = result[1];",
            "if (result[1] < 0)",
            "\"already gave them an error message\";",
            "return;",
            "elseif (result[2] == 1)",
            "everyone = 1;",
            "else",
            "everyone = 0;",
            "set_task_perms(result[2]);",
            "realplayer = result[2];",
            "endif",
            "endif",
            "else",
            "soon = 60;",
            "everyone = 0;",
            "endif",
            "elseif (percent = args[1][1] == \"%\")",
            "l = length(args[1]);",
            "digits = toint(args[1][2..l]);",
            "percent = toint(\"1\" + \"0000000000\"[1..l - 1]);",
            "elseif (colon = index(argstr, \":\"))",
            "whatstr = argstr[1..colon - 1];",
            "vrb = argstr[colon + 1..$];",
            "if (whatstr)",
            "what = player:my_match_object(whatstr);",
            "endif",
            "else",
            "player:notify_lines({tostr(\"Usage:  \", verb, \" [object]:[verb]\"), tostr(\"        \", verb, \" task_id\"), tostr(\"        \", verb, \" soon [number-of-seconds]\", player.wizard ? \" [everyone|<player name>]\" | \"\"), tostr(\"        \", verb, \" all\", player.wizard ? \" [\\\"everyone\\\"|<player name>]\" | \"\")});",
            "return;",
            "endif",
            "\"OK, parsed the line, and punted them if it was bogus.  This verb could have been a bit shorter at the expense of readability.  I think it's getting towards unreadable as is.  At this point we've set_task_perms'd, and set up an enormous number of local variables.  Evaluate them in the order we set them, and we should never get var not found.\";",
            "queued_tasks = queued_tasks();",
            "killed = 0;",
            "if (taskid)",
            "try",
            "kill_task(taskid);",
            "player:notify(tostr(\"Killed task \", taskid, \".\"));",
            "killed = 1;",
            "except error (ANY)",
            "player:notify(tostr(\"Can't kill task \", taskid, \": \", error[2]));",
            "endtry",
            "elseif (all)",
            "for task in (queued_tasks)",
            "if (everyone || (realplayer == task[5]))",
            "`kill_task(task[1]) ! ANY';",
            "killed = killed + 1;",
            "if (!quiet)",
            "this:_kill_task_message(task);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(3, \"... killing tasks\");",
            "endfor",
            "elseif (soon)",
            "now = time();",
            "for task in (queued_tasks)",
            "if (((task[2] - now) < soon) && ((!player.wizard) || (everyone || (realplayer == task[5]))))",
            "`kill_task(task[1]) ! ANY';",
            "killed = killed + 1;",
            "if (!quiet)",
            "this:_kill_task_message(task);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(3, \"... killing tasks\");",
            "endfor",
            "elseif (percent)",
            "for task in (queued_tasks)",
            "if (digits == (task[1] % percent))",
            "`kill_task(task[1]) ! ANY';",
            "killed = killed + 1;",
            "if (!quiet)",
            "this:_kill_task_message(task);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(3, \"... killing tasks\");",
            "endfor",
            "elseif ((colon || vrb) || whatstr)",
            "for task in (queued_tasks)",
            "if ((((((whatstr == \"\") || (valid(task[6]) && (index(task[6].name, whatstr) == 1))) || (valid(task[9]) && (index(task[9].name, whatstr) == 1))) || (task[9] == what)) || (task[6] == what)) && ((vrb == \"\") || (index(\" \" + strsub(task[7], \"*\", \"\"), \" \" + vrb) == 1)))",
            "`kill_task(task[1]) ! ANY';",
            "killed = killed + 1;",
            "if (!quiet)",
            "this:_kill_task_message(task);",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(3, \"... killing tasks\");",
            "endfor",
            "else",
            "player:notify(\"Something is funny; I didn't understand your @kill command.  You shouldn't have gotten here.  Please send yduJ mail saying you got this message from @kill, and what you had typed to @kill.\");",
            "endif",
            "if (!killed)",
            "player:notify(\"No tasks killed.\");",
            "elseif (quiet)",
            "player:notify(tostr(\"Killed \", killed, \" tasks.\"));",
            "endif"
          ]
        },
        {
          "name": "@copy @copy-x @copy-move",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 58,
          "code": [
            "\"Usage:  @copy source:verbname to target[:verbname]\";",
            "\"  the target verbname, if not given, defaults to that of the source.  If the target verb doesn't already exist, a new verb is installed with the same args, names, code, and permission flags as the source.  Otherwise, the existing target's verb code is overwritten and no other changes are made.\";",
            "\"This the poor man's version of multiple inheritance... the main problem is that someone may update the verb you're copying and you'd never know.\";",
            "\"  if @copy-x is used, makes an unusable copy (!x, this none this).  If @copy-move is used, deletes the source verb as well.\";",
            "set_task_perms(player);",
            "if (!player.programmer)",
            "player:notify(\"You need to be a programmer to do this.\");",
            "player:notify(\"If you want to become a programmer, talk to a wizard.\");",
            "return;",
            "elseif ((verb != \"@copy-move\") && (!$quota_utils:verb_addition_permitted(player)))",
            "player:notify(\"Verb addition not permitted because quota exceeded.\");",
            "return;",
            "elseif ((!(from = $code_utils:parse_verbref(dobjstr))) || (!iobjstr))",
            "player:notify(tostr(\"Usage:  \", verb, \" obj:verb to obj:verb\"));",
            "player:notify(tostr(\"        \", verb, \" obj:verb to obj\"));",
            "player:notify(tostr(\"        \", verb, \" obj:verb to :verb\"));",
            "return;",
            "elseif ($command_utils:object_match_failed(fobj = player:my_match_object(from[1]), from[1]))",
            "return;",
            "elseif (iobjstr[1] == \":\")",
            "to = {fobj, iobjstr[2..$]};",
            "elseif ((!index(iobjstr, \":\")) || (!(to = $code_utils:parse_verbref(iobjstr))))",
            "iobj = player:my_match_object(iobjstr);",
            "if ($command_utils:object_match_failed(iobj, iobjstr))",
            "return;",
            "endif",
            "to = {iobj, from[2]};",
            "elseif ($command_utils:object_match_failed(tobj = player:my_match_object(to[1]), to[1]))",
            "return;",
            "else",
            "to[1] = tobj;",
            "endif",
            "from[1] = fobj;",
            "if (verb == \"@copy-move\")",
            "if ((!$perm_utils:controls(player, fobj)) && (!$quota_utils:verb_addition_permitted(player)))",
            "player:notify(\"Won't be able to delete old verb.  Quota exceeded, so unable to continue.  Aborted.\");",
            "return;",
            "elseif ($perm_utils:controls(player, fobj))",
            "\"only try to move if the player controls the verb. Otherwise, skip and treat as regular @copy\";",
            "if (typeof(result = $code_utils:move_verb(@from, @to)) == ERR)",
            "player:notify(tostr(\"Unable to move verb from \", from[1], \":\", from[2], \" to \", to[1], \":\", to[2], \" --> \", result));",
            "else",
            "player:notify(tostr(\"Moved verb from \", from[1], \":\", from[2], \" to \", result[1], \":\", result[2]));",
            "endif",
            "return;",
            "else",
            "player:notify(\"Won't be able to delete old verb.  Treating this as regular @copy.\");",
            "endif",
            "endif",
            "to_firstname = strsub(to[2][1..index(to[2] + \" \", \" \") - 1], \"*\", \"\") || \"*\";",
            "if ((!(hv = $object_utils:has_verb(to[1], to_firstname))) || (hv[1] != to[1]))",
            "if ((!(info = `verb_info(@from) ! ANY')) || (!(vargs = `verb_args(@from) ! ANY')))",
            "player:notify(tostr(\"Retrieving \", from[1], \":\", from[2], \" --> \", info && vargs));",
            "return;",
            "endif",
            "if (!player.wizard)",
            "info[1] = player;",
            "endif",
            "if (verb == \"@copy-x\")",
            "\"... make sure this is an unusable copy...\";",
            "info[2] = strsub(info[2], \"x\", \"\");",
            "vargs = {\"this\", \"none\", \"this\"};",
            "endif",
            "if (from[2] != to[2])",
            "info[3] = to[2];",
            "endif",
            "if (ERR == typeof(e = `add_verb(to[1], info, vargs) ! ANY'))",
            "player:notify(tostr(\"Adding \", to[1], \":\", to[2], \" --> \", e));",
            "return;",
            "endif",
            "endif",
            "code = `verb_code(@from) ! ANY';",
            "owner = `verb_info(@from)[1] ! ANY';",
            "if (typeof(code) == ERR)",
            "player:notify(tostr(\"Couldn't retrieve code from \", from[1].name, \" (\", from[1], \"):\", from[2], \" => \", code));",
            "return;",
            "endif",
            "if (owner != player)",
            "comment = tostr(\"Copied from \", $string_utils:nn(from[1]), \":\", from[2], (from[1] == owner) ? \"\" | tostr(\" [verb author \", $string_utils:nn(owner), \"]\"), \" at \", ctime());",
            "code = {$string_utils:print(comment) + \";\", @code};",
            "if (!player:prog_option(\"copy_expert\"))",
            "player:notify(\"Use of @copy is discouraged.  Please do not use @copy if you can use inheritance or features instead.  Use @copy carefully, and only when absolutely necessary, as it is wasteful of database space.\");",
            "endif",
            "endif",
            "e = `set_verb_code(to[1], to_firstname, code) ! ANY';",
            "if (ERR == typeof(e))",
            "player:notify(tostr(\"Copying \", from[1], \":\", from[2], \" to \", to[1], \":\", to[2], \" --> \", e));",
            "elseif ((typeof(e) == LIST) && e)",
            "player:notify(tostr(\"Copying \", from[1], \":\", from[2], \" to \", to[1], \":\", to[2], \" -->\"));",
            "player:notify_lines(e);",
            "else",
            "player:notify(tostr(to[1], \":\", to[2], \" code set.\"));",
            "endif"
          ]
        },
        {
          "name": "_kill_task_message",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "set_task_perms(caller_perms());",
            "task = args[1];",
            "player:notify(tostr(\"Killed: \", $string_utils:right(tostr(\"task \", task[1]), 17), \", verb \", task[6], \":\", task[7], \", line \", task[8], (task[9] != task[6]) ? \", this==\" + tostr(task[9]) | \"\"));"
          ]
        },
        {
          "name": "@prog*ram @program#",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"This version of @program deals with multiple verbs having the same name.\";",
            "\"... @program <object>:<verbname> <dobj> <prep> <iobj>  picks the right one.\";",
            "if (player != caller)",
            "return;",
            "endif",
            "set_task_perms(player);",
            "\"...\";",
            "\"...catch usage errors first...\";",
            "\"...\";",
            "punt = \"...set punt to 0 only if everything works out...\";",
            "if (!(args && (spec = $code_utils:parse_verbref(args[1]))))",
            "player:notify(tostr(\"Usage: \", verb, \" <object>:<verb> [<dobj> <prep> <iobj>]\"));",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "\"...bogus object...\";",
            "elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)",
            "player:notify(tostr(argspec));",
            "elseif (verb == \"@program#\")",
            "verbname = $code_utils:toint(spec[2]);",
            "if (verbname == E_TYPE)",
            "player:notify(\"Verb number expected.\");",
            "elseif (length(args) > 1)",
            "player:notify(\"Don't give args for @program#.\");",
            "elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM')",
            "player:notify(\"Verb number out of range.\");",
            "else",
            "argspec = 0;",
            "punt = 0;",
            "endif",
            "elseif (argspec[2])",
            "player:notify($string_utils:from_list(argspec[2], \" \") + \"??\");",
            "elseif (length(argspec = argspec[1]) in {1, 2})",
            "player:notify({\"Missing preposition\", \"Missing iobj specification\"}[length(argspec)]);",
            "else",
            "punt = 0;",
            "verbname = spec[2];",
            "if (index(verbname, \"*\") > 1)",
            "verbname = strsub(verbname, \"*\", \"\");",
            "endif",
            "endif",
            "\"...\";",
            "\"...if we have an argspec, we'll need to reset verbname...\";",
            "\"...\";",
            "if (punt)",
            "elseif (argspec)",
            "if (!(argspec[2] in {\"none\", \"any\"}))",
            "argspec[2] = $code_utils:full_prep(argspec[2]);",
            "endif",
            "loc = $code_utils:find_verb_named(object, verbname);",
            "while ((loc > 0) && (`verb_args(object, loc) ! ANY' != argspec))",
            "loc = $code_utils:find_verb_named(object, verbname, loc + 1);",
            "endwhile",
            "if (!loc)",
            "punt = \"...can't find it....\";",
            "player:notify(\"That object has no verb matching that name + args.\");",
            "else",
            "verbname = loc;",
            "endif",
            "else",
            "loc = 0;",
            "endif",
            "\"...\";",
            "\"...get verb info...\";",
            "\"...\";",
            "if (punt || (!(punt = \"...reset punt to TRUE...\")))",
            "else",
            "try",
            "info = verb_info(object, verbname);",
            "punt = 0;",
            "aliases = info[3];",
            "if (!loc)",
            "loc = aliases in (verbs(object) || {});",
            "endif",
            "except (E_VERBNF)",
            "player:notify(\"That object does not have that verb definition.\");",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry",
            "endif",
            "\"...\";",
            "\"...read the code...\";",
            "\"...\";",
            "if (punt)",
            "player:notify(tostr(\"Now ignoring code for \", args ? args[1] | \"nothing in particular\", \".\"));",
            "$command_utils:read_lines();",
            "player:notify(\"Verb code ignored.\");",
            "else",
            "player:notify(tostr(\"Now programming \", object.name, \":\", aliases, \"(\", (!loc) ? \"??\" | loc, \").\"));",
            "lines = $command_utils:read_lines_escape((active = player in $verb_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are editing \", $string_utils:nn(object), \":\", verbname, \".\"), @active ? {} | {\"Type `@edit' to take this into the verb editor.\"}});",
            "if (lines[1] == \"@edit\")",
            "$verb_editor:invoke(args[1], \"@program\", lines[2]);",
            "return;",
            "endif",
            "simpleedit = $mcp.registry:match_package(\"dns-org-mud-moo-simpleedit\");",
            "if ((simpleedit != $failed_match) && simpleedit.v_filter_in)",
            "lines[2] = simpleedit.v_filter_in[1]:(simpleedit.v_filter_in[2])(lines[2]);",
            "endif",
            "try",
            "if (result = set_verb_code(object, verbname, lines[2]))",
            "player:notify_lines(result);",
            "player:notify(tostr(length(result), \" error(s).\"));",
            "player:notify(\"Verb not programmed.\");",
            "else",
            "player:notify(\"0 errors.\");",
            "player:notify(\"Verb programmed.\");",
            "endif",
            "except error (ANY)",
            "player:notify(error[2]);",
            "player:notify(\"Verb not programmed.\");",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "@setenv",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"Usage: @setenv <environment string>\";",
            "\"Set your .eval_env property.\";",
            "set_task_perms(player);",
            "if (!argstr)",
            "player:notify(tostr(\"Usage:  \", verb, \" <environment string>\"));",
            "return;",
            "endif",
            "player:notify(tostr(\"Current eval environment is: \", player.eval_env));",
            "result = player:set_eval_env(argstr);",
            "if (typeof(result) == ERR)",
            "player:notify(tostr(result));",
            "return;",
            "endif",
            "player:notify(tostr(\".eval_env set to \\\"\", player.eval_env, \"\\\" (\", player.eval_ticks, \" ticks).\"));"
          ]
        },
        {
          "name": "@pros*pectus pros*pectus",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 58,
          "code": [
            "\"Usage: @prospectus <player> [from <start>] [to <end>]\";",
            "set_task_perms((caller_perms() == $nothing) ? player | caller_perms());",
            "dobj = dobjstr ? $string_utils:match_player(dobjstr) | player;",
            "if ($command_utils:player_match_result(dobj, dobjstr)[1])",
            "return;",
            "endif",
            "dobjwords = $string_utils:words(dobjstr);",
            "if (args[1..length(dobjwords)] == dobjwords)",
            "args = args[length(dobjwords) + 1..$];",
            "endif",
            "if (!(parse_result = $code_utils:_parse_audit_args(@args)))",
            "player:notify(tostr(\"Usage:  \", verb, \" player [from <start>] [to <end>]\"));",
            "return;",
            "endif",
            "return $building_utils:do_prospectus(dobj, @parse_result);"
          ]
        },
        {
          "name": "@d*isplay",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"@display <object>[.[property]]*[,[inherited_property]]*[:[verb]]*[;[inherited_verb]]*\";",
            "if (player != this)",
            "player:notify(tostr(\"Sorry, you can't use \", this:title(), \"'s `\", verb, \"' command.\"));",
            "return E_PERM;",
            "endif",
            "\"null names for properties and verbs are interpreted as meaning all of them.\";",
            "opivu = {{}, {}, {}, {}, {}};",
            "string = \"\";",
            "punc = 1;",
            "literal = 0;",
            "set_task_perms(player);",
            "for jj in [1..length(argstr)]",
            "j = argstr[jj];",
            "if (literal)",
            "string = string + j;",
            "literal = 0;",
            "elseif (j == \"\\\\\")",
            "literal = 1;",
            "elseif (y = index(\".,:;\", j))",
            "opivu[punc] = {@opivu[punc], string};",
            "punc = 1 + y;",
            "string = \"\";",
            "else",
            "string = string + j;",
            "endif",
            "endfor",
            "opivu[punc] = {@opivu[punc], string};",
            "objname = opivu[1][1];",
            "it = this:my_match_object(objname);",
            "if ($command_utils:object_match_failed(it, objname))",
            "return;",
            "endif",
            "readable = (it.owner == this) || (it.r || this.wizard);",
            "cant = {};",
            "if (\"\" in opivu[2])",
            "if (readable)",
            "prop = properties(it);",
            "else",
            "prop = {};",
            "cant = setadd(cant, it);",
            "endif",
            "if (!this:display_option(\"thisonly\"))",
            "what = it;",
            "while ((!prop) && valid(what = parent(what)))",
            "if ((what.owner == this) || (what.r || this.wizard))",
            "prop = properties(what);",
            "else",
            "cant = setadd(cant, what);",
            "endif",
            "endwhile",
            "endif",
            "else",
            "prop = opivu[2];",
            "endif",
            "if (\"\" in opivu[3])",
            "inh = {};",
            "for what in ({it, @$object_utils:ancestors(it)})",
            "if (((what.owner == this) || what.r) || this.wizard)",
            "inh = {@inh, @properties(what)};",
            "else",
            "cant = setadd(cant, what);",
            "endif",
            "endfor",
            "else",
            "inh = opivu[3];",
            "endif",
            "for q in (inh)",
            "if (q in `properties(it) ! ANY => {}')",
            "prop = setadd(prop, q);",
            "inh = setremove(inh, q);",
            "endif",
            "endfor",
            "vrb = {};",
            "if (\"\" in opivu[4])",
            "if (readable)",
            "vrbs = verbs(it);",
            "else",
            "vrbs = $object_utils:accessible_verbs(it);",
            "cant = setadd(cant, it);",
            "endif",
            "what = it;",
            "if (!this:display_option(\"thisonly\"))",
            "while ((!vrbs) && valid(what = parent(what)))",
            "if ((what.owner == this) || (what.r || this.wizard))",
            "vrbs = verbs(what);",
            "else",
            "cant = setadd(cant, what);",
            "endif",
            "endwhile",
            "endif",
            "for n in [1..length(vrbs)]",
            "vrb = setadd(vrb, {what, n});",
            "endfor",
            "else",
            "for w in (opivu[4])",
            "if (y = $object_utils:has_verb(it, w))",
            "vrb = setadd(vrb, {y[1], w});",
            "else",
            "this:notify(tostr(\"No such verb, \\\"\", w, \"\\\"\"));",
            "endif",
            "endfor",
            "endif",
            "if (\"\" in opivu[5])",
            "for z in ({it, @$object_utils:ancestors(it)})",
            "if (((this == z.owner) || z.r) || this.wizard)",
            "for n in [1..length(verbs(z))]",
            "vrb = setadd(vrb, {z, n});",
            "endfor",
            "else",
            "cant = setadd(cant, z);",
            "endif",
            "endfor",
            "else",
            "for w in (opivu[5])",
            "if (typeof(y = $object_utils:has_verb(it, w)) == LIST)",
            "vrb = setadd(vrb, {y[1], w});",
            "else",
            "this:notify(tostr(\"No such verb, \\\"\", w, \"\\\"\"));",
            "endif",
            "endfor",
            "endif",
            "if (({\"\"} in opivu) || (opivu[2..5] == {{}, {}, {}, {}}))",
            "this:notify(tostr(it.name, \" (\", it, \") [ \", it.r ? \"readable \" | \"\", it.w ? \"writeable \" | \"\", it.f ? \"fertile \" | \"\", is_player(it) ? \"(player) \" | \"\", it.programmer ? \"programmer \" | \"\", it.wizard ? \"wizard \" | \"\", \"]\"));",
            "if (it.owner != (is_player(it) ? it | this))",
            "this:notify(tostr(\"  Owned by \", valid(p = it.owner) ? p.name | \"** extinct **\", \" (\", p, \").\"));",
            "endif",
            "this:notify(tostr(\"  Child of \", valid(p = parent(it)) ? p.name | \"** none **\", \" (\", p, \").\"));",
            "if (it.location != $nothing)",
            "this:notify(tostr(\"  Location \", valid(p = it.location) ? p.name | \"** unplace (tell a wizard, fast!) **\", \" (\", p, \").\"));",
            "endif",
            "if ($quota_utils.byte_based && $object_utils:has_property(it, \"object_size\"))",
            "this:notify(tostr(\"  Size: \", $string_utils:group_number(it.object_size[1]), \" bytes at \", this:ctime(it.object_size[2])));",
            "endif",
            "endif",
            "blankargs = this:display_option(\"blank_tnt\") ? {\"this\", \"none\", \"this\"} | #-1;",
            "for b in (vrb)",
            "$command_utils:suspend_if_needed(0);",
            "where = b[1];",
            "q = b[2];",
            "short = (typeof(q) == INT) ? q | strsub(y = index(q, \" \") ? q[1..y - 1] | q, \"*\", \"\");",
            "inf = `verb_info(where, short) ! ANY';",
            "if ((typeof(inf) == LIST) || (inf == E_PERM))",
            "name = (typeof(inf) == LIST) ? index(inf[3], \" \") ? (\"\\\"\" + inf[3]) + \"\\\"\" | inf[3] | q;",
            "line = $string_utils:left(tostr($string_utils:right(tostr(where), 6), \":\", name, \" \"), 32);",
            "if (inf == E_PERM)",
            "line = line + \"   ** unreadable **\";",
            "else",
            "line = $string_utils:left(tostr(line, inf[1].name, \" (\", inf[1], \") \"), 53) + ((i = inf[2] in {\"x\", \"xd\", \"d\", \"rd\"}) ? {\" x\", \" xd\", \"  d\", \"r d\"}[i] | inf[2]);",
            "vargs = `verb_args(where, short) ! ANY';",
            "if (vargs != blankargs)",
            "if (this:display_option(\"shortprep\") && (!(vargs[2] in {\"any\", \"none\"})))",
            "vargs[2] = $code_utils:short_prep(vargs[2]);",
            "endif",
            "line = $string_utils:left(line + \" \", 60) + $string_utils:from_list(vargs, \" \");",
            "endif",
            "endif",
            "this:notify(line);",
            "elseif (inf == E_VERBNF)",
            "this:notify(tostr(inf));",
            "this:notify(tostr(\"  ** no such verb, \\\"\", short, \"\\\" **\"));",
            "else",
            "this:notify(\"This shouldn't ever happen. @display is buggy.\");",
            "endif",
            "endfor",
            "all = {@prop, @inh};",
            "max = (length(all) < 4) ? 999 | (this:linelen() - 56);",
            "depth = (length(all) < 4) ? -1 | 1;",
            "truncate_owner_names = length(all) > 1;",
            "for q in (all)",
            "$command_utils:suspend_if_needed(0);",
            "inf = `property_info(it, q) ! ANY';",
            "if (inf == E_PROPNF)",
            "if (q in $code_utils.builtin_props)",
            "this:notify(tostr($string_utils:left(\",\" + q, 25), \"Built in property            \", $string_utils:abbreviated_value(it.(q), max, depth)));",
            "else",
            "this:notify(tostr(\"  ** property not found, \\\"\", q, \"\\\" **\"));",
            "endif",
            "else",
            "pname = $string_utils:left(tostr((q in `properties(it) ! ANY => {}') ? \".\" | (`is_clear_property(it, q) ! ANY' ? \" \" | \",\"), q, \" \"), 25);",
            "if (inf == E_PERM)",
            "this:notify(pname + \"   ** unreadable **\");",
            "else",
            "oname = inf[1].name;",
            "truncate_owner_names && ((length(oname) > 12) && (oname = oname[1..12]));",
            "`inf[2][1] != \"r\" ! E_RANGE => 1' && (inf[2][1..0] = \" \");",
            "`inf[2][2] != \"w\" ! E_RANGE => 1' && (inf[2][2..1] = \" \");",
            "this:notify($string_utils:left(tostr($string_utils:left(tostr(pname, oname, \" (\", inf[1], \") \"), 47), inf[2], \" \"), 54) + $string_utils:abbreviated_value(it.(q), max, depth));",
            "endif",
            "endif",
            "endfor",
            "if (cant)",
            "failed = {};",
            "for k in (cant)",
            "failed = listappend(failed, tostr(k.name, \" (\", k, \")\"));",
            "endfor",
            "this:notify($string_utils:centre(tostr(\" no permission to read \", $string_utils:english_list(failed, \", \", \" or \", \" or \"), \". \"), 75, \"-\"));",
            "else",
            "this:notify($string_utils:centre(\" finished \", 75, \"-\"));",
            "endif"
          ]
        },
        {
          "name": "@db*size",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "\"Let 'em @kill it.\";",
            "count = (maxobj = toint(max_object()) + 1) - length(recycled_objects());",
            "player:notify(tostr(\"There are \", count, \" valid objects out of \", maxobj, \" allocated object numbers.\"));"
          ]
        },
        {
          "name": "@gethelp",
          "owner": 2,
          "perms": 93,
          "preps": -2,
          "object": 58,
          "code": [
            "\"@gethelp [<topic>] [from <db or dblist>]\";",
            "\"  Prints the raw text of topic from the appropriate help db.\";",
            "\"  With no argument, gets the blank (\\\"\\\") topic from wherever it lives\";",
            "\"  Text is printed as a script for changing this help topic \";",
            "\"  (somewhat like @dump...)\";",
            "if (!prepstr)",
            "topic = argstr;",
            "dblist = $code_utils:help_db_list();",
            "elseif (prepstr != \"from\")",
            "player:notify(\"Usage:  \", verb, \" [<topic>] [from <db>]\");",
            "return;",
            "elseif (!(e = $no_one:eval_d(iobjstr = argstr[$string_utils:word_start(argstr)[(prepstr in args) + 1][1]..$])))",
            "player:notify(tostr(e));",
            "return;",
            "elseif (!e[1])",
            "player:notify_lines(e[2]);",
            "return;",
            "elseif (!(typeof(dblist = e[2]) in {OBJ, LIST}))",
            "player:notify(tostr(iobjstr, \" => \", dblist, \" -- not an object or a list\"));",
            "return;",
            "else",
            "topic = dobjstr;",
            "if (typeof(dblist) == OBJ)",
            "dblist = {dblist};",
            "endif",
            "endif",
            "search = $code_utils:help_db_search(topic, dblist);",
            "if (!search)",
            "player:notify(\"Topic not found.\");",
            "elseif (search[1] == $ambiguous_match)",
            "player:notify(tostr(\"Topic `\", topic, \"' ambiguous:  \", $string_utils:english_list(search[2], \"none\", \" or \")));",
            "elseif (typeof(text = (db = search[1]):dump_topic(fulltopic = search[2])) == ERR)",
            "\"...ok...shoot me.  This is a -d verb...\";",
            "player:notify(tostr(\"Cannot retrieve `\", fulltopic, \"' on \", $code_utils:corify_object(db), \":  \", text));",
            "else",
            "player:notify_lines(text);",
            "endif"
          ]
        },
        {
          "name": "@grep*all @egrep*all",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (prepstr == \"in\")",
            "pattern = dobjstr;",
            "objlist = player:eval_cmd_string(iobjstr, 0);",
            "if (!objlist[1])",
            "player:notify(tostr(\"Had trouble reading `\", iobjstr, \"':  \"));",
            "player:notify_lines(@objlist[2]);",
            "return;",
            "elseif (typeof(objlist[2]) == OBJ)",
            "objlist = {objlist[2..2]};",
            "elseif (typeof(objlist[2]) != LIST)",
            "player:notify(tostr(\"Value of `\", iobjstr, \"' is not an object or list:  \", toliteral(objlist[2])));",
            "return;",
            "else",
            "objlist = objlist[2..2];",
            "endif",
            "elseif ((prepstr == \"from\") && (player.wizard && (n = toint(toobj(iobjstr)))))",
            "pattern = dobjstr;",
            "objlist = {n};",
            "elseif (args && player.wizard)",
            "pattern = argstr;",
            "objlist = {};",
            "else",
            "player:notify(tostr(\"Usage:  \", verb, \" <pattern> \", player.wizard ? \"[in {<objectlist>} | from <number>]\" | \"in {<objectlist>}\"));",
            "return;",
            "endif",
            "player:notify(tostr(\"Searching for verbs \", @prepstr ? {prepstr, \" \", iobjstr, \" \"} | {}, (verb == \"@egrep\") ? \"matching the pattern \" | \"containing the string \", toliteral(pattern), \" ...\"));",
            "player:notify(\"\");",
            "egrep = verb[2] == \"e\";",
            "all = index(verb, \"a\");",
            "$code_utils:(all ? egrep ? \"find_verb_lines_matching\" | \"find_verb_lines_containing\" | (egrep ? \"find_verbs_matching\" | \"find_verbs_containing\"))(pattern, @objlist);"
          ]
        },
        {
          "name": "@s*how",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (dobjstr == \"\")",
            "player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb>\"));",
            "return;",
            "endif",
            "if (index(dobjstr, \".\") && (spec = $code_utils:parse_propref(dobjstr)))",
            "if (valid(object = player:my_match_object(spec[1])))",
            "return $code_utils:show_property(object, spec[2]);",
            "endif",
            "elseif (index(dobjstr, \":\") && (spec = $code_utils:parse_verbref(dobjstr)))",
            "if (valid(object = player:my_match_object(spec[1])) && player.programmer)",
            "return $code_utils:show_verbdef(object, spec[2]);",
            "else",
            "player:tell(\"You must be a programmer to show verbs.\");",
            "return;",
            "endif",
            "elseif (((dobjstr[1] == \"$\") && ((pname = dobjstr[2..$]) in properties(#0))) && (typeof(#0.(pname)) == OBJ))",
            "if (valid(object = #0.(pname)))",
            "return $code_utils:show_object(object);",
            "endif",
            "elseif ((dobjstr[1] == \"$\") && (spec = $code_utils:parse_propref(dobjstr)))",
            "return $code_utils:show_property(#0, spec[2]);",
            "else",
            "if (valid(object = player:my_match_object(dobjstr)))",
            "return $code_utils:show_object(object);",
            "endif",
            "endif",
            "$command_utils:object_match_failed(object, dobjstr);"
          ]
        },
        {
          "name": "@check-p*roperty",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"@check-prop object.property\";",
            "\"  checks for descendents defining the given property.\";",
            "set_task_perms(player);",
            "if (!(spec = $code_utils:parse_propref(dobjstr)))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>.<prop-name>\"));",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "\"...bogus object...\";",
            "elseif (!($perm_utils:controls(player, object) || object.w))",
            "player:notify(\"You can't create a property on that object anyway.\");",
            "elseif ($object_utils:has_property(object, prop = spec[2]))",
            "player:notify(\"That object already has that property.\");",
            "elseif (olist = $object_utils:descendants_with_property_suspended(object, prop))",
            "player:notify(\"The following descendents have this property defined:\");",
            "player:notify(\"  \" + $string_utils:from_list(olist, \" \"));",
            "else",
            "player:notify(\"No property name conflicts found.\");",
            "endif"
          ]
        },
        {
          "name": "set_eval_env",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "\"set_eval_env(string);\";",
            "\"Run <string> through eval.  If it doesn't compile, return E_INVARG.  If it crashes, well, it crashes.  If it works okay, set .eval_env to it and set .eval_ticks to the amount of time it took.\";",
            "if (is_player(this) && $perm_utils:controls(caller_perms(), this))",
            "program = args[1];",
            "value = $no_one:eval_d((\";ticks = ticks_left();\" + program) + \";return ticks - ticks_left() - 2;\");",
            "if (!value[1])",
            "return E_INVARG;",
            "elseif (typeof(value[2]) == ERR)",
            "return value[2];",
            "endif",
            "try",
            "ok = this.eval_env = program;",
            "this.eval_ticks = value[2];",
            "return 1;",
            "except error (ANY)",
            "return error[1];",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "@clearp*roperty @clprop*erty",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"@clearproperty <obj>.<prop>\";",
            "\"Set the value of <obj>.<prop> to `clear', making it appear to be the same as the property on its parent.\";",
            "set_task_perms(player);",
            "if (!(l = $code_utils:parse_propref(dobjstr)))",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>.<property>\"));",
            "elseif ($command_utils:object_match_failed(dobj = player:my_match_object(l[1]), l[1]))",
            "\"... bogus object...\";",
            "endif",
            "try",
            "if (is_clear_property(dobj, prop = l[2]))",
            "player:notify(tostr(\"Property \", dobj, \".\", prop, \" is already clear!\"));",
            "return;",
            "endif",
            "clear_property(dobj, prop);",
            "player:notify(tostr(\"Property \", dobj, \".\", prop, \" cleared; value is now \", toliteral(dobj.(prop)), \".\"));",
            "except (E_INVARG)",
            "player:notify(tostr(\"You can't clear \", dobj, \".\", prop, \"; none of the ancestors define that property.\"));",
            "except error (ANY)",
            "player:notify(error[2]);",
            "endtry"
          ]
        },
        {
          "name": "@disown @disinherit",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"Syntax: @disown <object> [from <object>]\";",
            "\"This command is used to remove unwanted children of objects you control. If you control an object, and there is a child of that object you do not want, this command will chparent() the object to its grandparent.\";",
            "set_task_perms(player);",
            "if (prepstr)",
            "if (prepstr != \"from\")",
            "player:notify(\"Usage:  \", verb, \" <object> [from <object>]\");",
            "return;",
            "elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))",
            "\"... from WHAT?..\";",
            "return;",
            "elseif (valid(dobj = $string_utils:literal_object(dobjstr)))",
            "\"... literal object number...\";",
            "if (parent(dobj) != iobj)",
            "player:notify(tostr(dobj, \" is not a child of \", iobj.name, \" (\", iobj, \")\"));",
            "return;",
            "endif",
            "elseif ($command_utils:object_match_failed(dobj = $string_utils:match(dobjstr, children(iobj), \"name\", children(iobj), \"aliases\"), dobjstr))",
            "\"... can't match dobjstr against any children of iobj\";",
            "return;",
            "endif",
            "elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))",
            "\"... can't match dobjstr...\";",
            "return;",
            "endif",
            "try",
            "if ($object_utils:disown(dobj))",
            "player:notify(tostr(dobj.name, \" (\", dobj, \")'s parent is now \", (grandparent = parent(dobj)).name, \" (\", grandparent, \").\"));",
            "else",
            "\"this should never happen\";",
            "endif",
            "except e (E_PERM, E_INVARG)",
            "{code, message, value, traceback} = e;",
            "player:notify(message);",
            "endtry"
          ]
        },
        {
          "name": "eval_cmd_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "\":eval_cmd_string(string[,debug])\";",
            "\"Evaluates the string the way this player would normally expect to see it evaluated if it were typed on the command line.  debug (defaults to 1) indicates how the debug flag should be set during the evaluation.\";",
            "\" => {@eval_result, ticks, seconds}\";",
            "\"where eval_result is the result of the actual eval() call.\";",
            "\"\";",
            "\"For the case where string is an expression, we need to prefix `return ' and append `;' to string before passing it to eval().  However this is not appropriate for statements, where it is assumed an explicit return will be provided somewhere or that the return value is irrelevant.  The code below assumes that string is an expression unless it either begins with a semicolon `;' or one of the MOO language statement keywords.\";",
            "\"Next, the substitutions described by this.eval_subs, which should be a list of pairs {string, sub}, are performed on string\";",
            "\"Finally, this.eval_env is prefixed to the beginning while this.eval_ticks is subtracted from the eventual tick count.  This allows string to refer to predefined variables like `here' and `me'.\";",
            "set_task_perms(caller_perms());",
            "{program, ?debug = 1} = args;",
            "program = program + \";\";",
            "debug = debug ? 38 | 0;",
            "if (!match(program, \"^ *%(;%|%(if%|fork?%|return%|while%|try%)[^a-z0-9A-Z_]%)\"))",
            "program = \"return \" + program;",
            "endif",
            "program = tostr(this.eval_env, \";\", $code_utils:substitute(program, this.eval_subs));",
            "ticks = ((ticks_left() - 53) - this.eval_ticks) + debug;",
            "seconds = seconds_left();",
            "value = debug ? eval(program) | $code_utils:eval_d(program);",
            "seconds = seconds - seconds_left();",
            "ticks = ticks - ticks_left();",
            "return {@value, ticks, seconds};"
          ]
        },
        {
          "name": "@dump",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"@dump something [with [id=...] [noprops] [noverbs] [create]]\";",
            "\"This spills out all properties and verbs on an object, calling suspend at appropriate intervals.\";",
            "\"   id=#nnn -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)\";",
            "\"   noprops -- don't show properties.\";",
            "\"   noverbs -- don't show verbs.\";",
            "\"   create  -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it.\";",
            "set_task_perms(player);",
            "dobj = player:my_match_object(dobjstr);",
            "if ($command_utils:object_match_failed(dobj, dobjstr))",
            "return;",
            "endif",
            "if (prepstr && (prepstr != \"with\"))",
            "player:notify(tostr(\"Usage:  \", verb, \" something [with [id=...] [noprops] [noverbs] [create]]\"));",
            "return;",
            "endif",
            "targname = tostr(dobj);",
            "options = {\"props\", \"verbs\"};",
            "create = 0;",
            "if (iobjstr)",
            "for o in ($string_utils:explode(iobjstr))",
            "if (index(o, \"id=\") == 1)",
            "targname = o[4..$];",
            "elseif (o in {\"noprops\", \"noverbs\"})",
            "options = setremove(options, o[3..$]);",
            "elseif (o in {\"create\"})",
            "create = 1;",
            "else",
            "player:notify(tostr(\"`\", o, \"' not understood as valid option.\"));",
            "player:notify(tostr(\"Usage:  \", verb, \" something [with [id=...] [noprops] [noverbs] [create]]\"));",
            "return;",
            "endif",
            "endfor",
            "endif",
            "$ansi_utils:add_noansi();",
            "if (create)",
            "player:notify($code_utils:dump_preamble(dobj));",
            "endif",
            "if (\"props\" in options)",
            "player:notify_lines_suspended($code_utils:dump_properties(dobj, create, targname));",
            "endif",
            "if (!(\"verbs\" in options))",
            "player:notify(\"\\\"***finished***\");",
            "return;",
            "endif",
            "player:notify(\"\");",
            "player:notify_lines_suspended($code_utils:dump_verbs(dobj, create, targname));",
            "player:notify(\"\\\"***finished***\");",
            "$ansi_utils:remove_noansi();"
          ]
        },
        {
          "name": "#*",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):# by Geust (#24442) Sun May  9 20:19:05 1993 PDT\";",
            "\"#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.\";",
            "\"If neither .<property>|.parent nor <code> is specified, just return <thing>.\";",
            "\"If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).\";",
            "\"If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.\";",
            "\"For example, the command\";",
            "\"  #JoeFeedback.parent player for toint(%#)\";",
            "\"will return 26026 (unless Joe has chparented since writing this).\";",
            "set_task_perms(player);",
            "if (!(whatstr = verb[2..dot = min(index(verb + \".\", \".\"), index(verb + \":\", \":\")) - 1]))",
            "player:notify(\"Usage:  #string [exit|player|inventory]\");",
            "return;",
            "elseif (!args)",
            "what = player:my_match_object(whatstr);",
            "elseif (index(\"exits\", args[1]) == 1)",
            "what = player.location:match_exit(whatstr);",
            "elseif (index(\"inventory\", args[1]) == 1)",
            "what = player:match(whatstr);",
            "elseif (index(\"players\", args[1]) == 1)",
            "what = $string_utils:match_player(whatstr);",
            "if ($command_utils:player_match_failed(what, whatstr))",
            "return;",
            "endif",
            "else",
            "what = player:my_match_object(whatstr);",
            "endif",
            "if ((!valid(what)) && match(whatstr, \"^[0-9]+$\"))",
            "what = toobj(whatstr);",
            "endif",
            "if ($command_utils:object_match_failed(what, whatstr))",
            "return;",
            "endif",
            "while (index(verb, \".parent\") == (dot + 1))",
            "what = parent(what);",
            "dot = dot + 7;",
            "endwhile",
            "if (dot >= length(verb))",
            "val = what;",
            "elseif ((value = $code_utils:eval_d(tostr(\"return \", what, verb[dot + 1..$], \";\")))[1])",
            "val = value[2];",
            "else",
            "player:notify_lines(value[2]);",
            "return;",
            "endif",
            "if (prepstr)",
            "program = strsub(iobjstr + \";\", \"%#\", toliteral(val));",
            "end = 1;",
            "\"while (\\\"A\\\" <= (l = argstr[end]) && l <= \\\"Z\\\")\";",
            "while ((\"A\" <= (l = program[end])) && (l <= \"Z\"))",
            "end = end + 1;",
            "endwhile",
            "if ((program[1] == \";\") || (program[1..end - 1] in {\"if\", \"for\", \"fork\", \"return\", \"while\", \"try\"}))",
            "program = $code_utils:substitute(program, this.eval_subs);",
            "else",
            "program = $code_utils:substitute(\"return \" + program, this.eval_subs);",
            "endif",
            "if ((value = eval(program))[1])",
            "player:notify(this:eval_value_to_string(value[2]));",
            "else",
            "player:notify_lines(value[2]);",
            "nerrors = length(value[2]);",
            "player:notify(tostr(nerrors, \" error\", (nerrors == 1) ? \".\" | \"s.\"));",
            "endif",
            "else",
            "player:notify(this:eval_value_to_string(val));",
            "endif"
          ]
        },
        {
          "name": "eval_value_to_string",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "set_task_perms(caller_perms());",
            "if (typeof(val = args[1]) == OBJ)",
            "return tostr(\"=> \", val, \"  \", valid(val) ? (\"(\" + val.name) + \")\" | ((a = $list_utils:assoc(val, {{#-1, \"<$nothing>\"}, {#-2, \"<$ambiguous_match>\"}, {#-3, \"<$failed_match>\"}})) ? a[2] | \"<invalid>\"));",
            "elseif (typeof(val) == ERR)",
            "return tostr(\"=> \", toliteral(val), \"  (\", val, \")\");",
            "else",
            "return tostr(\"=> \", toliteral(val));",
            "endif"
          ]
        },
        {
          "name": "@progo*ptions @prog-o*ptions @programmero*ptions @programmer-o*ptions",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"@<what>-option <option> [is] <value>   sets <option> to <value>\";",
            "\"@<what>-option <option>=<value>        sets <option> to <value>\";",
            "\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";",
            "\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@<what>-option <option>      displays value of <option>\";",
            "set_task_perms(player);",
            "what = \"prog\";",
            "options = what + \"_options\";",
            "option_pkg = $options[what];",
            "set_option = (\"set_\" + what) + \"_option\";",
            "if (!args)",
            "player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});",
            "return;",
            "elseif (typeof(presult = option_pkg:parse(args)) == STR)",
            "player:notify(presult);",
            "return;",
            "else",
            "if (length(presult) > 1)",
            "if (typeof(sresult = this:(set_option)(@presult)) == STR)",
            "player:notify(sresult);",
            "return;",
            "elseif (!sresult)",
            "player:notify(\"No change.\");",
            "return;",
            "endif",
            "endif",
            "player:notify_lines(option_pkg:show(this.(options), presult[1]));",
            "endif"
          ]
        },
        {
          "name": "prog_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "\":prog_option(name)\";",
            "\"Returns the value of the specified prog option\";",
            "if ((caller in {this, $mcp.simpleedit}) || $perm_utils:controls(caller_perms(), this))",
            "return $options[\"prog\"]:get(this.prog_options, args[1]);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_prog_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 58,
          "code": [
            "\":set_prog_option(oname,value)\";",
            "\"Changes the value of the named option.\";",
            "\"Returns a string error if something goes wrong.\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return tostr(E_PERM);",
            "endif",
            "\"...this is kludgy, but it saves me from writing the same verb 3 times.\";",
            "\"...there's got to be a better way to do this...\";",
            "verb[1..4] = \"\";",
            "foo_options = verb + \"s\";",
            "prop = verb[1..index(verb, \"_\") - 1];",
            "\"...\";",
            "if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)",
            "return s;",
            "elseif (s == this.(foo_options))",
            "return 0;",
            "else",
            "this.(foo_options) = s;",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "@list*#",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "\"@list <obj>:<verb> [<dobj> <prep> <iobj>] [with[out] paren|num] [all] [ranges]\";",
            "set_task_perms(player);",
            "bynumber = verb == \"@list#\";",
            "pflag = player:prog_option(\"list_all_parens\");",
            "nflag = !player:prog_option(\"list_no_numbers\");",
            "permflag = player:prog_option(\"list_show_permissions\");",
            "aflag = 0;",
            "argspec = {};",
            "range = {};",
            "spec = args ? $code_utils:parse_verbref(args[1]) | E_INVARG;",
            "args = spec ? listdelete(args, 1) | E_INVARG;",
            "while (args)",
            "if (args[1] && ((index(\"without\", args[1]) == 1) || (args[1] == \"wo\")))",
            "\"...w,wi,wit,with => 1; wo,witho,withou,without => 0...\";",
            "fval = !index(args[1], \"o\");",
            "if (`index(\"parentheses\", args[2]) ! ANY' == 1)",
            "pflag = fval;",
            "args[1..2] = {};",
            "elseif (`index(\"numbers\", args[2]) ! ANY' == 1)",
            "nflag = fval;",
            "args[1..2] = {};",
            "else",
            "player:notify(tostr(args[1], \" WHAT?\"));",
            "args = E_INVARG;",
            "endif",
            "elseif (index(\"all\", args[1]) == 1)",
            "if (bynumber)",
            "player:notify(\"Don't use `all' with @list#.\");",
            "args = E_INVARG;",
            "else",
            "aflag = 1;",
            "args[1..1] = {};",
            "endif",
            "elseif (index(\"0123456789\", args[1][1]) || (index(args[1], \"..\") == 1))",
            "if (E_INVARG == (s = $seq_utils:from_string(args[1])))",
            "player:notify(tostr(\"Garbled range:  \", args[1]));",
            "args = E_INVARG;",
            "else",
            "range = $seq_utils:union(range, s);",
            "args = listdelete(args, 1);",
            "endif",
            "elseif (bynumber)",
            "player:notify(\"Don't give args with @list#.\");",
            "args = E_INVARG;",
            "elseif (argspec)",
            "\"... second argspec?  Not likely ...\";",
            "player:notify(tostr(args[1], \" unexpected.\"));",
            "args = E_INVARG;",
            "elseif (typeof(pas = $code_utils:parse_argspec(@args)) == LIST)",
            "argspec = pas[1];",
            "if (length(argspec) < 2)",
            "player:notify(tostr(\"Argument `\", @argspec, \"' malformed.\"));",
            "args = E_INVARG;",
            "else",
            "argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];",
            "args = pas[2];",
            "endif",
            "else",
            "\"... argspec is bogus ...\";",
            "player:notify(tostr(pas));",
            "args = E_INVARG;",
            "endif",
            "endwhile",
            "if (args == E_INVARG)",
            "if (bynumber)",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>:<verbnumber> [with|without parentheses|numbers] [ranges]\"));",
            "else",
            "player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb> [<dobj> <prep> <iobj>] [with|without parentheses|numbers] [all] [ranges]\"));",
            "endif",
            "return;",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "return;",
            "endif",
            "shown_one = 0;",
            "for what in ({object, @$object_utils:ancestors(object)})",
            "if (bynumber)",
            "vname = $code_utils:toint(spec[2]);",
            "if (vname == E_TYPE)",
            "return player:notify(\"Verb number expected.\");",
            "elseif ((vname < 1) || `vname > length(verbs(what)) ! E_PERM => 0')",
            "return player:notify(\"Verb number out of range.\");",
            "endif",
            "code = `verb_code(what, vname, pflag) ! ANY';",
            "elseif (argspec)",
            "vnum = $code_utils:find_verb_named(what, spec[2]);",
            "while (vnum && (`verb_args(what, vnum) ! ANY' != argspec))",
            "vnum = $code_utils:find_verb_named(what, spec[2], vnum + 1);",
            "endwhile",
            "vname = vnum;",
            "code = (!vnum) ? E_VERBNF | `verb_code(what, vnum, pflag) ! ANY';",
            "else",
            "vname = spec[2];",
            "code = `verb_code(what, vname, pflag) ! ANY';",
            "endif",
            "if (code != E_VERBNF)",
            "if (shown_one)",
            "player:notify(\"\");",
            "elseif (what != object)",
            "player:notify(tostr(\"Object \", object, \" does not define that verb\", argspec ? \" with those args\" | \"\", \", but its ancestor \", what, \" does.\"));",
            "endif",
            "if (typeof(code) == ERR)",
            "player:notify(tostr(what, \":\", vname, \" -- \", code));",
            "else",
            "info = verb_info(what, vname);",
            "vargs = verb_args(what, vname);",
            "fullname = info[3];",
            "if (index(fullname, \" \"))",
            "fullname = toliteral(fullname);",
            "endif",
            "if (index(vargs[2], \"/\"))",
            "vargs[2] = tostr(\"(\", vargs[2], \")\");",
            "endif",
            "$ansi_utils:add_noansi();",
            "player:notify(tostr(what, \":\", fullname, \"   \", $string_utils:from_list(vargs, \" \"), permflag ? \" \" + info[2] | \"\"));",
            "if (code == {})",
            "player:notify(\"(That verb has not been programmed.)\");",
            "else",
            "lineseq = {1, length(code) + 1};",
            "range && (lineseq = $seq_utils:intersection(range, lineseq));",
            "if (!lineseq)",
            "player:notify(\"(No lines in that range.)\");",
            "endif",
            "for k in [1..length(lineseq) / 2]",
            "for i in [lineseq[(2 * k) - 1]..lineseq[2 * k] - 1]",
            "if (nflag)",
            "player:notify(tostr(\" \"[1..i < 10], i, \":  \", code[i]));",
            "else",
            "player:notify(code[i]);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endfor",
            "endif",
            "$ansi_utils:remove_noansi();",
            "endif",
            "shown_one = 1;",
            "endif",
            "if (shown_one && (!aflag))",
            "return;",
            "endif",
            "endfor",
            "if (!shown_one)",
            "player:notify(tostr(\"That object does not define that verb\", argspec ? \" with those args.\" | \".\"));",
            "endif"
          ]
        },
        {
          "name": "set_eval_subs",
          "owner": 2,
          "perms": 13,
          "preps": -1,
          "object": 58,
          "code": [
            "\"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):set_eval_subs by Geust (#24442) Fri Aug  5 13:18:59 1994 PDT\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "elseif (typeof(subs = args[1]) != LIST)",
            "return E_TYPE;",
            "else",
            "for pair in (subs)",
            "if (((length(pair) != 2) || typeof(pair[1] != STR)) || typeof(pair[2] != STR))",
            "return E_INVARG;",
            "endif",
            "endfor",
            "endif",
            "return `this.eval_subs = subs ! ANY';"
          ]
        },
        {
          "name": "@verbs*",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "set_task_perms(player);",
            "if (!dobjstr)",
            "try",
            "if ((verb[7] != \"(\") && (verb[$] != \")\"))",
            "player:tell(\"Usage:  @verbs <object>\");",
            "return;",
            "else",
            "dobjstr = verb[8..$ - 1];",
            "endif",
            "except (E_RANGE)",
            "return player:tell(\"Usage:  @verbs <object>\");",
            "endtry",
            "endif",
            "thing = player:my_match_object(dobjstr);",
            "if (!$command_utils:object_match_failed(thing, dobjstr))",
            "verbs = $object_utils:accessible_verbs(thing);",
            "player:tell(\";verbs(\", thing, \") => \", toliteral(verbs));",
            "endif"
          ]
        },
        {
          "name": "@old-forked-v*erbose",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 58,
          "code": [
            "\"Syntax:  @forked-v*erbose [player]\";",
            "\"         @forked-v*erbose all wizards\";",
            "\"\";",
            "\"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. For a task which has suspended, and not a fresh fork, shows the full callers() stack.\";",
            "\"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.\";",
            "set_task_perms(player);",
            "if (!dobjstr)",
            "tasks = queued_tasks();",
            "elseif ((dobjstr == \"all wizards\") && player.wizard)",
            "tasks = {};",
            "for t in (queued_tasks())",
            "if (valid(t[5]) && t[5].wizard)",
            "tasks = {@tasks, t};",
            "endif",
            "$command_utils:suspend_if_needed(1);",
            "endfor",
            "elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])",
            "return;",
            "elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)",
            "player:notify(tostr(verb, \" \", dobj.name, \"(\", dobj, \"):  \", tasks));",
            "return;",
            "endif",
            "if (tasks)",
            "su = $string_utils;",
            "player:notify(\"Queue ID    Start Time            Owner         Verb (Line) [This]\");",
            "player:notify(\"--------    ----------            -----         -----------------\");",
            "now = time();",
            "for task in (tasks)",
            "$command_utils:suspend_if_needed(0);",
            "{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;",
            "time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? \"Reading input ...\" | tostr(now - start, \" seconds ago...\"), 20);",
            "owner_name = valid(owner) ? owner.name | tostr(\"Dead \", owner);",
            "player:notify(tostr(su:left(tostr(q_id), 10), \"  \", time, \"  \", su:left(owner_name, 12), \"  \", vloc, \":\", vname, \" (\", lineno, \")\", (this != vloc) ? tostr(\" [\", this, \"]\") | \"\"));",
            "if (stack = `task_stack(q_id, 1) ! E_INVARG => 0')",
            "for frame in (listdelete(stack, 1))",
            "{sthis, svname, sprogger, svloc, splayer, slineno} = frame;",
            "player:notify(tostr(\"                    Called By...  \", su:left(valid(sprogger) ? sprogger.name | tostr(\"Dead \", sprogger), 12), \"  \", svloc, \":\", svname, (sthis != svloc) ? tostr(\" [\", sthis, \"]\") | \"\", \" (\", slineno, \")\"));",
            "endfor",
            "endif",
            "endfor",
            "player:notify(\"-----------------------------------------------------------------\");",
            "else",
            "player:notify(\"No tasks.\");",
            "endif"
          ]
        },
        {
          "name": "@props @properties",
          "owner": 2,
          "perms": 81,
          "preps": -2,
          "object": 58,
          "code": [
            "\"Usage: @properties <object>\";",
            "\"Alias: @props\";",
            "\"Displays all properties defined on <object>. Properties unreadable by you display as `E_PERM'.\";",
            "if (player != this)",
            "return player:tell(E_PERM);",
            "endif",
            "set_task_perms(player);",
            "ob = this:my_match_object(argstr);",
            "if (!$command_utils:object_match_failed(ob, argstr))",
            "this:notify(tostr(\";properties(\", $code_utils:corify_object(ob), \") => \", toliteral($object_utils:accessible_props(ob))));",
            "endif",
            "\"Last modified Mon Nov 28 06:21:21 2005 PST, by Roebare (#109000).\";"
          ]
        },
        {
          "name": "@add-option",
          "owner": 2,
          "perms": 89,
          "preps": 1,
          "object": 58,
          "code": [
            "\"I never, ever remember how to add to option packages. So here we are.\";",
            "if (!player.programmer)",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "package = player:my_match_object(iobjstr);",
            "if ((package == $failed_match) || (isa(package, $generic_options) == 0))",
            "return player:tell(\"You need to specify an option package.\");",
            "elseif (dobjstr in package.names)",
            "return player:tell(\"That option already exists.\");",
            "elseif ((!player.wizard) && (package.owner != player))",
            "return player:tell(\"You don't own that option package.\");",
            "else",
            "dobjstr = strsub(dobjstr, \" \", \"_\");",
            "player:tell(\"What text is displayed when the option is DISABLED?\");",
            "text = {$command_utils:read()};",
            "player:tell(\"What text is displayed when the option is ENABLED?\");",
            "text = {@text, $command_utils:read()};",
            "package:add_name(dobjstr);",
            "add_property(package, tostr(\"show_\", dobjstr), text, {player, \"rc\"});",
            "player:tell(\"Option added!\");",
            "endif"
          ]
        },
        {
          "name": "@ref*erence",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 58,
          "code": [
            "if (player != this)",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "OBJ = player:my_match_object(argstr);",
            "return player:tell($string_utils:nn(OBJ), \" => \", $code_utils:corify_object(OBJ));"
          ]
        },
        {
          "name": "@remove-option @rmoption @rm-option",
          "owner": 2,
          "perms": 89,
          "preps": 5,
          "object": 58,
          "code": [
            "if (!player.programmer)",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "package = player:my_match_object(iobjstr);",
            "dobjstr = strsub(dobjstr, \" \", \"_\");",
            "if ((package == $failed_match) || (isa(package, $generic_options) == 0))",
            "return player:tell(\"You need to specify an option package.\");",
            "elseif ((dobjstr in package.names) == 0)",
            "return player:tell(\"'\", dobjstr, \" isn't an option on \", $su:nn(package), \".\");",
            "elseif ((!player.wizard) && (package.owner != player))",
            "return player:tell(\"You don't own that option package.\");",
            "else",
            "if ($cu:yes_or_no(tostr(\"Really delete option '\", dobjstr, \" from \", $su:nn(package), \"?\")) == 1)",
            "package:remove_name(dobjstr);",
            "delete_property(package, tostr(\"show_\", dobjstr));",
            "player:tell(\"Option removed.\");",
            "else",
            "player:tell(\"Aborted.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@toaststunt-commits @server-commits",
          "owner": 2,
          "perms": 9,
          "preps": -1,
          "object": 58,
          "code": [
            "\"Display ToastStunt commits.\";",
            "sourcedata = server_version(\"source\");",
            "current_commit = sourcedata[\"commit\" in slice(sourcedata)][2];",
            "last_commits = parse_json($string_utils:strip_binary(curl(\"https://api.github.com/repos/lisdude/toaststunt/commits\")));",
            "commit_lst = {{\"Author\", \"SHA\", \"Date\", \"Message\"}};",
            "for commit in (last_commits)",
            "is_current_commit = commit[\"sha\"] == current_commit[1..$ - 1];",
            "author = ((commit[\"commit\"][\"author\"][\"name\"] + \" (\") + commit[\"commit\"][\"author\"][\"email\"]) + \")\";",
            "message = commit[\"commit\"][\"message\"];",
            "if (line_End = index(message, \"~0a\"))",
            "message = message[1..line_End - 1];",
            "endif",
            "sha = commit[\"sha\"];",
            "date = commit[\"commit\"][\"author\"][\"date\"];",
            "commit_lst = {@commit_lst, {(is_current_commit ? \"[green]*[normal]\" | \"\") + author, sha[1..6], date, message}};",
            "endfor",
            "player:tell_lines($string_utils:fit_to_screen(commit_lst, 2, 1));",
            "player:tell();",
            "player:tell(\"[green]*[normal] == The server is presently compiled from this commit.\");"
          ]
        }
      ],
      "propnames": [
        "eval_subs",
        "eval_ticks",
        "eval_env",
        "prog_options"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 3,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "here=player.location;me=player",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            86,
            22,
            28,
            18,
            19,
            116
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic",
            "programmer"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "You see a player who is too experienced to have any excuse for not having a description.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            86428,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "59": {
      "id": 59,
      "name": "code utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "eval_d",
          "owner": 2,
          "perms": 85,
          "preps": -2,
          "object": 59,
          "code": [
            "\":eval_d(code...) => {compiled?,result}\";",
            "\"This works exactly like the builtin eval() except that the code is evaluated \";",
            "\"as if the d flag were unset.\";",
            "code = {\"set_verb_code(this,\\\"eval_d_util\\\",{\\\"\\\\\\\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\\\\\\\";\\\"});\", \"dobj=iobj=this=#-1;\", \"dobjstr=iobjstr=prepstr=argstr=verb=\\\"\\\";\", tostr(\"caller=\", caller, \";\"), \"set_task_perms(caller_perms());\", @args};",
            "if (!caller_perms().programmer)",
            "return E_PERM;",
            "elseif ((caller_perms() == $no_one) && $no_one:bad_eval(tostr(@args)))",
            "return E_PERM;",
            "elseif (svc = set_verb_code(this, \"eval_d_util\", code))",
            "lines = {};",
            "for line in (svc)",
            "if ((index(line, \"Line \") == 1) && (n = toint(line[6..(colon = index(line + \":\", \":\")) - 1])))",
            "lines = {@lines, tostr(\"Line \", n - 5, line[colon..$])};",
            "else",
            "lines = {@lines, line};",
            "endif",
            "endfor",
            "return {0, lines};",
            "else",
            "set_task_perms(caller_perms());",
            "return {1, this:eval_d_util()};",
            "endif"
          ]
        },
        {
          "name": "toint tonum",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":toint(STR)\";",
            "\"=> toint(s) if STR is numeric\";",
            "\"=> E_TYPE if it isn't\";",
            "return match(s = args[1], \"^ *[-+]?[0-9]+ *$\") ? toint(s) | E_TYPE;"
          ]
        },
        {
          "name": "toobj",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":toobj(objectid as string) => objectid\";",
            "return match(s = args[1], \"^ *#[-+]?[0-9]+ *$\") ? toobj(s) | E_TYPE;"
          ]
        },
        {
          "name": "toerr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"toerr(n), toerr(\\\"E_FOO\\\"), toerr(\\\"FOO\\\") => E_FOO.\";",
            "if (typeof(s = args[1]) != STR)",
            "n = toint(s) + 1;",
            "if (n > length(this.error_list))",
            "return 1;",
            "endif",
            "elseif (!(n = (s in this.error_names) || ((\"E_\" + s) in this.error_names)))",
            "return 1;",
            "endif",
            "return this.error_list[n];"
          ]
        },
        {
          "name": "error_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"error_name(E_FOO) => \\\"E_FOO\\\"\";",
            "return toliteral(@args);",
            "return this.error_names[toint(args[1]) + 1];"
          ]
        },
        {
          "name": "show_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "set_task_perms(caller_perms());",
            "{object, ?what = {\"props\", \"verbs\"}} = args;",
            "player:notify(tostr(\"Object ID:  \", object));",
            "player:notify(tostr(\"Name:       \", object.name));",
            "names = {\"Parent\", \"Location\", \"Owner\"};",
            "vals = {parent(object), object.location, object.owner};",
            "for i in [1..length(vals)]",
            "if (!valid(vals[i]))",
            "val = \"*** NONE ***\";",
            "else",
            "val = ((vals[i].name + \" (\") + tostr(vals[i])) + \")\";",
            "endif",
            "player:notify(tostr(names[i], \":      \"[1..12 - length(names[i])], val));",
            "endfor",
            "line = \"Flags:     \";",
            "if (is_player(object))",
            "line = line + \" player\";",
            "endif",
            "for flag in ({\"programmer\", \"wizard\", \"r\", \"w\", \"f\"})",
            "if (object.(flag))",
            "line = (line + \" \") + flag;",
            "endif",
            "endfor",
            "player:notify(line);",
            "if (player.programmer && ((player.wizard || (player == object.owner)) || object.r))",
            "if ((\"verbs\" in what) && (vs = verbs(object)))",
            "player:notify(\"Verb definitions:\");",
            "for v in (vs)",
            "$command_utils:suspend_if_needed(0);",
            "player:notify(tostr(\"    \", v));",
            "endfor",
            "endif",
            "if (\"props\" in what)",
            "if (ps = properties(object))",
            "player:notify(\"Property definitions:\");",
            "for p in (ps)",
            "$command_utils:suspend_if_needed(0);",
            "player:notify(tostr(\"    \", p));",
            "endfor",
            "endif",
            "all_props = $object_utils:all_properties(object);",
            "if (all_props != {})",
            "player:notify(\"Properties:\");",
            "for p in (all_props)",
            "$command_utils:suspend_if_needed(0);",
            "strng = `toliteral(object.(p)) ! E_PERM => \"(Permission denied.)\"';",
            "player:notify(tostr(\"    \", p, \": \", strng));",
            "endfor",
            "endif",
            "endif",
            "elseif (player.programmer)",
            "player:notify(\"** Can't list properties or verbs: permission denied.\");",
            "endif",
            "if (object.contents)",
            "player:notify(\"Contents:\");",
            "for o in (object.contents)",
            "$command_utils:suspend_if_needed(0);",
            "player:notify(tostr(\"    \", o.name, \" (\", o, \")\"));",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "show_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "set_task_perms(caller_perms());",
            "{object, pname} = args;",
            "if (pname in this.builtin_props)",
            "player:notify(tostr(object, \".\", pname));",
            "player:notify(\"Built-in property.\");",
            "else",
            "try",
            "{owner, perms} = property_info(object, pname);",
            "except error (ANY)",
            "player:notify(error[2]);",
            "return;",
            "endtry",
            "player:notify(tostr(object, \".\", pname));",
            "player:notify(tostr(\"Owner:        \", valid(owner) ? tostr(owner.name, \" (\", owner, \")\") | \"*** NONE ***\"));",
            "player:notify(tostr(\"Permissions:  \", perms));",
            "endif",
            "player:notify(tostr(\"Value:        \", $string_utils:print(object.(pname))));"
          ]
        },
        {
          "name": "show_verbdef",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "set_task_perms(caller_perms());",
            "{object, vname} = args;",
            "if (!(hv = $object_utils:has_verb(object, vname)))",
            "player:notify(\"That object does not define that verb.\");",
            "return;",
            "elseif (hv[1] != object)",
            "player:notify(tostr(\"Object \", object, \" does not define that verb, but its ancestor \", hv[1], \" does.\"));",
            "object = hv[1];",
            "endif",
            "try",
            "{owner, perms, names} = verb_info(object, vname);",
            "except error (ANY)",
            "player:notify(error[2]);",
            "return;",
            "endtry",
            "arg_specs = verb_args(object, vname);",
            "player:notify(tostr(object, \":\", names));",
            "player:notify(tostr(\"Owner:            \", valid(owner) ? tostr(owner.name, \" (\", owner, \")\") | \"*** NONE ***\"));",
            "player:notify(tostr(\"Permissions:      \", perms));",
            "player:notify(tostr(\"Direct Object:    \", arg_specs[1]));",
            "player:notify(tostr(\"Preposition:      \", arg_specs[2]));",
            "player:notify(tostr(\"Indirect Object:  \", arg_specs[3]));"
          ]
        },
        {
          "name": "explain_verb_syntax",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "if (args[4..5] == {\"none\", \"this\"})",
            "return 0;",
            "endif",
            "{thisobj, verb, adobj, aprep, aiobj} = args;",
            "prep_part = (aprep == \"any\") ? \"to\" | this:short_prep(aprep);",
            "\".........`any' => `to' (arbitrary),... `none' => empty string...\";",
            "if ((adobj == \"this\") && (dobj == thisobj))",
            "dobj_part = dobjstr;",
            "iobj_part = ((!prep_part) || (aiobj == \"none\")) ? \"\" | ((aiobj == \"this\") ? dobjstr | iobjstr);",
            "elseif ((aiobj == \"this\") && (iobj == thisobj))",
            "dobj_part = (adobj == \"any\") ? dobjstr | ((adobj == \"this\") ? iobjstr | \"\");",
            "iobj_part = iobjstr;",
            "elseif (!(\"this\" in args[3..5]))",
            "dobj_part = (adobj == \"any\") ? dobjstr | \"\";",
            "iobj_part = (prep_part && (aiobj == \"any\")) ? iobjstr | \"\";",
            "else",
            "return 0;",
            "endif",
            "return tostr(verb, dobj_part ? \" \" + dobj_part | \"\", prep_part ? \" \" + prep_part | \"\", iobj_part ? \" \" + iobj_part | \"\");"
          ]
        },
        {
          "name": "verb_p*erms verb_permi*ssions",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"returns the permissions of the current verb (either the owner or the result of the most recent set_task_perms()).\";",
            "return caller_perms();"
          ]
        },
        {
          "name": "verb_loc*ation",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"returns the object where the current verb is defined.\";",
            "return callers()[1][4];"
          ]
        },
        {
          "name": "verb_documentation",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":verb_documentation([object,verbname]) => documentation at beginning of verb code, if any\";",
            "\"default is the calling verb\";",
            "set_task_perms(caller_perms());",
            "c = callers()[1];",
            "{?object = c[4], ?vname = c[2]} = args;",
            "try",
            "code = verb_code(object, vname);",
            "except error (ANY)",
            "return error[2];",
            "endtry",
            "doc = {};",
            "for line in (code)",
            "if (match(line, \"^\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))",
            "\"... now that we're sure `line' is just a string, eval() is safe...\";",
            "doc = {@doc, $no_one:eval(\"; return \" + line)[2]};",
            "else",
            "return doc;",
            "endif",
            "endfor",
            "return doc;"
          ]
        },
        {
          "name": "set_verb_documentation",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":set_verb_documentation(object,verbname,text)\";",
            "\"  changes documentation at beginning of verb code\";",
            "\"  text is either a string or a list of strings\";",
            "\"  returns a non-1 value if anything bad happens...\";",
            "set_task_perms(caller_perms());",
            "{object, vname, text} = args;",
            "if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)",
            "return code;",
            "elseif (typeof(vd = $code_utils:verb_documentation(object, vname)) == ERR)",
            "return vd;",
            "elseif (!(typeof(text) in {LIST, STR}))",
            "return E_INVARG;",
            "else",
            "newdoc = {};",
            "for l in ((typeof(text) == LIST) ? text | {text})",
            "if (typeof(l) != STR)",
            "return E_INVARG;",
            "endif",
            "newdoc = {@newdoc, $string_utils:print(l) + \";\"};",
            "endfor",
            "if (ERR == typeof(svc = `set_verb_code(object, vname, {@newdoc, @code[length(vd) + 1..$]}) ! ANY'))",
            "\"... this shouldn't happen.  I'm not setting this code -d just yet...\";",
            "return svc;",
            "else",
            "return 1;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "parse_propref",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:parse_propref(string)\";",
            "\"Parses string as a MOO-code property reference, returning {object-string, prop-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object.\";",
            "s = args[1];",
            "if (dot = index(s, \".\"))",
            "object = s[1..dot - 1];",
            "prop = s[dot + 1..$];",
            "if ((object == \"\") || (prop == \"\"))",
            "return 0;",
            "elseif (object[1] == \"$\")",
            "ob = `#0.(object[2..$]) ! ANY';",
            "if (typeof(ob) != OBJ)",
            "\"Try a map...\";",
            "ob = $code_utils:parse_sysobj_map(object);",
            "endif",
            "if (typeof(ob) != OBJ)",
            "return 0;",
            "endif",
            "object = tostr(ob);",
            "endif",
            "elseif (index(s, \"$\") == 1)",
            "object = \"#0\";",
            "prop = s[2..$];",
            "else",
            "return 0;",
            "endif",
            "return {object, prop};"
          ]
        },
        {
          "name": "parse_verbref",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:parse_verbref(string)\";",
            "\"Parses string as a MOO-code verb reference, returning {object-string, verb-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object().\";",
            "s = args[1];",
            "if (colon = index(s, \":\"))",
            "object = s[1..colon - 1];",
            "verbname = s[colon + 1..$];",
            "if (!(object && verbname))",
            "return 0;",
            "elseif (object[1] == \"$\")",
            "pname = object[2..$];",
            "if ((!(pname in properties(#0))) || (typeof(ob = #0.(pname)) != OBJ))",
            "\"Try a map...\";",
            "ob = $code_utils:parse_sysobj_map(object);",
            "endif",
            "if (typeof(ob) != OBJ)",
            "return 0;",
            "endif",
            "object = tostr(ob);",
            "endif",
            "return {object, verbname};",
            "elseif ((index(s, \"$\") == 1) && (!index(s, \".\")))",
            "return {\"#0\", s[2..$]};",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "parse_argspec",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":parse_arg_spec(@args)\";",
            "\"  attempts to parse the given sequence of args into a verb_arg specification\";",
            "\"returns {verb_args,remaining_args} if successful.\";",
            "\"  e.g., :parse_arg_spec(\\\"this\\\",\\\"in\\\",\\\"front\\\",\\\"of\\\",\\\"any\\\",\\\"foo\\\"..)\";",
            "\"           => {{\\\"this\\\",\\\"in front of\\\",\\\"any\\\"},{\\\"foo\\\"..}}\";",
            "\"returns a string error message if parsing fails.\";",
            "nargs = length(args);",
            "if (nargs < 1)",
            "return {{}, {}};",
            "elseif ((ds = args[1]) == \"tnt\")",
            "return {{\"this\", \"none\", \"this\"}, listdelete(args, 1)};",
            "elseif (!(ds in {\"this\", \"any\", \"none\"}))",
            "return tostr(\"\\\"\", ds, \"\\\" is not a valid direct object specifier.\");",
            "elseif ((nargs < 2) || (args[2] in {\"none\", \"any\"}))",
            "verbargs = args[1..min(3, nargs)];",
            "rest = args[4..nargs];",
            "elseif (!(gp = $code_utils:get_prep(@args[2..nargs]))[1])",
            "return tostr(\"\\\"\", args[2], \"\\\" is not a valid preposition.\");",
            "else",
            "verbargs = {ds, @gp[1..min(2, nargs = length(gp))]};",
            "rest = gp[3..nargs];",
            "endif",
            "if ((length(verbargs) >= 3) && (!(verbargs[3] in {\"this\", \"any\", \"none\"})))",
            "return tostr(\"\\\"\", verbargs[3], \"\\\" is not a valid indirect object specifier.\");",
            "endif",
            "return {verbargs, rest};"
          ]
        },
        {
          "name": "prepositions",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "if (server_version() != this._version)",
            "this:_fix_preps();",
            "endif",
            "return this.prepositions;"
          ]
        },
        {
          "name": "short_prep",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":short_prep(p) => shortest preposition equivalent to p\";",
            "\"p may be a single word or one of the strings returned by verb_args().\";",
            "if (server_version() != this._version)",
            "this:_fix_preps();",
            "endif",
            "word = args[1];",
            "word = word[1..index(word + \"/\", \"/\") - 1];",
            "if (p = word in this._other_preps)",
            "return this._short_preps[this._other_preps_n[p]];",
            "elseif (word in this._short_preps)",
            "return word;",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "full_prep",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "if (server_version() != this._version)",
            "this:_fix_preps();",
            "endif",
            "prep = args[1];",
            "if (p = prep in this._short_preps)",
            "return this.prepositions[p];",
            "elseif (p = prep in this._other_preps)",
            "return this.prepositions[this._other_preps_n[p]];",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "get_prep",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":get_prep(@args) extracts the prepositional phrase from the front of args, returning a list consisting of the preposition (or \\\"\\\", if none) followed by the unused args.\";",
            "\":get_prep(\\\"in\\\",\\\"front\\\",\\\"of\\\",...) => {\\\"in front of\\\",...}\";",
            "\":get_prep(\\\"inside\\\",...)          => {\\\"inside\\\",...}\";",
            "\":get_prep(\\\"frabulous\\\",...}       => {\\\"\\\", \\\"frabulous\\\",...}\";",
            "prep = \"\";",
            "allpreps = {@this._short_preps, @this._other_preps};",
            "rest = 1;",
            "for i in [1..length(args)]",
            "accum = (i == 1) ? args[1] | tostr(accum, \" \", args[i]);",
            "if (accum in allpreps)",
            "prep = accum;",
            "rest = i + 1;",
            "endif",
            "if (!(accum in this._multi_preps))",
            "return {prep, @args[rest..$]};",
            "endif",
            "endfor",
            "return {prep, @args[rest..$]};"
          ]
        },
        {
          "name": "_fix_preps",
          "owner": 36,
          "perms": 173,
          "preps": 1,
          "object": 59,
          "code": [
            "\":_fix_preps() updates the properties on this having to do with prepositions.\";",
            "\"_fix_preps should be called whenever we detect that a new server version has been installed.\";",
            "orig_args = verb_args(this, verb);",
            "multis = nothers = others = shorts = longs = {};",
            "i = 0;",
            "while (typeof(`set_verb_args(this, verb, {\"this\", tostr(i), \"this\"}) ! ANY') != ERR)",
            "l = verb_args(this, verb)[2];",
            "all = $string_utils:explode(l, \"/\");",
            "s = all[1];",
            "for p in (listdelete(all, 1))",
            "if (length(p) <= length(s))",
            "s = p;",
            "endif",
            "endfor",
            "for p in (all)",
            "while (j = rindex(p, \" \"))",
            "multis = {p = p[1..j - 1], @multis};",
            "endwhile",
            "endfor",
            "longs = {@longs, l};",
            "shorts = {@shorts, s};",
            "others = {@others, @setremove(all, s)};",
            "nothers = {@nothers, @$list_utils:make(length(all) - 1, length(shorts))};",
            "i = i + 1;",
            "endwhile",
            "set_verb_args(this, verb, orig_args);",
            "this.prepositions = longs;",
            "this._short_preps = shorts;",
            "this._other_preps = others;",
            "this._other_preps_n = nothers;",
            "this._multi_preps = multis;",
            "this._version = server_version();",
            "return;"
          ]
        },
        {
          "name": "find_verb_named",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 59,
          "code": [
            "\":find_verb_named(object,name[,n])\";",
            "\"  returns the *number* of the first verb on object matching the given name.\";",
            "\"  optional argument n, if given, starts the search with verb n,\";",
            "\"  causing the first n verbs (1..n-1) to be ignored.\";",
            "\"  0 is returned if no verb is found.\";",
            "\"  This routine does not find inherited verbs.\";",
            "{object, name, ?start = 1} = args;",
            "for i in [start..length(verbs(object))]",
            "verbinfo = verb_info(object, i);",
            "if (this:verbname_match(verbinfo[3], name))",
            "return i;",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "find_last_verb_named",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":find_last_verb_named(object,name[,n])\";",
            "\"  returns the *number* of the last verb on object matching the given name.\";",
            "\"  optional argument n, if given, starts the search with verb n-1,\";",
            "\"  causing verbs (n..length(verbs(object))) to be ignored.\";",
            "\"  -1 is returned if no verb is found.\";",
            "\"  This routine does not find inherited verbs.\";",
            "{object, name, ?last = -1} = args;",
            "if (last < 0)",
            "last = length(verbs(object));",
            "endif",
            "for i in [0..last - 1]",
            "verbinfo = verb_info(object, last - i);",
            "if (this:verbname_match(verbinfo[3], name))",
            "return last - i;",
            "endif",
            "endfor",
            "return -1;"
          ]
        },
        {
          "name": "find_callable_verb_named",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":find_callable_verb_named(object,name[,n])\";",
            "\"  returns the *number* of the first verb on object that matches the given\";",
            "\"  name and has the x flag set.\";",
            "\"  optional argument n, if given, starts the search with verb n,\";",
            "\"  causing the first n verbs (0..n-1) to be ignored.\";",
            "\"  0 is returned if no verb is found.\";",
            "\"  This routine does not find inherited verbs.\";",
            "{object, name, ?start = 1} = args;",
            "for i in [start..length(verbs(object))]",
            "verbinfo = verb_info(object, i);",
            "if (index(verbinfo[2], \"x\") && this:verbname_match(verbinfo[3], name))",
            "return i;",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "find_verbs_containing find_verbs_matching find_verb_lines_containing find_verb_lines_matching",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:find_verbs_containing(pattern[,object|object-list[,casematters]])\";",
            "\"$code_utils:find_verbs_matching(pattern[,object|object-list[,casematters]])\";",
            "\"$code_utils:find_verb_lines_containing(pattern[,object|object-list[,casematters]])\";",
            "\"$code_utils:find_verb_lines_matching(pattern[,object|object-list[,casematters]])\";",
            "\"\";",
            "\"Print (to player) the name and owner of every verb in the database whose code\";",
            "\"  (find_verbs_containing) contains PATTERN as a substring \";",
            "\"  (find_verbs_matching)   has a substring matches the regular expression PATTERN .\";",
            "\"Optional second argument limits the search to the specified object or objects.\";",
            "\"Optional third argument if true specifies case-sensitive matching.\";",
            "\":find_verbs_*() prints the first matching line in a verb while\";",
            "\":find_verb_lines_*() prints all matching lines\";",
            "\"\";",
            "\"Because it searches the entire database, this function may suspend the task several times before returning.\";",
            "\"\";",
            "set_task_perms(caller_perms());",
            "\"... puts the task in a player's own job queue and prevents someone from learning about verbs that are otherwise unreadable to him/her.\";",
            "{pattern, ?where = 0, ?casematters = 0} = args;",
            "count = 0;",
            "_find_verbs = \"_\" + verb;",
            "if (typeof(where) == INT)",
            "for o in [toobj(where)..max_object()]",
            "count = count + this:(_find_verbs)(pattern, o, casematters);",
            "endfor",
            "elseif (typeof(where) == LIST)",
            "for o in (where)",
            "count = count + this:(_find_verbs)(pattern, o, casematters);",
            "endfor",
            "else",
            "\"...typeof(where) == OBJ...\";",
            "count = this:(_find_verbs)(pattern, where, casematters);",
            "endif",
            "player:notify(\"\");",
            "player:notify(tostr(\"Total: \", count, \" verb\", (count != 1) ? \"s.\" | \".\"));"
          ]
        },
        {
          "name": "_find_verbs_containing _find_verbs_matching",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_find_verbs_containing(pattern,object[,casematters])\";",
            "\":_find_verbs_matching(regexp,object[,casematters])\";",
            "\"number of verbs in object with code having a line containing pattern or matching regexp\";",
            "\"prints verbname and offending line to player\";",
            "set_task_perms(caller_perms());",
            "{pattern, o, ?casematters = 0} = args;",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", o));",
            "suspend(0);",
            "endif",
            "if (!valid(o))",
            "return 0;",
            "endif",
            "count = 0;",
            "verbs = $object_utils:accessible_verbs(o);",
            "_grep_verb_code = (verb == \"_find_verbs_matching\") ? \"_egrep_verb_code\" | \"_grep_verb_code\";",
            "if (typeof(verbs) != LIST)",
            "return player:notify(tostr(\"verbs(\", o, \") => \", tostr(verbs)));",
            "endif",
            "for vnum in [1..length(verbs)]",
            "if (l = this:(_grep_verb_code)(pattern, o, vnum, casematters))",
            "owner = verb_info(o, vnum)[1];",
            "player:notify(tostr(o, \":\", verbs[vnum], \" [\", valid(owner) ? owner.name | \"Recycled Player\", \" (\", owner, \")]:  \", l));",
            "count = count + 1;",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", o));",
            "suspend(0);",
            "endif",
            "endfor",
            "return count;"
          ]
        },
        {
          "name": "_grep_verb_code",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_grep_verb_code(pattern,object,verbname[,casematters]) => line number or 0\";",
            "\"  returns line number on which pattern occurs in code for object:verbname\";",
            "set_task_perms(caller_perms());",
            "{pattern, object, vname, ?casematters = 0} = args;",
            "\"The following gross kluge is due to Quade (#82589).  tostr is fast, and so we can check for nonexistence of a pattern very quickly this way rather than checking line by line.  MOO needs a compiler.  --Nosredna\";",
            "vc = `verb_code(object, vname) ! ANY';",
            "if ((typeof(vc) == ERR) || (!index(tostr(@vc), pattern, casematters)))",
            "return 0;",
            "else",
            "for line in (vc)",
            "if (index(line, pattern, casematters))",
            "return line;",
            "endif",
            "endfor",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "_egrep_verb_code",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_egrep_verb_code(regexp,object,verbname[,casematters]) => 0 or line number\";",
            "\"  returns line number of first line matching regexp in object:verbname code\";",
            "set_task_perms(caller_perms());",
            "{pattern, object, vname, ?casematters = 0} = args;",
            "try",
            "for line in (vc = `verb_code(object, vname) ! ANY => {}')",
            "if (match(line, pattern, casematters))",
            "return line;",
            "endif",
            "endfor",
            "except (E_INVARG)",
            "raise(E_INVARG, \"Malformed regular expression.\");",
            "endtry",
            "return 0;"
          ]
        },
        {
          "name": "_parse_audit_args",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"Parse [from <start>] [to <end>] [for <name>].\";",
            "\"Takes a series of strings, most likely @args with dobjstr removed.\";",
            "\"Returns a list {INT start, INT end, STR name}, or {} if there is an error.\";",
            "fail = length(args) % 2;",
            "start = 0;",
            "end = toint(max_object());",
            "match = \"\";",
            "while (args && (!fail))",
            "prep = args[1];",
            "if (prep == \"from\")",
            "if ((start = player.location:match_object(args[2])) >= #0)",
            "start = toint(start);",
            "else",
            "start = toint(args[2]);",
            "endif",
            "elseif (prep == \"to\")",
            "if ((end = player.location:match_object(args[2])) >= #0)",
            "end = toint(end);",
            "else",
            "end = toint(args[2]);",
            "endif",
            "elseif (prep == \"for\")",
            "match = args[2];",
            "else",
            "fail = 1;",
            "endif",
            "args = args[3..length(args)];",
            "endwhile",
            "return fail ? {} | {start, end, match};"
          ]
        },
        {
          "name": "help_db_list",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":help_db_list([player]) => list of help dbs\";",
            "\"in the order that they are consulted by player\";",
            "{?who = player} = args;",
            "olist = {who, @$object_utils:ancestors(who)};",
            "if (valid(who.location))",
            "olist = {@olist, who.location, @$object_utils:ancestors(who.location)};",
            "endif",
            "dbs = {};",
            "for o in (olist)",
            "h = `o.help ! ANY => 0';",
            "if (typeof(h) == OBJ)",
            "h = {h};",
            "endif",
            "if (typeof(h) == LIST)",
            "for db in (h)",
            "if ((typeof(db) == OBJ) && (valid(db) && (!(db in dbs))))",
            "dbs = {@dbs, db};",
            "endif",
            "endfor",
            "endif",
            "endfor",
            "return setadd(dbs, $help);"
          ]
        },
        {
          "name": "help_db_search",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":help_db_search(string,dblist)\";",
            "\"  searches each of the help db's in dblist for a topic matching string.\";",
            "\"  Returns  {db,topic}  or  {$ambiguous_match,{topic...}}  or {}\";",
            "{what, dblist} = args;",
            "topics = {};",
            "help = 1;",
            "verb_help_match = 0;",
            "for db in (dblist)",
            "$command_utils:suspend_if_needed(0);",
            "if ({what} == (ts = `db:find_topics(what) ! ANY => 0'))",
            "if (db == $help_db[\"verb\"])",
            "\"Verb help is considered a last resort. It's possible help files contain more relevant information (e.g. $login).\";",
            "verb_help_match = {db, ts[1]};",
            "else",
            "return {db, ts[1]};",
            "endif",
            "elseif (ts && (typeof(ts) == LIST))",
            "if (help)",
            "help = db;",
            "endif",
            "for t in (ts)",
            "topics = setadd(topics, t);",
            "endfor",
            "endif",
            "endfor",
            "if (length(topics) > 1)",
            "return {$ambiguous_match, topics};",
            "elseif (topics)",
            "return {help, topics[1]};",
            "elseif (verb_help_match)",
            "return verb_help_match;",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "corify_object",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":corify_object(object)  => string representing object\";",
            "\"  usually just returns tostr(object), but in the case of objects that have\";",
            "\"  corresponding #0 properties, return the appropriate $-string.\";",
            "object = args[1];",
            "\"Just in case #0 is !r on some idiot core.\";",
            "for p in (`properties(#0) ! ANY => {}')",
            "\"And if for some reason, some #0 prop is !r.\";",
            "if (`#0.(p) ! ANY' == object)",
            "return \"$\" + p;",
            "elseif (typeof(`#0.(p) ! ANY') == MAP)",
            "for value, key in (#0.(p))",
            "if (value == object)",
            "return tostr(\"$\", p, \"[\\\"\", key, \"\\\"]\");",
            "endif",
            "endfor",
            "endif",
            "endfor",
            "return tostr(object);"
          ]
        },
        {
          "name": "inside_quotes",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"See if the end of the string passed as args[1] ends 'inside' a doublequote.  Used by $code_utils:substitute.\";",
            "{string} = args;",
            "quoted = 0;",
            "while (i = index(string, \"\\\"\"))",
            "if ((!quoted) || ((i == 1) || (string[i - 1] != \"\\\\\")))",
            "quoted = !quoted;",
            "endif",
            "string = string[i + 1..$];",
            "endwhile",
            "return quoted;"
          ]
        },
        {
          "name": "verb_or_property",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"verb_or_property(<obj>, <name> [, @<args>])\";",
            "\"Looks for a callable verb or property named <name> on <obj>.\";",
            "\"If <obj> has a callable verb named <name> then return <obj>:(<name>)(@<args>).\";",
            "\"If <obj> has a property named <name> then return <obj>.(<name>).\";",
            "\"Otherwise return E_PROPNF, or E_PERM if you don't have permission to read the property.\";",
            "set_task_perms(caller_perms());",
            "{object, name, @rest} = args;",
            "return `object:(name)(@rest) ! E_VERBNF, E_INVIND => `object.(name) ! ANY'';"
          ]
        },
        {
          "name": "task_valid",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"task_valid(INT id)\";",
            "\"Return true iff there is currently a valid task with the given id.\";",
            "set_task_perms($no_one);",
            "{id} = args;",
            "t = $list_utils:slice(queued_tasks(), 1);",
            "return ((id == task_id()) || (id in t)) || (E_PERM == `kill_task(id) ! ANY');"
          ]
        },
        {
          "name": "task_owner",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":task_owner(INT task_id) => returns the owner of the task belonging to the id.\";",
            "if (a = $list_utils:assoc(args[1], queued_tasks()))",
            "return a[5];",
            "else",
            "return E_INVARG;",
            "endif"
          ]
        },
        {
          "name": "argstr",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":argstr(verb,args[,argstr]) => what argstr should have been.  \";",
            "\"Recall that the command line is parsed into a sequence of words; `verb' is\";",
            "\"assigned the first word, `args' is assigned the remaining words, and argstr\";",
            "\"is assigned a substring of the command line, which *should* be the one\";",
            "\"starting first nonblank character after the verb, but is instead (because\";",
            "\"the parser is BROKEN!) the one starting with the first nonblank character\";",
            "\"after the first space in the line, which is not necessarily after the verb.\";",
            "\"Clearly, if the verb contains spaces --- which can happen if you use\";",
            "\"backslashes and quotes --- this loses, and argstr will then erroneously\";",
            "\"have extra junk at the beginning.  This verb, given verb, args, and the\";",
            "\"actual argstr, returns what argstr should have been.\";",
            "verb = args[1];",
            "argstr = {@args, argstr}[3];",
            "n = length(args = args[2]);",
            "if (!index(verb, \" \"))",
            "return argstr;",
            "elseif (!args)",
            "return \"\";",
            "endif",
            "\"space in verb => two possible cases:\";",
            "\"(1) first space was not in a quoted string.\";",
            "\"    first word of argstr == rest of verb unless verb ended on this space.\";",
            "if ((nqargs = $string_utils:words(argstr)) == args)",
            "return argstr;",
            "elseif (((nqn = length(nqargs)) == (n + 1)) && (nqargs[2..nqn] == args))",
            "return argstr[$string_utils:word_start(argstr)[2][1]..length(argstr)];",
            "else",
            "\"(2) first space was in a quoted string.\";",
            "\"    argstr starts with rest of string\";",
            "qs = $string_utils:word_start(\"\\\"\" + argstr);",
            "return argstr[qs[(length(qs) - length(args)) + 1][1] - 1..length(argstr)];",
            "endif"
          ]
        },
        {
          "name": "verbname_match",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'\";",
            "verblist = (\" \" + args[1]) + \" \";",
            "if (index(verblist, (\" \" + (name = args[2])) + \" \") && (!(index(name, \"*\") || index(name, \" \"))))",
            "\"Note that if name has a * or a space in it, then it can only match one of the * verbnames\";",
            "return 1;",
            "else",
            "namelen = length(name);",
            "while (star = index(verblist, \"*\"))",
            "vstart = rindex(verblist[1..star], \" \") + 1;",
            "vlast = (vstart + index(verblist[vstart..$], \" \")) - 2;",
            "if ((namelen >= (star - vstart)) && ((!(v = strsub(verblist[vstart..vlast], \"*\", \"\"))) || (index(v, (verblist[vlast] == \"*\") ? name[1..min(namelen, length(v))] | name) == 1)))",
            "return 1;",
            "endif",
            "verblist = verblist[vlast + 1..$];",
            "endwhile",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "substitute",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:substitute(string,subs) => new line\";",
            "\"Subs are a list of lists, {{\\\"target\\\",\\\"sub\\\"},{...}...}\";",
            "\"Substitutes targets for subs in a delimited string fashion, avoiding substituting anything inside quotes, e.g. player:tell(\\\"don't sub here!\\\")\";",
            "{s, subs} = args;",
            "lets = \"abcdefghijklmnopqrstuvwxyz0123456789\";",
            "for x in (subs)",
            "len = length(sub = x[1]);",
            "delimited = index(lets, sub[1]) && index(lets, sub[len]);",
            "prefix = \"\";",
            "while (i = index(s, sub))",
            "prefix = prefix + s[1..i - 1];",
            "if ((((prefix == \"\") || ((!delimited) || (!index(lets, prefix[$])))) && ((!delimited) || (((i + len) > length(s)) || (!index(lets, s[i + len]))))) && (!this:inside_quotes(prefix)))",
            "prefix = prefix + x[2];",
            "else",
            "prefix = prefix + s[i..(i + len) - 1];",
            "endif",
            "s = s[i + len..length(s)];",
            "endwhile",
            "s = prefix + s;",
            "endfor",
            "return s;"
          ]
        },
        {
          "name": "show_who_listing",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":show_who_listing(players[,more_players])\";",
            "\" prints a listing of the indicated players.\";",
            "\" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.\";",
            "{plist, ?more_plist = {}} = args;",
            "idles = itimes = offs = otimes = {};",
            "argstr = dobjstr = iobjstr = prepstr = \"\";",
            "for p in (more_plist)",
            "if (!valid(p))",
            "caller:notify(tostr(p, \" <invalid>\"));",
            "elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)",
            "if (!(p in offs))",
            "offs = {@offs, p};",
            "otimes = {@otimes, {-t, -t, p}};",
            "endif",
            "elseif (is_player(p))",
            "caller:notify(tostr(p.name, \" (\", p, \") \", (t == E_PROPNF) ? \"is not a $player.\" | \"has a garbled .last_disconnect_time.\"));",
            "else",
            "caller:notify(tostr(p.name, \" (\", p, \") is not a player.\"));",
            "endif",
            "endfor",
            "for p in (plist)",
            "if (p in offs)",
            "elseif (!valid(p))",
            "caller:notify(tostr(p, \" <invalid>\"));",
            "elseif (typeof(i = `idle_seconds(p) ! ANY') != ERR)",
            "if (!(p in idles))",
            "idles = {@idles, p};",
            "itimes = {@itimes, {i, connected_seconds(p), p}};",
            "endif",
            "elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)",
            "offs = {@offs, p};",
            "otimes = {@otimes, {-t, -t, p}};",
            "elseif (is_player(p))",
            "caller:notify(tostr(p.name, \" (\", p, \") not logged in.\", (t == E_PROPNF) ? \"  Not a $player.\" | \"  Garbled .last_disconnect_time.\"));",
            "else",
            "caller:notify(tostr(p.name, \" (\", p, \") is not a player.\"));",
            "endif",
            "endfor",
            "if (!(idles || offs))",
            "return 0;",
            "endif",
            "idles = $list_utils:sort_alist(itimes);",
            "offs = $list_utils:sort_alist(otimes);",
            "\"...\";",
            "\"... calculate widths...\";",
            "\"...\";",
            "headers = {\"Player name\", @idles ? {\"Connected\", \"Idle time\"} | {\"Last disconnect time\", \"\"}, \"Location\"};",
            "total_width = `caller:linelen() ! ANY => 0' || 79;",
            "max_name = total_width / 4;",
            "name_width = length(headers[1]);",
            "names = locations = {};",
            "for lst in ({@idles, @offs})",
            "$command_utils:suspend_if_needed(0);",
            "p = lst[3];",
            "namestr = tostr(p.name[1..min(max_name, $)], \" (\", p, \")\");",
            "name_width = max(length(namestr), name_width);",
            "names = {@names, namestr};",
            "if (typeof(wlm = `p.location:who_location_msg(p) ! ANY') != STR)",
            "wlm = valid(p.location) ? p.location.name | tostr(\"** Nowhere ** (\", p.location, \")\");",
            "endif",
            "locations = {@locations, wlm};",
            "endfor",
            "time_width = 3 + (offs ? 12 | length(\"59 minutes\"));",
            "before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};",
            "\"...\";",
            "\"...print headers...\";",
            "\"...\";",
            "su = $string_utils;",
            "tell1 = headers[1];",
            "tell2 = su:space(tell1, \"-\");",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + headers[j];",
            "tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");",
            "endfor",
            "caller:notify(tell1[1..min($, total_width)]);",
            "caller:notify(tell2[1..min($, total_width)]);",
            "\"...\";",
            "\"...print lines...\";",
            "\"...\";",
            "active = 0;",
            "for i in [1..total = (ilen = length(idles)) + length(offs)]",
            "if (i <= ilen)",
            "lst = idles[i];",
            "if (lst[1] < (5 * 60))",
            "active = active + 1;",
            "endif",
            "l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};",
            "else",
            "lct = offs[i - ilen][3].last_connect_time;",
            "ldt = offs[i - ilen][3].last_disconnect_time;",
            "ctime = `caller:ctime(ldt) ! ANY => 0' || ctime(ldt);",
            "l = {names[i], (lct <= time()) ? ctime | \"Never\", \"\", locations[i]};",
            "if ((i == (ilen + 1)) && idles)",
            "caller:notify(su:space(before[2]) + \"------- Disconnected -------\");",
            "endif",
            "endif",
            "tell1 = l[1];",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + l[j];",
            "endfor",
            "caller:notify(tell1[1..min($, total_width)]);",
            "if ($command_utils:running_out_of_time())",
            "if ($login:is_lagging())",
            "\"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.\";",
            "caller:notify(tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\"));",
            "return;",
            "endif",
            "now = time();",
            "suspend(0);",
            "if ((time() - now) > 10)",
            "caller:notify(tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\"));",
            "return;",
            "endif",
            "endif",
            "endfor",
            "\"...\";",
            "\"...epilogue...\";",
            "\"...\";",
            "caller:notify(\"\");",
            "if (total == 1)",
            "active_str = \", who has\" + ((active == 1) ? \"\" | \" not\");",
            "else",
            "if (active == total)",
            "active_str = (active == 2) ? \"s, both\" | \"s, all\";",
            "elseif (active == 0)",
            "active_str = \"s, none\";",
            "else",
            "active_str = tostr(\"s, \", active);",
            "endif",
            "active_str = tostr(active_str, \" of whom ha\", (active == 1) ? \"s\" | \"ve\");",
            "endif",
            "caller:notify(tostr(\"Total: \", total, \" player\", active_str, \" been active recently.\"));",
            "return total;"
          ]
        },
        {
          "name": "_egrep_verb_code_all",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_egrep_verb_code_all(regexp,object,verbname[,casematters]) => list of lines number\";",
            "\"  returns list of all lines matching regexp in object:verbname code\";",
            "set_task_perms(caller_perms());",
            "{pattern, object, vname, ?casematters = 0} = args;",
            "lines = {};",
            "for line in (vc = `verb_code(object, vname, 1, 0) ! ANY => {}')",
            "if (match(line, pattern, casematters))",
            "lines = {@lines, line};",
            "endif",
            "endfor",
            "return lines;"
          ]
        },
        {
          "name": "_grep_verb_code_all",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_grep_verb_code_all(pattern,object,verbname[,casematters]) => list of lines\";",
            "\"  returns list of lines on which pattern occurs in code for object:verbname\";",
            "set_task_perms(caller_perms());",
            "{pattern, object, vname, ?casematters = 0} = args;",
            "lines = {};",
            "for line in (vc = `verb_code(object, vname) ! ANY => {}')",
            "if (index(line, pattern, casematters))",
            "lines = {@lines, line};",
            "endif",
            "endfor",
            "return lines;"
          ]
        },
        {
          "name": "verb_usage",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":verb_usage([object,verbname]) => usage string at beginning of verb code, if any\";",
            "\"default is the calling verb\";",
            "set_task_perms(caller_perms());",
            "c = callers()[1];",
            "{?object = c[4], ?vname = c[2]} = args;",
            "if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)",
            "return code;",
            "else",
            "doc = {};",
            "indent = \"^$\";",
            "for line in (code)",
            "if (match(line, \"^\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))",
            "\"... now that we're sure `line' is just a string, eval() is safe...\";",
            "e = $no_one:eval(line)[2];",
            "if (subs = match(e, \"^%(%(Usage%|Syntax%): +%)%([^ ]+%)%(.*$%)\"))",
            "\"Server is broken, hence the next three lines:\";",
            "if (subs[3][4][1] > subs[3][4][2])",
            "subs[3][4] = {0, -1};",
            "endif",
            "indent = (\"^%(\" + $string_utils:space(length(substitute(\"%1\", subs)))) + \" *%)%([^ ]+%)%(.*$%)\";",
            "docverb = substitute(\"%3\", subs);",
            "if (match(vname, \"^[0-9]+$\"))",
            "vname = docverb;",
            "endif",
            "doc = {@doc, (substitute(\"%1\", subs) + vname) + substitute(\"%4\", subs)};",
            "elseif (subs = match(e, indent))",
            "if (substitute(\"%3\", subs) == docverb)",
            "doc = {@doc, (substitute(\"%1\", subs) + vname) + substitute(\"%4\", subs)};",
            "else",
            "doc = {@doc, e};",
            "endif",
            "elseif (indent)",
            "return doc;",
            "endif",
            "else",
            "return doc;",
            "endif",
            "endfor",
            "return doc;",
            "endif"
          ]
        },
        {
          "name": "verb_frame",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"returns the callers() frame for the current verb.\";",
            "return callers()[1];"
          ]
        },
        {
          "name": "verb_all_frames",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"returns {this:verb_frame(), @callers()}.\";",
            "return callers();"
          ]
        },
        {
          "name": "move_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":move_verb(OBJ from, STR verb name, OBJ to, [STR new verb name]) -> Moves the specified verb from one object to another. Returns {OBJ, Full verb name} where the verb now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the verb, unless called with wizard perms. Supplying a fourth argument moves the verb to a new name.\";",
            "\"Should handle verbnames with aliases and wildcards correctly.\";",
            "who = caller_perms();",
            "{from, origverb, to, ?destverb = origverb} = args;",
            "if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origverb) != STR)) || (typeof(destverb) != STR))",
            "\"check this first so we can parse out long verb names next\";",
            "return E_TYPE;",
            "endif",
            "origverb_first = strsub(origverb[1..index(origverb + \" \", \" \") - 1], \"*\", \"\") || \"*\";",
            "destverb_first = strsub(destverb[1..index(destverb + \" \", \" \") - 1], \"*\", \"\") || \"*\";",
            "if ((!valid(from)) || (!valid(to)))",
            "return E_INVARG;",
            "elseif ((from == to) && (destverb == origverb))",
            "\"Moving same origverb onto the same object puts the verbcode in the wrong one. Just not allow\";",
            "return E_NACC;",
            "elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))",
            "\"caller_perms() is not allowed to hack on either object in question\";",
            "return E_PERM;",
            "elseif (!$object_utils:defines_verb(from, origverb_first))",
            "\"verb is not defined on the from object\";",
            "return E_VERBNF;",
            "elseif ((vinfo = verb_info(from, origverb_first)) && (!$perm_utils:controls(who, vinfo[1])))",
            "\"caller_perms() is not permitted to add a verb with the existing verb owner\";",
            "return E_PERM;",
            "elseif (!who.programmer)",
            "return E_PERM;",
            "else",
            "\"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)\";",
            "vcode = verb_code(from, origverb_first);",
            "vargs = verb_args(from, origverb_first);",
            "vinfo[3] = (destverb == origverb) ? vinfo[3] | destverb;",
            "if (typeof(res = `add_verb(to, vinfo, vargs) ! ANY') == ERR)",
            "return res;",
            "else",
            "set_verb_code(to, destverb_first, vcode);",
            "delete_verb(from, origverb_first);",
            "return {to, vinfo[3]};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "move_prop*erty",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":move_prop(OBJ from, STR prop name, OBJ to, [STR new prop name]) -> Moves the specified property and its contents from one object to another. Returns {OBJ, property name} where the property now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the property, unless called with wizard perms. Supplying a fourth argument gives the property a new name on the new object.\";",
            "who = caller_perms();",
            "{from, origprop, to, ?destprop = origprop} = args;",
            "if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origprop) != STR)) || (typeof(destprop) != STR))",
            "return E_TYPE;",
            "elseif ((!valid(from)) || (!valid(to)))",
            "return E_INVARG;",
            "elseif ((from == to) && (destprop == origprop))",
            "\"Moving same prop onto the same object puts the contents in the wrong one. Just not allow\";",
            "return E_NACC;",
            "elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))",
            "\"caller_perms() is not allowed to hack on either object in question\";",
            "return E_PERM;",
            "elseif (!$object_utils:defines_property(from, origprop))",
            "\"property is not defined on the from object\";",
            "return E_PROPNF;",
            "elseif ((pinfo = property_info(from, origprop)) && (!$perm_utils:controls(who, pinfo[1])))",
            "\"caller_perms() is not permitted to add a property with the existing property owner\";",
            "return E_PERM;",
            "elseif (!who.programmer)",
            "return E_PERM;",
            "else",
            "\"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective property owner (by more traditional means)\";",
            "pdata = from.(origprop);",
            "pname = (destprop == origprop) ? origprop | destprop;",
            "if (typeof(res = `add_property(to, pname, pdata, pinfo) ! ANY') == ERR)",
            "return res;",
            "else",
            "delete_property(from, origprop);",
            "return {to, pname};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "eval_d_util",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 59,
          "code": [
            "\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\";"
          ]
        },
        {
          "name": "display_callers",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":display_callers([callers() style list]) - displays the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.\";",
            "call = (caller_perms() == player) ? \"notify_lines\" | \"tell_lines\";",
            "player:(call)(this:callers_text(@args));"
          ]
        },
        {
          "name": "callers_text",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":callers_text([callers() style list]) - returns the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.\";",
            "linelen = min(player:linelen(), 200);",
            "text = {};",
            "su = $string_utils;",
            "lu = $list_utils;",
            "verbwidth = 0;",
            "{?match = callers(1)} = args;",
            "for verbitem in (lu:slice(match, 2))",
            "verbwidth = max(verbwidth, length(verbitem));",
            "endfor",
            "verbwidth = 3 + verbwidth;",
            "numwidth = ((linelen - verbwidth) / 4) - 1;",
            "widths = {numwidth, verbwidth, numwidth, numwidth, numwidth};",
            "top = l = between = \"\";",
            "for x in [1..5]",
            "top = (top + between) + su:left({\"This\", \"Verb\", \"Permissions\", \"VerbLocation\", \"Player\"}[x], -widths[x]);",
            "l = (l + between) + su:space(widths[x], \"-\");",
            "between = \" \";",
            "endfor",
            "text = listappend(text, top);",
            "text = listappend(text, l);",
            "for line in (match)",
            "output = {};",
            "for bit in [1..5]",
            "$command_utils:suspend_if_needed(3);",
            "\"bit == 2 below for verb: append line number.\";",
            "output = {@output, su:left((typeof(word = line[bit]) == STR) ? (bit == 2) ? tostr(word, \"(\", `line[6] ! ANY => 0', \")\") | word | tostr(word, \"(\", valid(word) ? lu:shortest({word.name, @word.aliases}) | ((word == $nothing) ? \"invalid\" | ((word == $ambiguous_match) ? \"ambiguous match\" | \"Error\")), \")\"), -widths[bit]), \" \"};",
            "endfor",
            "text = listappend(text, su:trimr(tostr(@output)));",
            "endfor",
            "text = listappend(text, l);",
            "return text;"
          ]
        },
        {
          "name": "set_property_value set_verb_or_property",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 59,
          "code": [
            "\":set_property_value(object, property, value)\";",
            "\" set_verb_or_property(same) -- similar to `verb_or_property'\";",
            "\"  -- attempts to set <object>.<property> to <value>.  If there exists <object>:set_<property>, then it is called and its returned value is returned.  If not, we try to set the property directly; the result of this is returned.\";",
            "set_task_perms(caller_perms());",
            "if (length(args) != 3)",
            "return E_ARGS;",
            "elseif (typeof(o = args[1]) != OBJ)",
            "return E_INVARG;",
            "elseif (!$recycler:valid(o))",
            "return E_INVIND;",
            "elseif (typeof(p = args[2]) != STR)",
            "return E_INVARG;",
            "elseif ($object_utils:has_callable_verb(o, v = \"set_\" + p))",
            "return o:(v)(args[3]);",
            "else",
            "return o.(p) = args[3];",
            "endif"
          ]
        },
        {
          "name": "owns_task",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:owns_task(task_id, who)\";",
            "\"The purpose of this is to be faster than $code_utils:task_owner(task_id) in those cases where you are interested in whether a certain person owns the task rather than in determining the owner of a task where you have no preconceived notion of the owner.\";",
            "return $list_utils:assoc(args[1], $wiz_utils:queued_tasks(args[2]));"
          ]
        },
        {
          "name": "dflag_on",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"Syntax:  $code_utils:dflag_on()   => 0|1\";",
            "\"\";",
            "\"Returns true if the verb calling the verb that called this verb has the `d' flag set true. Returns false if it is !d. If there aren't that many callers, or the calling verb was a builtin such as eval, assume the debug flag is on for traceback purposes and return true.\";",
            "\"This is useful for determining whether the calling verb should return or raise an error to the verb that called it.\";",
            "return (length(c = callers()) >= 2) ? `index(verb_info(c[2][4], c[2][2])[2], \"d\") && 1 ! E_INVARG => 1' | 1;"
          ]
        },
        {
          "name": "type_str",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"type_str -- returns a string describing the type of args[1]\";",
            "x = args[1];",
            "type_data = {1, 3.14, \"\", #0, E_NONE, {}};",
            "type_strs = {\"INT\", \"FLOAT\", \"STR\", \"OBJ\", \"ERR\", \"LIST\"};",
            "for i in [1..length(type_data)]",
            "if (typeof(type_data[i]) == typeof(x))",
            "return type_strs[i];",
            "endif",
            "endfor",
            "return \"NONE\";"
          ]
        },
        {
          "name": "dump_properties",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":dump_properties (object, create_flag): returns the list of strings representing the property information for this object and its ancestor objects in @dump format.\";",
            "set_task_perms(caller_perms());",
            "{dobj, create, ?targname = tostr(dobj)} = args;",
            "result = {};",
            "for p in (`properties(dobj) ! ANY => {}')",
            "pquoted = toliteral(p);",
            "try",
            "info = property_info(dobj, p);",
            "value = dobj.(p);",
            "except error (ANY)",
            "result = {@result, tostr(\"\\\"\", targname, \".(\", pquoted, \") => \", toliteral(error[1]), \" (\", error[2], \")\")};",
            "continue p;",
            "endtry",
            "if (create)",
            "uvalue = (typeof(value) == LIST) ? \"{}\" | 0;",
            "result = {@result, tostr(\"@prop \", targname, \".\", pquoted, \" \", uvalue || toliteral(value), \" \", info[2] || \"\\\"\\\"\", (info[1] == dobj.owner) ? \"\" | tostr(\" \", info[1]))};",
            "if (uvalue && value)",
            "result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};",
            "endif",
            "else",
            "if (info[2] != \"rc\")",
            "result = {@result, tostr(\"@chmod \", targname, \".\", pquoted, \" \", info[2])};",
            "endif",
            "if (info[1] != dobj.owner)",
            "result = {@result, tostr(\"@chown \", targname, \".\", pquoted, \" \", info[1])};",
            "endif",
            "result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "for a in ($object_utils:ancestors(dobj))",
            "for p in (`properties(a) ! ANY => {}')",
            "$command_utils:suspend_if_needed(1);",
            "pquoted = toliteral(p);",
            "try",
            "value = dobj.(p);",
            "except error (ANY)",
            "result = {@result, tostr(\"\\\"\", targname, \".(\", pquoted, \") => \", toliteral(error[1]), \" (\", error[2], \")\")};",
            "continue p;",
            "endtry",
            "avalue = `a.(p) ! ANY';",
            "if ((typeof(avalue) == ERR) || (value != avalue))",
            "result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};",
            "endif",
            "endfor",
            "$command_utils:suspend_if_needed(1);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "dump_preamble",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":dump_preamble(object): produces the @create command necessary to dump this object.\";",
            "dobj = args[1];",
            "parent = parent(dobj);",
            "pstring = tostr(parent);",
            "for p in (properties(#0))",
            "if (#0.(p) == parent)",
            "pstring = \"$\" + p;",
            "endif",
            "endfor",
            "return tostr(\"@create \", pstring, \" named \", dobj.name, \":\", $string_utils:from_list(dobj.aliases, \",\"));"
          ]
        },
        {
          "name": "dump_verbs",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":dump_verbs (object, create_flag): returns the list of strings representing the verb information for this object in @dump format.\";",
            "set_task_perms(caller_perms());",
            "{dobj, create, ?targname = tostr(dobj)} = args;",
            "result = {};",
            "v = 1;",
            "while ((info = `verb_info(dobj, v) ! ANY') || (info == E_PERM))",
            "if (`index(info[3], \"(old)\") ! ANY' && 0)",
            "\"Thought about skipping (old) verbs...\";",
            "player:tell(\"Skipping \", dobj, \":\\\"\", info[3], \"\\\"...\");",
            "else",
            "if (typeof(info) == ERR)",
            "result = {@result, tostr(\"\\\"\", dobj, \":\", v, \" --- \", info, \"\\\";\")};",
            "else",
            "if (i = index(vname = info[3], \" \"))",
            "vname = vname[1..i - 1];",
            "endif",
            "if (vname[1] != \"*\")",
            "vname = strsub(vname, \"*\", \"\");",
            "endif",
            "args = verb_args(dobj, v);",
            "prep = (args[2] in {\"any\", \"none\"}) ? args[2] | $code_utils:short_prep(args[2]);",
            "perms = (info[2] != ((args == {\"this\", \"none\", \"this\"}) ? \"rxd\" | \"rd\")) ? info[2] || \"\\\"\\\"\" | \"\";",
            "if (create)",
            "if (info[1] == dobj.owner)",
            "tail = perms ? tostr(\" \", perms) | \"\";",
            "else",
            "tail = tostr(\" \", perms || info[2], \" \", info[1]);",
            "endif",
            "result = {@result, tostr(\"@verb \", targname, \":\\\"\", info[3], \"\\\" \", args[1], \" \", prep, \" \", args[3], tail)};",
            "else",
            "result = {@result, tostr(\"@args \", targname, \":\\\"\", info[3], \"\\\" \", args[1], \" \", prep, \" \", args[3])};",
            "if (info[1] != dobj.owner)",
            "result = {@result, tostr(\"@chown \", targname, \":\", vname, \" \", info[1])};",
            "endif",
            "if (perms)",
            "result = {@result, tostr(\"@chmod \", targname, \":\", vname, \" \", perms)};",
            "endif",
            "endif",
            "if (code = verb_code(dobj, v, 1, 1))",
            "result = {@result, tostr(\"@program \", targname, \":\", vname), @code, \".\", \"\"};",
            "endif",
            "endif",
            "endif",
            "if (`index(tostr(\" \", info[3], \" \"), \" * \") ! ANY')",
            "\"... we have a * verb.  may as well forget trying to list...\";",
            "\"... the rest; they're invisible.  set v to something nonstring.\";",
            "v = E_TYPE;",
            "else",
            "v = v + 1;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endwhile",
            "return result;"
          ]
        },
        {
          "name": "_find_verb_lines_containing _find_verb_lines_matching",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\":_find_verb_lines_containing(pattern,object[,casematters])\";",
            "\":_find_verb_lines_matching(regexp,object[,casematters])\";",
            "\"number of verbs in object with code having a line containing pattern or matching regexp\";",
            "\"prints verbname and all offending lines to player\";",
            "set_task_perms(caller_perms());",
            "{pattern, o, ?casematters = 0} = args;",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", o));",
            "suspend(0);",
            "endif",
            "if (!valid(o))",
            "return 0;",
            "endif",
            "count = 0;",
            "verbs = $object_utils:accessible_verbs(o);",
            "if (typeof(verbs) != LIST)",
            "return player:notify(tostr(\"verbs(\", o, \") => \", tostr(verbs)));",
            "endif",
            "_grep_verb_code_all = (verb == \"_find_verb_lines_matching\") ? \"_egrep_verb_code_all\" | \"_grep_verb_code_all\";",
            "for vnum in [1..length(verbs)]",
            "found = 0;",
            "for l in (this:(_grep_verb_code_all)(pattern, o, vnum, casematters))",
            "owner = verb_info(o, vnum)[1];",
            "player:notify(tostr(o, \":\", verbs[vnum], \" [\", valid(owner) ? owner.name | \"Recycled Player\", \" (\", owner, \")]:  \", l));",
            "found = 1;",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (found)",
            "count = count + 1;",
            "endif",
            "if ($command_utils:running_out_of_time())",
            "player:notify(tostr(\"...\", o));",
            "suspend(0);",
            "endif",
            "endfor",
            "return count;"
          ]
        },
        {
          "name": "commentify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"Usage:  commentify(lines)\";",
            "\"\";",
            "\"Given lines of text, translate them into comment strings and return the list.\";",
            "{lines} = args;",
            "out = {};",
            "for line in (lines)",
            "out = {@out, $string_utils:print(line) + \";\"};",
            "endfor",
            "return out;"
          ]
        },
        {
          "name": "parse_sysobj_map",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\"$code_utils:parse_sysobj_map(string)\";",
            "\"Attempt to parse a string into a map on $sysobj, allowing it to function as a poor man's namespace.\";",
            "\"Returns E_PROPNF if no map could be matched or the value of the given key's value if successful.\";",
            "{string} = args;",
            "set_task_perms(caller_perms());",
            "if (string[1] == \"$\")",
            "string = string[2..$];",
            "endif",
            "if ((ind = index(string, \"[\")) && (string[$] == \"]\"))",
            "key = strsub(string[ind + 1..$ - 1], \"\\\"\", \"\");",
            "\"Let it work with \\\"key\\\" or key\";",
            "ob = `#0.(string[1..ind - 1])[key] ! ANY';",
            "if (typeof(ob) != ERR)",
            "return ob;",
            "endif",
            "endif",
            "return E_PROPNF;"
          ]
        },
        {
          "name": "uncommentify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 59,
          "code": [
            "\" Usage:  uncommentify(lines)\";",
            "\"\";",
            "\" Given lines of comment code, translate them into text and return the list.\";",
            "set_task_perms($no_one);",
            "{lines} = args;",
            "out = {};",
            "for line in (lines)",
            "if (match(line, \"^\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))",
            "out = {@out, eval(\"return \" + line)[2]};",
            "else",
            "return E_INVARG;",
            "endif",
            "endfor",
            "return out;"
          ]
        }
      ],
      "propnames": [
        "_version",
        "_multi_preps",
        "_other_preps_n",
        "_other_preps",
        "_short_preps",
        "_all_preps",
        "builtin_props",
        "error_names",
        "error_list",
        "prepositions"
      ],
      "propdefs": [
        {
          "value": "2.7.0_20",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "off",
            "from",
            "out",
            "on",
            "on top",
            "in",
            "in front"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            1,
            2,
            4,
            4,
            5,
            5,
            5,
            6,
            6,
            9,
            9,
            12,
            15
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "using",
            "at",
            "inside",
            "into",
            "on top of",
            "onto",
            "upon",
            "out of",
            "from inside",
            "underneath",
            "beneath",
            "about",
            "off of"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "with",
            "to",
            "in front of",
            "in",
            "on",
            "from",
            "over",
            "through",
            "under",
            "behind",
            "beside",
            "for",
            "is",
            "as",
            "off"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "with",
            "using",
            "at",
            "to",
            "in front of",
            "in",
            "inside",
            "into",
            "on top of",
            "on",
            "onto",
            "upon",
            "out of",
            "from inside",
            "from",
            "over",
            "through",
            "under",
            "underneath",
            "beneath",
            "behind",
            "beside",
            "for",
            "about",
            "is",
            "as",
            "off",
            "off of"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "name",
            "r",
            "w",
            "f",
            "programmer",
            "wizard",
            "owner",
            "location",
            "contents",
            "last_move",
            "a"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "E_NONE",
            "E_TYPE",
            "E_DIV",
            "E_PERM",
            "E_PROPNF",
            "E_VERBNF",
            "E_VARNF",
            "E_INVIND",
            "E_RECMOVE",
            "E_MAXREC",
            "E_RANGE",
            "E_ARGS",
            "E_NACC",
            "E_INVARG",
            "E_QUOTA",
            "E_FLOAT",
            "E_FILE",
            "E_EXEC",
            "E_INTRPT"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            3467820585508143104,
            1,
            8391718368071122946,
            94240172408835,
            94240172408836,
            94240172408837,
            94240172408838,
            94240172408839,
            94240172408840,
            94240172408841,
            94240172408842,
            94240172408843,
            94240172408844,
            94240172408845,
            94240172408846,
            94240172408847,
            94240172408848,
            94240172408849,
            94240172408850
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "with/using",
            "at/to",
            "in front of",
            "in/inside/into",
            "on top of/on/onto/upon",
            "out of/from inside/from",
            "over",
            "through",
            "under/underneath/beneath",
            "behind",
            "beside",
            "for/about",
            "is",
            "as",
            "off/off of"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "parse_propref(\"foo.bar\")  => {\"foo\",\"bar\"} (or 0 if arg. isn't a property ref.)",
            "parse_verbref(\"foo:bar\")  => {\"foo\",\"bar\"} (or 0 if arg. isn't a verb ref.)",
            "parse_argspec(\"any\",\"in\",\"front\",\"of\",\"this\",\"baz\"...)",
            "                          => {{\"any\", \"in front of\", \"this\"},{\"baz\"...}} ",
            "                                           (or string if args don't parse)",
            "",
            "toint(string)           => integer (or E_TYPE if string is not a integer)",
            "toobj(string)           => object (or E_TYPE if string is not an object)",
            "toerr(number or string) => error value (or 1 if out of range or unrecognized)",
            "error_name(error value) => name of error (e.g., error_name(E_PERM) => \"E_PERM\")",
            "",
            "verb_perms()      => the current task_perms (as set by set_task_perms()).",
            "verb_location()   => the object where the current verb is defined.",
            "verb_frame()      => callers()-style frame for the current verb.",
            "verb_all_frames() => entire callers() stack including current verb.",
            "verb_usage([object,verbname]) => returns first line of verb doc, usually usage",
            "verb_documentation([object,verbname]) => documentation at beginning of",
            "           verb code, if any -- default is the calling verb",
            "set_verb_documentation(object,verbname,text) => sets text at beginning of verb",
            "",
            "   Preposition routines",
            "",
            "prepositions()     => full list of prepostions",
            "full_prep (\"in\")   => \"in/inside/into\"",
            "short_prep(\"into\") => \"in\"",
            "short_prep(\"in/inside/into\") => \"in\"",
            "get_prep  (\"off\", \"of\", \"the\", \"table\") => {\"off of\", \"the\", \"table\"}",
            "",
            "   Verb routines",
            "",
            "verbname_match (fullname,name) => can `name' be used to call `fullname'",
            "find_verb_named          (object,name[,n]) => verb number or 0 if not found",
            "find_last_verb_named     (object,name[,n]) => verb number of last verb match",
            "find_callable_verb_named (object,name[,n]) => verb number or 0 if not found",
            "find_verbs_containing (pattern[,object|objlist]) => does work for @grep",
            "find_verbs_matching (pattern[,object|objlist]) => does work for @egrep",
            "move_verb (from obj,name,to obj[,newname]) => move a verb from object to object",
            "",
            "move_prop (from obj,name,to obj[,newname]) => move a property to another object",
            "",
            "   Verbs that do the actual dirty work for command lines verbs:",
            "",
            "@show           => show_object  (object)",
            "                   show_property(object,propname)",
            "                   show_verbdef (object,verbname)",
            "explain_syntax  => explain_verb_syntax(thisname,verbname,@verbargs)",
            "eval*-d         => eval_d(code)",
            "help            => help_db_list([player])",
            "                   help_db_search(string topic, dblist)",
            "@who            => show_who_listing(players [,more_players])",
            "@check-full     => display_callers([callers() output])",
            "@dump           => dump_preamble(object)",
            "                => dump_properties(object, create_flag)",
            "                => dump_verbs(object, create_flag)",
            "",
            "   Random but useful verbs",
            "",
            "verb_or_property(object,name[,@args]) => result of verb or property call,",
            "                                         or E_PROPNF",
            "corify_object(object)     => if the object is corified, returns $<name>",
            "task_valid(INT task_id)   => returns true if task_id is currently running.",
            "task_owner(INT task_id)   => returns owner of task_id, if running",
            "owns_task(NUM task_id,OBJ who) => returns whether who owns task_id (if running)",
            "argstr(verb,args[,argstr] => returns a corrected argstr (see full verb help)",
            "substitute(string,subs)   => subs in form {{\"target\", \"sub\"}, {...}, ...}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "code",
            "utils"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the code utilities utility package.  See `help $code_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            83718,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "60": {
      "id": 60,
      "name": "Help Database",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "player_quota",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "return $player.ownership_quota;"
          ]
        },
        {
          "name": "prog_quota",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "return $prog.ownership_quota;"
          ]
        },
        {
          "name": "get_topic",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "text = pass(@args);",
            "object = $string_utils:match_object(what = args[1], player.location);",
            "if ((text != E_PROPNF) || (!valid(object)))",
            "return text;",
            "elseif (ohelp = `object:help_msg() ! ANY' || `object.help_msg ! ANY')",
            "return {tostr(object.name, \" (\", object, \"):\"), \"----\", @(typeof(ohelp) == LIST) ? ohelp | {ohelp}};",
            "else",
            "about = $object_utils:has_verb(object, \"about\");",
            "return {tostr(\"Sorry, but no help is available on \", object.name, \" (\", object, \").\"), tostr(\"Try `examine \", what, \"'\", @about ? {\" or `about \", what, \"'\"} | {}, \".\")};",
            "endif"
          ]
        },
        {
          "name": "find_topics",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "topiclist = pass(@args);",
            "if (topiclist || (!args))",
            "return topiclist;",
            "elseif (valid(o = $string_utils:match_object(what = args[1], player.location)))",
            "return {what};",
            "else",
            "return {};",
            "endif"
          ]
        },
        {
          "name": "full_index",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "text = {};",
            "for db in ($code_utils:help_db_list())",
            "if ($object_utils:has_callable_verb(db, \"index\"))",
            "text = {@text, @db:index({tostr(db.name, \" (\", db, \")\")})};",
            "endif",
            "endfor",
            "return text;"
          ]
        },
        {
          "name": "index_list",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "hdr = \"Available Help Indices\";",
            "text = {\"\", hdr, $string_utils:space(hdr, \"-\")};",
            "for db in ($code_utils:help_db_list())",
            "try",
            "for p in (db:find_index_topics())",
            "text = {@text, tostr($string_utils:left(p, 14), \" -- \", `db.(p)[2] ! ANY' || db.name, \" (\", db, \")\")};",
            "endfor",
            "except (ANY)",
            "\"generally it will be E_TYPE when :find_index_topics returns an ERR. Just skip\";",
            "continue db;",
            "endtry",
            "endfor",
            "if (full = this:find_full_index_topic())",
            "text = {@text, \"\", tostr($string_utils:left(full, 14), \" -- \", \"EVERYTHING\")};",
            "endif",
            "return text;"
          ]
        },
        {
          "name": "wizard_list",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "wizzes = {};",
            "for w in ($object_utils:leaves($wiz))",
            "if (w.wizard && (w.advertised && is_player(w)))",
            "wizzes = {@wizzes, w};",
            "endif",
            "endfor",
            "wizzes = {#2, @$list_utils:randomly_permute(setremove(wizzes, #2))};",
            "numwiz = length(wizzes);",
            "hlist = {\"ArchWizard:\", \"Wizard\" + ((numwiz == 2) ? \":\" | \"s:\"), @$list_utils:make(max(0, numwiz - 2), \"\")};",
            "slist = {};",
            "su = $string_utils;",
            "for i in [1..numwiz]",
            "wiz = wizzes[i];",
            "slist = {@slist, tostr(su:left(hlist[i], 13), su:left(wiz.name, 16), (wpi = `wiz.public_identity.name ! ANY') ? (\" (a.k.a. \" + wpi) + \")\" | \"\")};",
            "endfor",
            "return slist;"
          ]
        },
        {
          "name": "dump_topic",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "if (((text = pass(@args)) != E_PROPNF) || ((!valid(object = $string_utils:match_object(what = args[1], player.location))) || (!$object_utils:has_property(object, \"help_msg\"))))",
            "return text;",
            "else",
            "return {tostr(\";;\", $code_utils:corify_object(object), \".help_msg = $command_utils:read_lines()\"), @$command_utils:dump_lines((typeof(text = object.help_msg) == LIST) ? text | {text})};",
            "endif"
          ]
        },
        {
          "name": "find_full_index_topic",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 60,
          "code": [
            "\":find_full_index_topic([search])\";",
            "\"Return the *full_index* topic or 0\";",
            "\"If search argument is given and true, we don't depend on cached info.\";",
            "{?search = 0} = args;",
            "\"... N.B.  There is no cached info; it turns out that\";",
            "\"... full-index is near enough to the beginning of $help's property list\";",
            "\"... that there's no point to doing this.  --Rog\";",
            "for p in (`properties(this) ! E_PERM => {}')",
            "if (`this.(p)[1] ! ANY' == \"*full_index*\")",
            "return p;",
            "endif",
            "endfor",
            "return 0;"
          ]
        }
      ],
      "propnames": [
        "@uptime",
        "wizard-list",
        "@wrap",
        "full-index",
        " index",
        "gen-index",
        "@pagelength",
        "@more",
        "programming",
        "@linelength",
        "@gaglist",
        "::",
        "@comment",
        "",
        "spoofing",
        "privacy",
        "@examine",
        "security",
        "@sweep",
        "@paranoid",
        "@check",
        "@eject",
        "@quit",
        "whereis",
        "@suggest",
        "@idea",
        "@bug",
        "@typo",
        "@notedit",
        "editors",
        "@memory",
        "\"",
        ":",
        "@lastlog",
        "@version",
        "miscellaneous",
        "insert",
        "information",
        "?",
        "put",
        "remove",
        "burn",
        "letters",
        "decrypt",
        "encrypt",
        "delete",
        "erase",
        "write",
        "read",
        "examine",
        "hand",
        "throw",
        "take",
        "@messages",
        "pronouns",
        "messages",
        "descriptions",
        "@describe",
        "tinymud",
        "@gripe",
        "@listgag",
        "@ungag",
        "@gag",
        "go",
        "@password",
        "@sethome",
        "@who",
        "introduction",
        "give",
        "news",
        "gagging",
        "@move",
        "inventory",
        "@gender",
        "@rename",
        "notes",
        "look",
        "drop",
        "get",
        "manipulation",
        "help",
        "movement",
        "home",
        "say",
        "whisper",
        "page",
        "emote",
        "players",
        "summary",
        "@edit-options",
        "@editoptions",
        "@add-feature",
        "@remove-feature",
        "@features",
        "features",
        "@rmalias",
        "@addalias",
        "commands",
        " name",
        "@request-character",
        "player-names",
        "@registerme",
        "@eject!",
        "options",
        "@age",
        "@edit",
        "@addfeature",
        "communication",
        "objects",
        " aliases",
        "@check-full",
        "@users",
        "alias",
        "@add-alias",
        "@mode",
        "wizard-names",
        "backspace",
        "spivak",
        "@owner",
        "checkpoint"
      ],
      "propdefs": [
        {
          "value": [
            "Syntax:  @uptime",
            "",
            "   The @uptime command displays the amount of time since the last restart of the server.",
            "   Note to programmers:  The last restart time of the server is stored in $last_restart_time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "",
            "%;this:wizard_list()",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@linelength"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*full_index*"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index_list*"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "General Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @pagelength <number>",
            "         @pagelength",
            "",
            "If the lines you see scroll off the top of your screen too quickly for you to",
            "read and your client program is such that any lines scrolling off the top are",
            "gone forever, you can use the @pagelength command to invoke page buffering to",
            "limit the number of lines sent at a time.  E.g., if your terminal has a 24 line",
            "screen, you can do @pagelength 24 and output will stop every 24 lines if you",
            "don't type any other commands.",
            "",
            "You will need to use the @more command to continue reading output once it ",
            "has been stopped.  Make sure you read `help @more' before setting @pagelength.",
            "",
            "@pagelength 0 means no page buffering will be done by the MOO.",
            "",
            "By default the MOO will assume you have an infinitely wide terminal screen, so",
            "you may wish to set @linelength as well, and ensure wrapping is on with @wrap",
            "on.  (See help @linelength and help @wrap.)  As with word wrapping, you are",
            "best off running a client that can do its own page buffering; the MOO server's",
            "page buffering is inherently slower and many MUD's do not have page buffering",
            "at all."
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "Syntax:  @more",
            "         @more rest",
            "         @more flush",
            "",
            "If you have @pagelength set (see `help @pagelength') and some combination of events or commands produces sufficiently many lines of output, you will see a message of the form",
            "",
            "%[strsub(player.more_msg,\"%%n\",\"37\")]",
            "",
            "indicating (in this case) 37 more lines of text waiting to be read.  ",
            "At this point, you should give one of the @more commands above.  ",
            "",
            "@more without arguments prints sufficiently many lines to fill your screen,",
            "assuming you've set @pagelength correctly, unless there are not that many",
            "lines left to print.",
            "",
            "@more rest will print all of the remaining lines, regardless of your @pagelength setting.  ",
            "",
            "@more flush discards all remaining lines"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.",
            "",
            "Not every player is allowed to program in MOO, including (at the moment, anyway) you.  If you would like to be, find a wizard and convince them that you've got good ideas that the MOO needs.  Good luck!"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @wrap <on|off>",
            "         @wrap",
            "",
            "         @linelength <number>",
            "         @linelength",
            "",
            "If the lines you see get cut off at the edge of your screen (you don't have",
            "word-wrap), you can get the MOO to split lines for you.  The @linelength",
            "command tells the MOO how many columns you have on your screen--you probably",
            "want @linelength 79--and \"@wrap on\" tells the MOO you want it to do word-",
            "wrap.",
            "",
            "It's better if you can fix this problem without the MOO's help, though,",
            "because the MOO's solution will be slower than a local solution, and",
            "because not all MUDs are willing to do word-wrap.",
            "",
            "If you don't want the MOO to split lines for you, there might still be some",
            "use for the @linelength command.  Certain commands, like @who and @check,",
            "print truncated lines so they can print in neat columns.  The default for",
            "these is generally about 79 columns, which looks fine if you have an",
            "eighty-column screen.  If your screen is a different width, though, you",
            "can set @linelength and some of these commands will react accordingly."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@listgag"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "emote"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@typo"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "summary",
            "",
            "Type 'help <topic>' for information on a particular topic.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "security"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Some things you should be aware of:",
            "",
            " -*-*- OMNISCIENT WIZARDS AND SYSADMINS: -*-*-",
            "Wizards can look at absolutely *anything* in the MOO database.  ",
            "The arch-wizard and the sysadmin for the MOO-server host have complete access not only to the MOO database itself but to many other possibly-relevant things.",
            "The above mentioned parties (wizards et al), while they will endeavor to be discreet about anything incidental that turns up, nevertheless reserve the right to look at anything they want, if only for the sake of being able to resolve technical problems.",
            "",
            " -*-*- LOGGING: -*-*- ",
            "Some client programs (the \"client\" is the program you use to connect to the MOO, e.g., telnet, tinytalk, tinyfugue, emacs with mud.el...) are capable of logging everything that happens to the corresponding player.  In fact, with some clients this happens by default.  If a given player's client has logging enabled and said player is either in the room with you or is monitoring an object that is in the room with you, then *everything* you say and emote gets recorded.  Also, if you are in a room owned by someone else, all bets are off.  There is *no way* that the MOO server can know about what client a given player is using; thus, anyone who can hear you is a potential logger.",
            "",
            "In and of itself this would not be a problem --- indeed, logs are often useful for reference purposes.  However, there is no guarantee that the log will not end up someplace where you'd rather it didn't, e.g., posted on the rec.games.mud Usenet newsgroup.  While it is considered bad form (i.e., rude) to circulate or post a log without having the permission of at least the major participants in the activities logged, there is not a whole lot we can do on the technical side to prevent it from happening.",
            "",
            "Be aware of the problem.  The @sweep command (see `help @sweep') attempts to determine what players can be listening at any given moment.  If anything, it errs on the side of paranoia.  Even so, it doesn't cover *all* possible avenues of eavesdropping, and there's no hope for it covering the situations like the one where someone manages to convince one of the participants in your discussion who kept a log that it really doesn't need to be kept private after all.",
            "",
            "If you've got something really sensitive to discuss, you are best off doing it by encrypted email or in person."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @examine <object>",
            "         @exam <object>",
            "",
            "Prints several useful pieces of information about the named object, including the following:",
            "        + its full name, aliases, and object number",
            "        + its owner's name and object number",
            "        + its description",
            "        + its key expression (if it is locked and if you own it)",
            "        + its contents and their object numbers",
            "        + the 'obvious' verbs defined on it",
            "",
            "[Note to programmers: the 'obvious' verbs are those that are readable and that can be invoked as commands.  To keep a verb off this list, either make it unreadable (see 'help @chmod') or, if it shouldn't be used as a command, give it 'args' of 'this none this' (see 'help @args').]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "There are several commands available to determine the origins of messages and to check that your communications with other players are secure. Help is available on the following topics:",
            "",
            "@paranoid -- keeping a record of messages your character hears.",
            "@check    -- looking at that record to determine responsibility for messages.",
            "@sweep    -- checking who is listening in on your conversation."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @sweep",
            "",
            "Used when you wish to have a private conversation, and are concerned someone may be listening in. @sweep tries to list the avenues by which information may be leaving the room. In a manner analogous to @check, it assumes that you don't want to hear about your own verbs, or those belonging to wizards, who presumably wouldn't stoop to bugging."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @paranoid",
            "         @paranoid off",
            "         @paranoid immediate",
            "         @paranoid <number>",
            "",
            "In immediate mode, the monitor prepends everything you hear with the name of ",
            "the character it considers responsible for the message. Otherwise, it keeps ",
            "records of the last <number> (defaults to 10) lines you have heard. These ",
            "records can be accessed by the @check command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   @check <options>",
            "",
            "where <options> is one or more of:",
            "-- the number of lines to be displayed",
            "-- a player's name, someone to be \"trusted\" during the assignment of responsibility for the message.",
            "-- a player's named prefixed by !, someone not to be \"trusted\".",
            "",
            "          @check-full <options>",
            "where <options is either ",
            "-- the number of lines to be displayed",
            "-- a search string: only lines containing that string will be displayed.",
            "",
            "Used when you are suspicious about the origin of some of the messages your character has just heard.",
            "",
            "Output from @check is in columns that contain, in order, the monitor's best guess as to:",
            "    what object the message came from,",
            "    what verb on that object that was responsible,",
            "    whose permissions that verb was running with, and",
            "    the beginning of the actual message.",
            "",
            "Output from @check-full is in columns that contains a description of all the verbs that were responsible for the noise heard, not just the best guess as to who was responsible.",
            "",
            "@check operates by examining the list of verbs that were involved in delivering the message, and assigning responsibility to the first owner it sees who is not \"trusted\".  By default, it trusts you and all the wizards.  It uses the records maintained by @paranoid, so you must have used that command before you received the message."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @eject[!] <object> [from <place>]",
            "",
            "This command is used to remove unwanted objects from places you own.  Players thus removed are unceremoniously dumped in their homes (unless that's this room, in which case they are dumped in the default player starting place).  Other kinds of objects are checked for a .home property and sent there if possible, otherwise they get thrown into #-1.  Unlike @move, @eject does *not* check to see if the object wants to be moved, and with the destination being what it is, there is no question of the destination refusing the move, either.  Generally, you should only resort to @eject if @move doesn't work.",
            "",
            "`@eject <object>' removes <object> from the current room, whereas `@eject <object> from <place>' removes the object from the specified location (in most cases, <place> will need to be specified as an object number).  In either case, this command only works if you own the room/entity from which the object is being ejected.",
            "",
            "`@eject ... from me' suffices to get rid of some unwanted object in your inventory.",
            "",
            "The verbs @eject! and @eject!! are provided for those rare situations in which @eject does not work.  @eject! does not check for .home properties, sending the offending object to #-1 immediately, but with a notification.  @eject!! is just like @eject! but provides no notification to the object.",
            "",
            "See 'help room-messages' for a list of messages one can set regarding the @eject command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @quit",
            "",
            "Disconnect from the MOO.  This breaks your network connection and leaves your player sleeping.  Disconnecting in most parts of the MOO automatically returns your player to its designated home (see 'help home')."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  whereis [<player> [<player>...]]",
            "        @whereis [<player> [<player>...]]",
            "",
            "Returns the current location of each of the specified players, or of all players if not arguments given."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@typo"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@typo"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@typo"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @typo    [<text>]",
            "         @bug     [<text>]",
            "         @suggest [<text>]",
            "         @idea    [<text>]",
            "         @comment [<text>]",
            "",
            "If <text> is given, a one-line message is sent to the owner of the room, presumably about something that you've noticed.  If <text> is not given, we assume you have more to say than can fit comfortably on a single line; the usual mail editor is invoked.  The convention is that @typo is for typographical errors on the room or objects found therein, @bug is for anomalous or nonintuitive behaviour of some sort, @idea/@suggest for any particular brainstorms or criticisms you might happen to have, and @comment for anything else.",
            "",
            "If you're sending a bug report to someone because you got an error traceback when you used some object of theirs, please give them enough information to work on the problem.  In particular, please tell them *exactly* what you typed and *all* of the error messages that were printed to you, including the entire traceback, up to the line `(End of traceback.)'.  Without this information, it is nearly impossible for the programmer to discover, let alone fix, the problem.",
            "",
            "The usual mail editor is only invoked for this command when in rooms that allow free entry, i.e., rooms that are likely to allow you back after you are done editing your message.  Otherwise these commands will require <text> and only let you do one-line messages.  ",
            "Most adventuring scenario rooms fall into this latter category."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @notedit <note-object>",
            "         @notedit <object>.<property>",
            "",
            "Enters the MOO Note Editor to edit the text on the named object",
            "For the first form, <note-object> must be a descendant of $note.  ",
            "For the second form, <object>.<property> can be any string-valued or text-valued (i.e., list of strings) property on any object.",
            "",
            "See 'help editors' for more detail."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "One can always enter an editor by teleporting to it, or you can use one of the commands provided",
            "",
            "    @edit     <object>:<verb>    invokes the Verb Editor (edits verb code)",
            "    @notedit  <note_object>      invokes the Note Editor (edits note text)",
            "    @notedit  <object>.<prop>    invokes the Note Editor (edits text property)",
            "    @send     <list of recipients>        invokes the Mailer (edits a mail msg)",
            "    @answer   [<msg_number>] [<flags>...] invokes the Mailer (edits a reply)",
            "",
            "This will transport you to one of several special rooms that have editing commands available.  These editors are admittedly not as good as EMACS, but for those with no other editing capability on their host systems, they are better than nothing.",
            "",
            "There is a generic editor that provides basic editing commands that are applicable to all editors.  Documentation for these commands can be obtained by typing `help <topic>' within the editor:",
            "",
            "    abort              emote/:            pause              send      (M) ",
            "    also-to (M)        fill               prev               showlists (M) ",
            "    compile (V)        insert             print     (M)      subject   (M) ",
            "    copy               join               quit               subst         ",
            "    delete             list               ranges             to    (M)     ",
            "    done               move               save      (N)      what          ",
            "    edit    (V,N)      next               say/\"              who   (M)     ",
            "",
            "In addition, individual editors provide their own additional commands for loading text from places, saving text to places, and various other specialized functions which are denoted in the above list with (M),(N),(V) according as they apply to the mail editor, the note editor, or the verb editor, respectively.",
            "",
            "Note that a given editor only allows you one session at a time (ie. one verb, one note, or one mail message).  If you leave an editor without either aborting or compiling/saving/sending the item you're working on, that editor remembers what you are doing next time you enter it, whether you enter it by teleporting or by using the appropriate command.  Note that editors are periodically flushed so anything left there for sufficiently long will eventually go away.",
            "",
            "A player may have his own .edit_options property which is a list containing one or more (string) flags from the following list",
            "",
            "  quiet_insert",
            "      suppresses those annoying \"Line n added.\" or \"Appended...\" messages",
            "      that one gets in response to 'say' or 'emote'.  This is useful if you're",
            "      entering a long list of lines, perhaps via some macro on your client,",
            "      and you don't want to see an equally long list of \"Line n added...\"",
            "      messages.  What you do want, however is some indication that this all",
            "      got through, which is why the \".\" command is an abbreviation for insert.",
            "",
            "  eval_subs",
            "      Enables the verb editor to process your eval_subs property when",
            "      compiling your verb.  See `help eval' for more information about",
            "      the eval_subs property.",
            "",
            "There will be more options, some day."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @memory",
            "",
            "Prints out all information available on the current memory-usage behavior of the MOO server.  Probably only a wizard, if anyone, cares about this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "say"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "emote"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @lastlog",
            "         @lastlog <player>",
            "",
            "The first form prints out a list of all players, roughly sorted by how long it's been since that player last connected to the MOO.  For each player, the precise time of their last connection is printed.",
            "",
            "The second form only shows the last-connection time for the named player."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @version",
            "",
            "Prints out the version number for the currently-executing MOO server."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Here are a few commands of occasional utility that didn't fit into any of the neat categories for the rest of the help system:",
            "",
            "@version -- printing the MOO server version number",
            "@lastlog -- finding out when some player last connected to the MOO"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "put"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "help"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "help"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  put <object> into <container>",
            "         insert <object> in <container>",
            "",
            "Moves the named object into the named container.  Sometimes the owners of the object and/or the container will not allow you to do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "take"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  burn <letter>",
            "",
            "Destroy the named letter irretrievably.  Only players who can read the letter can do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "A letter is a special kind of note (see 'help notes') with the added feature that it can be recycled by anyone who can read it.  This is often useful for notes from one player to another.  You create the letter as a child of the generic letter, $letter (see 'help @create' and 'help write'), encrypt it so that only you and the other player can read it (see 'help encrypt') and then either give it to the player in question or leave it where they will find it.  Once they've read it, they can use the 'burn' command to recycle the letter; see 'help burn' for details."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  decrypt <note>",
            "",
            "Removes any restriction on who may read the named note or letter.  Only the owner of a note may do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  encrypt <note> with <key-expression>",
            "",
            "Restricts the set of players who can read the named note or letter to those for whom the given key expression is true.  See 'help keys' for information on the syntax and semantics of key expressions.  Only the owner of a note may do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  delete <line-number> from <note>",
            "",
            "Removes a single line of text from a note.  The first line of text is numbered 1, the second is 2, and so on.  Only the owner of a note may do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  erase <note>",
            "",
            "Deletes all of the text written on a note or letter.  Only the owner of a note may do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  write \"<any text>\" on <note>",
            "",
            "Adds a line of text to the named note or letter.  Only the owner of a note may do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  read <note>",
            "",
            "Prints the text written on the named object, usually a note or letter.  Some notes are encrypted so that only certain players may read them."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  examine <object>",
            "         exam <object>",
            "",
            "Prints several useful pieces of information about the named object, including the following:",
            "        + its full name, object number, and aliases",
            "        + its owner's name",
            "        + its description",
            "        + its key expression (if it is locked and if you own it)",
            "        + its contents",
            "        + the 'obvious' verbs defined on it"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "give"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "drop"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  take <object>",
            "         get <object>",
            "         take <object> from <container>",
            "         get <object> from <container>",
            "         remove <object> from <container>",
            "",
            "The first two forms pick up the named object and place it in your inventory.  Sometimes the owner of the object won't allow it to be picked up for some reason.",
            "",
            "The remaining forms move the named object from inside the named container (see 'help containers') into your inventory.  As before, sometimes the owner of an object will not allow you to do this."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @messages <object>",
            "",
            "List all of the messages that can be set on the named object and their current values.  See 'help messages' for more details."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Some kinds of messages are not printed directly to players; they are allowed to contain special characters marking places to include the appropriate pronoun for some player.  For example, a builder might have a doorway that's very short, so that people have to crawl to get through it.  When they do so, the builder wants a little message like this to be printed:",
            "",
            "        Balthazar crawls through the little doorway, bruising his knee.",
            "",
            "The problem is the use of 'his' in the message; what if the player in question is female?  The correct setting of the 'oleave' message on that doorway is as follows:",
            "",
            "        \"crawls through the little doorway, bruising %p knee.\"",
            "",
            "The '%p' in the message will be replaced by either 'his', 'her', or 'its', depending upon the gender of the player.  ",
            "",
            "As it happens, you can also refer to elements of the command line (e.g., direct and indirect objects) the object issuing the message, and the location where this is all happening.  In addition one can refer to arbitrary string properties on these objects, or get the object numbers themselves.",
            "",
            "The complete set of substitutions is as follows:",
            "",
            "        %% => `%'  (just in case you actually want to talk about percentages).",
            "    Names:",
            "        %n => the player",
            "        %t => this object (i.e., the object issuing the message,... usually)",
            "        %d => the direct object from the command line",
            "        %i => the indirect object from the command line",
            "        %l => the location of the player",
            "    Pronouns:",
            "        %s => subject pronoun:          either `he',  `she', or `it'",
            "        %o => object pronoun:           either `him', `her', or `it'",
            "        %p => posessive pronoun (adj):  either `his', `her', or `its'  ",
            "        %q => posessive pronoun (noun): either `his', `hers', or `its'",
            "        %r => reflexive pronoun:  either `himself', `herself', or `itself'",
            "    General properties:",
            "        %(foo) => player.foo ",
            "        %[tfoo], %[dfoo], %[ifoo], %[lfoo]",
            "               => this.foo, dobj.foo, iobj.foo, and player.location.foo",
            "    Object numbers:",
            "        %#  => player's object number",
            "        %[#t], %[#d], %[#i], %[#l]",
            "            => object numbers for this, direct obj, indirect obj, and location.",
            "",
            "In addition there is a set of capitalized substitutions for use at the ",
            "beginning of sentences.  These are, respectively, ",
            "",
            "   %N, %T, %D, %I, %L for object names, ",
            "   %S, %O, %P, %Q, %R for pronouns, and",
            "   %(Foo), %[dFoo] (== %[Dfoo] == %[DFoo]),... for general properties",
            "",
            "Note: there is a special exception for player .name's which are assumed to",
            "already be capitalized as desired.",
            "",
            "There may be situations where the standard algorithm, i.e., upcasing the first letter, yields something incorrect, in which case a \"capitalization\" for a particular string property can be specified explicitly.  If your object has a \".foo\" property that is like this, you need merely add a \".fooc\" (in general .(propertyname+\"c\")) specifying the correct capitalization.  This will also work for player .name's if you want to specify a capitalization that is different from your usual .name",
            "",
            "Example:  ",
            "Rog makes a hand-grenade with a customizable explode message.",
            "Suppose someone sets grenade.explode_msg to:",
            "",
            "  \"%N(%#) drops %t on %p foot.  %T explodes.  ",
            "   %L is engulfed in flames.\"",
            "",
            "If the current location happens to be #3443 (\"yduJ's Hairdressing Salon\"),",
            "the resulting substitution may produce, eg.,",
            "",
            "  \"Rog(#4292) drops grenade on his foot.  Grenade explodes.  ",
            "   YduJ's Hairdressing Salon is engulfed in flames.\"",
            "",
            "which contains an incorrect capitalization.  ",
            "yduJ may remedy this by setting #3443.namec=\"yduJ's Hairdressing Salon\".",
            "",
            "Note for programmers:  ",
            " In programs, use $string_utils:pronoun_sub().",
            " %n actually calls player:title() while %(name) refers to player.name directly."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Most objects have messages that are printed when a player succeeds or fails in manipulating the object in some way.  Of course, the kinds of messages printed are specific to the kinds of manipulations and those, in turn, are specific to the kind of object.  Regardless of the kind of object, though, there is a uniform means for listing the kinds of messages that can be set and then for setting them.",
            "",
            "The '@messages' command prints out all of the messages you can set on any object you own.  Type 'help @messages' for details.",
            "",
            "To set a particular message on one of your objects use a command with this form:",
            "        @<message-name> <object> is \"<message>\"",
            "where '<message-name>' is the name of the message being set, <object> is the name or number of the object on which you want to set that message, and <message> is the actual text.",
            "",
            "For example, consider the 'leave' message on an exit; it is printed to a player when they successfully use the exit to leave a room.  To set the 'leave' message on the exit 'north' from the current room, use the command",
            "        @leave north is \"You wander in a northerly way out of the room.\"",
            "",
            "[Note to programmers: This class of commands automatically applies to any property whose name ends in '_msg'.  Thus, in the example above, the command is setting the 'leave_msg' property of the named exit.  You can get such a command to work on new kinds of objects simply by giving the appropriate properties names that end in '_msg'.  Additionally, in many cases the _msg property is accompanied by a _msg verb, which defaultly returns the named property, but which is available to be customized in more complex ways than allowed by simple string substitution.  You should check for the particular property you're considering whether the verb form exists (typically with @list).]",
            "",
            "The following help topics describe the uses of the various messages available on standard kinds of objects:",
            "",
            "container-messages -- the messages on objects that can contain other objects",
            "exit-messages -- the messages on exit objects",
            "thing-messages -- the messages on objects that can be taken and dropped"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Most objects have one or more descriptive pieces of text associated with them; these texts are printed under various circumstances depending on the kind of text.  For example, every object has a 'description' text that is printed whenever a player looks at the object.  The following help topics discuss the commands for manipulating these descriptive texts on your objects:",
            "",
            "@rename -- setting the name and aliases of your objects",
            "@describe -- setting what others see when they look at your objects",
            "messages -- listing and setting the other descriptive texts on an object"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @describe <object> as <description>",
            "",
            "Sets the description string of <object> to <description>.  This is the string that is printed out whenever someone uses the 'look' command on <object>.  To describe yourself, use 'me' as the <object>.",
            "",
            "Example:",
            "Munchkin types this:",
            "  @describe me as \"A very fine fellow, if a bit on the short side.\"",
            "People who type 'look Munchkin' now see this:",
            "  A very fine fellow, if a bit on the short side.",
            "",
            "Note for programmers:",
            "The description of an object is kept in its .description property.  ",
            "For descriptions of more than one paragraph, .description can be a list of strings."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "This is yduJ's table of tinymud commands and their equivalents in LambdaMOO.  A longer document, with discussions of the different verbs and how they have changed, is available via FTP from ftp.lambda.moo.mud.org as pub/MOO/contrib/docs/TinyMUD-LambdaMOO-equivs.  All the commands mentioned here have help nodes on LambdaMOO.",
            "",
            "The following commands are basically the same in MOO and MUD.",
            "",
            "    drop(throw), get(take), go, help, home, inventory, look, news, say (\",:)",
            "",
            "",
            "The following commands have no equivalent:",
            "",
            "    kill, rob, score, @force",
            "",
            "",
            "The following commands have the same names and do similar things, but are changed in some way (both syntactic and semantic differences, sometimes quite substantial differences):",
            "",
            "    @examine, give, page, read, whisper, @create, @dig,",
            "    @lock, @password, @unlock, @describe",
            "",
            "",
            "The following commands have rough equivalents in LambdaMOO but the name is different:",
            "",
            "    TinyMUD name            LambdaMOO name",
            "    ------------            --------------",
            "    QUIT                    @quit",
            "    gripe                   @gripe",
            "    goto/move               go",
            "    WHO                     @who",
            "    @fail                   @take_failed, @nogo, @drop_failed",
            "    @find                   @audit",
            "    @link                   @dig, @sethome, @add-exit, @add-entrance",
            "    @name                   @rename",
            "    @ofail                  @otake_failed, @onogo, @odrop_failed",
            "    @open                   @dig",
            "    @osuccess               @oleave, @oarrive, @otake_succeeded, ",
            "                            @odrop_succeeded",
            "    @success                @leave, @arrive, @take_succeeded",
            "                            @drop_succeeded",
            "    @teleport               @move",
            "",
            "",
            "Here are some commands for which no equivalent exists, or for which the equivalent is a complicated set of actions.",
            "",
            "    @set, @stats, @unlink",
            "",
            "",
            "Documentation on most of the LambdaMOO commands mentioned above can be acquired using 'help <command-name>'.  A notable exception is the commands like @oarrive and @take_failed that set textual messages on objects.  These are described under 'help messages'."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @gripe <anything> ...",
            "",
            "Puts you into the MOO mail system to register a complaint (or, conceivably, a compliment) with the wizards.  The rest of the command line (the <anything> ... part) is used as the subject line for the message.  More information on using the MOO mail system is given once you're in it.",
            "",
            "You may hear back from the wizards eventually; see 'help @mail' for how to read their reply.",
            "",
            "Example:",
            "Munchkin types:",
            "  @gripe The little bird",
            "  \"How come I can't ever see the little bird in the cuckoo clock?",
            "  \"        -- A frustrated player",
            "  send",
            "and, somewhat later, the wizards reply with a note about being sure to look while the clock is chiming."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @listgag [all]",
            "         @gaglist [all]",
            "",
            "Shows you a list of the players and objects currently on your 'gag list'.  You don't see any messages that result from actions initiated by the players or objects on this list.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.  With the optional \"all\" parameter it will also scan the database for players who are gagging you.  This may induce lag, so caution is advised with this option."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @ungag <player or object>",
            "         @ungag everyone",
            "",
            "Remove the given player or object (or, in the second form, everyone) from your 'gag list'.  You will once again see any messages that result from actions initiated by the ungagged player(s) or objects.  In particular, you will once again be able to hear them if they speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.",
            "",
            "Example:",
            "Munchkin types:",
            "  @ungag Grover",
            "and is once again able to hear Grover's witty remarks.  Sigh..."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @gag <player or object> [<player or object>...]",
            "",
            "Add the given players to your 'gag list'.  You will no longer see any messages that result from actions initiated by these players.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.",
            "",
            "Example:",
            "Munchkin types:",
            "  @gag Grover",
            "and no longer hears anything that Grover says.  What a relief!",
            "",
            "If you specify an object, then any text originating from that object will not be printed.  Example:  Noisy Robot prints \"Hi there\" every 15 seconds.   In order to avoid seeing that, Munchkin types:",
            "  @gag Noisy",
            "and no longer hears that robot!  (Munchkin must be in the same room as Noisy Robot for this to work, or know its object number.)"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax: go <direction> ...",
            "",
            "Invokes the named exits in the named order, moving through many rooms in a single command.",
            "",
            "Example:",
            "Munchkin types:",
            "  go n e e u e e s e",
            "and moves quite rapidly from the Living Room all the way to the Bovine Illuminati Atrium, all in one command."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax: @password <old-password> <new-password>",
            "",
            "Changes your player's password (as typed in the 'connect' command when you log in to the MOO) to <new-password>.  For security reasons, you are required to type your current (soon to be old) password as the first argument.",
            "",
            "Your password is stored in an encrypted form in the MOO database; in principle, not even the wizards can tell what it is, though they can change it, of course.  It is recommended that your password not be your name or a common word; MOO passwords have been stolen or cracked in the past and characters have been made unhappy by such theft.  Your password is your security; choose a safe one.",
            "",
            "If your character does get stolen, a wizard can change it for you and tell you the new password in secret.  You may have to provide your email address for verification.",
            "",
            "Only the first 8 characters of a password are significant."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax: @sethome",
            "",
            "Sets your designated home (see `help home') to be the room you're in now.  If the current room wouldn't allow you to teleport in, then the `@sethome' command nicely refuses to set your home there.  This avoids later, perhaps unpleasant, surprises.  Additionally, your home must be a room that will allow you to stay there.  Rooms which you own will do this, as will rooms to which you have been added as a resident.  See the @resident command for help on adding someone as a resident to a room you own."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "Syntax: @who",
            "        @who <player> [<player> ... ]",
            "",
            "The first form lists all of the currently-connected players, along with the amount of time they've been connected, the amount of time they've been idle, and their present location in the MOO.",
            "",
            "The second form, in which a list of player names is given, shows information for just those players.  For any listed players that are not connected, we show the last login time instead of the connect/idle times.",
            "",
            "@who refers to the @who_location message (see 'help messages') on each player's location in order to determine what should be printed in the location column.  Pronoun substitutions are done on this string in the usual manner (see 'help pronouns').  The default value is \"%[$room.who_location_msg]\" (i.e., the room name).",
            "",
            "If the list of players to display is longer than 100, this command will not show its normal output, since it can be quite expensive to compute.  In such cases, you might want to use the @users command instead; see `help @users' for more information."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "LambdaMOO is a kind of virtual reality, in which players move about from place to place manipulating their environment in what we hope are amusing, entertaining, or enlightening ways.",
            "",
            "LambdaMOO is more of a pastime than a game in the usual sense; there is no `score' kept, there are no specific goals to attain in general, and there's no competition involved.  LambdaMOO participants explore the virtual world, talk to the other participants, try out the weird gadgets that others have built, and create new places and things for others to encounter and enjoy.",
            "",
            "Most commands have the form of simple English sentences:",
            "    <verb>",
            "    <verb>  <direct object>",
            "    <verb>  <direct object>  <preposition>  <indirect object>",
            "Don't use English articles (e.g. 'a', 'an', or 'the') in your commands; the MOO won't understand them.  You can refer to yourself as 'me' and the room you're in as 'here'.",
            "",
            "The first five kinds of commands you'll want to know are listed below.  Type 'help <topic-name>' for details on any of them:",
            "",
            "look -- getting a description of the current room or any other object",
            "say -- speaking to the other players in the same room as you",
            "@who -- showing which players are currently connected to the MOO",
            "movement -- how to move around in the MOO, from room to room",
            "@quit -- disconnecting from the MOO"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  give <object> to <player>",
            "         hand <object> to <player>",
            "",
            "Move an object from your contents to that of another player.  This doesn't change the ownership of the object.  Some players may refuse to accept gifts and some objects may refuse to be given."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Syntax: news",
            "        news all",
            "        news new",
            "        news contents",
            "        news archive",
            "",
            "Read the latest edition of the %[$network.MOO_name] Newspaper, which carries articles concerning recent changes to the MOO server or to the main public classes, or other articles of interest to the MOO at large.",
            "",
            "The default behavior for the `news' command is to act like `news new' but this may be changed by setting the @mail-option news to one of `all' or `new' or `contents'.  `news all' displays all current news articles.  `news new' only displays articles you have not yet read.  `news contents' displays the authors and subjects of all current news.  `news archive' displays back issues of the newspaper which are deemed worth reading by every citizen at any time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Occasionally, you may run into a situation in which you'd rather not hear from certain other players.  It might be that they're being annoying, or just that whatever they're doing makes a lot of noise.  Gagging a player will stop you from hearing the results of any task initiated by that player.  You can also gag a specific object, if you want to hear what the owner of that object says, but not the output from their noisy robot.  The commands to use gagging are listed below; detailed help is available on each of them:",
            "",
            "@gag -- add one or more players to your gag list",
            "@ungag -- remove a player from your gag list",
            "@listgag -- list the players you currently have gagged"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @move <thing> to <place>",
            "",
            "Move the specified object to the specified location.  This is not guaranteed to work; in particular, the object must agree to be moved and the destination must agree to allow the object in.  This is usually the case, however.  The special case where <thing> is 'me' is useful for teleporting yourself around.",
            "",
            "If @move doesn't work and you own the room where the object is located, try using @eject instead."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  inventory",
            "         i",
            "",
            "Prints a list showing every object you're carrying."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @gender <gender>",
            "        @gender",
            "",
            "The first form, with an argument, defines your player to have the gender <gender>.  If <gender> is one of the standard genders (e.g., 'male', 'female', 'neuter',...), your various pronouns will also be set appropriately, making exits and certain other objects behave more pleasantly for you.",
            "",
            "The second form tells you the current definition of your player's gender, your current pronouns, and the complete list of standard genders.",
            "",
            "It should be noted that some of the \"genders\" on the standard gender list need verb conjugation in order to work properly and much of the MOO isn't set up for this (...yet).  For example, you should expect to see `they is' a fair amount if you @gender yourself `plural'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @rename <object>        to [name-and-alias],<alias>,...,<alias>",
            "        @rename <object>        to [name]:<alias>,...,<alias>",
            "        @rename <object>.<property> to <new-property-name>",
            "        @rename <object>:<verb-name> to <new-verb-name>",
            "        @rename# <object>:<verb-number> to <new-verb-name>",
            "",
            "The first two forms are used to change the name and aliases of an object. The name is what will be used in most printed descriptions of the object. The aliases are the names by which players can refer to the object in commands. Typically you want to include the name in the aliases, as the MOO parser only checks .aliases when matching, so the first syntax is generally preferred.",
            "",
            "If you leave out the \"name\" part of the list, @rename will leave the object's name as it is, and only change the aliases.",
            "",
            "Note that for renaming players, more stringent rules apply.  See `help player-names'.  Certain other kinds of objects (e.g., mail recipients) also enforce their own rules w.r.t what they can be named.",
            "",
            "Examples:",
            "Munchkin names his dog:",
            "  @rename #4237 to \"Rover the Wonder Dog\":Rover,dog",
            "Now we'll see 'Rover the Wonder Dog' if we're in the same room as him and we can refer to him as either 'Rover' or just 'dog' in our commands, like 'pet dog'.  Note, however, that it will be impossible to use \"Rover the Wonder Dog\" to rever to the dog: if you don't include the name in the aliases, confusion can result.  It might have been better to start off with",
            "  @rename #4237 to \"Rover the Wonder Dog\",Rover,dog",
            "",
            "Since he didn't, Munchkin now changes his dog's aliases:",
            "  @rename #4237 to ,Rover,dog,Rover the Wonder Dog",
            "The name remains the same--we still see 'Rover the Wonder Dog'--but now any of 'Rover', 'dog', or 'Rover the Wonder Dog' can be used to refer to him.  This can help reduce confusion.",
            "",
            "The third form of the @rename command is also for use by programmers, to change the name of a property they own to <new-property-name>.",
            "",
            "The fourth form of the @rename command is for use by programmers, to change the name of a verb they own. If the <new-verb-name> contains spaces, the verb will have multiple names, one for each space-separated word.",
            "",
            "The fifth form, @rename#, is for unambiguously referring to a verb on an object in case there is more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Notes are objects that can have text written on them to be read later.  They are useful for leaving messages to people, or for documenting your creations.",
            "",
            "The following help topics cover verbs that can be used with notes:",
            "",
            "read -- reading the text on the note",
            "write -- adding text to a note",
            "erase -- removing all the text from a note",
            "delete -- deleting one line of text from a note",
            "",
            "@notedit -- general editing on the text of a note",
            "",
            "encrypt -- restricting who can read a note",
            "decrypt -- undoing a previous encryption",
            "",
            "You can make a note by creating a child of the standard note, $note (see 'help @create').  Note that, like most objects, only the owner of a note can recycle it.  If you'd like to make it possible for a reader of your note to destroy it (this is a common desire for notes to other individual players), then you might want to look at 'help letters'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: look",
            "        look <object>",
            "        look <object> in <container>",
            "",
            "Show a description of something.",
            "",
            "The first form, with no arguments, shows you the name and description of the room you're in, along with a list of the other objects that are there.",
            "",
            "The second form lets you look at a specific object.  Most objects have descriptions that may be read this way.  You can look at your own description using 'look me'.  You can set the description for an object or room, including yourself, with the 'describe' command (see 'help describe').",
            "",
            "The third form shows you the description of an object that is inside some other object, including objects being carried by another player."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  drop <object>",
            "         throw <object>",
            "",
            "Remove an object you are carrying from your inventory and put it in your current room.  Occasionally you may find that the owner of the room won't allow you to do this."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "take"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Objects usually have verbs defined on them that allow players to manipulate and use them in various ways. Standard ones are:",
            "",
            "get  -- pick an object up and place it in your inventory",
            "drop -- remove an object from your inventory and place it in the room",
            "put  -- take an object from your inventory and place it in a container",
            "give -- hand an object to some other player",
            "look -- see what an object looks like",
            "",
            "You can see what objects you're carrying with the 'inventory' command; see 'help inventory' for details.",
            "",
            "Some specialized objects will have other commands. The programmer of the object will usually provide some way for you to find out what the commands are.  One way that works for most objects is the 'examine' command; see 'help examine' for details.",
            "",
            "The following specialized objects have help entries you should consult:",
            "",
            "notes -- objects that allow text to be written on them and read later",
            "letters -- notes that a recipient can burn after reading",
            "containers -- objects that may contain other objects"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  help",
            "         help <topic>",
            "         help index",
            "",
            "Print out entries from the online documentation system.  The commands `?' and `information' (usually abbreviated `info') are synonyms for `help'.",
            "",
            "The first form prints out a summary table of contents for the entire help system.  ",
            "",
            "The second form prints out the documentation available on the given topic.  Many help system entries contain references to other entries accessible in this way.  The topic name may be abbreviated; if there is no topic exactly matching the name you give, the help system checks for topics for which the name is a prefix, perhaps with the addition or omission of an initial `@', or perhaps with some confusion beween dashes (-) and underscores (_), e.g., ",
            "      `bui' instead of `building', ",
            "      `who' instead of `@who', ",
            "     `@wri' instead of `write',",
            "  `add_ent' instead of `@add-entrance',",
            " `unlock-'  instead of `@unlock_for_open'",
            "",
            "If the abbreviation you give is ambiguous, you will be presented with a list of the matching complete topic names.",
            "",
            "The `help index' commands prints out a list of indices for the various help databases.  Each index gives a list of topics available on that database.  It is sometimes easier to find the topics you're interested in this way, rather than tracing through the chain of cross references."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The descriptions of most rooms outline the directions in which exits exist.  Typical directions include the eight compass points ('north', 'south', 'east', 'west', 'northeast', 'southeast', 'northwest', and 'southwest'), 'up', 'down', and 'out'.",
            "",
            "To go in a particular direction, simply type the name of that direction (e.g, 'north', 'up').  The name of the direction can usually be abbreviated to one or two characters (e.g., 'n', 'sw').  You can also type 'go <direction>' to move; this is particularly useful if you know you're going to type several movement commands in a row (see 'help go').",
            "",
            "In addition to such vanilla movement, some areas may contain objects allowing teleportation and almost all areas permit the use of the 'home' command to teleport you to your designated home (see 'help home' for more details)."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "Syntax: home",
            "",
            "Instantly teleports you to your designated home room.",
            "Initially, this room is %[tostr($player_start.name,\" (\",$player_start,\")\")].",
            "You can change your designated home; see 'help @sethome' for details."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  say <anything> ...",
            "         \"<anything> ...",
            "",
            "Says <anything> out loud, so that everyone in the same room hears it.  This is so commonly used that there's a special abbreviation for it: any command-line beginning with a double-quote ('\"') is treated as a 'say' command.",
            "",
            "Example:",
            "Munchkin types this:",
            "  \"This is a great MOO!",
            "Munchkin sees this:",
            "  You say, \"This is a great MOO!\"",
            "Others in the same room see this:",
            "  Munchkin says, \"This is a great MOO!\""
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "whisper \"<text>\" to <player>",
            "sends the message \"<yourname> whispers, \"<text>\" to you \" to <player>, if they are in the room."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "Syntax:  page <player> [[with] <text>]",
            "",
            "Sends a message to a connected player, telling them your location and, optionally, <text>.",
            "",
            "Example:",
            "Munchkin types:",
            "        page Frebble with \"Where are you?\"",
            "Frebble sees:",
            "        You sense that Munchkin is looking for you in the Kitchen.",
            "        He pages, \"Where are you?\"",
            "Munchkin sees:",
            "        Your message has been received.",
            "",
            "Advanced Features:",
            "Page refers to the following messages on the players involved (see 'help messages'):",
            "",
            "@page_origin [%[$player.page_origin_msg]]",
            "  Determines how the recipient is told of your location.",
            "",
            "@page_echo   [%[$player.page_echo_msg]]",
            "  Determines the response received by anyone who pages you.",
            "",
            "@page_absent [%[$player.page_absent_msg]]",
            "  Determines the response received by anyone who tries to page you when you aren't connected.",
            "",
            "All of these undergo the usual pronoun substitutions (see 'help pronouns') except that in both cases the direct object (%d) refers to the recipent of the page and the indirect object (%i) refers to the sender.  You should only change these messages if you want to add to the Virtual Reality feel of the MOO for your character."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  emote <anything> ...",
            "         :<anything> ...",
            "         ::<anything> ...",
            "",
            "Announces <anything> to everyone in the same room, prepending your name.  This is commonly used to express various non-verbal forms of communication.  In fact, it is so commonly used that there's a special abbreviation for it: any command-line beginning with ':' is treated as an 'emote' command.",
            "",
            "The alternate form, '::' (less commonly 'emote :'), does not insert the space between the player name and the text.",
            "",
            "Examples:",
            "Munchkin types this:",
            "  :wishes he were much taller...",
            "Everyone in the same room sees this:",
            "  Munchkin wishes he were much taller...",
            "",
            "Munchkin types this:",
            "  ::'s eyes are green.",
            "Everyone in the same room sees this:",
            "  Munchkin's eyes are green."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "There are a number of commands for modifying various characteristics of the object representing you in the MOO, your 'player'.  Help on them is available in the following topics:",
            "",
            "@describe -- setting what others see when they look at you",
            "@gender -- changing your player's gender",
            "@password -- changing your player's password",
            "@sethome -- changing your designated home room",
            "@rename -- changing your name and/or aliases",
            "@linelength -- adding word-wrap to the lines you see"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Help is available on the following general topics:",
            "",
            "introduction -- what's going on here and some basic commands",
            "index -- index into the help system",
            "",
            "players -- setting characteristics of yourself",
            "movement -- moving yourself between rooms",
            "communication -- communicating with other players",
            "manipulation -- moving or using other objects",
            "miscellaneous -- commands that don't fit anywhere else",
            "",
            "building -- extending the MOO",
            "programming -- writing code in the MOO programming language",
            "editors -- editing text and code in the MOO",
            "",
            "@pagelength -- what to do if lines scroll off your screen too fast",
            "@linelength -- what to do if lines are truncated",
            "tinymud -- a list of equivalences between MOO and TinyMUD concepts/commands"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @edit-option",
            "         @edit-option <option>",
            "",
            "Synonym:  @editoption",
            "",
            "The edit options customize the behavior of the various editors (mail editor, verb editor, etc...) to your particular taste.  The first form of this command displays all of your edit options.  The second form displays just that one option, one of the flags listed below.",
            "",
            "The remaining forms of this command are for setting your edit options:",
            "",
            "         @edit-option +<flag>",
            "         @edit-option -<flag>",
            "         @edit-option !<flag>           (equivalent to -<flag>)",
            "",
            "These respectively set and reset the specified flag",
            "",
            "-quiet_insert    insert (\") and append (:) echo back the line numbers",
            "+quiet_insert    insert (\") and append (:) produce no output",
            "-eval_subs       (VERB EDITOR) ignore .eval_subs when compiling verbs",
            "+eval_subs       (VERB EDITOR) apply .eval_subs to verbs being compiled",
            "-local           Use in-MOO text editors.",
            "+local           Ship text to client for local editing.",
            "-no_parens       include all parentheses in verb code.",
            "+no_parens       include only necessary parentheses in verb code.",
            "",
            "+parens        is a synonym for -no_parens",
            "+noisy_insert  is a synonym for -quiet_insert"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@edit-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:  @add-feature  <object>",
            " @remove-feature <object>",
            "",
            "Add or remove a feature from your list.  A feature is an object which provides additional commands you can use.  For more information, see `help features'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@add-feature"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:  @features [<name>] [for <player>]",
            "",
            "List all of <player>'s features matching <name>, or all of <player>'s features if <name> is not supplied.  <player> defaults to you.  See `help features' for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Features are objects that provide you with commands not covered by the ordinary player objects.  The advantage of using features is that you can mix and match the things you like; whereas if you like a command that's defined on a player class, you have to also get all the commands it defines, and all the commands its ancestors define.",
            "",
            "You can list your features with the @features command, and add or remove features from your list with the @add-feature and @remove-feature commands."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @rmalias <alias>[,...,<alias>] from <object>",
            "        @rmalias <alias>[,...,<alias>] from <object>:<verb-name>",
            "        @rmalias# <alias>[,...,<alias>] from <object>:<verb-number>",
            "",
            "The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.",
            "Note that @rmalias will not affect the object's name, only its aliases.",
            "",
            "The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.",
            "",
            "The third form, @rmalias#, is for unambiguously referring to a verb on an object that might have more than one verb with the same name. The verb-number is the 1-based index of the verb as it appears in the verb() (or @verbs) output list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @addalias <alias>[,...,<alias>] to <object>",
            "        @addalias <alias>[,...,<alias>] to <object>:<verb-name>",
            "        @addalias# <alias>[,...,<alias>] to <object>:<verb-number>",
            "",
            "The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.",
            "",
            "Example:",
            "Muchkin wants to add new aliases to Rover the Wonder Dog:",
            "  @addalias Dog,Wonder Dog to Rover",
            "Since Rover the Wonder Dog already has the alias \"Dog\" but does not have the alias \"Wonder Dog\", Munchkin sees:",
            "  Rover the Wonder Dog(#4237) already has the alias Dog.",
            "  Alias Wonder Dog added to Rover the Wonder Dog(#4237).",
            "",
            "If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.  Certain other classes of objects (e.g., mail-recipients) also enforce rules about what aliases may be given them.",
            "",
            "Example:",
            "Munchkin wants to add his nicknames to his own list of aliases:",
            "  @addalias Foobar Davey to me",
            "@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias \"Davey\" so Munchkin sees:",
            "  DaveTheMan(#5432) is already using the alias Davey",
            "  Alias Foobar added to Munchkin(#1523).",
            "",
            "The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.",
            "",
            "The third form, @addalias#, is for unambiguously referring to a verb on an object in case there are more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "summary",
            "",
            "Type 'help <topic>' for information on a particular topic.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Every object (including players, rooms, exits) has a name and a set of aliases. The object name is commonly used to display an object in various contexts. The object aliases are used to refer to an object when players type commands.",
            "Help is available on the following commands:",
            "@rename -- change the names or aliases of an object or yourself.",
            "@addalias, @rmalias -- add and remove aliases."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:    @request <player-name> for <email-address>",
            "",
            "Example:  @request Munchkin for msneed@baum.edu",
            "",
            "This command is available to Guest characters only.",
            "",
            "The @request command requests a new character, registered for your email address. Please use your primary address for this, as your password will be sent to the address provided."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "A player name must be a single word, must not contain any spaces, backslashes, or quotes, nor can it begin with the characters #, *, (, or ).  Finally it cannot be one that is in use by any other player nor any of the words on the following list:",
            "",
            "%;;lns={};for l in ($string_utils:columnize({@$player_db.stupid_names,@$player_db.reserved},6)) lns={@lns,\"  \"+l}; endfor return lns;",
            "",
            "Note that these rules apply as well to your single-word aliases, since those can equally well be used to refer to you in commands that match on player names (@who, whereis, ...).  There are no restrictions on your multi-word aliases, however the commands that expect player names will not recognize them."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "  @registerme as <email-address>",
            "This verb changes your registered email_address property. It will modify the registration, and then, to validate the email address, it will assign a new password and mail the password to the given email_address.",
            "If, for some reason, this is a problem for you, contact a wizard or registrar to get your email address changed.",
            "",
            "  @registerme",
            "Prints your registered email address."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@eject"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Options allow you to customize the behavior of various commands.  Options are grouped into separate option packages that each affects a given class of related commands.  Each has its own help topic:",
            "",
            "  @mail-options    --- mail commands (@mail, @read, @next, @prev, @send...)",
            "  @edit-options    --- editing commands (@edit and commands within the editor)",
            "  @build-options   --- building commands (@create, @dig, @recycle)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @age [player]",
            "",
            "Displays the MOO age of the player if the player specified first connected after initial connections were recorded.",
            "MOO age is computed from the moment the player first connected until the current time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @edit <object>.<property>",
            "         @edit <object>:<verb-name> [<dobj> [<prep> [<iobj>]]]",
            "         @edit <object>",
            "",
            "Enters a MOO editor, as appropriate.",
            "",
            "Chooses the MOO Note editor for the named property, or the MOO verb editor for the named verb.  If no property or verb name is given, assumes property .text for a note object, or .description for any other object.",
            "",
            "See 'help editors' for more detail."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@add-feature"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "There are several commands available to allow you to communicate with your fellow MOOers.  Help is available on the following communication-related topics:",
            "",
            "say      -- talking to the other connected players in the room",
            "whisper  -- talking privately to someone in the same room",
            "page     -- yelling to someone anywhere in the MOO",
            "emote    -- non-verbal communication with others in the same room",
            "gagging  -- screening out noise generated by certain other players",
            "news     -- reading the wizards' most recent set of general announcements",
            "@gripe   -- sending complaints to the wizards",
            "@typo @bug @idea @suggest",
            "         -- sending complaints/ideas to the owner of the current room",
            "whereis  -- locating other players",
            "@who     -- finding out who is currently logged in",
            "mail     -- the MOO email system",
            "security -- the facilities for detecting forged messages and eavesdropping."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Objects are the fundamental building blocks of the MOO.  Every object has a unique number, a name, an owner, a location, and various other properties.  An object can always be referred to by its number, and sometimes by its name or one of its aliases -- if you are in the same location as the object, for example, and also in some other special cases.",
            "",
            "For help on creating an object, see 'help @create'.",
            "",
            "For help on recycling an object, see 'help @recycle'.",
            "",
            "For help on finding information about specific objects, see 'help @display', 'help @show', and 'help $object_utils'."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Every object on the MOO (players included) has a list of aliases, or names by which it can be referred.  This is useful when an object has a nice long descriptive name that you don't want to have to type every time you refer to it.",
            "",
            "Typing `exam object' will show you its aliases.  If you are a programmer, you can type `#<object>.aliases', using an object's number, or `#Munchkin.aliases p'.  (The `p' indicates that the prefix is a player's name.)",
            "",
            "See also `help #', `help @addalias', and `help @rmalias'."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@check"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @users",
            "",
            "Prints out the number of users currently connected and a list of their names, in alphabetical order."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            " name"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@addalias"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @mode <brief | verbose>",
            "",
            "Sets your current mode to either brief or verbose.  In brief mode, when you enter into a room, you will not see the room's description unless you explicitly type `look'.  Verbose is the default mode."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "wizard-list"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Players sometimes have difficulty getting their backspace key to work.  This is an outside-MOO problem:  Whatever access software you have determines how the line you type is edited before the MOO ever sees it.  If your backspace key won't work here, you will probably need to consult with some documentation or a guru at your end.",
            "",
            "The above notwithstanding, here are a few things to try instead of backspace:",
            "",
            "   ctrl-h            (another way of typing backspace)",
            "   del               (delete character)",
            "   ctrl-backspace    (another way of typing delete character)",
            "   ctrl-w            (delete word left)",
            "   ctrl-u            (delete entire line)",
            "   ctrl-r            (redraw line)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The spivak pronouns were developed by mathematician Michael Spivak for use in his books.  They are the most simplistic of the gender neutral pronouns (others being \"neuter\" and \"splat\") and can be easily integrated into writing.  They should be used in a generic setting where the gender of the person referred to is unknown, such as \"the reader.\"  They can also be used to describe a specific individual who has chosen not to identify emself with the traditional masculine (male) or feminine (female) gender.",
            "",
            "The spivak pronouns are",
            "E      - subjective",
            "Em     - objective",
            "Eir    - possessive (adjective)",
            "Eirs   - possessive (noun)",
            "Emself - reflexive"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage: @owner object",
            "",
            "Displays the specified object, its object number, and its owner (and its owner's object number)."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Checkpointing refers to process by which the MOO makes a backup copy of itself.  Because the computer that's running the MOO has to simultaneously handle two copies of itself, this results in a period of high lag for the MOO users.  So, why do we put up with this?",
            "",
            "Every successful checkpoint results in a database of what the MOO was like at that point in time.  All the MOOmail, mailing lists, objects, descriptions, properties, and verbs on all of the MOO are frozen in time and stored.  In the event that the MOO crashes (due to a power failure or the like), this checkpoint database can be used to restart the MOO with much of our recent work intact.  This is a very good thing.",
            "",
            "Checkpointing is a global backup.  Do not rely on the checkpoint database to back up your own work!  Archive your code, properties, and objects offline to ensure their safety.  Each successful checkpoint overwrites the previous day's checkpoint, so it is an unreliable means of recovering lost data.  Some of these checkpoints do get backed up quarterly, but these are not available without inconveniencing the MOO populace as a whole."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "gen-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The object $help is the main help database.  For every help topic there is a corresponding property on $help, interpreted as follows:",
            "",
            "$help.(topic) = string           - one-line help text.",
            "$help.(topic) = {\"*verb*\",@args} - call this:verb(args,{}) to get text",
            "$help.(topic) = any other list   - multi-line help text",
            "",
            "There is also a \"\" property which applies in the case of `help' typed without any arguments.",
            "",
            "See the description of $generic_help for more detail."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            96515,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "61": {
      "id": 61,
      "name": "News",
      "flags": 16,
      "owner": 36,
      "location": 46,
      "parents": [
        45
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "description",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "raw = ctime(this.last_news_time);",
            "\"         111111111122222\";",
            "\"123456789012345678901234\";",
            "\"Fri Nov 30 14:31:21 1990\";",
            "date = (raw[1..10] + \",\") + raw[20..24];",
            "return strsub(this.description, \"%d\", date);"
          ]
        },
        {
          "name": "is_writable_by",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "return pass(@args) || (args[1] in $list_utils:map_prop($object_utils:descendants($wiz), \"mail_identity\"));"
          ]
        },
        {
          "name": "rm_message_seq",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (this:ok_write(caller, caller_perms()))",
            "seq = args[1];",
            "this.current_news_going = $seq_utils:intersection(this.current_news, seq);",
            "this.current_news = $seq_utils:contract(this.current_news, seq);",
            "return $mail_agent:(verb)(@args);",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "undo_rmm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "seq = $mail_agent:(verb)(@args);",
            "this.current_news = $seq_utils:union(this.current_news_going, $seq_utils:expand(this.current_news, seq));",
            "this.current_news_going = {};",
            "return seq;"
          ]
        },
        {
          "name": "expunge_rmm",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "endif",
            "this.current_news_going = {};",
            "return $mail_agent:(verb)(@args);"
          ]
        },
        {
          "name": "set_current_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "else",
            "this.current_news = new = args[1];",
            "if (new)",
            "newlast = $seq_utils:last(new);",
            "newlasttime = this:messages_in_seq(newlast)[2][1];",
            "if (newlasttime > this.last_news_time)",
            "\"... only notify people if there exists a genuinely new item...\";",
            "this.last_news_time = newlasttime;",
            "this:touch();",
            "endif",
            "else",
            "\"...flush everything...\";",
            "this.last_news_time = 0;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "add_current_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "else",
            "return this:set_current_news($seq_utils:union(this.current_news, args[1]));",
            "endif"
          ]
        },
        {
          "name": "rm_current_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "return E_PERM;",
            "else",
            "return this:set_current_news($seq_utils:intersection(this.current_news, $seq_utils:complement(args[1])));",
            "endif"
          ]
        },
        {
          "name": "news_display_seq_full",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "\":news_display_seq_full(msg_seq) => {cur, last-read-date}\";",
            "\"Display the given msg_seq as a collection of news items\";",
            "set_task_perms(caller_perms());",
            "desc = this:description();",
            "player:notify((typeof(desc) == LIST) ? desc[1] | desc);",
            "player:notify(\"\");",
            "msgs = this:messages_in_seq(args[1]);",
            "for i in [-(n = length(msgs))..-1]",
            "x = msgs[-i];",
            "player:notify_lines(this:to_text(@x[2]));",
            "player:notify(\"\");",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "player:notify(\"(end)\");",
            "return {msgs[n][1], msgs[n][2][1]};"
          ]
        },
        {
          "name": "to_text",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "\":to_text(@msg) => message in text form -- formatted like a $news entry circa October, 1993\";",
            "date = args[1];",
            "by = args[2];",
            "\"by = by[1..index(by, \\\"(\\\") - 2]\";",
            "subject = (args[4] == \" \") ? \"-*-NEWS FLASH-*-\" | $string_utils:uppercase(args[4]);",
            "text = args[(\"\" in {@args, \"\"}) + 1..$];",
            "ctime = $time_utils:time_sub(\"$D, $N $3, $Y\", date);",
            "return {ctime, subject, @text};",
            "return {subject, tostr(\"  by \", by, \" on \", ctime), \"\", @text};"
          ]
        },
        {
          "name": "check",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "set_task_perms(caller_perms());",
            "if ((player:get_current_message(this) || {0, 0})[2] < this.last_news_time)",
            "if ((n = player:mail_option(\"news\")) in {0, \"all\"})",
            "player:tell(\"There is new news.  Type `news' to read all news or `news new' to read just new news.\");",
            "elseif (n == \"contents\")",
            "player:tell(\"There is new news.  Type `news all' to read all news or `news new' to read just new news.\");",
            "elseif (n == \"new\")",
            "player:tell(\"There is new news.  Type `news' to read new news, or `news all' to read all news.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "touch",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, valid(who = caller_perms()) ? who | player))",
            "player:notify(\"Permission denied.\");",
            "return;",
            "endif",
            "fork (0)",
            "for p in (connected_players())",
            "$command_utils:suspend_if_needed(0);",
            "if ((p:get_current_message(this) || {0, 0})[2] < this.last_news_time)",
            "p:notify(\"There's a new edition of the newspaper.  Type 'news new' to see the new article(s).\");",
            "endif",
            "endfor",
            "endfork"
          ]
        },
        {
          "name": "@addnews",
          "owner": 2,
          "perms": 157,
          "preps": 1,
          "object": 61,
          "code": [
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "raise(E_PERM);",
            "endif",
            "set_task_perms(player);",
            "if (!this:is_writable_by(player))",
            "player:notify(\"You can't write the news.\");",
            "elseif (typeof(result = this:add_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)",
            "player:notify(result);",
            "else",
            "new = this.current_news;",
            "if (new)",
            "player:notify(\"Current newspaper set.\");",
            "this:display_seq_headers(new);",
            "else",
            "player:notify(\"Current newspaper is now empty.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@rmnews",
          "owner": 2,
          "perms": 157,
          "preps": 5,
          "object": 61,
          "code": [
            "if ((caller_perms() != #-1) && (caller_perms() != player))",
            "raise(E_PERM);",
            "endif",
            "set_task_perms(player);",
            "if (!this:is_writable_by(player))",
            "player:notify(\"You can't write the news.\");",
            "elseif (typeof(result = this:rm_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)",
            "player:notify(result);",
            "else",
            "new = this.current_news;",
            "if (new)",
            "player:notify(\"Current newspaper set.\");",
            "this:display_seq_headers(new);",
            "else",
            "player:notify(\"Current newspaper is now empty.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@setnews",
          "owner": 2,
          "perms": 105,
          "preps": 1,
          "object": 61,
          "code": [
            "set_task_perms(player);",
            "if (!this:is_writable_by(player))",
            "player:notify(\"You can't write the news.\");",
            "elseif (typeof(seq = this:_parse(strings = args[(prepstr in args) + 1..$], @player:get_current_message(this) || {0, 0})) == STR)",
            "player:notify(seq);",
            "else",
            "old = this.current_news;",
            "if (old == seq)",
            "player:notify(\"No change.\");",
            "else",
            "this:set_current_news(seq);",
            "if (seq)",
            "player:notify(\"Current newspaper set.\");",
            "this:display_seq_headers(seq);",
            "else",
            "player:notify(\"Current newspaper is now empty.\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "_parse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!(strings = args[1]))",
            "return \"You need to specify a message sequence\";",
            "elseif (typeof(pms = this:parse_message_seq(@args)) == STR)",
            "return $string_utils:substitute(pms, {{\"%f\", \"The news\"}, {\"%<has>\", \"has\"}, {\"%%\", \"%\"}});",
            "elseif (typeof(pms) != LIST)",
            "return tostr(pms);",
            "elseif (length(pms) > 1)",
            "return tostr(\"I don't understand `\", pms[2], \"'.\");",
            "elseif (!(seq = pms[1]))",
            "return tostr(\"The News (\", this, \") has no `\", $string_utils:from_list(strings, \" \"), \"' messages.\");",
            "else",
            "return seq;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.description = \"It's the current issue of the News, dated %d.\";",
            "this.moderated = 1;",
            "this.last_news_time = 0;",
            "this.readers = 1;",
            "this.expire_period = 0;",
            "this.archive_news = {};",
            "$mail_agent:send_message(#2, this, \"Welcome to LambdaCore\", $wiz_utils.new_core_message);",
            "this:add_news(\"$\");",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "add_news",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "$error:raise(E_PERM);",
            "endif",
            "{specs, ?cur = {0, 0}} = args;",
            "seq = this:_parse(specs, @cur);",
            "if (typeof(seq) == STR)",
            "return seq;",
            "endif",
            "old = this.current_news;",
            "new = $seq_utils:union(old, seq);",
            "if (old == new)",
            "return \"Those messages are already in the news.\";",
            "endif",
            "this:set_current_news(new);",
            "return 1;"
          ]
        },
        {
          "name": "rm_news",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 61,
          "code": [
            "if (!this:ok_write(caller, caller_perms()))",
            "raise(E_PERM);",
            "endif",
            "{specs, ?cur = {0, 0}} = args;",
            "seq = this:_parse(specs, @cur);",
            "if (typeof(seq) == STR)",
            "return seq;",
            "endif",
            "old = this.current_news;",
            "new = $seq_utils:intersection(old, $seq_utils:complement(seq));",
            "if (old == new)",
            "return \"Those messages were not in the news.\";",
            "endif",
            "this:set_current_news(new);",
            "return 1;"
          ]
        },
        {
          "name": "@listnews",
          "owner": 2,
          "perms": 141,
          "preps": 4,
          "object": 61,
          "code": [
            "player:notify(\"The following articles are currently in the newspaper:\");",
            "this:display_seq_headers(this.current_news);"
          ]
        },
        {
          "name": "@clearnews",
          "owner": 2,
          "perms": 41,
          "preps": -1,
          "object": 61,
          "code": [
            "set_task_perms(player);",
            "if (this:is_writable_by(player))",
            "this:set_current_news({});",
            "player:notify(\"Current newspaper is now empty.\");",
            "else",
            "player:notify(\"You can't write the news.\");",
            "endif"
          ]
        }
      ],
      "propnames": [
        "current_news",
        "last_news_time",
        "current_news_going",
        "archive_news"
      ],
      "propdefs": [
        {
          "value": [
            1,
            2
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1084848652,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1084848652,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1084848652,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            [
              1,
              [
                1084848652,
                "Wizard (#2)",
                "*News (#61)",
                "Welcome to LambdaCore",
                "",
                "Getting Started with your LambdaCore MOO",
                "========================================",
                "",
                "Thank you for choosing LambdaCore!",
                "",
                "Initial Setup Notes",
                "-------------------",
                "",
                "The \"welcome\" screen, seen when a player connects.",
                "  -- this is stored in $login.welcome_message",
                "",
                "Do you want on-line character creation?",
                "  -- this is stored in $login.create_enabled",
                "     for more detailed information, edit $login:player_creation_enabled",
                "",
                "Do you want to limit the number of players on the MOO at once?",
                "  -- look at $login.max_connections",
                "     the `connection_limit' message on $login is the message printed",
                "     when this limit is reached.",
                "",
                "Do you want a different default player class?",
                "  -- set $player_class to a different value",
                "     *do not* change $player",
                "",
                "You should also set the following:",
                "  $network.postmaster",
                "    -- your email address, or the email address of the person who will ",
                "       handle your email",
                "  $network.site",
                "    -- the machine your MOO is running on (e.g. \"lambda.moo.mud.org\")",
                "  $network.port",
                "    -- the port your MOO is running on (e.g. 8888)",
                "  $network.MOO_Name",
                "    -- the name of your MOO (e.g. \"LambdaMOO\")",
                "  $site_db.domain",
                "  -- this is set to the `domain' of your address",
                "     (eg `foo.com' for `moo.foo.com')",
                "",
                "If you compiled the server with open_network_connection() enabled (allowing the MOO to open up connections with other computers on the network), then you should set",
                "  $network.active = 1",
                "     This will enable @newpassword, @registerme, @password, @mailme, @netforward, and others to send mail from the MOO.",
                "",
                "-------------------------------------------------------------------",
                "",
                "Setting Yourself Up",
                "-------------------",
                "",
                "Set a password for yourself.",
                "  -- @password <new-password>",
                "",
                "Set a description for yourself.",
                "  -- @describe me as <anything>",
                "",
                "Set a gender for yourself.",
                "  -- @gender <gender>",
                "",
                "There are, also, a large number of messages you can set on yourself.  Setting them will enhance the virtual reality.",
                "",
                "-------------------------------------------------------------------",
                "",
                "About Guests",
                "------------",
                "",
                "To make a new Guest character:",
                "  -- @make-guest <guestname>",
                "     will make a new guest with the name you specify with `_Guest' appended",
                "     and some other standard but useful aliases",
                "",
                "This is the easiest way to make Guest characters.  The most important things to remember about Guests, if you want to make them yourself, are:",
                "  -- make them owned by nonwizards, and not owned by themselves",
                "  -- make sure they've got .password == 0, and that .password is nonclear",
                "  -- at least one Guest must always be named `Guest'; this can be an alias",
                "",
                "To set the default description and gender for a guest:",
                "  -- set .default_description to the description the guest should start with",
                "  -- set .default_gender to the gender the guest should start with",
                "  -- remember to set .description and .gender too, for the guest's first use",
                "",
                "-------------------------------------------------------------------",
                "",
                "Adding to the Newspaper",
                "-----------------------",
                "",
                "The newspaper is a special mailing list.  To add a post to the newspaper, send mail to it (as *News or $news), and then note the number of your post (let's call it <x> and:",
                "  -- @addnews <x> to *News",
                "... in general, `@addnews $ to *News' will work as well.",
                "",
                "-------------------------------------------------------------------",
                "",
                "Quota",
                "-----",
                "",
                "By default, LambdaCore runs with byte-based quota, an in-DB quota system, limiting users by total database space as opposed to total objects.  You'll need to do two things:",
                "  -- decide on the default quota:",
                "     ;$byte_quota_utils.default_quota[1] = <a number of bytes>",
                "  -- start the measurement task; see `help routine_tasks' for more information (Note: this help topic contains information about more than just the quota task; it should be read regardless of how quota is set).",
                "",
                "If you prefer the quota system documented in the LambdaMOO Programmer's Manual, directly supported by the server, you can enable object-based quota:",
                "  -- set $quota_utils to $object_quota_utils",
                "",
                "It's best that you make this switch before users start, because converting existing users is an awkward (and inherently arbitrary and political) move.",
                "",
                "-------------------------------------------------------------------",
                "",
                "Making Programmers",
                "------------------",
                "",
                "The command to turn someone into a programmer is `@programmer'  Its syntax is `@programmer <user>'.  For example:",
                "  -- @programmer Haakon",
                "The `@programmer' verb will prompt you if the user isn't set up with a description and a gender.",
                "",
                "No code to automatically grant programmer bits is included with LambdaCore.",
                "",
                "Making Wizards",
                "--------------",
                "",
                "THINK CAREFULLY.",
                "",
                "Be very careful before giving someone a wizard bit.  That person can do gross damage to your database, and fixable but serious damage to the machine it runs on.  That person can quite possibly open outbound network connections from your machine, and thus commit acts for which your host system will be blamed.  That person can ruin your MOO's as-yet-untarnished reputation.",
                "",
                "Wizards have technical power, the ability to change anything within the database, to create anything within the database.  Be careful with the idea of a `Social Wizard' -- a nontechnical person holding a wizard bit is fairly likely to, at some point, accidentally do something destructive.  It's a good idea not to socialize as your wizard character, for the same reason, to make it less likely to be accidentally destructive.",
                "",
                "That said, in general you don't turn an existing character into a wizard, you make a -new- character to be the wizard.  This is because the existing character probably owns code and objects which could be destructive if suddenly made wizardly; it's a good security measure to make a fresh player.  So, to make a fresh player:",
                "  -- @make-player (see `help @make-player' for more information)",
                "     this will make you a new player. for this example, #123",
                "",
                "To make #123 a wizard:",
                "  -- @programmer #123",
                "     (a nonprogrammer wizard is a truly strange beast)",
                "  -- ;#123.wizard = 1;",
                "  -- @chparent #123 to $wiz",
                "  -- ;#123.public_identity = <the player's nonwizard character's object number>",
                "",
                "-------------------------------------------------------------------",
                "",
                "Good luck with your new LambdaCore database!",
                "",
                "Visit us at LambdaMOO: lambda.moo.mud.org 8888",
                "",
                "Join the international mailing list for MOO coders: send an email message to moo-cows-request@the-b.org with the word `subscribe' as the body of your message.",
                "",
                "Do good things.",
                "",
                "The LambdaMOO Wizards",
                "[authored February 15, 1999]"
              ]
            ]
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "News"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "It's the current issue of the News, dated %d.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            29103,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "62": {
      "id": 62,
      "name": "The First Room",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        3
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "disfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 62,
          "code": [
            "\"Copied from The Coat Closet (#11):disfunc by Haakon (#2) Mon May  8 10:41:04 1995 PDT\";",
            "if ((((cp = caller_perms()) == (who = args[1])) || $perm_utils:controls(cp, who)) || (caller == this))",
            "\"need the first check since guests don't control themselves\";",
            "if (who.home == this)",
            "move(who, $limbo);",
            "this:announce(\"You hear a quiet popping sound; \", who.name, \" has disconnected.\");",
            "else",
            "pass(who);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "enterfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 62,
          "code": [
            "\"Copied from The Coat Closet (#11):enterfunc by Haakon (#2) Mon May  8 10:41:38 1995 PDT\";",
            "who = args[1];",
            "if ($limbo:acceptable(who))",
            "move(who, $limbo);",
            "else",
            "pass(who);",
            "endif"
          ]
        },
        {
          "name": "match",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 62,
          "code": [
            "\"Copied from The Coat Closet (#11):match by Lambda (#50) Mon May  8 10:42:01 1995 PDT\";",
            "m = pass(@args);",
            "if (m == $failed_match)",
            "\"... it might be a player off in the body bag...\";",
            "m = $string_utils:match_player(args[1]);",
            "if (valid(m) && (!(m.location in {this, $limbo})))",
            "return $failed_match;",
            "endif",
            "endif",
            "return m;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 62,
          "code": [
            "\"Copied from The Coat Closet (#11):init_for_core by Nosredna (#2487) Mon May  8 10:42:52 1995 PDT\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "for v in ({\"announce*\", \"emote\", \"button\", \"knob\"})",
            "if (`verb_info($player_start, v) ! E_VERBNF => 0')",
            "delete_verb($player_start, v);",
            "endif",
            "endfor",
            "for p in ({\"out\", \"quiet\", \"button\"})",
            "if (p in properties($player_start))",
            "delete_property($player_start, p);",
            "endif",
            "endfor",
            "for p in ($object_utils:all_properties($room))",
            "clear_property($player_start, p);",
            "endfor",
            "$player_start.name = \"The First Room\";",
            "$player_start.aliases = {};",
            "$player_start.description = \"This is all there is right now.\";",
            "$player_start.exits = $player_start.entrances = {};",
            "\"... at the end since $room:init_for_core moves stuff in\";",
            "pass(@args);"
          ]
        },
        {
          "name": "keep_clean",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 62,
          "code": [
            "\"Copied from The Coat Closet (#11):keep_clean by Haakon (#2) Mon May  8 10:47:08 1995 PDT\";",
            "if ($perm_utils:controls(caller_perms(), this))",
            "junk = {};",
            "while (1)",
            "for x in (junk)",
            "$command_utils:suspend_if_needed(0);",
            "if (x in this.contents)",
            "\"This is old junk that's still around five minutes later.  Clean it up.\";",
            "if (!valid(x.owner))",
            "move(x, $nothing);",
            "#2:tell(\">**> Cleaned up orphan object `\", x.name, \"' (\", x, \"), owned by \", x.owner, \", to #-1.\");",
            "elseif (!$object_utils:contains(x, x.owner))",
            "move(x, x.owner);",
            "x.owner:tell(\"You shouldn't leave junk in \", this.name, \"; \", x.name, \" (\", x, \") has been moved to your inventory.\");",
            "#2:tell(\">**> Cleaned up `\", x.name, \"' (\", x, \"), owned by `\", x.owner.name, \"' (\", x.owner, \"), to \", x.owner, \".\");",
            "endif",
            "endif",
            "endfor",
            "junk = {};",
            "for x in (this.contents)",
            "if ((seconds_left() < 2) || (ticks_left() < 1000))",
            "suspend(0);",
            "endif",
            "if (!is_player(x))",
            "junk = {@junk, x};",
            "endif",
            "endfor",
            "suspend(5 * 60);",
            "endwhile",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is all there is right now.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            6559,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "63": {
      "id": 63,
      "name": "Recycling Center",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        5
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "_recreate",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "\"Return a toad (child of #1, owned by $hacker) from this.contents.  Move it to #-1.  Recreate as a child of args[1], or of #1 if no args are given.  Chown to caller_perms() or args[2] if present.\";",
            "{?what = #1, ?who = caller_perms()} = args;",
            "if (!(caller_perms().wizard || (who == caller_perms())))",
            "return E_PERM;",
            "elseif (!(valid(what) && is_player(who)))",
            "return E_INVARG;",
            "elseif ((((who != what.owner) && (!what.f)) && (!who.wizard)) && (!caller_perms().wizard))",
            "return E_PERM;",
            "endif",
            "potential = next_recycled_object();",
            "if (typeof(potential) == OBJ)",
            "return this:setup_toad(potential, who, what);",
            "else",
            "return E_NONE;",
            "endif"
          ]
        },
        {
          "name": "_recycle",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "{item} = args;",
            "if (!$perm_utils:controls(caller_perms(), item))",
            "raise(E_PERM);",
            "elseif (is_player(item))",
            "raise(E_INVARG);",
            "endif",
            "this:addhist(caller_perms(), item);",
            "\"...recreate can fail (:recycle can crash)...\";",
            "this:add_orphan(item);",
            "this:kill_all_tasks(item);",
            "$quota_utils:reimburse_quota(item.owner, item);",
            "$building_utils:recreate(item, $nothing);",
            "this:remove_orphan(item);"
          ]
        },
        {
          "name": "_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "e = `set_task_perms(caller_perms()) ! ANY';",
            "if (typeof(e) == ERR)",
            "return e;",
            "else",
            "val = this:_recreate(@args);",
            "return (val == E_NONE) ? $quota_utils:bi_create(@args) | val;",
            "endif"
          ]
        },
        {
          "name": "addhist",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "if (caller == this)",
            "h = this.history;",
            "if ((len = length(h)) > this.nhist)",
            "h = h[len - this.nhist..len];",
            "endif",
            "this.history = {@h, args};",
            "endif"
          ]
        },
        {
          "name": "show*-history",
          "owner": 2,
          "perms": 45,
          "preps": -1,
          "object": 63,
          "code": [
            "if ($perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))",
            "for x in (this.history)",
            "pname = valid(x[1]) ? x[1].name | \"A recycled player\";",
            "oname = valid(x[2]) ? x[2].name | \"recycled\";",
            "player:notify(tostr(pname, \" (\", x[1], \") recycled \", x[2], \" (now \", oname, \")\"));",
            "endfor",
            "else",
            "player:tell(\"Sorry.\");",
            "endif"
          ]
        },
        {
          "name": "setup_toad",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "\"this:setup_toad(objnum,new_owner,parent)\";",
            "\"Called by :_create and :request.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{potential, who, what} = args;",
            "if (!$quota_utils:creation_permitted(who))",
            "return E_QUOTA;",
            "elseif (valid(potential))",
            "return E_INVARG;",
            "else",
            "set_task_perms({@callers(), {#-1, \"\", player}}[2][3]);",
            "\"... if :initialize crashes...\";",
            "this:add_orphan(potential);",
            "$building_utils:recreate(potential, what);",
            "$wiz_utils:set_owner(potential, who);",
            "this:remove_orphan(potential);",
            "\"... if we don't get this far, the object stays on the orphan list...\";",
            "\"... orphan list should be checked periodically...\";",
            "return potential;",
            "endif"
          ]
        },
        {
          "name": "add_orphan",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "if (caller == this)",
            "this.orphans = setadd(this.orphans, args[1]);",
            "endif"
          ]
        },
        {
          "name": "remove_orphan",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "if (caller == this)",
            "this.orphans = setremove(this.orphans, args[1]);",
            "endif"
          ]
        },
        {
          "name": "valid",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "\"Usage:  valid(object)\";",
            "\"True if object is valid.\";",
            "return valid(args[1]);"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "if (caller_perms().wizard)",
            "this.orphans = {};",
            "this.history = {};",
            "this.lost_souls = {};",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "reclaim_lost_souls",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "fork (1800)",
            "this:(verb)();",
            "endfork",
            "for x in (this.lost_souls)",
            "this.lost_souls = setremove(this.lost_souls, x);",
            "if ((valid(x) && (typeof(x.owner.owned_objects) == LIST)) && (!(x in x.owner.owned_objects)))",
            "x.owner.owned_objects = setadd(x.owner.owned_objects, x);",
            "$quota_utils:summarize_one_user(x.owner);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor"
          ]
        },
        {
          "name": "check_quota_scam",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "who = args[1];",
            "if ($quota_utils.byte_based && (is_clear_property(who, \"size_quota\") || is_clear_property(who, \"owned_objects\")))",
            "raise(E_QUOTA);",
            "endif",
            "cheater = 0;",
            "other_cheaters = {};",
            "for x in (this.lost_souls)",
            "if (((valid(x) && ((owner = x.owner) != $hacker)) && (typeof(owner.owned_objects) == LIST)) && (!(x in owner.owned_objects)))",
            "if (owner == who)",
            "who.owned_objects = setadd(who.owned_objects, x);",
            "cheater = 1;",
            "else",
            "\"it's someone else's quota scam we're detecting...\";",
            "other_cheaters = setadd(other_cheaters, owner);",
            "owner.owned_objects = setadd(owner.owned_objects, x);",
            "this.lost_souls = setremove(this.lost_souls, x);",
            "endif",
            "endif",
            "this.lost_souls = setremove(this.lost_souls, x);",
            "endfor",
            "if ($quota_utils.byte_based)",
            "if (cheater)",
            "$quota_utils:summarize_one_user(who);",
            "endif",
            "if (other_cheaters)",
            "fork (0)",
            "for x in (other_cheaters)",
            "$quota_utils:summarize_one_user(x);",
            "endfor",
            "endfork",
            "endif",
            "endif"
          ]
        },
        {
          "name": "gc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "for x in (this.orphans)",
            "if ((!valid(x)) || ((x.owner != $hacker) && (x in x.owner.owned_objects)))",
            "this.orphans = setremove(this.orphans, x);",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "moveto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "pass(#-1);"
          ]
        },
        {
          "name": "kill_all_tasks",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 63,
          "code": [
            "\"kill_all_tasks ( object being recycled )\";",
            "\" -- kill all tasks involving this now-recycled object\";",
            "((caller == this) || (caller == #0)) || raise(E_PERM);",
            "{object} = args;",
            "((typeof(object) == OBJ) || (typeof(object) == ANON)) || raise(E_INVARG);",
            "if (!valid(object))",
            "fork (0)",
            "for t in (queued_tasks())",
            "for c in (`task_stack(t[1]) ! E_INVARG => {}')",
            "if (object in c)",
            "kill_task(t[1]);",
            "continue t;",
            "endif",
            "endfor",
            "endfor",
            "endfork",
            "endif"
          ]
        }
      ],
      "propnames": [
        "orphans",
        "announce_removal_msg",
        "nhist",
        "history",
        "lost_souls"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 50,
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Recycling Center",
            "Center"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Object reuse. Call $recycler:_create() to create an object (semantics the same as create()), $recycler:_recycle() to recycle an object. Will create a new object if nothing available in its contents. Note underscores, to avoid builtin :recycle() verb called when objects are recycled. Uses $building_utils:recreate() to prepare objects.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            13313,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "64": {
      "id": 64,
      "name": "Telnet Handler",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": {
        "source": 2,
        "time": 1668941514
      },
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "if (caller_perms().wizard)",
            "\"Clear all MSSP values that don't have verbs and reset to defaults.\";",
            "default = {\"family\"};",
            "for x in (mapkeys(this.mssp_data))",
            "if ($object_utils:has_callable_verb(this, tostr(\"mssp_\", x)))",
            "this.mssp_data[x] = 1;",
            "elseif (!(x in default))",
            "this.mssp_data[x] = $nothing;",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "do_out_of_band_command doobc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "\"Process out of band data for telnet command sequences.\";",
            "\"As of right now, only 'IAC DO' command sequences are processed. You can, of course, extend this verb to support other telnet commands as needed.\";",
            "if (caller != $sysobj)",
            "raise(E_PERM);",
            "endif",
            "cmd = decode_binary(args[1], 1);",
            "\"Don't process commands that don't begin with 'IAC DO'.\";",
            "if ((length(cmd) < 3) || (cmd[1..2] != {this.commands[\"IAC\"], this.commands[\"DO\"]}))",
            "return 0;",
            "endif",
            "\".handled_commands maps telnet options to MOO verbs. e.g. '70' is the MSSP option, which maps to the 'do_mssp' verb.\";",
            "if (cmd[3] in mapkeys(this.handled_commands))",
            "return this:(this.handled_commands[cmd[3]])(cmd[3..$]);",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "do_mssp",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "\":do_mssp(LIST <telnet commands>) => INT <successfully handled>\";",
            "\"Implements the MUD Server Status Protocol via telnet.\";",
            "\"'player' is sent binary data and this verb returns 1 if successful, 0 if not.\";",
            "\"See 'HELP MSSP' for details on how to populate MSSP variables.\";",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "{telnet_commands} = args;",
            "MSSP_VAR = this.commands[\"MSSP_VAR\"];",
            "MSSP_VAL = this.commands[\"MSSP_VAL\"];",
            "mssp = {this.commands[\"IAC\"], this.commands[\"SB\"], this.commands[\"MSSP\"]};",
            "mssp_data = this:_mssp_data();",
            "for value, key in (mssp_data)",
            "mssp = {@mssp, MSSP_VAR, key, MSSP_VAL, value};",
            "endfor",
            "mssp = {@mssp, this.commands[\"IAC\"], this.commands[\"SE\"]};",
            "return this:send(player, mssp);"
          ]
        },
        {
          "name": "send",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "\":send(OBJ <player>, LIST <telnet commands>) => INT <success>\";",
            "\"Send binary encoded <telnet commands> to <player>.\";",
            "{who, commands} = args;",
            "if (!(caller in {$sysobj, this}))",
            "raise(E_PERM);",
            "elseif (!(who in connected_players(1)))",
            "return E_INVARG;",
            "elseif (typeof(commands) != LIST)",
            "return E_INVARG;",
            "else",
            "try",
            "set_connection_option(who, \"binary\", 1);",
            "notify(who, encode_binary(commands));",
            "finally",
            "set_connection_option(who, \"binary\", 0);",
            "endtry",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "mssp_name",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "return $network.moo_name;"
          ]
        },
        {
          "name": "mssp_codebase",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "return \"LambdaMOO-ToastStunt \" + server_version();"
          ]
        },
        {
          "name": "mssp_players",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "return length(connected_players());"
          ]
        },
        {
          "name": "new_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "\"Called by $sysobj:do_login_command().\";",
            "if (caller != $sysobj)",
            "raise(E_PERM);",
            "endif",
            "{who} = args;",
            "if (this.mssp_active)",
            "\"Notify the connection that MSSP is supported.\";",
            "this:send(who, {this.commands[\"IAC\"], this.commands[\"WILL\"], this.commands[\"MSSP\"]});",
            "endif"
          ]
        },
        {
          "name": "_mssp_data",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "\":_mssp_data() => MAP <mssp data>\";",
            "\"Return a map of the MSSP data that we actually have available.\";",
            "mssp = [];",
            "for value, key in (this.mssp_data)",
            "if (value == $nothing)",
            "continue;",
            "elseif (value == 1)",
            "mssp_verb = tostr(\"mssp_\", key);",
            "if ($object_utils:has_callable_verb(this, mssp_verb))",
            "value = `this:(mssp_verb)() ! ANY => $nothing';",
            "if (value == $nothing)",
            "continue;",
            "endif",
            "endif",
            "endif",
            "mssp[key] = toliteral(value);",
            "endfor",
            "return mssp;"
          ]
        },
        {
          "name": "mssp_uptime",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "return $server[\"last_restart_time\"];"
          ]
        },
        {
          "name": "mssp_contact",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "if ($network.postmaster != \"postmastername@yourhost\")",
            "return $network.postmaster;",
            "else",
            "return $nothing;",
            "endif"
          ]
        },
        {
          "name": "mssp_hostname",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 64,
          "code": [
            "if ($network.site != \"yoursite\")",
            "return $network.site;",
            "else",
            "return $nothing;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "commands",
        "handled_commands",
        "mssp_data",
        "mssp_active"
      ],
      "propdefs": [
        {
          "value": {
            "DO": 253,
            "DONT": 254,
            "GMCP": 201,
            "IAC": 255,
            "MCCP": 86,
            "MSDP": 69,
            "MSSP": 70,
            "MSSP_VAL": 2,
            "MSSP_VAR": 1,
            "SB": 250,
            "SE": 240,
            "TTYPE": 24,
            "WILL": 251,
            "WONT": 252
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "70": "do_mssp"
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": {
            "codebase": 1,
            "contact": 1,
            "family": "MOO",
            "hostname": 1,
            "name": 1,
            "players": 1,
            "uptime": 1
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Telnet Handler",
            "Handler"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            11542,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "65": {
      "id": 65,
      "name": "Mail Options",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "actual",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (i = args[1] in {\"noinclude\", \"sender\"})",
            "return {{{\"include\", \"all\"}[i], !args[2]}};",
            "else",
            "return {args};",
            "endif"
          ]
        },
        {
          "name": "parse_@mail",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "\"... we'll take anything...\";",
            "raw = args[2];",
            "if (raw == 1)",
            "\"...+@mail => @mailo=new\";",
            "return {args[1], \"new\"};",
            "else",
            "return args[1..2];",
            "endif"
          ]
        },
        {
          "name": "parse_sticky parse_manymsgs",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) == LIST)",
            "if (length(raw) > 1)",
            "return \"Too many arguments.\";",
            "endif",
            "raw = raw[1];",
            "elseif (typeof(raw) == INT)",
            "return {oname, raw && ((oname == \"manymsgs\") ? 20 | 1)};",
            "endif",
            "if ((value = $code_utils:toint(raw)) == E_TYPE)",
            "return tostr(\"`\", raw, \"'?  Number expected.\");",
            "endif",
            "return {oname, value};"
          ]
        },
        {
          "name": "parse_replyto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) == STR)",
            "raw = $string_utils:explode(raw, \",\");",
            "elseif (typeof(raw) == INT)",
            "return raw ? \"You need to give one or more recipients.\" | {oname, 0};",
            "endif",
            "value = $mail_editor:parse_recipients({}, raw);",
            "if (value)",
            "return {oname, value};",
            "else",
            "return \"No valid recipients in list.\";",
            "endif"
          ]
        },
        {
          "name": "show_manymsgs",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "value = this:get(@args);",
            "if (value)",
            "return {tostr(value), {tostr(\"Query when asking for \", value, \" or more messages.\")}};",
            "else",
            "return {0, {\"Willing to be spammed with arbitrarily many messages/headers\"}};",
            "endif"
          ]
        },
        {
          "name": "show_sticky",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "value = this:get(@args);",
            "if (value)",
            "return {value, {\"Sticky folders:  mail commands default to whatever\", \"mail collection the previous successful command looked at.\"}};",
            "else",
            "return {0, {\"Teflon folders:  mail commands always default to `on me'.\"}};",
            "endif"
          ]
        },
        {
          "name": "show_@mail",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (value = this:get(@args))",
            "return {\"\", {tostr(\"Default message sequence for @mail:  \", (typeof(value) == STR) ? value | $string_utils:from_list(value, \" \"))}};",
            "else",
            "default = $mail_agent.(\"player_default_@mail\");",
            "return {0, {tostr(\"Default message sequence for @mail:  \", (typeof(default) == STR) ? default | $string_utils:from_list(default, \" \"))}};",
            "endif"
          ]
        },
        {
          "name": "show_replyto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (value = this:get(@args))",
            "return {\"\", {tostr(\"Default Reply-to:  \", $mail_agent:name_list(@value))}};",
            "else",
            "return {0, {\"No default Reply-to: field\"}};",
            "endif"
          ]
        },
        {
          "name": "show",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (o = (name = args[2]) in {\"sender\", \"noinclude\"})",
            "args[2] = {\"all\", \"include\"}[o];",
            "return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "check_replyto",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "\"... must be object, list of objects, or false...\";",
            "value = args[1];",
            "if (typeof(value) == OBJ)",
            "return {{value}};",
            "elseif (!this:istype(value, {{OBJ}}))",
            "return $string_utils:capitalize(\"Object or list of objects expected.\");",
            "else",
            "return {value};",
            "endif"
          ]
        },
        {
          "name": "show_netmail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (value = this:get(@args))",
            "return {value, {\"Have MOO-mail automatically forwarded to me at\", \"my registered email-address.\"}};",
            "else",
            "return {value, {\"Receive MOO-mail here on the MOO.\"}};",
            "endif",
            "\"Last modified Tue Jun  1 02:10:08 1993 EDT by Edison@OpalMOO (#200).\";"
          ]
        },
        {
          "name": "check_netmail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "\":check_netmail(value) => Makes sure the email-address is one that can actually be used by $network:sendmail().\";",
            "\"The actual value sent is not checked since it can only be a boolean flag.  The player's email_address property is what is checked.\";",
            "\"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.\";",
            "\"Returns a string error message if unusable or {value} otherwise.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "if (args[1] && (reason = $network:email_will_fail($wiz_utils:get_email_address(player))))",
            "return tostr(\"Invalid registered email_address: \", reason);",
            "endif",
            "return args;"
          ]
        },
        {
          "name": "show_expire",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "value = this:get(args[1], \"expire\");",
            "if (value < 0)",
            "return {1, {\"Messages will not expire.\"}};",
            "else",
            "return {value, {tostr(\"Unkept messages expire in \", $time_utils:english_time(value || $mail_agent.player_expire_time), value ? \"\" | \" (default)\")}};",
            "endif"
          ]
        },
        {
          "name": "parse_expire",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "{oname, value, data} = args;",
            "if ((typeof(value) == STR) && index(value, \" \"))",
            "value = $string_utils:explode(value, \" \");",
            "if (!value)",
            "return {oname, 0};",
            "endif",
            "endif",
            "if (value == 1)",
            "return {oname, -1};",
            "elseif (typeof(value) == LIST)",
            "if (length(value) > 1)",
            "nval = $time_utils:parse_english_time_interval(@value);",
            "if (typeof(nval) == ERR)",
            "return \"Time interval should be of a form like \\\"30 days, 10 hours and 43 minutes\\\".\";",
            "else",
            "return {oname, nval};",
            "endif",
            "endif",
            "value = value[1];",
            "endif",
            "if ((nval = $code_utils:toint(value)) || (nval == 0))",
            "return {oname, (nval < 0) ? -1 | nval};",
            "elseif (value == \"Never\")",
            "return {oname, -1};",
            "else",
            "return \"Number, time interval (e.g., \\\"30 days\\\"), or \\\"Never\\\" expected\";",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 65,
          "code": [
            "if (caller_perms().wizard)",
            "for x in ({\"fast_check\", \"idle_check\", \"idle_threshold\"})",
            "this:remove_name(x);",
            "for y in ({\"show\", \"check\", \"parse\"})",
            "delete_verb(this, (y + \"_\") + x);",
            "delete_property(this, (y + \"_\") + x);",
            "endfor",
            "endfor",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "check_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if ((what = args[1]) in {\"new\", \"contents\", \"all\"})",
            "return {what};",
            "else",
            "return \"Error: `news' option must be one of `new' or `contents' or `all'\";",
            "endif"
          ]
        },
        {
          "name": "parse_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (typeof(args[2]) == INT)",
            "return tostr(strsub(verb, \"parse_\", \"\"), \" is not a boolean option.\");",
            "else",
            "return {args[1], (typeof(args[2]) == STR) ? args[2] | $string_utils:from_list(args[2], \" \")};",
            "endif"
          ]
        },
        {
          "name": "show_news",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if ((value = this:get(@args)) == \"all\")",
            "return {value, {\"the `news' command will show all news\"}};",
            "elseif (value == \"contents\")",
            "return {value, {\"the `news' command will show the titles of all articles\"}};",
            "elseif (value == \"new\")",
            "return {value, {\"the `news' command will show only new news\"}};",
            "else",
            "return {0, {\"the `news' command will show all news\"}};",
            "endif"
          ]
        },
        {
          "name": "parse_@unsend",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "{name, value, bleh} = args;",
            "if (typeof(value) == INT)",
            "return tostr(name, \" is not a boolean option.\");",
            "elseif (typeof(value) == STR)",
            "value = {value};",
            "endif",
            "ok = this.unsend_sequences;",
            "for x in (value)",
            "if ((!(pos = index(x, \":\"))) || (!(x[1..pos - 1] in ok)))",
            "return tostr(\"Invalid sequence - \", x);",
            "elseif (pos != rindex(x, \":\"))",
            "return tostr(\"As a preventative measure, you may not use more than one : in a sequence. The following sequence is therefore invalid - \", x);",
            "endif",
            "endfor",
            "return {name, value};"
          ]
        },
        {
          "name": "show_@unsend",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 65,
          "code": [
            "if (value = this:get(@args))",
            "return {\"\", {tostr(\"Default message sequence for @unsend:  \", (typeof(value) == STR) ? value | $string_utils:from_list(value, \" \"))}};",
            "else",
            "default = $mail_agent.(\"player_default_@unsend\");",
            "return {0, {tostr(\"Default message sequence for @unsend:  \", (typeof(default) == STR) ? default | $string_utils:from_list(default, \" \"))}};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "show_include",
        "show_all",
        "show_nosubject",
        "show_expert",
        "show_enter",
        "type_manymsgs",
        "type_@mail",
        "type_replyto",
        "type_expire",
        "show_followup",
        "show_resend_forw",
        "choices_rn_order",
        "show_no_auto_forward",
        "show_expert_netfwd",
        "show_no_dupcc",
        "show_no_unsend",
        "type_@unsend",
        "unsend_sequences"
      ],
      "propdefs": [
        {
          "value": [
            "Original message will not be included in replies",
            "Original message will be included in replies"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Replies will go to original sender only.",
            "Replies will go to original sender and all previous recipients."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Mail editor will initially require a subject line.",
            "Mail editor will not initially require a subject line."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Novice mail user...",
            "Expert mail user..."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Mail editor will not start with an implicit `enter' command.",
            "Mail editor will start with an implicit `enter' command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            0
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            2,
            [
              2
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            1,
            [
              1
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            0
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "No special reply action for messages with non-player recipients.",
            "Replies go only to first non-player recipient if any."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@resend puts player in Resent-By: header",
            "@resend puts player in From: header (like @forward)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            [
              "read",
              [
                ".current_message folders are sorted by last read date."
              ]
            ],
            [
              "send",
              [
                ".current_message folders are sorted by last send date."
              ]
            ],
            [
              "fixed",
              [
                ".current_message folders are not sorted."
              ]
            ]
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@netforward when expiring messages",
            "do not @netforward messages when expiring mail"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@netforward confirms before emailing messages",
            "@netforward doesn't confirm before emailing messages"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "i want to read mail to me also sent to lists i read",
            "don't send me personal copies of mail also sent to lists i read"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "People may @unsend unread messages they send to me",
            "No one may @unsend messages they sent to me"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            2,
            [
              2
            ]
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "before",
            "after",
            "since",
            "until",
            "subject",
            "body",
            "last"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "include",
            "all",
            "followup",
            "nosubject",
            "expert",
            "enter",
            "sticky",
            "@mail",
            "manymsgs",
            "replyto",
            "netmail",
            "expire",
            "resend_forw",
            "rn_order",
            "no_auto_forward",
            "expert_netfwd",
            "news",
            "no_dupcc",
            "no_unsend",
            "@unsend"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!include!noinclude!all!sender!nosubject!expert!enter!sticky!@mail!manymsgs!replyto!netmail!expire!followup!resend_forw!rn_order!no_auto_forward!expert_netfwd!news!no_dupcc!no_unsend!@unsend!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "noinclude",
            "sender"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Mail Options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Options for mailing",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            21303,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "66": {
      "id": 66,
      "name": "Edit Options",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "actual",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 66,
          "code": [
            "if (i = args[1] in {\"parens\", \"noisy_insert\"})",
            "return {{{\"no_parens\", \"quiet_insert\"}[i], !args[2]}};",
            "else",
            "return {args};",
            "endif"
          ]
        },
        {
          "name": "show",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 66,
          "code": [
            "if (o = (name = args[2]) in {\"parens\", \"noisy_insert\"})",
            "args[2] = {\"no_parens\", \"quiet_insert\"}[o];",
            "return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};",
            "else",
            "return pass(@args);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "show_quiet_insert",
        "show_eval_subs",
        "show_local",
        "show_no_parens"
      ],
      "propdefs": [
        {
          "value": [
            "Report line numbers on insert or append.",
            "No echo on insert or append."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Ignore .eval_subs when compiling verbs.",
            "Use .eval_subs when compiling verbs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Use in-MOO text editors.",
            "Ship text to client for local editing."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "include all parentheses when fetching verbs.",
            "includes only necessary parentheses when fetching verbs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "quiet_insert",
            "eval_subs",
            "local",
            "no_parens"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!quiet_insert!eval_subs!local!no_parens!parens!noisy_insert!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "parens",
            "noisy_insert"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Edit Options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            2904,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "67": {
      "id": 67,
      "name": "Display Options",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "show_blank_tnt",
        "show_shortprep",
        "show_thisonly"
      ],
      "propdefs": [
        {
          "value": [
            "Treat `this none this' verbs like the others.",
            "Blank out the args on `this none this' verbs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Display prepositions in full.",
            "Use short forms of prepositions."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "./: will show ancestor properties/verbs if none on this.",
            "./: will not show ancestor properties/verbs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "blank_tnt",
            "shortprep",
            "thisonly"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!blank_tnt!shortprep!thisonly!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Display Options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            1273,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "68": {
      "id": 68,
      "name": "Generic Option Package",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        65,
        66,
        67,
        77,
        76,
        102
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "get",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":get(options,name) => returns the value of the option specified by name\";",
            "\"i.e., if {name,value} is present in options, return value\";",
            "\"      if name is present, return 1\";",
            "\"      otherwise return 0\";",
            "{options, name} = args;",
            "if (name in options)",
            "return 1;",
            "elseif (a = $list_utils:assoc(name, options))",
            "return a[2];",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "set",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":set(optionlist,oname,value) => revised optionlist or string error message.\";",
            "\"oname must be the full name of an option in .names or .extras.\";",
            "\"Note that values must not be of type ERR.  \";",
            "\"FALSE (0, blank string, or empty list) is always a legal value.\";",
            "\"If a verb :check_foo is defined on this, it will be used to typecheck any\";",
            "\"non-false or object-type value supplied as a new value for option `foo'.\";",
            "\"\";",
            "\"   :check_foo(value) => string error message or {value to use}\";",
            "\"\";",
            "\"If instead there is a property .check_foo, that will give either the expected \";",
            "\"type or a list of allowed types.\";",
            "\"Otherwise, the option is taken to be a boolean flag and all non-false, \";",
            "\"non-object values map to 1.\";",
            "\"\";",
            "{options, oname, value} = args;",
            "if (!((oname in this.names) || (oname in this.extras)))",
            "return \"Unknown option:  \" + oname;",
            "elseif (typeof(value) == ERR)",
            "\"... no option should have an error value...\";",
            "return \"Error value\";",
            "elseif ((!value) && (typeof(value) != OBJ))",
            "\"... always accept FALSE (0, blankstring, emptylist)...\";",
            "elseif ($object_utils:has_callable_verb(this, check = \"check_\" + oname))",
            "\"... a :check_foo verb exists; use it to typecheck the value...\";",
            "if (typeof(c = this:(check)(value)) == STR)",
            "return c;",
            "endif",
            "value = c[1];",
            "elseif ($object_utils:has_property(this, tprop = \"type_\" + oname))",
            "\"... a .type_foo property exists...\";",
            "\"... property value should be a type or list of types...\";",
            "if (!this:istype(value, t = this.(tprop)))",
            "return $string_utils:capitalize(this:desc_type(t) + \" value expected.\");",
            "endif",
            "elseif ($object_utils:has_property(this, cprop = \"choices_\" + oname))",
            "\"... a .choices_foo property exists...\";",
            "\"... property value should be a list of {value,docstring} pairs...\";",
            "if (!$list_utils:assoc(value, c = this.(cprop)))",
            "return tostr(\"Allowed values: \", $string_utils:english_list($list_utils:slice(c, 1), \"(??)\", \" or \"));",
            "endif",
            "else",
            "\"... value is considered to be boolean...\";",
            "if (!value)",
            "\"... must be an object.  oops.\";",
            "return tostr(\"Non-object value expected.\");",
            "endif",
            "value = 1;",
            "endif",
            "\"... We now have oname and a value.  However, if oname is one of the extras,\";",
            "\"... then we need to call :actual to see what it really means.\";",
            "if (oname in this.names)",
            "nvlist = {{oname, value}};",
            "elseif ((typeof(nvlist = this:actual(oname, value)) != LIST) || (!nvlist))",
            "return nvlist || \"Not implemented.\";",
            "endif",
            "\"... :actual returns a list of pairs...\";",
            "for nv in (nvlist)",
            "{oname, value} = nv;",
            "if (i = (oname in options) || $list_utils:iassoc(oname, options))",
            "if ((!value) && (typeof(value) != OBJ))",
            "\"value == 0, blank string, empty list\";",
            "options[i..i] = {};",
            "elseif (value == 1)",
            "options[i] = oname;",
            "else",
            "options[i] = {oname, value};",
            "endif",
            "elseif (value || (typeof(value) == OBJ))",
            "options[1..0] = {(value == 1) ? oname | {oname, value}};",
            "endif",
            "endfor",
            "return options;"
          ]
        },
        {
          "name": "parse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":parse(args[,...]) => {oname [,value]} or string error message\";",
            "\"additional arguments are fed straight through to :parse_* routines.\";",
            "\" <option> <value>     => {option, value}\";",
            "\" <option>=<value>     => {option, value}\";",
            "\" <option> is <value>  => {option, value}\";",
            "\" +<option>            => {option, 1}\";",
            "\" -<option>            => {option, 0}\";",
            "\" !<option>            => {option, 0}\";",
            "\" <option>             => {option}\";",
            "if (!(words = args[1]))",
            "return \"\";",
            "endif",
            "option = words[1];",
            "words[1..1] = {};",
            "if (flag = option && index(\"-+!\", option[1]))",
            "option[1..1] = \"\";",
            "endif",
            "if (i = index(option, \"=\"))",
            "rawval = option[i + 1..$];",
            "option = option[1..i - 1];",
            "if (i == 1)",
            "\"... =bar ...\";",
            "return \"Blank option name?\";",
            "elseif (flag)",
            "\"... +foo=bar\";",
            "return \"Don't give a value if you use +, -, or !\";",
            "elseif (words)",
            "\"... foo=bar junk\";",
            "return $string_utils:from_list(words, \" \") + \"??\";",
            "endif",
            "elseif (!option)",
            "return \"Blank option name?\";",
            "elseif (flag)",
            "if (words)",
            "\"... +foo junk\";",
            "return \"Don't give a value if you use +, -, or !\";",
            "endif",
            "rawval = (flag - 1) % 2;",
            "else",
            "words && ((words[1] == \"is\") && (words[1..1] = {}));",
            "rawval = words;",
            "endif",
            "\"... do we know about this option?...\";",
            "if (!(oname = this:_name(strsub(option, \"-\", \"_\"))))",
            "return tostr((oname == $failed_match) ? \"Unknown\" | \"Ambiguous\", \" option:  \", option);",
            "endif",
            "\"... determine new value...\";",
            "if (!rawval)",
            "\"... `@option foo is' or `@option foo=' ...\";",
            "return (rawval == {}) ? {oname} | {oname, 0};",
            "elseif ($object_utils:has_callable_verb(this, pverb = \"parse_\" + oname))",
            "return this:(pverb)(oname, rawval, args[2..$]);",
            "elseif ($object_utils:has_property(this, cprop = \"choices_\" + oname))",
            "return this:parsechoice(oname, rawval, this.(cprop));",
            "elseif (rawval in {0, \"0\", {\"0\"}})",
            "return {oname, 0};",
            "elseif (rawval in {1, \"1\", {\"1\"}})",
            "return {oname, 1};",
            "else",
            "return tostr(\"Option is a flag, use `+\", option, \"' or `-\", option, \"' (or `!\", option, \"')\");",
            "endif"
          ]
        },
        {
          "name": "_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":_name(string) => full option name corresponding to string \";",
            "\"               => $failed_match or $ambiguous_match as appropriate.\";",
            "if (((string = args[1]) in this.names) || (string in this.extras))",
            "return string;",
            "endif",
            "char = (namestr = this._namelist)[1];",
            "if (!(i = index(namestr, char + string)))",
            "return $failed_match;",
            "elseif (i != rindex(namestr, char + string))",
            "return $ambiguous_match;",
            "else",
            "j = index(namestr[i + 1..$], char);",
            "return namestr[i + 1..(i + j) - 1];",
            "endif"
          ]
        },
        {
          "name": "add_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":add_name(name[,isextra]) adds name to the list of options recognized.\";",
            "\"name must be a nonempty string and must not contain spaces, -, +, !, or =.\";",
            "\"isextra true means that name isn't an actual option (recognized by :get) but merely a name that the option setting command should recognize to set a particular combination of options.  Actual options go in .names; others go in .extras\";",
            "{name, ?isextra = 0} = args;",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "elseif ((!name) || match(name, \"[-!+= ]\"))",
            "\"...name is blank or contains a forbidden character\";",
            "return E_INVARG;",
            "elseif (name in this.names)",
            "\"...name is already in option list\";",
            "if (isextra)",
            "this.names = setremove(this.names, name);",
            "this.extras = setadd(this.extras, name);",
            "return 1;",
            "else",
            "return 0;",
            "endif",
            "elseif (name in this.extras)",
            "if (isextra)",
            "return 0;",
            "else",
            "this.names = setadd(this.names, name);",
            "this.extras = setremove(this.extras, name);",
            "return 1;",
            "endif",
            "else",
            "char = this._namelist[1];",
            "if (isextra)",
            "this.extras = setadd(this.extras, name);",
            "else",
            "this.names = setadd(this.names, name);",
            "endif",
            "if (!index(this._namelist, (char + name) + char))",
            "this._namelist = tostr(this._namelist, name, char);",
            "endif",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "remove_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":remove_name(name) removes name from the list of options recognized.\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "elseif (!(((name = args[1]) in this.names) || (name in this.extras)))",
            "\"...hmm... already gone...\";",
            "return 0;",
            "else",
            "char = this._namelist[1];",
            "this._namelist = strsub(this._namelist, (char + name) + char, char);",
            "this.names = setremove(this.names, name);",
            "this.extras = setremove(this.extras, name);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "show",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":show(options,name or list of names)\";",
            "\" => text describing current value of option and what it means\";",
            "name = args[2];",
            "if (typeof(name) == LIST)",
            "text = {};",
            "for n in (name)",
            "text = {@text, @this:show(@listset(args, n, 2))};",
            "endfor",
            "return text;",
            "elseif (!((name in this.names) || (name in this.extras)))",
            "return {\"Unknown option:  \" + name};",
            "elseif ($object_utils:has_callable_verb(this, sverb = \"show_\" + name))",
            "r = this:(sverb)(@args);",
            "value = r[1];",
            "desc = r[2];",
            "elseif ($object_utils:has_property(this, sverb) && ((value = this:get(args[1], name)) in {0, 1}))",
            "desc = this.(sverb)[value + 1];",
            "if (typeof(desc) == STR)",
            "desc = {desc};",
            "endif",
            "elseif ($object_utils:has_property(this, cprop = \"choices_\" + name))",
            "if (!(value = this:get(args[1], name)))",
            "desc = this.(cprop)[1][2];",
            "elseif (!(a = $list_utils:assoc(value, this.(cprop))))",
            "return {(name + \" has unexpected value \") + toliteral(value)};",
            "else",
            "desc = a[2];",
            "endif",
            "elseif (name in this.extras)",
            "return {name + \" not documented (complain)\"};",
            "else",
            "value = this:get(args[1], name);",
            "desc = {\"not documented (complain)\"};",
            "if (typeof(value) in {LIST, STR})",
            "desc[1..0] = toliteral(value);",
            "value = \"\";",
            "endif",
            "endif",
            "if (value in {0, 1})",
            "which = \"-+\"[value + 1] + name;",
            "elseif ((typeof(value) in {OBJ, STR, INT}) && (value != \"\"))",
            "which = tostr(\" \", name, \"=\", value);",
            "else",
            "which = \" \" + name;",
            "endif",
            "show = {$string_utils:left(which + \"  \", this.namewidth) + desc[1]};",
            "for i in [2..length(desc)]",
            "show = {@show, $string_utils:space(this.namewidth) + desc[i]};",
            "endfor",
            "return show;"
          ]
        },
        {
          "name": "actual",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":actual(<name>,<value>) => list of {<name>,<value>} pairs or string errormsg\";",
            "\" corresponding to what setting option <name> to <value> actually means\";",
            "\" e.g., :actual(\\\"unfoo\\\",1) => {{\\\"foo\\\",0}}\";",
            "\" e.g., :actual(\\\"g7mode\\\",1) => {{\\\"splat\\\",37},{\\\"baz\\\",#3}}\";",
            "return \"Not implemented.\";"
          ]
        },
        {
          "name": "istype",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":istype(value,types) => whether value is one of the given types\";",
            "if ((vtype = typeof(value = args[1])) in (types = args[2]))",
            "return 1;",
            "elseif (vtype != LIST)",
            "return 0;",
            "else",
            "for t in (types)",
            "if ((typeof(t) == LIST) && this:islistof(value, t))",
            "return 1;",
            "endif",
            "endfor",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "islistof",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":islistof(value,types) => whether value (a list) has each element being one of the given types\";",
            "types = args[2];",
            "for v in (value = args[1])",
            "if (!this:istype(v, types))",
            "return 0;",
            "endif",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "desc_type",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":desc_type(types) => string description of types\";",
            "nlist = {};",
            "for t in (types = args[1])",
            "if (typeof(t) == LIST)",
            "if (length(t) > 1)",
            "nlist = {@nlist, tostr(\"(\", this:desc_type(t), \")-list\")};",
            "else",
            "nlist = {@nlist, tostr(this:desc_type(t), \"-list\")};",
            "endif",
            "elseif (t in {INT, OBJ, STR, LIST})",
            "nlist = {@nlist, {\"number\", \"object\", \"string\", \"?\", \"list\"}[t + 1]};",
            "else",
            "return \"Bad type list\";",
            "endif",
            "endfor",
            "return $string_utils:english_list(nlist, \"nothing\", \" or \");"
          ]
        },
        {
          "name": "parsechoice",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 68,
          "code": [
            "\":parsechoice(oname,rawval,assoclist)\";",
            "which = {};",
            "oname = args[1];",
            "rawval = args[2];",
            "choices = $list_utils:slice(args[3], 1);",
            "errmsg = tostr(\"Allowed values for this flag: \", $string_utils:english_list(choices, \"(??)\", \" or \"));",
            "if (typeof(rawval) == LIST)",
            "if (length(rawval) > 1)",
            "return errmsg;",
            "endif",
            "rawval = rawval[1];",
            "elseif (typeof(rawval) != STR)",
            "return errmsg;",
            "endif",
            "for c in (choices)",
            "if (index(c, rawval) == 1)",
            "which = {@which, c};",
            "endif",
            "endfor",
            "if (!which)",
            "return errmsg;",
            "elseif (length(which) > 1)",
            "return tostr(rawval, \" is ambiguous.\");",
            "else",
            "return {oname, which[1]};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "names",
        "_namelist",
        "extras",
        "namewidth"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Option Package"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "an option package in need of a description.  See `help $generic_option'...",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            17483,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "69": {
      "id": 69,
      "name": "Error Generator",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "raise",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "raise(@args);",
            "\"this:(this.names[toint(args[1]) + 1])()\";"
          ]
        },
        {
          "name": "E_NONE",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"... hmmm... don't know how to raise E_NONE...\";",
            "return E_NONE;"
          ]
        },
        {
          "name": "E_TYPE",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_TYPE ...\";",
            "1[2];"
          ]
        },
        {
          "name": "E_DIV",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_DIV ...\";",
            "1 / 0;"
          ]
        },
        {
          "name": "E_PERM",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_PERM ...\";",
            "this.owner.password;"
          ]
        },
        {
          "name": "E_PROPNF",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_PROPNF ...\";",
            "this.a;"
          ]
        },
        {
          "name": "E_VERBNF",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_VERBNF ...\";",
            "this:a();"
          ]
        },
        {
          "name": "E_VARNF",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_VARNF ...\";",
            "a;"
          ]
        },
        {
          "name": "E_INVIND",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_INVIND ...\";",
            "#-1.a;"
          ]
        },
        {
          "name": "E_RECMOVE",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "move(this, this);"
          ]
        },
        {
          "name": "E_MAXREC",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_MAXREC ...\";",
            "this:(verb)();"
          ]
        },
        {
          "name": "E_RANGE",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_RANGE ...\";",
            "{}[1];"
          ]
        },
        {
          "name": "E_ARGS",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_ARGS ...\";",
            "toint();"
          ]
        },
        {
          "name": "E_NACC",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_NACC ...\";",
            "move($hacker, this);"
          ]
        },
        {
          "name": "E_INVARG",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"...raise E_INVARG ...\";",
            "parent(#-1);"
          ]
        },
        {
          "name": "E_QUOTA",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "set_task_perms($no_one);",
            "\"...raise E_QUOTA ...\";",
            "create($thing);"
          ]
        },
        {
          "name": "accept",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "return 0;"
          ]
        },
        {
          "name": "name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "return toliteral(args[1]);",
            "\"return this.names[toint(args[1]) + 1];\";"
          ]
        },
        {
          "name": "toerr",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"toerr -- given a string or a number, return the corresponding ERR.\";",
            "\"If not found or an execution error, return -1.\";",
            "if (typeof(string = args[1]) == STR)",
            "for e in (this.all_errors)",
            "if (tostr(e) == string)",
            "return e;",
            "endif",
            "endfor",
            "elseif (typeof(number = args[1]) == INT)",
            "for e in (this.all_errors)",
            "if (toint(e) == number)",
            "return e;",
            "endif",
            "endfor",
            "endif",
            "return -1;"
          ]
        },
        {
          "name": "match_error",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 69,
          "code": [
            "\"match_error -- searches for tostr(E_WHATEVER) in a string, returning the ERR, returns -1 if no error string is found.\";",
            "string = args[1];",
            "for e in (this.all_errors)",
            "if (index(string, tostr(e)))",
            "return e;",
            "endif",
            "endfor",
            "return -1;"
          ]
        }
      ],
      "propnames": [
        "names",
        "all_errors"
      ],
      "propdefs": [
        {
          "value": [
            "E_NONE",
            "E_TYPE",
            "E_DIV",
            "E_PERM",
            "E_PROPNF",
            "E_VERBNF",
            "E_VARNF",
            "E_INVIND",
            "E_RECMOVE",
            "E_MAXREC",
            "E_RANGE",
            "E_ARGS",
            "E_NACC",
            "E_INVARG",
            "E_QUOTA",
            "E_FLOAT"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Error Generator"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Object to automatically generate errors.",
            "",
            "raise(error) actually raises the error."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            12480,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "70": {
      "id": 70,
      "name": "Site-Locks",
      "flags": 0,
      "owner": 2,
      "location": 46,
      "parents": [
        45
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 70,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.mail_notify = {player};",
            "player:set_current_message(this, 0, 0, 1);",
            "this.moderated = 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "%n (%#) can't send to moderated list %t (%[#t]) directly.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 2592000,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Site-Locks"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "Notes on annoying sites.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            1864,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "71": {
      "id": 71,
      "name": "housekeeper",
      "flags": 19,
      "owner": 71,
      "location": -1,
      "parents": [
        58
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "look_self",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "player:tell_lines(this:description());",
            "player:tell($string_utils:pronoun_sub(\"%S %<is> moving around from room to room, cleaning up.\", this));"
          ]
        },
        {
          "name": "cleanup",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"$housekeeper:cleanup([insist]) => clean up player's objects. Argument is 'up' or 'up!' for manually requested cleanups (notify player differently)\";",
            "if (caller_perms() != this)",
            "return E_PERM;",
            "endif",
            "for object in (this.clean)",
            "x = object in this.clean;",
            "if (this.requestors[x] == player)",
            "if (result = this:replace(object, @args))",
            "player:tell(result, \".\");",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "player:tell(\"The housekeeper has finished cleaning up your objects.\");"
          ]
        },
        {
          "name": "replace",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"replace the object given to its proper spot (if there is one).\";",
            "{object, ?insist = 0} = args;",
            "i = object in this.clean;",
            "if (!i)",
            "return tostr(object, \" is not on the \", this.name, \"'s cleanup list\");",
            "endif",
            "place = this.destination[i];",
            "if (!((($recycler:valid(object) && ($recycler:valid(r = this.requestors[i]) && is_player(r))) && ($recycler:valid(place) || (place == #-1))) && (!(object.location in this.recycle_bins))))",
            "\"object no longer valid (recycled or something), remove it.\";",
            "this.clean = listdelete(this.clean, i);",
            "this.requestors = listdelete(this.requestors, i);",
            "this.destination = listdelete(this.destination, i);",
            "return tostr(object) + \" is no longer valid, removed from cleaning list\";",
            "endif",
            "oldloc = loc = object.location;",
            "if (object.location == place)",
            "\"already in its place\";",
            "return \"\";",
            "endif",
            "requestor = $recycler:valid(tr = this.requestors[i]) ? tr | $no_one;",
            "if (insist != \"up!\")",
            "if ($code_utils:verb_or_property(object, \"in_use\"))",
            "return (\"Not returning \" + object.name) + \" because it claims to be in use\";",
            "endif",
            "for thing in (object.contents)",
            "if (thing:is_listening())",
            "return (((\"Not returning \" + object.name) + \" because \") + thing.name) + \" is inside\";",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (valid(loc) && (loc != $limbo))",
            "if (loc:is_listening())",
            "return (((\"Not returning \" + object.name) + \" because \") + loc.name) + \" is holding it\";",
            "endif",
            "for y in (loc:contents())",
            "if ((y != object) && y:is_listening())",
            "return ((((\"Not returning \" + object.name) + \" because \") + y.name) + \" is in \") + loc.name;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "endif",
            "if (valid(place) && (!place:acceptable(object)))",
            "return (place.name + \" won't accept \") + object.name;",
            "endif",
            "try",
            "requestor:tell(\"As you requested, the housekeeper tidies \", $string_utils:nn(object), \" from \", $string_utils:nn(loc), \" to \", $string_utils:nn(place), \".\");",
            "if ($object_utils:has_verb(loc, \"announce_all_but\"))",
            "loc:announce_all_but({requestor, object}, \"At \", requestor.name, \"'s request, the \", this.name, \" sneaks in, picks up \", object.name, \" and hurries off to put \", ($object_utils:has_property(object, \"po\") && (typeof(object.po) == STR)) ? object.po | \"it\", \" away.\");",
            "endif",
            "except (ANY)",
            "\"Ignore errors\";",
            "endtry",
            "fork (0)",
            "this:moveit(object, place, requestor);",
            "if ((loc = object.location) == oldloc)",
            "return (object.name + \" wouldn't go; \") + ((!place:acceptable(object)) ? (\" perhaps \" + $string_utils:nn(place)) + \" won't let it in\" | ((\" perhaps \" + $string_utils:nn(loc)) + \" won't let go of it\"));",
            "endif",
            "try",
            "object:tell(\"The housekeeper puts you away.\");",
            "if ($object_utils:isa(loc, $room))",
            "loc:announce_all_but({object}, \"At \", requestor.name, \"'s request, the housekeeper sneaks in, deposits \", object:title(), \" and leaves.\");",
            "else",
            "loc:tell(\"You notice the housekeeper sneak in, give you \", object:title(), \" and leave.\");",
            "endif",
            "except (ANY)",
            "\"Ignore errors\";",
            "endtry",
            "endfork",
            "return \"\";"
          ]
        },
        {
          "name": "cleanup_list",
          "owner": 71,
          "perms": 29,
          "preps": -1,
          "object": 71,
          "code": [
            "if (args)",
            "if (!valid(who = args[1]))",
            "return;",
            "endif",
            "player:tell(who.name, \"'s personal cleanup list:\");",
            "else",
            "who = 0;",
            "player:tell(\"Housekeeper's complete cleanup list:\");",
            "endif",
            "player:tell(\"------------------------------------------------------------------\");",
            "printed_anything = 0;",
            "objs = this.clean;",
            "reqs = this.requestors;",
            "dest = this.destination;",
            "objfieldwid = length(tostr(max_object())) + 1;",
            "for i in [1..length(objs)]",
            "$command_utils:suspend_if_needed(2);",
            "req = $recycler:valid(tr = reqs[i]) ? tr | $no_one;",
            "ob = objs[i];",
            "place = dest[i];",
            "if (((who == 0) || (req == who)) || (ob.owner == who))",
            "if (!valid(ob))",
            "player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left(\"** recycled **\", 50), \"(\", req.name, \")\");",
            "else",
            "player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left(ob.name, 26), \"=>\", $string_utils:left(tostr(place), objfieldwid), (valid(place) ? place.name | \"nowhere\") || \"nowhere\", \" (\", req.name, \")\");",
            "endif",
            "printed_anything = 1;",
            "endif",
            "endfor",
            "if (!printed_anything)",
            "player:tell(\"** The housekeeper has nothing in the cleanup list.\");",
            "endif",
            "player:tell(\"------------------------------------------------------------------\");"
          ]
        },
        {
          "name": "add_cleanup",
          "owner": 71,
          "perms": 93,
          "preps": -2,
          "object": 71,
          "code": [
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "endif",
            "{what, ?who = player, ?where = what.location} = args;",
            "if ((what < #1) || (!valid(what)))",
            "return \"invalid object\";",
            "endif",
            "if ($object_utils:isa(who, $guest))",
            "return tostr(\"Guests can't use the \", this.name, \".\");",
            "endif",
            "if (!is_player(who))",
            "return tostr(\"Non-players can't use the \", this.name, \".\");",
            "endif",
            "if (!valid(where))",
            "return tostr(\"The \", this.name, \" doesn't know how to find \", where, \" in order to put away \", what.name, \".\");",
            "endif",
            "if (is_player(what))",
            "return (\"The \" + this.name) + \" doesn't do players, except to cart them home when they fall asleep.\";",
            "endif",
            "for x in (this.eschews)",
            "if ($object_utils:isa(what, x[1]))",
            "ok = 0;",
            "for y in [3..length(x)]",
            "if ($object_utils:isa(what, x[y]))",
            "ok = 1;",
            "endif",
            "endfor",
            "if (!ok)",
            "return tostr(\"The \", this.name, \" doesn't do \", x[2], \"!\");",
            "endif",
            "endif",
            "endfor",
            "if ($object_utils:has_callable_verb(where, \"litterp\") ? where:litterp(what) | ((where in this.public_places) && (!(what in where.residents))))",
            "return tostr(\"The \", this.name, \" won't litter \", where.name, \"!\");",
            "endif",
            "if (i = what in this.clean)",
            "if ((!this:controls(i, who)) && valid(this.destination[i]))",
            "return tostr($recycler:valid(tr = this.requestors[i]) ? tr.name | \"Someone\", \" already asked that \", what.name, \" be kept at \", this.destination[i].name, \"!\");",
            "endif",
            "this.requestors[i] = who;",
            "this.destination[i] = where;",
            "else",
            "this.clean = {what, @this.clean};",
            "this.requestors = {who, @this.requestors};",
            "this.destination = {where, @this.destination};",
            "endif",
            "return tostr(\"The \", this.name, \" will keep \", what.name, \" (\", what, \") at \", valid(where) ? ((where.name + \" (\") + tostr(where)) + \")\" | where, \".\");"
          ]
        },
        {
          "name": "remove_cleanup",
          "owner": 71,
          "perms": 29,
          "preps": -1,
          "object": 71,
          "code": [
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "endif",
            "{what, ?who = player} = args;",
            "if (i = what in this.clean)",
            "if (!this:controls(i, who))",
            "return tostr(\"You may remove an object from \", this.name, \" list only if you own the object, the place it is kept, or if you placed the original cleaning order.\");",
            "endif",
            "this.clean = listdelete(this.clean, i);",
            "this.destination = listdelete(this.destination, i);",
            "this.requestors = listdelete(this.requestors, i);",
            "return tostr(what.name, \" (\", what, \") removed from cleanup list.\");",
            "else",
            "return tostr(what.name, \" not in cleanup list.\");",
            "endif"
          ]
        },
        {
          "name": "controls",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"does player control entry I?\";",
            "{i, who} = args;",
            "if ((who in {this.owner, @this.owners}) || who.wizard)",
            "return \"Yessir.\";",
            "endif",
            "cleanable = this.clean[i];",
            "if (this.requestors[i] == who)",
            "return \"you asked for the previous result, you can change this one.\";",
            "elseif (((who == cleanable.owner) || (!valid(dest = this.destination[i]))) || (who == dest.owner))",
            "return \"you own the object or the place where it is being cleaned to, or the destination is no longer valid.\";",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "continuous",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"start the housekeeper cleaning continuously. Kill any previous continuous\";",
            "\"task. Not meant to be called interactively.\";",
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "endif",
            "if ($code_utils:task_valid(this.task))",
            "taskn = this.task;",
            "this.task = 0;",
            "kill_task(taskn);",
            "endif",
            "fork taskn (0)",
            "while (1)",
            "index = 1;",
            "while (index <= length(this.clean))",
            "this.cleaning = x = this.clean[index];",
            "this.cleaning_index = index;",
            "index = index + 1;",
            "fork (0)",
            "`this:replace(x) ! ANY';",
            "endfork",
            "suspend(this.testing ? 2 | this:time());",
            "endwhile",
            "suspend(5);",
            "this:litterbug();",
            "endwhile",
            "endfork",
            "this.task = taskn;"
          ]
        },
        {
          "name": "litterbug",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "for room in (this.public_places)",
            "for thingy in (room.contents)",
            "suspend(10);",
            "if (((thingy.location == room) && this:is_litter(thingy)) && (!this:is_watching(thingy, $nothing)))",
            "\"if it is litter and no-one is watching\";",
            "fork (0)",
            "this:send_home(thingy);",
            "endfork",
            "suspend(0);",
            "endif",
            "endfor",
            "endfor"
          ]
        },
        {
          "name": "is_watching",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "return valid(thing = args[1]) && thing:is_listening();"
          ]
        },
        {
          "name": "send_home",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "litter = args[1];",
            "littering = litter.location;",
            "this:ejectit(litter, littering);",
            "home = litter.location;",
            "if ($object_utils:isa(home, $room))",
            "home:announce_all(\"The \", this.name, \" sneaks in, deposits \", litter:title(), \" and leaves.\");",
            "else",
            "home:tell(\"You notice the \", this.name, \" sneak in, give you \", litter:title(), \" and leave.\");",
            "endif",
            "if ($object_utils:has_callable_verb(littering, \"announce_all_but\"))",
            "littering:announce_all_but({litter}, \"The \", this.name, \" sneaks in, picks up \", litter:title(), \" and rushes off to put it away.\");",
            "endif"
          ]
        },
        {
          "name": "moveit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"Wizardly verb to move object with requestor's permission\";",
            "if (caller != this)",
            "return E_PERM;",
            "else",
            "set_task_perms(player = args[3]);",
            "return args[1]:moveto(args[2]);",
            "endif"
          ]
        },
        {
          "name": "ejectit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"this:ejectit(object,room): Eject args[1] from args[2].  Callable only by housekeeper's quarters verbs.\";",
            "if (caller == this)",
            "args[2]:eject(args[1]);",
            "endif"
          ]
        },
        {
          "name": "is_object_cleaned",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "what = args[1];",
            "if (!(where = what in this.clean))",
            "return 0;",
            "else",
            "return {this.destination[where], this.requestors[where]};",
            "endif"
          ]
        },
        {
          "name": "is_litter",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "thingy = args[1];",
            "for x in (this.litter)",
            "if ($object_utils:isa(thingy, x[1]) && (!$object_utils:isa(thingy, x[2])))",
            "return 1;",
            "endif",
            "endfor",
            "return 0;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "if (caller_perms().wizard)",
            "this.password = \"Impossible password to type\";",
            "this.last_password_time = 0;",
            "this.litter = {};",
            "this.public_places = {};",
            "this.requestors = {};",
            "this.destination = {};",
            "this.clean = {};",
            "this.eschews = {};",
            "this.recycle_bins = {};",
            "this.cleaning = #-1;",
            "this.task = 0;",
            "this.owners = {#2};",
            "this.mail_forward = {#2};",
            "this.player_queue = {};",
            "this.move_player_task = 0;",
            "this.moveto_task = 0;",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "clean_status",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "count = 0;",
            "for i in (this.requestors)",
            "if (i == player)",
            "count = count + 1;",
            "endif",
            "$command_utils:suspend_if_needed(1);",
            "endfor",
            "player:tell(\"Number of items in cleanup list: \", tostr(length(this.clean)));",
            "player:tell(\"Number of items you requested to be tidied: \", tostr(count));",
            "player:tell(\"Number of requestors: \", tostr(length($list_utils:remove_duplicates(this.requestors))));",
            "player:tell(\"Time to complete one cleaning circuit: \", $time_utils:english_time(length(this.clean) * this:time()));",
            "player:tell(\"The Housekeeper is in \" + (($housekeeper.testing == 0) ? \"normal, non-testing mode.\" | \"testing mode. \"));",
            "if (!$code_utils:task_valid($housekeeper.task))",
            "player:tell(\"The Housekeeper task has died. Restarting...\");",
            "$housekeeper:continuous();",
            "else",
            "player:tell(\"The Housekeeper is actively cleaning.\");",
            "endif"
          ]
        },
        {
          "name": "is_cleaning",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"return a string status if the hosuekeeper is cleaning this object\";",
            "cleanable = args[1];",
            "info = this:is_object_cleaned(cleanable);",
            "if (info == 0)",
            "return tostr(cleanable.name, \" is not cleaned by the \", this.name, \".\");",
            "else",
            "return tostr(cleanable.name, \" is kept tidy at \", $string_utils:nn(info[1]), \" at the request of \", $string_utils:nn(info[2]), \".\");",
            "endif"
          ]
        },
        {
          "name": "time",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"Returns the amount of time to suspend between objects while continuous cleaning.\";",
            "\"Currently set to try to complete cleaning circuit in one hour, but not exceed one object every 20 seconds.\";",
            "return max(20 + $login:current_lag(), length(this.clean) ? 3600 / length(this.clean) | 0);"
          ]
        },
        {
          "name": "acceptable",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "return caller == this;"
          ]
        },
        {
          "name": "move_players_home",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "if (!$perm_utils:controls(caller_perms(), this))",
            "\"perms don't control the $housekeeper; probably not called by $room:disfunc then. Used to let args[1] call this. No longer.\";",
            "return E_PERM;",
            "endif",
            "this.player_queue = {@this.player_queue, {args[1], time() + 300}};",
            "if ($code_utils:task_valid(this.move_player_task))",
            "\"the move-players-home task is already running\";",
            "return;",
            "endif",
            "fork tid (10)",
            "while (this.player_queue)",
            "if ((mtime = this.player_queue[1][2]) < (time() + 10))",
            "who = this.player_queue[1][1];",
            "\"Remove from queue first so that if they do something malicious, like put a kill_task in a custom :accept_for_abode, they won't be in the queue when the task restarts with the next player disconnect. Ho_Yan 12/3/98\";",
            "this.player_queue = listdelete(this.player_queue, 1);",
            "if (is_player(who) && (!$object_utils:connected(who)))",
            "dest = `who.home:accept_for_abode(who) ! ANY => 0' ? who.home | $player_start;",
            "if (who.location != dest)",
            "player = who;",
            "this:move_em(who, dest);",
            "endif",
            "endif",
            "else",
            "suspend(mtime - time());",
            "endif",
            "$command_utils:suspend_if_needed(1);",
            "endwhile",
            "endfork",
            "this.move_player_task = tid;"
          ]
        },
        {
          "name": "move_em",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "if (caller == this)",
            "{who, dest} = args;",
            "set_task_perms(who);",
            "fork (0)",
            "fork (0)",
            "\"This is forked so that it's protected from aborts due to errors in the player's :moveto verb.\";",
            "if (who.location != dest)",
            "\"Unfortunately, if who is -already- at $player_start, move() won't call :enterfunc and the sleeping body never goes to $limbo. Have to call explicitly for that case. Ho_Yan 11/2/95\";",
            "if (who.location == $player_start)",
            "$player_start:enterfunc(who);",
            "else",
            "\"Nosredna, 5/4/01: but wait, why don't we just moved them straight to limbo?\";",
            "move(who, $limbo);",
            "endif",
            "endif",
            "endfork",
            "start = who.location;",
            "this:set_moveto_task();",
            "who:moveto(dest);",
            "if (who.location != start)",
            "start:announce(this:take_away_msg(who));",
            "endif",
            "if (who.location == dest)",
            "dest:announce(this:drop_off_msg(who));",
            "endif",
            "endfork",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "take_away_msg drop_off_msg",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "return $string_utils:pronoun_sub(this.(verb), args[1], this);"
          ]
        },
        {
          "name": "set_moveto_task",
          "owner": 71,
          "perms": 173,
          "preps": -1,
          "object": 71,
          "code": [
            "\"sets $housekeeper.moveto_task to the current task_id() so player:moveto's can check for validity.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "this.moveto_task = task_id();"
          ]
        }
      ],
      "propnames": [
        "recycle_bins",
        "owners",
        "cleaning",
        "litter",
        "eschews",
        "public_places",
        "task",
        "requestors",
        "destination",
        "clean",
        "testing",
        "player_queue",
        "take_away_msg",
        "drop_off_msg",
        "move_player_task",
        "moveto_task",
        "cleaning_index"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 71,
          "perms": 5
        },
        {
          "value": -1,
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 1
        },
        {
          "value": "%[tpsc] arrives to cart %n off to bed.",
          "owner": 71,
          "perms": 5
        },
        {
          "value": "%[tpsc] arrives to drop off %n, who is sound asleep.",
          "owner": 71,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "here=player.location;me=player",
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 4
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            2
          ],
          "owner": 71,
          "perms": 5
        },
        {
          "value": [],
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 4
        },
        {
          "value": null,
          "owner": 71,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            71
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": -80,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 71,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": "The housekeeper is too busy putting away all of the junk all over LambdaMoo that there isn't time to listen to pages and stuff like that so your page isn't listened to, too bad.",
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": -9993,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 71,
          "perms": 5
        },
        {
          "value": "Impossible password to type",
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            183000,
            32307,
            1671219241,
            0
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 5
        },
        {
          "value": null,
          "owner": 71,
          "perms": 4
        },
        {
          "value": [
            "housekeeper"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "A very clean, neat, tidy person who doesn't mind lugging players and their gear all over the place.",
          "owner": 71,
          "perms": 5
        },
        {
          "value": [
            32307,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "72": {
      "id": 72,
      "name": "Network Utilities",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "parse_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"Given an email address, return {userid, site}.\";",
            "\"Valid addresses are of the form `userid[@site]'.\";",
            "\"At least for now, if [@site] is left out, site will be returned as blank.\";",
            "\"Should be a default address site, or something, somewhere.\";",
            "address = args[1];",
            "return (at = index(address, \"@\")) ? {address[1..at - 1], address[at + 1..$]} | {address, \"\"};"
          ]
        },
        {
          "name": "local_domain",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"given a site, try to figure out what the `local' domain is.\";",
            "\"if site has a @ or a % in it, give up and return E_INVARG.\";",
            "\"blank site is returned as is; try this:local_domain(this.localhost) for the answer you probably want.\";",
            "site = args[1];",
            "if (index(site, \"@\") || index(site, \"%\"))",
            "return E_INVARG;",
            "elseif (match(site, \"^[0-9.]+$\"))",
            "return E_INVARG;",
            "elseif (!site)",
            "return \"\";",
            "elseif (!(dot = rindex(site, \".\")))",
            "dot = rindex(site = this.site, \".\");",
            "endif",
            "if ((!dot) || (!(dot = rindex(site[1..dot - 1], \".\"))))",
            "return site;",
            "else",
            "domain = site[dot + 1..$];",
            "site = site[1..dot - 1];",
            "while (site && (domain in this.large_domains))",
            "if (dot = rindex(site, \".\"))",
            "domain = tostr(site[dot + 1..$], \".\", domain);",
            "site = site[1..dot - 1];",
            "else",
            "return tostr(site, \".\", domain);",
            "endif",
            "endwhile",
            "return domain;",
            "endif"
          ]
        },
        {
          "name": "open",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\":open(address, port, [connect-connection-to])\";",
            "\"Open a network connection to address/port.  If the connect-connection-to is passed, then the connection will be connected to that object when $login gets ahold of it.  If not, then the connection is just ignored by $login, i.e. not bothered by it with $welcome_message etc.\";",
            "\"The object specified by connect-connection-to has to be a player (though it need not be a $player).\";",
            "\"Returns the (initial) connection or an error, as in open_network_connection\";",
            "if (!this:trust(caller_perms()))",
            "return E_PERM;",
            "endif",
            "{address, port, ?connect_to} = args;",
            "if (length(args) < 3)",
            "connect_to = $nothing;",
            "elseif (((typeof(connect_to) == OBJ) && valid(connect_to)) && is_player(connect_to))",
            "if (!$perm_utils:controls(caller_perms(), connect_to))",
            "return E_PERM;",
            "endif",
            "else",
            "return E_INVARG;",
            "endif",
            "if (typeof(connection = `open_network_connection(address, port) ! ANY') != ERR)",
            "if (valid(connect_to))",
            "this.connect_connections_to = {@this.connect_connections_to, {connection, connect_to}};",
            "endif",
            "endif",
            "return connection;"
          ]
        },
        {
          "name": "close",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "if (!this:trust(caller_perms()))",
            "return E_PERM;",
            "endif",
            "con = args[1];",
            "if (!index(`connection_name(con) ! ANY => \"\"', \" to \"))",
            "return E_INVARG;",
            "endif",
            "boot_player(con);",
            "if (i = $list_utils:iassoc(con, $network.connect_connections_to))",
            "$network.connect_connections_to = listdelete($network.connect_connections_to, i);",
            "endif",
            "return 1;"
          ]
        },
        {
          "name": "sendmail",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 72,
          "code": [
            "\"sendmail(to, subject, line1, line2, ...)\";",
            "\"  sends mail to internet address 'to', with given subject.\";",
            "\"  It fills in various fields, such as date, from (from player), etc.\";",
            "\"  the rest of the arguments are remaining lines of the message, and may begin with additional header fields.\";",
            "\"  (must match RFC822 specification).\";",
            "\"Requires $network.trust to call (no anonymous mail from MOO).\";",
            "\"Returns 0 if successful, or else error condition or string saying why not.\";",
            "if (!this:trust(caller_perms()))",
            "return E_PERM;",
            "endif",
            "mooname = this.MOO_name;",
            "mooinfo = tostr(mooname, \" (\", this.site, \" \", this.port, \")\");",
            "if (reason = this:invalid_email_address(to = args[1]))",
            "return reason;",
            "endif",
            "\"took out Envelope-from:  + this.errors_to_address\";",
            "tries = 4;",
            "result = \"unknown\";",
            "while ((tries > 0) && (result != 0))",
            "tries = tries - 1;",
            "result = this:raw_sendmail(to, \"Date: \" + $time_utils:rfc822_ctime(), \"From: \" + this:return_address_for(player), \"To: \" + to, \"Subject: \" + args[2], \"Errors-to: \" + this.errors_to_address, \"X-Mail-Agent: \" + mooinfo, @args[3..$]);",
            "endwhile",
            "return result;"
          ]
        },
        {
          "name": "trust",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "return (who = args[1]).wizard || (who in this.trusts);"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.active = 0;",
            "this.errors_to_address = \"moomailerrors@yourhost\";",
            "this.site = \"yoursite\";",
            "this.postmaster = \"postmastername@yourhost\";",
            "this.usual_postmaster = \"postmastername@yourhost\";",
            "this.password_postmaster = \"postmastername@yourhost\";",
            "this.envelope_from = \"postmastername@yourhost\";",
            "this.blank_envelope = 0;",
            "this.MOO_name = \"YourMOO\";",
            "this.maildrop = \"localhost\";",
            "this.port = 7777;",
            "this.large_domains = {};",
            "this.trusts = {$hacker};",
            "this.connect_connections_to = {};",
            "endif"
          ]
        },
        {
          "name": "raw_sendmail",
          "owner": 2,
          "perms": 29,
          "preps": -1,
          "object": 72,
          "code": [
            "\"Copied from sendmail fix (#88079):raw_sendmail by Lineman (#108318) Mon Feb  1 19:29:43 1999 PST\";",
            "\"rawsendmail(to, @lines)\";",
            "\"sends mail without processing. Returns 0 if successful, or else reason why not.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "if (!this.active)",
            "return \"Networking is disabled.\";",
            "endif",
            "if (typeof(this.debugging) == LIST)",
            "\"who to notify\";",
            "debugging = this.debugging;",
            "else",
            "\"notify this owner\";",
            "debugging = this.debugging && {this.owner};",
            "endif",
            "address = args[1];",
            "body = listdelete(args, 1);",
            "data = {\"HELO \" + this.site, (\"MAIL FROM:<\" + this.postmaster) + \">\", (\"RCPT TO:<\" + address) + \">\", \"DATA\"};",
            "blank = 0;",
            "for x in (body)",
            "this:suspend_if_needed(0);",
            "if (!(blank || match(x, \"^[!-9;-~]+: \")))",
            "if (x)",
            "data = {@data, \"\"};",
            "endif",
            "blank = 1;",
            "endif",
            "data = {@data, (x && (x[1] == \".\")) ? \".\" + x | x};",
            "endfor",
            "data = {@data, \".\", \"QUIT\", \"\"};",
            "suspend(0);",
            "target = E_NONE;",
            "for maildrop in ((typeof(this.maildrop) == LIST) ? this.maildrop | {this.maildrop})",
            "target = $network:open(maildrop, 25);",
            "if (typeof(target) != ERR)",
            "break;",
            "endif",
            "endfor",
            "if (typeof(target) == ERR)",
            "return tostr(@(target == E_NONE) ? {\"No maildrop specified\"} | {\"Cannot open connection to maildrop \", maildrop, \": \", target});",
            "endif",
            "set_connection_option(target, \"hold-input\", 1);",
            "blast = 0;",
            "msg = 0;",
            "expects = {\"220\", \"250\", \"250\", \"250%|251\", \"354\", \"250\", \"221\"};",
            "for line in (data)",
            "if (!blast)",
            "reply = this:tcp_wait(target);",
            "if (typeof(reply) == ERR)",
            "msg = \"Connection dropped or timed out.\";",
            "break;",
            "elseif (!match(reply[1..3], expects[1]))",
            "msg = ((\"Expected \" + expects[1]) + \" but got \") + reply;",
            "break;",
            "endif",
            "debugging && notify(debugging[1], \"GET: \" + reply);",
            "expects[1..1] = {};",
            "if (reply[1..3] == \"221\")",
            "\"Service closing transmission channel\";",
            "break;",
            "elseif (reply[1..3] == \"354\")",
            "\"Start mail input; end with <CRLF>.<CRLF>\";",
            "blast = 1;",
            "endif",
            "elseif (line == \".\")",
            "blast = 0;",
            "endif",
            "debugging && notify(debugging[1], \"SEND:\" + line);",
            "while (((ticks_left() < 4000) || (seconds_left() < 2)) || (!notify(target, line, 1)))",
            "suspend(0);",
            "endwhile",
            "endfor",
            "$network:close(target);",
            "debugging && notify(debugging[1], \"EXIT:\" + (msg || \"Mail sent successfully.\"));",
            "return msg;"
          ]
        },
        {
          "name": "invalid_email_address",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"invalid_email_address(email) -- check to see if email looks like a valid email address. Return reason why not.\";",
            "address = args[1];",
            "if (!address)",
            "return \"no email address supplied\";",
            "endif",
            "if (!(at = rindex(address, \"@\")))",
            "return (\"'\" + address) + \"' doesn't look like a valid internet email address\";",
            "endif",
            "name = address[1..at - 1];",
            "host = address[at + 1..$];",
            "if (match(name, \"^in%%\") || match(name, \"^smtp%%\"))",
            "return tostr(\"'\", name, \"' doesn't look like a valid username (try removing the 'in%' or 'smtp%')\");",
            "endif",
            "if (!match(host, $network.valid_host_regexp))",
            "return tostr(\"'\", host, \"' doesn't look like a valid internet host\");",
            "endif",
            "if (!match(name, $network.valid_email_regexp))",
            "return tostr(\"'\", name, \"' doesn't look like a valid user name for internet mail\");",
            "endif",
            "return \"\";"
          ]
        },
        {
          "name": "invalid_hostname",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "return match(args[1], this.valid_host_regexp) ? \"\" | tostr(\"'\", args[1], \"' doesn't look like a valid internet host name\");"
          ]
        },
        {
          "name": "email_will_fail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\":email_will_fail(email-address[, display?]) => Makes sure the email-address is one that can actually be used by $network:sendmail().\";",
            "{email, ?display = 0} = args;",
            "reason = this:invalid_email_address(email);",
            "if (reason && display)",
            "player:tell(\"Invalid email address: \", reason);",
            "endif",
            "return reason;",
            "\"following is code from OpalMOO, not used here\";",
            "\"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.\";",
            "\"If <display> is true, error messages are displayed to the player and 1 is returned when address is unuable.  If <display> is false and address is unusable, the error message is returned.  If the address is usable, 0 is always returned.\";",
            "if (!this:approved_for_network(caller_perms()))",
            "return E_PERM;",
            "endif",
            "if (!this:valid_email_address(email))",
            "msg = tostr(\"Your email address (\", email, \") is not a usable account.\");",
            "elseif ((result = this:verify_email_address(email)) == E_INVARG)",
            "msg = tostr(\"Unable to connect to \", this:parse_address(email)[2], \".\");",
            "elseif (typeof(result) == STR)",
            "msg = tostr(\"The site \", (parse = this:parse_address(email))[2], \" does not recognize \", parse[1], \" as a valid account.\");",
            "else",
            "return 0;",
            "endif",
            "if (display)",
            "player:tell(msg);",
            "return 1;",
            "else",
            "return msg;",
            "endif",
            "\"Last modified Tue Jun 15 00:19:01 1993 EDT by Ranma (#200).\";"
          ]
        },
        {
          "name": "read",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"for trusted players, they can read from objects they own or open connections\";",
            "if (!this:trust(caller_perms()))",
            "return E_PERM;",
            "elseif (valid(x = args[1]))",
            "if ((x.owner == x) || (x.owner != caller_perms()))",
            "return E_INVARG;",
            "endif",
            "\"elseif (!this:is_outgoing_connection(x) return E_PERM\";",
            "endif",
            "return `read(@args) ! ANY';"
          ]
        },
        {
          "name": "is_open",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\":is_open(object)\";",
            "\"return true if the object is somehow connected, false otherwise.\";",
            "return typeof(`idle_seconds(@args) ! ANY') == INT;",
            "\"Relies on test in idle_seconds, and the error catching\";"
          ]
        },
        {
          "name": "incoming_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"Peer at an incoming connection.  Decide if it should be connected to something, return that object. If it should be ignored (outbound connection), return 1. Called only by #0:do_login_command\";",
            "if (caller != #0)",
            "return;",
            "endif",
            "what = args[1];",
            "\"this code for unix servers >= 1.7.5 only\";",
            "if (index(`connection_name(what) ! ANY => \"\"', \" to \"))",
            "\"outbound connection\";",
            "if (ct = $list_utils:assoc(what, this.connect_connections_to))",
            "this.connect_connections_to = setremove(this.connect_connections_to, ct);",
            "return ct[2];",
            "else",
            "return 1;",
            "endif",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "return_address_for",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\":return_address_for(player) => string of 'return address'. Currently inbound mail doesn't work, so this is a bogus address.\";",
            "who = args[1];",
            "if (valid(who) && is_player(who))",
            "return tostr(toint(who), \"@\", this.site, \" (\", who.name, \")\");",
            "else",
            "return tostr($login.registration_address, \" (non-player \", who, \")\");",
            "endif"
          ]
        },
        {
          "name": "server_started",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"called when restarting to clean out state.\";",
            "if (caller != #0)",
            "return E_PERM;",
            "endif",
            "this.connect_connections_to = {};"
          ]
        },
        {
          "name": "is_outgoing_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "return index(`connection_name(args[1]) ! ANY => \"\"', \" to \");"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"for trusted players, they can write to connections\";",
            "if (!this:trust(caller_perms()))",
            "return E_PERM;",
            "elseif (valid(x = args[1]))",
            "return E_INVARG;",
            "elseif (!this:is_outgoing_connection(x))",
            "return E_PERM;",
            "endif",
            "return notify(x, args[2]);"
          ]
        },
        {
          "name": "suspend_if_needed",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"$command_utils:suspend_if_needed but chowned to player\";",
            "if ($command_utils:running_out_of_time())",
            "set_task_perms(caller_perms().wizard ? player | caller_perms());",
            "return $command_utils:suspend_if_needed(@args);",
            "endif"
          ]
        },
        {
          "name": "error",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\":error(ERN, host, port) interpret open_network_connection(host, port) error\";",
            "{msg, host, port} = args;",
            "if (msg == E_PERM)",
            "return \"Networking not enabled in server, or else user doesn't have permission to call o_n_c();\";",
            "elseif (msg == E_INVARG)",
            "return tostr(\"The host/port \", toliteral(host), \"/\", toliteral(port), \" is invalid or is not responding.\");",
            "elseif (msg == E_QUOTA)",
            "return tostr(\"The connection to \", toliteral(host), \"/\", toliteral(port), \" cannot be made at this time.\");",
            "else",
            "return tostr(\"Unusual error: \", toliteral(msg));",
            "endif"
          ]
        },
        {
          "name": "help_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"'cause this doesn't have a $_utils name\";",
            "return this:description();"
          ]
        },
        {
          "name": "adjust_postmaster_for_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"adjust_postmaster_for_password(enter_or_exit): permits the MOO to have two different postmasters for different kinds of bounces.  If entering password (argument \\\"enter\\\"), change to $network.password_postmaster, else (argument \\\"exit\\\") change to $network.usual_postmaster.\";",
            "if (args[1] == \"enter\")",
            "$network.postmaster = $network.password_postmaster;",
            "$network.errors_to_address = $network.password_postmaster;",
            "$network.envelope_from = $network.password_postmaster;",
            "else",
            "$network.postmaster = $network.usual_postmaster;",
            "$network.errors_to_address = $network.usual_postmaster;",
            "$network.envelope_from = $network.blank_envelope ? \"\" | $network.usual_postmaster;",
            "endif"
          ]
        },
        {
          "name": "add_queued_mail",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"$network:add_queued_mail( mail message )\";",
            "\"  -- where `mail message' is in the same format as passed to :raw_sendmail\";",
            "if (caller == this)",
            "this.queued_mail = {@this.queued_mail, {time(), args}};",
            "if (!$code_utils:task_valid(this.queued_mail_task))",
            "fork fid (3600)",
            "this:send_queued_mail();",
            "endfork",
            "this.queued_mail_task = fid;",
            "endif",
            "return 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "send_queued_mail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"$network:send_queued_mail()\";",
            "\"  -- tries to send the mail stored in the .queued_mail property\";",
            "while (queued_mail = this.queued_mail)",
            "message = queued_mail[1];",
            "if (!this:raw_sendmail(@message[2]))",
            "this.queued_mail = setremove(this.queued_mail, message);",
            "else",
            "\"wait an hour\";",
            "suspend(3600);",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "tcp_wait",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 72,
          "code": [
            "\"Copied from sendmail fix (#88079):tcp_wait by Lineman (#108318) Mon Feb  1 19:28:18 1999 PST\";",
            "{conn, ?timeout = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "elseif (timeout)",
            "fork task (timeout)",
            "boot_player(conn);",
            "endfork",
            "endif",
            "while (1)",
            "if (typeof(line = `read(conn) ! ANY') == ERR)",
            "break;",
            "elseif (match(line, \"^[0-9][0-9][0-9] \"))",
            "timeout && `kill_task(task) ! ANY';",
            "break;",
            "endif",
            "endwhile",
            "return line;"
          ]
        }
      ],
      "propnames": [
        "site",
        "large_domains",
        "connect_connections_to",
        "postmaster",
        "port",
        "MOO_name",
        "valid_host_regexp",
        "maildrop",
        "trusts",
        "active",
        "valid_email_regexp",
        "invalid_userids",
        "debugging",
        "errors_to_address",
        "suspicious_userids",
        "usual_postmaster",
        "password_postmaster",
        "queued_mail",
        "queued_mail_task",
        "envelope_from",
        "blank_envelope"
      ],
      "propdefs": [
        {
          "value": "yoursite",
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [],
          "owner": 2,
          "perms": 0
        },
        {
          "value": "postmastername@yourhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 7777,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "YourMOO",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "^%([-_a-z0-9]+%.%)+%(gov%|edu%|com%|org%|int%|mil%|net%|%nato%|arpa%|name%|info%|[a-z][a-z]%)$",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "localhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            36
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "^[-a-z0-9_!.%+$'=/]*[-a-z0-9_!%+$'=]$",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "",
            "sysadmin",
            "root",
            "postmaster",
            "system",
            "operator",
            "bin"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "moomailerrors@yourhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "",
            "sysadmin",
            "root",
            "postmaster",
            "bin",
            "SYSTEM",
            "OPERATOR",
            "guest",
            "me",
            "mailer-daemon",
            "webmaster",
            "sysop",
            "info"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "postmastername@yourhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "postmastername@yourhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 1076002766,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "postmastername@yourhost",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Network Utilities"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "Utilities for dealing with network connections",
            "---------------",
            "Creating & tracking hosts:",
            "",
            ":open(host, port [, connect-connection-to]) => connection",
            "    open a network connection (using open_network_connection).",
            "    If 'connect-connection-to' is a player object, the",
            "    connection will be connected to that object when it",
            "    gets the first line of input.",
            "",
            ":close(connection)",
            "     closes the connection & cleans up data",
            "",
            "------------------",
            "Parsing network things:",
            "",
            ":invalid_email_address(email)",
            "     return \"\" or string saying why 'email' is invalid.",
            "     uses .valid_email_regexp",
            "",
            ":invalid_hostname(host)",
            "     return \"\" or string saying why 'host' doesn't look",
            "     like a valid internet host name",
            "",
            ":local_domain(host)",
            "     returns the 'important' part of a host name, e.g.",
            "     golden.parc.xerox.com => parc.xerox.com",
            "",
            "-------------------",
            "Sending mail",
            "",
            ":sendmail(to, subject, @lines)",
            "     send mail to the email address 'to' with indicated subject.",
            "     header fields like 'from', 'date', etc. are filled in.",
            "     lines can start with additional header lines.",
            "",
            ":raw_sendmail(to, @lines)",
            "     used by :sendmail. Send mail to given user at host, just",
            "     as specified, no error checking.",
            "",
            "================================================================",
            "Parameters:",
            "",
            ".active If 0, disabled sending of mail.",
            "",
            ".site   Where does this MOO run?",
            "        (Maybe MOOnet will use it later).",
            "",
            ".port   The network port this MOO listens on.",
            "",
            ".large_domains ",
            "        A list of sites where more than 2 levels of host name are",
            "        significant, e.g., if you want 'parc.xerox.com' to be",
            "        different than 'cinops.xerox.com', put \"xerox.com\" as an",
            "        element in .large_domains.",
            "",
            ".postmaster",
            "        Email address to which problems with MOO mail should",
            "        go. This should be a real email address that someone reads.",
            "",
            ".maildrop",
            "        Hostname to connect to for dropping off mail. Usually can",
            "        just be \"localhost\".",
            "",
            ".reply_address",
            "        If a MOO character sends email, where does a reply go?",
            "        Inserted in 'From:' for mail from characters without",
            "        registration addresses.        ",
            "",
            ".trusts",
            "        List of (non-wizard) programmers who can call",
            "        :open, :sendmail, :close",
            "",
            "                "
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            32197,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "73": {
      "id": 73,
      "name": "Generic BigList Resident",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "_make",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "\":_make(...) => new node with value {...}\";",
            "if (!(caller in {this._mgr, this}))",
            "return E_PERM;",
            "endif",
            "prop = this:_genprop();",
            "add_property(this, prop, args, {$generic_biglist_home.owner, \"\"});",
            "return prop;"
          ]
        },
        {
          "name": "_kill",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "\":_kill(node) destroys the given node.\";",
            "if (!(caller in {this, this._mgr}))",
            "return E_PERM;",
            "endif",
            "delete_property(this, args[1]);"
          ]
        },
        {
          "name": "_get",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "return (caller == this._mgr) ? this.(args[1]) | E_PERM;"
          ]
        },
        {
          "name": "_put",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;"
          ]
        },
        {
          "name": "_genprop",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "gp = this._genprop;",
            "ngp = \"\";",
            "for i in [1..length(gp)]",
            "if (gp[i] != \"z\")",
            "ngp = (ngp + \"bcdefghijklmnopqrstuvwxyz\"[strcmp(gp[i], \"`\")]) + gp[i + 1..$];",
            "return \" \" + (this._genprop = ngp);",
            "endif",
            "ngp = ngp + \"a\";",
            "endfor",
            "return \" \" + (this._genprop = ngp + \"a\");"
          ]
        },
        {
          "name": "_ord",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "\"this is a dummy. You have to decide what your leaves are going to look like and then write this verb accordingly.  It should, given a leaf/list-element, return the corresponding key value.  So for an ordinary alist, where all of the leaves are of the form {key,datum}, you want:\";",
            "return args[1][1];"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 73,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "pass(@args);",
            "this.mowner = $hacker;",
            "this._mgr = $biglist;"
          ]
        }
      ],
      "propnames": [
        "_genprop",
        "mowner",
        "_mgr"
      ],
      "propdefs": [
        {
          "value": "a",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 36,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 13,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "biglist",
            "resident",
            "gblr"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the object you want to use as a parent in order to @create a place for your biglists to live.  Suitably sick souls may wish to reimplement :_genprop and :_kill to reclaim unused properties (this :_kill just throws them away and this :_genprop just relentlessly advances....  who cares).  Anyway, you'll need to look at $biglist before this will make sense."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            5624,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "74": {
      "id": 74,
      "name": "Generic Feature Object",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        5
      ],
      "children": [
        89,
        90
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "help_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "all_help = this.help_msg;",
            "if (typeof(all_help) == STR)",
            "all_help = {all_help};",
            "endif",
            "helpless = {};",
            "for vrb in (this.feature_verbs)",
            "if (loc = $object_utils:has_verb(this, vrb))",
            "loc = loc[1];",
            "help = $code_utils:verb_documentation(loc, vrb);",
            "if (help)",
            "all_help = {@all_help, \"\", tostr(loc, \":\", verb_info(loc, vrb)[3]), @help};",
            "else",
            "helpless = {@helpless, vrb};",
            "endif",
            "endif",
            "endfor",
            "if (helpless)",
            "all_help = {@all_help, \"\", (\"No help found on \" + $string_utils:english_list(helpless, \"nothing\", \" or \")) + \".\"};",
            "endif",
            "return {@all_help, \"----\"};"
          ]
        },
        {
          "name": "look_self",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "\"Definition from #1\";",
            "desc = this:description();",
            "if (desc)",
            "player:tell_lines(desc);",
            "else",
            "player:tell(\"You see nothing special.\");",
            "endif",
            "player:tell(\"Please type \\\"help \", this, \"\\\" for more information.\");"
          ]
        },
        {
          "name": "using this",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "\"Proper usage for the Generic Feature Object:\";",
            "\"\";",
            "\"First of all, the Generic Feature Object is constructed with the idea\";",
            "\"that its children will be @moved to #24300, which is kind of a warehouse\";",
            "\"for feature objects.  If there's enough interest, I'll try to make the\";",
            "\"stuff that works with that in mind optional.\";",
            "\"\";",
            "\"Make a short description.  This is so I can continue to have looking at\";",
            "\"#24300 give the descriptions of each of the objects in its .contents.\";",
            "\"The :look_msg automatically includes a pointer to `help <this object>',\";",
            "\"so you don't have to.\";",
            "\"\";",
            "\"Put a list of the commands you want people to use in\";",
            "\"<this object>.feature_verbs.  (You need to use the :set_feature_verbs\";",
            "\"verb to do this.)\";",
            "\"\";",
            "\"When someone types `help <this object>', they will be told the comment\";",
            "\"strings from each of the verbs named in .feature_verbs.\";"
          ]
        },
        {
          "name": "examine_commands_ok",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "return this in args[1].features;"
          ]
        },
        {
          "name": "set_feature_ok",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this) || (caller == this))",
            "return this.feature_ok = args[1];",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "hidden_verbs",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "\"Can't see `get' unless it's in the room; can't see `drop' unless it's in the player.  Should possibly go on $thing.\";",
            "\"Should use :contents, but I'm in a hurry.\";",
            "hidden = pass(@args);",
            "if (this.location != args[1])",
            "hidden = setadd(hidden, {$thing, verb_info($thing, \"drop\")[3], {\"this\", \"none\", \"none\"}});",
            "hidden = setadd(hidden, {$thing, verb_info($thing, \"give\")[3], {\"this\", \"at/to\", \"any\"}});",
            "endif",
            "if (this.location != args[1].location)",
            "hidden = setadd(hidden, {$thing, verb_info($thing, \"get\")[3], {\"this\", \"none\", \"none\"}});",
            "endif",
            "return hidden;"
          ]
        },
        {
          "name": "set_feature_verbs",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this) || (caller == this))",
            "return this.feature_verbs = args[1];",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "initialize",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "pass(@args);",
            "this.feature_verbs = {};",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "if (($code_utils:verb_location() == this) && caller_perms().wizard)",
            "this.warehouse = $feature_warehouse;",
            "`delete_property(this, \"guest_ok\") ! ANY';",
            "`delete_verb(this, \"set_ok_for_guest_use\") ! ANY';",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "feature_remove",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "\"This is just a blank verb definition to encourage others to use this verb name if they care when a user is no longer using that feature.\";"
          ]
        },
        {
          "name": "player_connected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "return;"
          ]
        },
        {
          "name": "has_feature_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 74,
          "code": [
            "\":has_feature_verb(verb, dlist, plist, ilist)\";",
            "\"If this feature has a feature verb that matches <verb> and whose {dobj, prep, iobj} arguments match the possibilities listed in <dlist>, <plist> and <ilist>, then return the name of that verb, otherwise return false.\";",
            "\"Note: Individual FOs may over-ride this the method to redirect particular feature verbs to different verbs on the object. For example, 'sit with <any>' and 'sit on <any>' could be directed to separate :sit_with() and :sit_on() verbs -- which is something that the code below cannot do.\";",
            "{vrb, dlist, plist, ilist} = args;",
            "if (`valid(loc = $object_utils:has_callable_verb(this, vrb)[1]) ! ANY => 0')",
            "vargs = verb_args(loc, vrb);",
            "if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))",
            "return vrb;",
            "endif",
            "endif",
            "return 0;"
          ]
        }
      ],
      "propnames": [
        "warehouse",
        "help_msg",
        "feature_verbs",
        "feature_ok"
      ],
      "propdefs": [
        {
          "value": 83,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "The Generic Feature Object--not to be used as a feature object.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Using"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Generic Feature Object",
            "Generic .Features_Huh Object",
            "Feature Object",
            ".Features_Huh Object"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is the Generic Feature Object.  It is not meant to be used as a feature object itself, but is handy for making new feature objects.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            11423,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "75": {
      "id": 75,
      "name": "Shapes Object Serialization Library",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        -1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "_log",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "notify(player, tostr(@args));"
          ]
        },
        {
          "name": "_suspend_if_necessary",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);"
          ]
        },
        {
          "name": "_controls controls",
          "owner": 2,
          "perms": 164,
          "preps": -1,
          "object": 75,
          "code": null
        },
        {
          "name": "_controls_verb",
          "owner": 2,
          "perms": 164,
          "preps": -1,
          "object": 75,
          "code": [
            "{who, what, name} = args;",
            "return (who == verb_info(what, name)[1]) || who.wizard;"
          ]
        },
        {
          "name": "_controls_property",
          "owner": 2,
          "perms": 164,
          "preps": -1,
          "object": 75,
          "code": [
            "{who, what, name} = args;",
            "return (who == property_info(what, name)[1]) || who.wizard;"
          ]
        },
        {
          "name": "objects",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "args && raise(E_ARGS);",
            "set_task_perms(caller_perms());",
            "r = [];",
            "r[\"Objects\"] = {};",
            "return r;"
          ]
        },
        {
          "name": "read_object",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, ?options = []} = args;",
            "((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);",
            "if (`valid(o) ! E_TYPE')",
            "pcount = length(properties(o));",
            "vcount = length(verbs(o));",
            "set_task_perms(caller_perms());",
            "r = [\"Attributes\" -> []];",
            "v = parents(o);",
            "m = [\"id\" -> \"parents\"];",
            "m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";",
            "r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];",
            "if (typeof(o) == OBJ)",
            "v = is_player(o);",
            "m = [\"id\" -> \"player\"];",
            "m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";",
            "r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];",
            "endif",
            "r[\"Values\"] = [];",
            "for a in (this:_values(o))",
            "this:_suspend_if_necessary();",
            "r[\"Values\"][a] = this:read_value(o, a, options);",
            "endfor",
            "r[\"Properties\"] = {};",
            "for p in [1..pcount]",
            "this:_suspend_if_necessary();",
            "r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};",
            "endfor",
            "r[\"Verbs\"] = {};",
            "for v in [1..vcount]",
            "this:_suspend_if_necessary();",
            "r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};",
            "endfor",
            "if (p = o.w || this:_controls(caller_perms(), o))",
            "status = \"writable\";",
            "elseif (o.r)",
            "status = \"readable\";",
            "else",
            "status = \"\";",
            "endif",
            "if (typeof(o) == OBJ)",
            "r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];",
            "else",
            "r[\"Meta\"] = [\"status\" -> status];",
            "endif",
            "return r;",
            "else",
            "if (typeof(o) == OBJ)",
            "r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];",
            "else",
            "r = [\"Meta\" -> [\"status\" -> \"invalid\"]];",
            "endif",
            "return r;",
            "endif"
          ]
        },
        {
          "name": "write_object",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, r, ?options = []} = args;",
            "((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);",
            "if (`valid(o) ! E_TYPE')",
            "properties = properties(o);",
            "verbs = verbs(o);",
            "set_task_perms(caller_perms());",
            "try",
            "r[\"Attributes\"];",
            "r[\"Values\"];",
            "r[\"Properties\"];",
            "r[\"Verbs\"];",
            "errors = 0;",
            "parents = `r[\"Attributes\"][\"parents\"][\"Value\"][\"value\"] ! E_RANGE => parents(o)';",
            "if (parents(o) != parents)",
            "x = this:_write_parents(o, [\"Value\" -> [\"value\" -> {}]]);",
            "errors = errors + (\"Error\" in mapkeys(x));",
            "endif",
            "location = `r[\"Values\"][\"location\"][\"Value\"][\"value\"] ! E_RANGE => o.location';",
            "if (o.location != location)",
            "x = this:write_value(o, \"location\", [\"Value\" -> [\"value\" -> $nothing]]);",
            "errors = errors + (\"Error\" in mapkeys(x));",
            "endif",
            "owner = `r[\"Values\"][\"owner\"][\"Value\"][\"value\"] ! E_RANGE => o.owner';",
            "if (\"owner\" in mapkeys(r[\"Values\"]))",
            "r[\"Values\"][\"owner\"] = this:write_value(o, \"owner\", r[\"Values\"][\"owner\"]);",
            "errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"owner\"]));",
            "endif",
            "if (\"parents\" in mapkeys(r[\"Attributes\"]))",
            "r[\"Attributes\"][\"parents\"] = this:_write_parents(o, r[\"Attributes\"][\"parents\"]);",
            "errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"parents\"]));",
            "endif",
            "if (\"player\" in mapkeys(r[\"Attributes\"]))",
            "r[\"Attributes\"][\"player\"] = this:_write_player(o, r[\"Attributes\"][\"player\"]);",
            "errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"player\"]));",
            "endif",
            "if (\"location\" in mapkeys(r[\"Values\"]))",
            "r[\"Values\"][\"location\"] = this:write_value(o, \"location\", r[\"Values\"][\"location\"]);",
            "errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"location\"]));",
            "endif",
            "if ((lp1 = length(properties)) < (lp2 = length(r[\"Properties\"])))",
            "for p in [lp1 + 1..lp2]",
            "this:_suspend_if_necessary();",
            "`add_property(o, tostr(\"___\", p, \"___\"), 0, {owner, \"\"}) ! E_PERM';",
            "endfor",
            "else",
            "for p in [lp2 + 1..lp1]",
            "this:_suspend_if_necessary();",
            "delete_property(o, properties[p]);",
            "endfor",
            "endif",
            "if ((lv1 = length(verbs)) < (lv2 = length(r[\"Verbs\"])))",
            "for v in [lv1 + 1..lv2]",
            "this:_suspend_if_necessary();",
            "`add_verb(o, {owner, \"\", tostr(\"___\", v, \"___\")}, {\"this\", \"none\", \"this\"}) ! E_PERM';",
            "endfor",
            "else",
            "for v in [lv2 + 1..lv1]",
            "this:_suspend_if_necessary();",
            "delete_verb(o, lv2 + 1);",
            "endfor",
            "endif",
            "for p in [1..length(r[\"Properties\"])]",
            "this:_suspend_if_necessary();",
            "r[\"Properties\"][p] = this:write_property(o, p, r[\"Properties\"][p]);",
            "if (\"Error\" in mapkeys(r[\"Properties\"][p]))",
            "if ((lp1 < lp2) && (r[\"Properties\"][p][\"Error\"][\"diagnostic\"] == \"property is invalid\"))",
            "r[\"Properties\"][p][\"Error\"][\"diagnostic\"] = \"permission denied\";",
            "endif",
            "errors = errors + 1;",
            "endif",
            "endfor",
            "for v in [1..length(r[\"Verbs\"])]",
            "this:_suspend_if_necessary();",
            "r[\"Verbs\"][v] = this:write_verb(o, v, r[\"Verbs\"][v], `options[\"verbs\"] ! E_RANGE => []');",
            "if (\"Error\" in mapkeys(r[\"Verbs\"][v]))",
            "if ((lv1 < lv2) && (r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] == \"verb is invalid\"))",
            "r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] = \"permission denied\";",
            "endif",
            "errors = errors + 1;",
            "endif",
            "endfor",
            "values = setremove(setremove(mapkeys(r[\"Values\"]), \"location\"), \"owner\");",
            "for a in (values)",
            "this:_suspend_if_necessary();",
            "r[\"Values\"][a] = this:write_value(o, a, r[\"Values\"][a], options);",
            "errors = errors + (\"Error\" in mapkeys(r[\"Values\"][a]));",
            "endfor",
            "if (errors < 1)",
            "r = this:read_object(o);",
            "else",
            "r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> \"unknown\"];",
            "r[\"Error\"] = [\"diagnostic\" -> \"errors in sub-operations\"];",
            "endif",
            "return r;",
            "except (E_RANGE, E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "endtry",
            "else",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "endif"
          ]
        },
        {
          "name": "_parent_property_info",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{object, property} = args;",
            "for parent in (parents(object))",
            "this:_suspend_if_necessary();",
            "if (ret = `property_info(parent, property) ! E_PROPNF')",
            "return ret;",
            "endif",
            "endfor",
            "return {};"
          ]
        },
        {
          "name": "_values",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o} = args;",
            "x = {};",
            "for t in ({o, @ancestors(o)})",
            "this:_suspend_if_necessary();",
            "y = {};",
            "for z in (properties(t))",
            "this:_suspend_if_necessary();",
            "y = {z, @y};",
            "endfor",
            "x = {@y, @x};",
            "endfor",
            "x = {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\", @x};",
            "return x;"
          ]
        },
        {
          "name": "values",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o} = args;",
            "set_task_perms(caller_perms());",
            "r = [\"Values\" -> {}];",
            "for value in (this:_values(o))",
            "this:_suspend_if_necessary();",
            "r[\"Values\"] = {@r[\"Values\"], this:read_value(o, value)};",
            "endfor",
            "return r;"
          ]
        },
        {
          "name": "read_value",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, a, ?options = []} = args;",
            "strip_clear_values = `options[\"strip_clear_values\"] ! E_RANGE';",
            "set_task_perms(caller_perms());",
            "try",
            "if (a == \"location\")",
            "v = o.location;",
            "p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";",
            "elseif (a in {\"owner\", \"programmer\", \"wizard\"})",
            "v = o.(a);",
            "p = `caller_perms().wizard ! E_INVIND' ? \"rw\" | \"r\";",
            "elseif (a in {\"r\", \"w\", \"f\", \"a\"})",
            "v = o.(a);",
            "p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";",
            "elseif (a in {\"name\"})",
            "v = o.(a);",
            "p = (`caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && (!is_player(o)))) ? \"rw\" | \"r\";",
            "else",
            "v = o.(a);",
            "pi = property_info(o, a);",
            "p = (index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a)) ? \"rw\" | \"r\";",
            "c = is_clear_property(o, a);",
            "endif",
            "except (E_INVIND, E_PROPNF)",
            "r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];",
            "return r;",
            "except (E_PERM)",
            "r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];",
            "return r;",
            "endtry",
            "m = [\"id\" -> a];",
            "m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";",
            "r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];",
            "if (`r[\"Value\"][\"clear\"] = c ! E_VARNF' && strip_clear_values)",
            "r[\"Value\"] = mapdelete(r[\"Value\"], \"value\");",
            "endif",
            "if (`pi ! E_VARNF')",
            "if ((ppi = this:_parent_property_info(o, a)) && (ppi != pi))",
            "r[\"Value\"][\"owner\"] = pi[1];",
            "r[\"Value\"][\"perms\"] = pi[2];",
            "endif",
            "endif",
            "return r;"
          ]
        },
        {
          "name": "write_value",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, a, r, ?options = []} = args;",
            "set_task_perms(caller_perms());",
            "mk = mapkeys(r);",
            "if ((!(\"Meta\" in mk)) && (!(\"Value\" in mk)))",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "endif",
            "old = this:read_value(o, a, options);",
            "if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')",
            "return old;",
            "endif",
            "try",
            "mk = mapkeys(r[\"Value\"]);",
            "if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\"})",
            "if (\"clear\" in mk)",
            "r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];",
            "return r;",
            "endif",
            "if (\"owner\" in mk)",
            "r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];",
            "return r;",
            "endif",
            "if (\"perms\" in mk)",
            "r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];",
            "return r;",
            "endif",
            "endif",
            "c = `r[\"Value\"][\"clear\"] ! E_RANGE';",
            "if (c)",
            "clear_property(o, a);",
            "else",
            "v = r[\"Value\"][\"value\"];",
            "if (a == \"location\")",
            "(o.location != v) && move(o, v);",
            "else",
            "o.(a) = v;",
            "endif",
            "endif",
            "if ((\"owner\" in mk) || (\"perms\" in mk))",
            "set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});",
            "endif",
            "except (E_RANGE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_INVIND)",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "except (E_PROPNF)",
            "r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "except (E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];",
            "return r;",
            "except (E_NACC)",
            "r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];",
            "return r;",
            "except (E_RECMOVE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];",
            "return r;",
            "endtry",
            "return this:read_value(o, a, options);"
          ]
        },
        {
          "name": "_write_parents",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, r} = args;",
            "set_task_perms(caller_perms());",
            "try",
            "v = r[\"Value\"][\"value\"];",
            "(parents(o) != v) && chparents(o, v);",
            "except (E_RANGE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_INVARG)",
            "r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];",
            "return r;",
            "except (E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "endtry",
            "v = parents(o);",
            "m = [\"id\" -> \"parents\"];",
            "m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";",
            "return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];"
          ]
        },
        {
          "name": "_write_player",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, r} = args;",
            "set_task_perms(caller_perms());",
            "try",
            "v = r[\"Value\"][\"value\"];",
            "(is_player(o) != v) && set_player_flag(o, v);",
            "except (E_RANGE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_INVARG)",
            "r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];",
            "return r;",
            "except (E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "endtry",
            "v = is_player(o);",
            "m = [\"id\" -> \"player\"];",
            "m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";",
            "return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];"
          ]
        },
        {
          "name": "read_verb",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, v} = args;",
            "try",
            "vx = verbs(o);",
            "except (E_TYPE, E_INVARG)",
            "r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];",
            "return r;",
            "endtry",
            "try",
            "vn = vx[v];",
            "except (E_TYPE, E_RANGE)",
            "r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];",
            "return r;",
            "endtry",
            "set_task_perms(caller_perms());",
            "try",
            "vi = verb_info(o, v);",
            "va = verb_args(o, v);",
            "vc = verb_code(o, v);",
            "p = (index(vi[2], \"w\") || this:_controls_verb(caller_perms(), o, v)) ? \"rw\" | \"r\";",
            "except (E_TYPE, E_INVARG, E_VERBNF)",
            "r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];",
            "return r;",
            "except (E_PERM)",
            "r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"denied\"]];",
            "return r;",
            "endtry",
            "m = [\"id\" -> v];",
            "m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";",
            "r = [\"Meta\" -> m, \"Verb\" -> [\"owner\" -> vi[1], \"perms\" -> vi[2], \"names\" -> vi[3], \"dobj\" -> va[1], \"prep\" -> va[2], \"iobj\" -> va[3], \"code\" -> vc]];",
            "return r;"
          ]
        },
        {
          "name": "write_verb",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, v, r, ?options = []} = args;",
            "error1 = error2 = 0;",
            "try",
            "vx = verbs(o);",
            "except (E_TYPE, E_INVARG)",
            "error1 = 1;",
            "endtry",
            "try",
            "vn = vx[v];",
            "except (E_VARNF)",
            "except (E_TYPE, E_RANGE)",
            "error2 = 1;",
            "endtry",
            "set_task_perms(caller_perms());",
            "old = this:read_verb(o, v);",
            "if (`old[\"Verb\"] ! E_RANGE' == `r[\"Verb\"] ! E_RANGE')",
            "return old;",
            "endif",
            "if (error1)",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "elseif (error2)",
            "r[\"Error\"] = [\"diagnostic\" -> \"verb is invalid\"];",
            "return r;",
            "endif",
            "try",
            "r1 = r[\"Verb\"];",
            "set_verb_info(o, v, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"names\"]});",
            "set_verb_args(o, v, {r1[\"dobj\"], r1[\"prep\"], r1[\"iobj\"]});",
            "vc = `r1[\"code\"] ! E_RANGE => {}';",
            "if (vc != E_RANGE)",
            "if (set_verb_code(o, v, vc))",
            "r[\"Error\"] = [\"diagnostic\" -> \"compilation errors\"];",
            "return r;",
            "endif",
            "endif",
            "except (E_RANGE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_INVIND, E_INVARG)",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "except (E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];",
            "return r;",
            "endtry",
            "return this:read_verb(o, v);"
          ]
        },
        {
          "name": "read_property",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, p, ?options = []} = args;",
            "try",
            "px = properties(o);",
            "except (E_TYPE, E_INVARG)",
            "r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];",
            "return r;",
            "endtry",
            "try",
            "pn = px[p];",
            "except (E_TYPE, E_RANGE)",
            "r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];",
            "return r;",
            "endtry",
            "set_task_perms(caller_perms());",
            "try",
            "pi = property_info(o, pn);",
            "pv = o.(pn);",
            "s = (index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, pn)) ? \"rw\" | \"r\";",
            "except (E_TYPE, E_INVARG, E_PROPNF)",
            "r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];",
            "return r;",
            "except (E_PERM)",
            "r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"denied\"]];",
            "return r;",
            "endtry",
            "m = [\"id\" -> p];",
            "m[\"status\"] = index(s, \"w\") ? \"writable\" | \"readable\";",
            "r = [\"Meta\" -> m, \"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];",
            "return r;"
          ]
        },
        {
          "name": "write_property",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{o, p, r, ?options = []} = args;",
            "error1 = error2 = 0;",
            "try",
            "px = properties(o);",
            "except (E_TYPE, E_INVARG)",
            "error1 = 1;",
            "endtry",
            "try",
            "pn = px[p];",
            "except (E_VARNF)",
            "except (E_TYPE, E_RANGE)",
            "error2 = 1;",
            "endtry",
            "set_task_perms(caller_perms());",
            "old = this:read_property(o, p);",
            "if (`old[\"Property\"] ! E_RANGE' == `r[\"Property\"] ! E_RANGE')",
            "return old;",
            "endif",
            "if (error1)",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "elseif (error2)",
            "r[\"Error\"] = [\"diagnostic\" -> \"property is invalid\"];",
            "return r;",
            "endif",
            "try",
            "r1 = r[\"Property\"];",
            "set_property_info(o, pn, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"name\"]});",
            "o.(r1[\"name\"]) = r1[\"value\"];",
            "except (E_RANGE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];",
            "return r;",
            "except (E_INVIND, E_INVARG)",
            "r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];",
            "return r;",
            "except (E_PERM)",
            "r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];",
            "return r;",
            "except (E_TYPE)",
            "r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];",
            "return r;",
            "endtry",
            "return this:read_property(o, p);"
          ]
        },
        {
          "name": "bare_object",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{?parents = {}} = args;",
            "o = [\"Attributes\" -> [], \"Values\" -> [], \"Properties\" -> {}, \"Verbs\" -> {}];",
            "if (parents)",
            "o[\"Attributes\"][\"parents\"] = [\"Value\" -> [\"value\" -> parents]];",
            "endif",
            "return o;"
          ]
        },
        {
          "name": "add_value",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{t, n, v} = args;",
            "t[\"Values\"][n] = [\"Value\" -> [\"value\" -> v]];",
            "return t;"
          ]
        },
        {
          "name": "add_property_definition",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{t, pn, pv, pi} = args;",
            "p = [\"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];",
            "t[\"Properties\"] = {@t[\"Properties\"], p};",
            "return t;"
          ]
        },
        {
          "name": "add_verb_definition",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 75,
          "code": [
            "{t, vi, va, ?vc = {}} = args;",
            "v = [\"Verb\" -> [\"owner\" -> vi[1], \"perms\" -> vi[2], \"names\" -> vi[3], \"dobj\" -> va[1], \"prep\" -> va[2], \"iobj\" -> va[3], \"code\" -> vc]];",
            "t[\"Verbs\"] = {@t[\"Verbs\"], v};",
            "return t;"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "76": {
      "id": 76,
      "name": "Programmer Options",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "actual",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "if (i = args[1] in {\"list_numbers\"})",
            "return {{{\"list_no_numbers\"}[i], !args[2]}};",
            "else",
            "return {args};",
            "endif"
          ]
        },
        {
          "name": "show",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "if (o = (name = args[2]) in {\"list_numbers\"})",
            "args[2] = {\"list_no_numbers\"}[o];",
            "return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "show_verb_args",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "if (value = this:get(@args))",
            "return {value, {tostr(\"Default args for @verb:  \", $string_utils:from_list(value, \" \"))}};",
            "else",
            "return {0, {\"Default args for @verb:  none none none\"}};",
            "endif"
          ]
        },
        {
          "name": "check_verb_args",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "value = args[1];",
            "if (typeof(value) != LIST)",
            "return \"List expected\";",
            "elseif (length(value) != 3)",
            "return \"List of length 3 expected\";",
            "elseif (!(value[1] in {\"this\", \"none\", \"any\"}))",
            "return tostr(\"Invalid dobj specification:  \", value[1]);",
            "elseif (!((p = $code_utils:short_prep(value[2])) || (value[2] in {\"none\", \"any\"})))",
            "return tostr(\"Invalid preposition:  \", value[2]);",
            "elseif (!(value[3] in {\"this\", \"none\", \"any\"}))",
            "return tostr(\"Invalid iobj specification:  \", value[3]);",
            "else",
            "if (p)",
            "value[2] = p;",
            "endif",
            "return {value};",
            "endif"
          ]
        },
        {
          "name": "parse_verb_args",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) == STR)",
            "raw = $string_utils:explode(raw, \" \");",
            "elseif (typeof(raw) == INT)",
            "return raw ? {oname, {\"this\", \"none\", \"this\"}} | {oname, 0};",
            "endif",
            "value = $code_utils:parse_argspec(@raw);",
            "if (typeof(value) != LIST)",
            "return tostr(value);",
            "elseif (value[2])",
            "return tostr(\"I don't understand \\\"\", $string_utils:from_list(value[2], \" \"), \"\\\"\");",
            "else",
            "value = {@value[1], \"none\", \"none\", \"none\"}[1..3];",
            "return {oname, (value == {\"none\", \"none\", \"none\"}) ? 0 | value};",
            "endif"
          ]
        },
        {
          "name": "show_@prop_flags",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "value = this:get(@args);",
            "if (value)",
            "return {value, {tostr(\"Default permissions for @property=`\", value, \"'.\")}};",
            "else",
            "return {0, {\"Default permissions for @property=`rc'.\"}};",
            "endif"
          ]
        },
        {
          "name": "check_@prop_flags",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": null
        },
        {
          "name": "parse_@prop_flags",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) != STR)",
            "return \"Must be a string composed of the characters `rwc'.\";",
            "endif",
            "len = length(raw);",
            "for x in [1..len]",
            "if (!(raw[x] in {\"r\", \"w\", \"c\"}))",
            "return \"Must be a string composed of the characters `rwc'.\";",
            "endif",
            "endfor",
            "return {oname, raw};"
          ]
        },
        {
          "name": "check_verb_perms",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "value = args[1];",
            "if (typeof(value) != STR)",
            "return \"Must be a string composed of the characters `RWXD'.\";",
            "elseif ((stripped = $string_utils:subst(value, {{\"R\", \"\"}, {\"W\", \"\"}, {\"X\", \"\"}, {\"D\", \"\"}})) != \"\")",
            "\"I know you can strip_all_but, but we want to report invalid values.\";",
            "return tostr(\"Invalid permission \", $s(\"character\", length(stripped)), \": \", stripped);",
            "else",
            "return {value};",
            "endif"
          ]
        },
        {
          "name": "show_verb_perms",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "if (value = this:get(@args))",
            "return {value, {tostr(\"Default permissions for @verb:  \", value)}};",
            "else",
            "return {0, {\"Default permissions for @verb:  rd\"}};",
            "endif"
          ]
        },
        {
          "name": "parse_verb_perms",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 76,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) == STR)",
            "raw = {raw};",
            "elseif (typeof(raw) == INT)",
            "return raw ? {oname, \"rxd\"} | {oname, 0};",
            "endif",
            "value = this:check_verb_perms(raw[1]);",
            "if (typeof(value) == STR)",
            "return value;",
            "endif",
            "if (value[1] == \"\")",
            "value = \"RD\";",
            "endif",
            "return {oname, (value[1] == \"RD\") ? 0 | value[1]};"
          ]
        }
      ],
      "propnames": [
        "show_eval_time",
        "show_list_all_parens",
        "show_list_no_numbers",
        "show_copy_expert",
        "type_@prop_flags",
        "show_list_show_permissions",
        "show_rmverb_mail_backup",
        "show_//_comments"
      ],
      "propdefs": [
        {
          "value": [
            "eval does not show ticks/seconds consumed.",
            "eval shows ticks/seconds consumed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@list shows only necessary parentheses by default",
            "@list shows all parentheses by default"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@list gives line numbers by default",
            "@list omits line numbers by default"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@copy prints warning message.",
            "@copy omits warning message."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            2
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@list does not display permissions in header",
            "@list displays permissions in header"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@rmverb does not email you a backup",
            "@rmverb emails you a backup before deleting the verb"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Comments shown in editors will be MOO-style.",
            "Comments shown in editors will begin with //"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "list_all_parens",
            "list_no_numbers",
            "eval_time",
            "copy_expert",
            "verb_args",
            "verb_perms",
            "@prop_flags",
            "list_show_permissions",
            "rmverb_mail_backup",
            "//_comments"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!list_all_parens!list_no_numbers!list_show_permissions!eval_time!copy_expert!list_numbers!verb_args!@prop_flags!rmverb_mail_backup!//_comments!verb_perms!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "list_numbers"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Programmer Options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Option package for $prog commands.  See `help @prog-options'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            10468,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "77": {
      "id": 77,
      "name": "Builder Options",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "check_create_flags",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 77,
          "code": [
            "value = args[1];",
            "if (m = match(value, \"[^rwf]\"))",
            "return tostr(\"Unknown object flag:  \", value[m[1]]);",
            "else",
            "return {tostr(index(value, \"r\") ? \"r\" | \"\", index(value, \"w\") ? \"w\" | \"\", index(value, \"f\") ? \"f\" | \"\")};",
            "endif"
          ]
        },
        {
          "name": "show_create_flags",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 77,
          "code": [
            "if (value = this:get(@args))",
            "return {value, {tostr(\"Object flags for @create:  \", value)}};",
            "else",
            "return {0, {tostr(\"@create leaves all object flags reset\")}};",
            "endif"
          ]
        },
        {
          "name": "parse_create_flags",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 77,
          "code": [
            "raw = args[2];",
            "if (raw == 1)",
            "\"...+create_flags => create_flags=r\";",
            "return {args[1], \"r\"};",
            "elseif (typeof(raw) == STR)",
            "return args[1..2];",
            "elseif (typeof(raw) != LIST)",
            "return \"???\";",
            "elseif (length(raw) > 1)",
            "return tostr(\"I don't understand \\\"\", $string_utils:from_list(listdelete(raw, 1), \" \"), \"\\\"\");",
            "else",
            "return {args[1], raw[1]};",
            "endif"
          ]
        },
        {
          "name": "show_dig_room show_dig_exit",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 77,
          "code": [
            "name = args[2];",
            "what = (verb == \"show_dig_room\") ? \"room\" | \"exit\";",
            "if ((value = this:get(args[1], name)) == 0)",
            "return {0, {tostr(\"@dig \", what, \"s are children of $\", what, \".\")}};",
            "else",
            "return {value, {tostr(\"@dig \", what, \"s are children of \", value, \" (\", valid(value) ? value.name | \"invalid\", \").\")}};",
            "endif"
          ]
        },
        {
          "name": "parse_dig_room parse_dig_exit",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 77,
          "code": [
            "{oname, raw, data} = args;",
            "if (typeof(raw) == LIST)",
            "if (length(raw) > 1)",
            "return tostr(\"I don't understand \\\"\", $string_utils:from_list(listdelete(raw, 1), \" \"), \"\\\".\");",
            "endif",
            "raw = raw[1];",
            "endif",
            "if (typeof(raw) != STR)",
            "return \"You need to give an object id.\";",
            "elseif ($command_utils:object_match_failed(value = player:my_match_object(raw), raw))",
            "return \"Option unchanged.\";",
            "endif",
            "what = (verb == \"parse_dig_room\") ? \"room\" | \"exit\";",
            "generic = #0.(what);",
            "if (value == generic)",
            "return {oname, 0};",
            "else",
            "if (!$object_utils:isa(value, generic))",
            "player:tell(\"Warning: \", value, \" is not a descendant of $\", what, \".\");",
            "endif",
            "return {oname, value};",
            "endif"
          ]
        }
      ],
      "propnames": [
        "show_bi_create",
        "type_dig_room",
        "type_dig_exit",
        "show_audit_bytes",
        "show_audit_float"
      ],
      "propdefs": [
        {
          "value": [
            "@create/@recycle re-use object numbers.",
            "@create/@recycle call create()/recycle() directly."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            1
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            1
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@audit/@prospectus shows `<1K'",
            "@audit/@prospectus shows bytes"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "@audit/@prospectus shows integer sizes (1K)",
            "@audit/@prospectus shows floating-point sizes (1.0K)"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "dig_room",
            "dig_exit",
            "create_flags",
            "bi_create",
            "audit_bytes",
            "audit_float"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!dig_room!dig_exit!create_flags!bi_create!audit_bytes!audit_float!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Builder Options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Option package for $builder commands.  See `help @build-options'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            6109,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "78": {
      "id": 78,
      "name": "Generic Utilities Package",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        20,
        55,
        24,
        27,
        41,
        26,
        43,
        51,
        52,
        53,
        56,
        42,
        21,
        33,
        13,
        79,
        81,
        59,
        91,
        93,
        99,
        124,
        126
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "help_msg"
      ],
      "propdefs": [
        {
          "value": [
            "This is the Generic Utility Object.  One presumes it should have text in it explaining the use of the utility object in question."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Generic Utilities Package"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "This is a placeholder parent for all the $..._utils packages, to more easily find them and manipulate them. At present this object defines no useful verbs or properties. (Filfre.)",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            835,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "79": {
      "id": 79,
      "name": "Byte Quota Utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "initialize_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "args[1].size_quota = this.default_quota;",
            "args[1].ownership_quota = this.large_negative_number;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "pass(@args);",
            "this.exempted = {};",
            "this.working = #2;",
            "this.task_time_limit = 500;",
            "this.repeat_cycle = 0;",
            "this.large_objects = {};",
            "this.report_recipients = {#2};",
            "this.default_quota = {100000, 0, 0, 1};",
            "$quota_utils = this;",
            "endif"
          ]
        },
        {
          "name": "adjust_quota_for_programmer",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "return 0;"
          ]
        },
        {
          "name": "bi_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "set_task_perms(caller_perms());",
            "who = this:parse_create_args(@args);",
            "\"Because who can be E_INVARG, need to catch E_TYPE. Let $recycler:_create deal with returning E_PERM since that's what's going to happen. Ho_Yan 11/19/96.\";",
            "if ((!`who.wizard ! E_TYPE => 0') && $recycler.contents)",
            "return $recycler:_create(@args);",
            "elseif (this:creation_permitted(who))",
            "this:enable_create(who);",
            "value = `create(@args) ! ANY';",
            "this:disable_create(who);",
            "if (typeof(value) != ERR)",
            "this:charge_quota(who, value);",
            "if ((typeof(who.owned_objects) == LIST) && (!(value in who.owned_objects)))",
            "this:add_owned_object(who, value);",
            "endif",
            "endif",
            "return value;",
            "else",
            "return E_QUOTA;",
            "endif"
          ]
        },
        {
          "name": "enable_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if ((caller != this) && (!caller_perms().wizard))",
            "return E_PERM;",
            "else",
            "args[1].ownership_quota = 1;",
            "endif"
          ]
        },
        {
          "name": "disable_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if ((caller != this) && (!caller_perms().wizard))",
            "return E_PERM;",
            "else",
            "args[1].ownership_quota = this.large_negative_number;",
            "endif"
          ]
        },
        {
          "name": "parse_create_args",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"This figures out who is gonna own the stuff @create does.  If one arg, return caller_perms().  If two args, then if caller_perms().wizard, args[2].\";",
            "{what, ?who = #-1} = args;",
            "if (!valid(who))",
            "return caller_perms();",
            "elseif ($perm_utils:controls(caller_perms(), who))",
            "return who;",
            "else",
            "return E_INVARG;",
            "endif"
          ]
        },
        {
          "name": "creation_permitted verb_addition_permitted property_addition_permitted",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Here's the tricky one.  Collect all the user's characters' cached usage data and total quotas.  Compare same.  If usage bigger than quotas, return 0.  Else, add up the total number of objects that haven't been measured recently.  If greater than the allowed, return 0.  Else, reluctantly, return 1.\";",
            "who = args[1];",
            "if (who.wizard || (who == $hacker))",
            "\"... sorry folks --Rog\";",
            "return 1;",
            "endif",
            "if ((!$object_utils:has_property(who, \"size_quota\")) || is_clear_property(who, \"size_quota\"))",
            "return 0;",
            "endif",
            "$recycler:check_quota_scam(who);",
            "allwho = this:all_characters(who);",
            "quota = 0;",
            "usage = 0;",
            "unmeasured = 0;",
            "for x in (allwho)",
            "quota = quota + x.size_quota[1];",
            "usage = usage + x.size_quota[2];",
            "unmeasured = unmeasured + x.size_quota[4];",
            "endfor",
            "if (usage >= quota)",
            "return 0;",
            "elseif (unmeasured >= this.max_unmeasured)",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "all_characters",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "{who} = args;",
            "if ((caller != this) && (!this:can_peek(caller_perms(), who)))",
            "return E_PERM;",
            "elseif ($object_utils:has_property($local, \"second_char_registry\"))",
            "seconds = $local.second_char_registry:all_second_chars(who);",
            "if (seconds == E_INVARG)",
            "return {who};",
            "else",
            "return seconds;",
            "endif",
            "else",
            "return {who};",
            "endif"
          ]
        },
        {
          "name": "display_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "who = args[1];",
            "if (this:can_peek(caller_perms(), who) && (length(all = this:all_characters(who)) > 1))",
            "many = 1;",
            "else",
            "many = 0;",
            "all = {who};",
            "endif",
            "if (many)",
            "tquota = 0;",
            "tusage = 0;",
            "ttime = $maxint;",
            "tunmeasured = 0;",
            "tunmeasurable = 0;",
            "endif",
            "for x in (all)",
            "{quota, usage, timestamp, unmeasured} = x.size_quota;",
            "unmeasurable = 0;",
            "if (unmeasured >= 100)",
            "unmeasurable = unmeasured / 100;",
            "unmeasured = unmeasured % 100;",
            "endif",
            "if (many)",
            "player:tell(x.name, \" quota: \", $string_utils:group_number(quota), \"; usage: \", $string_utils:group_number(usage), \"; unmeasured: \", unmeasured, \"; no .object_size: \", unmeasurable, \".\");",
            "tquota = tquota + quota;",
            "tusage = tusage + usage;",
            "ttime = min(ttime, timestamp);",
            "tunmeasured = tunmeasured + unmeasured;",
            "tunmeasurable = tunmeasurable + unmeasurable;",
            "endif",
            "endfor",
            "if (many)",
            "this:display_quota_summary(who, tquota, tusage, ttime, tunmeasured, tunmeasurable);",
            "else",
            "this:display_quota_summary(who, quota, usage, timestamp, unmeasured, unmeasurable);",
            "endif"
          ]
        },
        {
          "name": "get_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "return args[1].size_quota[1];"
          ]
        },
        {
          "name": "charge_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Charge args[1] for the quota required to own args[2]\";",
            "{who, what} = args;",
            "if ((caller == this) || caller_perms().wizard)",
            "usage_index = 2;",
            "unmeasured_index = 4;",
            "object_size = $object_utils:has_property(what, \"object_size\") ? what.object_size[1] | -1;",
            "if (object_size <= 0)",
            "who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] + 1;",
            "else",
            "who.size_quota[usage_index] = who.size_quota[usage_index] + object_size;",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "reimburse_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"reimburse args[1] for the quota required to own args[2]\";",
            "{who, what} = args;",
            "if ((caller == this) || caller_perms().wizard)",
            "usage_index = 2;",
            "unmeasured_index = 4;",
            "if (((valid(who) && is_player(who)) && $object_utils:has_property(what, \"object_size\")) && (!is_clear_property(who, \"size_quota\")))",
            "object_size = what.object_size[1];",
            "if (object_size <= 0)",
            "who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] - 1;",
            "else",
            "who.size_quota[usage_index] = who.size_quota[usage_index] - object_size;",
            "endif",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Set args[1]'s quota to args[2]\";",
            "if ((caller_perms().wizard || (caller == this)) || this:can_touch(caller_perms()))",
            "\"Size_quota[1] is the total quota permitted.\";",
            "return args[1].size_quota[1] = args[2];",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "get_size_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Return args[1]'s quotas.  second arg of 1 means add all second chars.\";",
            "{who, ?all = 0} = args;",
            "if (all && ((caller == this) || this:can_peek(caller_perms(), who)))",
            "all = this:all_characters(who);",
            "else",
            "all = {who};",
            "endif",
            "baseline = {0, 0, 0, 0};",
            "for x in (all)",
            "baseline[1] = baseline[1] + x.size_quota[1];",
            "baseline[2] = baseline[2] + x.size_quota[2];",
            "baseline[3] = min(baseline[3], x.size_quota[3]) || x.size_quota[3];",
            "baseline[4] = baseline[4] + x.size_quota[4];",
            "endfor",
            "return baseline;"
          ]
        },
        {
          "name": "display_quota_summary",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "{who, quota, usage, timestamp, unmeasured, unmeasurable} = args;",
            "player:tell(who.name, \" has a total building quota of \", $string_utils:group_number(quota), \" bytes.\");",
            "player:tell($gender_utils:get_pronoun(\"P\", who), \" total usage was \", $string_utils:group_number(usage), \" as of \", player:ctime(timestamp), \".\");",
            "if (usage > quota)",
            "player:tell(who.name, \" is over quota by \", $string_utils:group_number(usage - quota), \" bytes.\");",
            "else",
            "player:tell(who.name, \" may create up to \", $string_utils:group_number(quota - usage), \" more bytes of objects, properties, or verbs.\");",
            "endif",
            "if (unmeasured)",
            "plural = unmeasured != 1;",
            "player:tell(\"There \", plural ? tostr(\"are \", unmeasured, \" objects\") | \"is 1 object\", \" which \", plural ? \"are\" | \"is\", \" not yet included in the tally; this tally may thus be inaccurate.\");",
            "if (unmeasured >= this.max_unmeasured)",
            "player:tell(\"The number of unmeasured objects is too large; no objects may be created until @measure new is used.\");",
            "endif",
            "endif",
            "if (unmeasurable)",
            "plural = unmeasurable != 1;",
            "player:tell(\"There \", plural ? tostr(\"are \", unmeasurable, \" objects\") | \"is 1 object\", \" which do\", plural ? \"\" | \"es\", \" not have a .object_size property and will thus prevent additional building.\", (who == player) ? \"  Contact a wizard for assistance in having this situation repaired.\" | \"\");",
            "endif"
          ]
        },
        {
          "name": "quota_remaining",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"This wants to only be called by a wizard cuz I'm lazy.  This is just for @second-char anyway.\";",
            "if (caller_perms().wizard)",
            "q = this:get_size_quota(args[1], 1);",
            "return q[1] - q[2];",
            "endif"
          ]
        },
        {
          "name": "value_bytes",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "return value_bytes(args[1]);",
            "set_task_perms(caller_perms());",
            "v = args[1];",
            "t = typeof(v);",
            "if (t == LIST)",
            "b = ((length(v) + 1) * 2) * 4;",
            "for vv in (v)",
            "$command_utils:suspend_if_needed(2);",
            "b = b + this:value_bytes(vv);",
            "endfor",
            "return b;",
            "elseif (t == STR)",
            "return length(v) + 1;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "object_bytes object_size",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"No need for lengthy algorithms to measure an object, we have a builtin now. Ho_Yan 10/31/96\";",
            "set_task_perms($wiz_utils:random_wizard());",
            "o = args[1];",
            "if (((($object_utils:has_property(o, \"object_size\") && (o.object_size[1] > this.too_large)) && (!caller_perms().wizard)) && (caller_perms() != this.owner)) && (caller_perms() != $hacker))",
            "return o.object_size[1];",
            "endif",
            "b = object_bytes(o);",
            "if ($object_utils:has_property(o, \"object_size\"))",
            "oldsize = is_clear_property(o, \"object_size\") ? 0 | o.object_size[1];",
            "if ($object_utils:has_property(o.owner, \"size_quota\"))",
            "\"Update quota cache.\";",
            "if (oldsize)",
            "o.owner.size_quota[2] = o.owner.size_quota[2] + (b - oldsize);",
            "else",
            "o.owner.size_quota[2] = o.owner.size_quota[2] + b;",
            "if (o.owner.size_quota[4] > 0)",
            "o.owner.size_quota[4] = o.owner.size_quota[4] - 1;",
            "endif",
            "endif",
            "endif",
            "o.object_size = {b, time()};",
            "endif",
            "if (b > this.too_large)",
            "this.large_objects = setadd(this.large_objects, o);",
            "endif",
            "return b;"
          ]
        },
        {
          "name": "do_summary",
          "owner": 36,
          "perms": 157,
          "preps": 0,
          "object": 79,
          "code": [
            "who = args[1];",
            "results = this:summarize_one_user(who);",
            "{total, nuncounted, nzeros, oldest, eldest} = results;",
            "player:tell(who.name, \" statistics:\");",
            "player:tell(\"  \", $string_utils:group_number(total), \" bytes of storage measured.\");",
            "player:tell(\"  Oldest measurement date \", ctime(oldest), \" (\", $string_utils:from_seconds(time() - oldest), \" ago) of object \", eldest, \" (\", valid(eldest) ? eldest.name | \"$nothing\", \")\");",
            "if (nzeros || nuncounted)",
            "player:tell(\"  Number of objects with no statistics recorded:  \");",
            "player:tell(\"      \", nzeros, \" recently created, \", nuncounted, \" not descendents of #1\");",
            "endif"
          ]
        },
        {
          "name": "summarize_one_user",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Summarizes total space usage by one user (args[1]).  Optional second argument is a flag to say whether to re-measure all objects for this user; specify the number of seconds out of date you are willing to accept.  If negative, will only re-measure objects which have no recorded data.\";",
            "\"Returns a list of four values:\";",
            "\"  total : total measured space in bytes\";",
            "\"  uncounted : Number of objects that were not counted because they aren't descendents of #1\";",
            "\"  zeros : Number of objects which have been created too recently to have any measurement data at all (presumably none if re-measuring)\";",
            "\"  most-out-of-date : the time() the oldest actual measurement was taken\";",
            "\"  object-thereof: the object who had this time()'d measurement\";",
            "who = args[1];",
            "if (length(args) == 2)",
            "if (args[2] < 0)",
            "earliest = 1;",
            "else",
            "earliest = time() - args[2];",
            "endif",
            "else",
            "earliest = 0;",
            "endif",
            "nzeros = 0;",
            "oldest = time();",
            "eldest = #-1;",
            "nuncounted = 0;",
            "total = 0;",
            "for x in ((typeof(who.owned_objects) == LIST) ? who.owned_objects | {})",
            "if (x.owner == who)",
            "\"Bulletproofing against recycling during suspends!\";",
            "\"Leaves us open to unsummarized creation during this period, which is unfortunate.\";",
            "if ($object_utils:has_property(x, \"object_size\"))",
            "size = x.object_size[1];",
            "time = x.object_size[2];",
            "if (time < earliest)",
            "\"Re-measure.  This side-effects x.object_size.\";",
            "this:object_bytes(x);",
            "size = x.object_size[1];",
            "time = x.object_size[2];",
            "endif",
            "if (time && (time <= oldest))",
            "oldest = time;",
            "eldest = x;",
            "elseif (!time)",
            "nzeros = nzeros + 1;",
            "endif",
            "if (size >= 0)",
            "total = total + size;",
            "endif",
            "else",
            "nuncounted = nuncounted + 1;",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (!is_clear_property(who, \"size_quota\"))",
            "\"Cache the data, but only if they aren't scamming.\";",
            "who.size_quota[2] = total;",
            "who.size_quota[3] = oldest;",
            "who.size_quota[4] = (nuncounted * this.unmeasured_multiplier) + nzeros;",
            "endif",
            "return {total, nuncounted, nzeros, oldest, eldest};"
          ]
        },
        {
          "name": "recent_object_bytes",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\":recent_object_bytes(x, n) -- return object size of x, guaranteed to be no more than n days old.  N defaults to this.cycle_days.\";",
            "{object, ?since = this.cycle_days} = args;",
            "if (!valid(object))",
            "return 0;",
            "elseif (`object.object_size[2] ! ANY => 0' > (time() - (((since * 24) * 60) * 60)))",
            "\"Trap error when doesn't have .object_size for some oddball reason. Ho_Yan 11/19/96\";",
            "return object.object_size[1];",
            "else",
            "return this:object_bytes(object);",
            "endif"
          ]
        },
        {
          "name": "measurement_task",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "start_time = time();",
            "{num_processed, num_repetitions} = this:measurement_task_body(args[1]);",
            "players = players();",
            "lengthp = length(players);",
            "if ((!num_repetitions) && (num_processed < (lengthp / 2)))",
            "\"Add this in because we aren't getting people summarized like we should.  We're going to work for way longer now, cuz we're going to do a second pass, but we really need to get those summaries done.  Only do this if we hardly did any work.  Note the -1 here: measure all newly created objects as well.  More work, sigh.\";",
            "extra_end = time() + (3600 * 3);",
            "for x in (players)",
            "if (is_player(x) && (time() < extra_end))",
            "\"Robustness as above, plus don't run all day.  My kingdom for a break statement\";",
            "this:summarize_one_user(x, -1);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "$mail_agent:send_message(player, this.report_recipients, \"quota-utils report\", {tostr(\"About to measure objects of player \", this.working.name, \" (\", this.working, \"), \", $string_utils:ordinal(this.working in players), \" out of \", lengthp, \".  We processed \", num_processed + (lengthp * num_repetitions), \" players in this run in \", num_repetitions, \" time\", (num_repetitions == 1) ? \"\" | \"s\", \" through all players.  Total time spent:  \", $time_utils:dhms(time() - start_time), \".\")});",
            "endif"
          ]
        },
        {
          "name": "can_peek",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "return (args[1] == this.owner) || $perm_utils:controls(args[1], args[2]);"
          ]
        },
        {
          "name": "can_touch",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "return args[1].wizard;"
          ]
        },
        {
          "name": "do_breakdown",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "dobj = args[1];",
            "who = valid(caller_perms()) ? caller_perms() | player;",
            "if (!this:can_peek(who, dobj.owner))",
            "return E_PERM;",
            "endif",
            "props = $object_utils:all_properties_suspended(dobj);",
            "grand_total = obj_over = this:object_overhead_bytes(dobj);",
            "output = {tostr(\"Object overhead:  \", obj_over)};",
            "if (props)",
            "total = 0;",
            "lines = {};",
            "output = {@output, \"Properties, defined and inherited, sorted by size:\"};",
            "for x in (props)",
            "$command_utils:suspend_if_needed(0, \"...One moment. Working on the breakdown...\");",
            "if (!is_clear_property(dobj, x))",
            "size = value_bytes(dobj.(x));",
            "total = total + size;",
            "if (size)",
            "lines = {@lines, {x, size}};",
            "endif",
            "endif",
            "endfor",
            "lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));",
            "for x in (lines)",
            "$command_utils:suspend_if_needed(0, \"...One moment. Working on the breakdown...\");",
            "text = tostr(\"  \", x[1], \":  \", x[2]);",
            "output = {@output, text};",
            "endfor",
            "output = {@output, tostr(\"Total size of properties:  \", total)};",
            "grand_total = grand_total + total;",
            "endif",
            "prop_over = this:property_overhead_bytes(dobj, props);",
            "output = {@output, tostr(\"Property overhead:  \", prop_over)};",
            "grand_total = grand_total + prop_over;",
            "if (verbs(dobj))",
            "output = {@output, \"Verbs, sorted by size:\"};",
            "total = 0;",
            "lines = {};",
            "for x in [1..length(verbs(dobj))]",
            "$command_utils:suspend_if_needed(0, \"...One moment. Working on the breakdown...\");",
            "vname = verb_info(dobj, x)[3];",
            "size = (value_bytes(verb_code(dobj, x, 0, 0)) + length(vname)) + 1;",
            "total = total + size;",
            "lines = {@lines, {vname, size}};",
            "endfor",
            "lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));",
            "for x in (lines)",
            "$command_utils:suspend_if_needed(0, \"...One moment. Working on the breakdown...\");",
            "text = tostr(\"  \", x[1], \":  \", x[2]);",
            "output = {@output, text};",
            "endfor",
            "output = {@output, tostr(\"Total size of verbs:  \", total)};",
            "grand_total = grand_total + total;",
            "verb_over = this:verb_overhead_bytes(dobj);",
            "output = {@output, tostr(\"Verb overhead:  \", verb_over)};",
            "grand_total = grand_total + verb_over;",
            "endif",
            "output = {@output, tostr(\"Grand total:  \", grand_total)};",
            "return output;",
            "\"Last modified Sun Dec 31 10:12:14 2006 PST, by Roebare (#109000) @ LM.\";"
          ]
        },
        {
          "name": "object_overhead_bytes",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "object = args[1];",
            "return ((13 * 4) + length(object.name)) + 1;"
          ]
        },
        {
          "name": "property_overhead_bytes",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "{o, ?ps = $object_utils:all_properties_suspended(o)} = args;",
            "return (value_bytes(properties(o)) - 4) + ((length(ps) * 4) * 4);"
          ]
        },
        {
          "name": "verb_overhead_bytes",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "o = args[1];",
            "vs = verbs(o);",
            "return (length(vs) * 5) * 4;"
          ]
        },
        {
          "name": "add_owned_object",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\":add_owned_object(who, what) -- adds what to whose .owned_objects.\";",
            "{who, what} = args;",
            "if ((typeof(who.owned_objects) == LIST) && (what.owner == who))",
            "who.owned_objects = setadd(who.owned_objects, what);",
            "endif"
          ]
        },
        {
          "name": "measurement_task_nofork",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"This is a one-shot run of the measurement task, as opposed to :measurement_task, which will fork once per day.\";",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "{num_processed, num_repetitions} = this:measurement_task_body();",
            "$mail_agent:send_message(player, player, \"quota-utils report\", {\"finished one shot run of measurement task: processed \", num_processed, \" players in \", num_repetitions, \" runs through all players.\"});",
            "endif"
          ]
        },
        {
          "name": "measurement_task_body",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "num_processed = 0;",
            "num_repetitions = 0;",
            "usage_index = 2;",
            "time_index = 3;",
            "unmeasured_index = 4;",
            "players = setremove(players(), $hacker);",
            "lengthp = length(players);",
            "index = this.working in players;",
            "keep_going = 1;",
            "if (!index)",
            "\"Uh, oh, our guy got reaped while we weren't looking.  Better look for someone else.\";",
            "index = 1;",
            "while ((this.working > players[index]) && (index < lengthp))",
            "$command_utils:suspend_if_needed(0);",
            "index = index + 1;",
            "endwhile",
            "this.working = players[index];",
            "endif",
            "day = (60 * 60) * 24;",
            "stop = time() + args[1];",
            "early = time() - (day * this.cycle_days);",
            "tooidle = day * this.cycle_days;",
            "\"tooidletime is only used if !this.repeat_cycle.\";",
            "tooidletime = time() - tooidle;",
            "local_per_player_hack = $object_utils:has_verb($local, \"per_player_daily_scan\");",
            "while ((time() < stop) && keep_going)",
            "who = players[index];",
            "if (is_player(who) && $object_utils:has_property(who, \"size_quota\"))",
            "\"Robustness in the face of reaping...\";",
            "if ((!this.repeat_cycle) || ((who.last_disconnect_time > tooidletime) && (who.last_disconnect_time != $maxint)))",
            "\"only measure people who login regularly if we're a big moo.\";",
            "usage = 0;",
            "unmeasured = 0;",
            "earliest = time();",
            "for o in (who.owned_objects)",
            "if ((valid(o) && (o.owner == who)) && (!(o in this.exempted)))",
            "\"sanity check: might have recycled while we suspended!\";",
            "if ($object_utils:has_property(o, \"object_size\"))",
            "if (o.object_size[2] < early)",
            "usage = usage + this:object_bytes(o);",
            "else",
            "usage = usage + o.object_size[1];",
            "earliest = min(earliest, o.object_size[2]);",
            "endif",
            "else",
            "unmeasured = unmeasured + 1;",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(3);",
            "endfor",
            "if (!is_clear_property(who, \"size_quota\"))",
            "who.size_quota[usage_index] = usage;",
            "who.size_quota[unmeasured_index] = this.unmeasured_multiplier * unmeasured;",
            "who.size_quota[time_index] = earliest;",
            "else",
            "$mail_agent:send_message(player, player, \"Quota Violation\", {tostr(who, \" has a clear .size_quota property.\"), $string_utils:names_of({who, @$object_utils:ancestors(who)})});",
            "endif",
            "elseif (who.size_quota[unmeasured_index])",
            "\"If they managed to create an object *despite* being too idle (presumably programmatically), measure it.\";",
            "this:summarize_one_user(who, -1);",
            "endif",
            "elseif (is_player(who))",
            "\"They don't have a size_quota property.  Whine.\";",
            "$mail_agent:send_message(player, player, \"Quota Violation\", {tostr(who, \" doesn't seem to have a .size_quota property.\"), $string_utils:names_of({who, @$object_utils:ancestors(who)})});",
            "endif",
            "if (local_per_player_hack)",
            "$local:per_player_daily_scan(who);",
            "endif",
            "if (index >= lengthp)",
            "index = 1;",
            "else",
            "index = index + 1;",
            "endif",
            "num_processed = num_processed + 1;",
            "if (num_processed > lengthp)",
            "if (this.repeat_cycle)",
            "\"If we've gotten everyone up to threshold, try measuring some later than that.\";",
            "early = early + ((24 * 60) * 60);",
            "tooidle = tooidle * 4;",
            "tooidletime = tooidletime - tooidle;",
            "num_repetitions = num_repetitions + 1;",
            "num_processed = 0;",
            "if (early > time())",
            "\"Don't spin our wheels when we've measured everything!\";",
            "keep_going = 0;",
            "endif",
            "else",
            "keep_going = 0;",
            "endif",
            "endif",
            "this.working = players[index];",
            "endwhile",
            "return {num_processed, num_repetitions};",
            "endif"
          ]
        },
        {
          "name": "schedule_measurement_task",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "if ((caller == this) || caller_perms().wizard)",
            "day = 24 * 3600;",
            "hour_of_day_GMT = 8;",
            "fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))",
            "this:schedule_measurement_task();",
            "this.measurement_task_running = task_id();",
            "this:measurement_task(this.task_time_limit);",
            "this.measurement_task_running = 0;",
            "endfork",
            "endif"
          ]
        },
        {
          "name": "task_perms",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"Put all your wizards in $byte_quota_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.\";",
            "$wiz_utils.old_task_perms_user = setadd($wiz_utils.old_task_perms_user, caller);",
            "return $wiz_utils:random_wizard();"
          ]
        },
        {
          "name": "property_exists",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 79,
          "code": [
            "\"this:property_exists(object, property)\";",
            "\" => does the specified property exist?\";",
            "return !(!`property_info(@args) ! ANY');"
          ]
        }
      ],
      "propnames": [
        "default_quota",
        "large_negative_number",
        "max_unmeasured",
        "unmeasured_multiplier",
        "working",
        "cycle_days",
        "task_time_limit",
        "byte_based",
        "exempted",
        "task_repeat",
        "repeat_cycle",
        "too_large",
        "large_objects",
        "report_recipients",
        "measurement_task_running"
      ],
      "propdefs": [
        {
          "value": [
            20000,
            0,
            0,
            1
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": -10000,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 10,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 100,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 98,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 5,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 500,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1000000,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            32
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Verbs a user might want to call from a program:",
            " :bi_create -- built-in create() call, takes same args.",
            "",
            " :get_quota(who) -- just get the raw size_quota property",
            " :display_quota(who) -- prints to player the quota of who.  If caller_perms() controls who, include any secondary characters.  Called by @quota.",
            " :get_size_quota(who [allchars]) -- return the quota of who, if allchars flag set, add info from all secondary chars, if caller_perms() permits.",
            "",
            " :value_bytes(value) -- computes the size of the value.",
            " :object_bytes(object) -- computes the size of the object and caches it.",
            " :recent_object_bytes(object, days) -- computes and caches the size of object only if cached value more than days old.  Returns cached value.",
            " :do_summary(user) -- prints out the results of summarize-one-user.",
            " :summarize_one_user(user) -- summarizes and caches space usage for user.  See verb help for details.",
            "",
            "Verbs the system calls:",
            " :\"creation_permitted verb_addition_permitted property_addition_permitted\"(who) -- returns true if who is permitted to build.",
            " :initialize_quota(who) -- sets quota for newly created players",
            " :adjust_quota_for_programmer(who) -- empty; might add more quota to newly @progged player.",
            " :enable_create(who) -- sets .ownership_quota to 1",
            " :disable_create(who) -- sets .ownership_quota back to -1000 to prohibit create()",
            " :charge_quota(who, object) -- subtract the size of object from who's quota.  Manipulates the #-unmeasured if what is not currently measured.  Called by $wiz_utils:set_owner.",
            " :reimburse_quota(who, object) -- add the size of object to who's quota.  Ditto.",
            " :preliminary_reimburse_quota(who, object) -- Because the set_owner is done *after* an object has been turned into $garbage, ordinary reimbursement fails.  So we use this verb in the $recycler.",
            " :set_quota(who, howmuch)",
            " :quota_remaining(who) ",
            " :display_quota_summary -- internal, called by display quota",
            "",
            "The measurement task:",
            "",
            " :measurement_task() -- runs once every 24 hours measuring stuff, separated from the scheduling in case you just want to run it once.  Calls the body and then reports via moomail.",
            " :schedule_measurement_task() -- actually schedules it.  Look here to change the start time.",
            " :measurement_task_body(timeout) -- does the real work, working for no longer than timeout seconds.",
            " .task_time_limit -- integer number of seconds indicating for how long it should run each day.",
            " .working -- object indicating the player whom it is either working on now (or if not running) will pick up working on when it commences tonight.",
            " .cycle_days -- integer numbers indicating how long ago an object must have been measured before it will be remeasured.",
            " .repeat_cycle -- boolean.  0 means have a vanilla cycle (goes through all players() exactly once measuring their objects measured more than .cycle_days ago).  1 means to have a much more complex algorithm: The first cycle, it only measures stuff owned by people who have logged in within .cycle_days.  If, in .task_time_limit seconds, it measures all objects not measured in cycle_days owned by such people, it will run again measuring those objects which have not been measured in cycle_days - 1, considering people who have logged in within 4 * cycle_days, repeating until it has used up its seconds.  (\"Doing some of tomorrow's work.\")  Selecting .repeat_cycle = 1 is appropriate only for large MOOs.",
            " .exempted -- list of objects to never measure (useful if there are huge objects).  Suggested huge objects include $player_db and $site_db.",
            " .measurement_task -- indicates the task_id() of the most recent measurement task -- used to prevent duplicate invocation.",
            " .report_recipients -- recipients of the daily reports.  Set to {} to disable reporting entirely.",
            "",
            "See help @measure and help @quota for the command line verbs.",
            "",
            "",
            "Porter's notes:  If you are planning on porting this system to another MOO, here are the things to grab in addition to @dumping all of $quota_utils:",
            "",
            "The following verbs have been changed on $prog:",
            "@prop*erty @verb @copy (@add-alias @copy-move as well)",
            "",
            "The following verbs have been changed on $wiz:",
            "@programmer @quota",
            "",
            "The following verbs have been changed on $wiz_utils:",
            "set_programmer set_owner make_player",
            "",
            "The following verbs have been changed on $builder:",
            "@quota _create",
            "",
            "This verb probably should have gone on $builder.",
            "@measure",
            "",
            "The followig verbs have been changed on $recycler",
            "_recycle _create setup_toad",
            "",
            "The following verb has been changed on $login:",
            "create",
            "",
            "And don't forget $object_quota_utils, which has the object based implementation."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Byte Quota Utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the Byte Quota Utilities utility package.  See `help $quota_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            44035,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "80": {
      "id": 80,
      "name": "@paranoid database",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "ensure_props_exist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "\"*Must* be called with PDATA first, and LINES second.\";",
            "if ((caller != this) && (!caller_perms().wizard))",
            "return E_PERM;",
            "else",
            "try",
            "this.(args[2]);",
            "except (E_PROPNF)",
            "add_property(this, args[2], {}, {$hacker, \"\"});",
            "endtry",
            "try",
            "this.(args[3]);",
            "except (E_PROPNF)",
            "add_property(this, args[3], 5, {$hacker, \"\"});",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "if (!caller_perms().wizard)",
            "return;",
            "else",
            "for x in (properties(this))",
            "if (x[1] == \"#\")",
            "delete_property(this, x);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "add_data",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "{who, newdata} = args;",
            "if (is_player(who) && caller_perms().wizard)",
            "\"if ($perm_utils:controls(caller_perms(), who) && is_player(who))\";",
            "d = tostr(who, \"pdata\");",
            "l = tostr(who, \"lines\");",
            "this:ensure_props_exist(who, d, l);",
            "data = this.(d);",
            "lines = this.(l);",
            "\"Icky G7 code copied straight out of $player:tell.\";",
            "if (((len = length(this.(d) = {@data, newdata})) * 2) > (lines * 3))",
            "this.(d) = this.(d)[(len - lines) + 1..len];",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "get_data",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "who = args[1];",
            "if ($perm_utils:controls(caller_perms(), who))",
            "d = tostr(who, \"pdata\");",
            "if (typeof(`this.(d) ! ANY') == LIST)",
            "return this.(d);",
            "else",
            "return {};",
            "endif",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "erase_data",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "who = args[1];",
            "if ($perm_utils:controls(caller_perms(), who))",
            "d = tostr(who, \"pdata\");",
            "\"OK if this would toss its cookies if no prop, no damage.\";",
            "`this.(d) = {} ! ANY';",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_kept_lines",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "maximum = this.max_lines;",
            "who = args[1];",
            "if ($perm_utils:controls(caller_perms(), who) && is_player(who))",
            "l = tostr(who, \"lines\");",
            "this:ensure_props_exist(who, l, l);",
            "kept = min(args[2], maximum);",
            "this.(l) = kept;",
            "return kept;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "gc",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "if ((((caller != this) && (caller_perms() != #-1)) && (caller_perms() != player)) || (!player.wizard))",
            "$error:raise(E_PERM);",
            "endif",
            "threshold = ((60 * 60) * 24) * 3;",
            "for x in (properties(this))",
            "if (x[1] == \"#\")",
            "l = length(x);",
            "who = toobj(x[1..l - 5]);",
            "if (((!valid(who)) || (!is_player(who))) || (!this:is_paranoid(who)))",
            "delete_property(this, x);",
            "else",
            "if (index(x, \"lines\"))",
            "if (typeof(this.(x)) != INT)",
            "this.(x) = 10;",
            "endif",
            "elseif (index(x, \"pdata\"))",
            "if (((!$object_utils:connected(who)) && (who.last_disconnect_time < (time() - threshold))) && (who.last_connect_time < (time() - threshold)))",
            "this.(x) = {};",
            "endif",
            "if (typeof(this.(x)) != LIST)",
            "this.(x) = {};",
            "endif",
            "endif",
            "endif",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor"
          ]
        },
        {
          "name": "help_msg",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "return this:description();"
          ]
        },
        {
          "name": "semiweeklyish",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "threedays = (3 * 24) * 3600;",
            "fork ((((7 * 60) * 60) + threedays) - (time() % threedays))",
            "this:(verb)();",
            "endfork",
            "this:gc();",
            "endif"
          ]
        },
        {
          "name": "is_paranoid",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 80,
          "code": [
            "\"Some people make their .paranoid !r.  Wizardly verb to retrieve value.\";",
            "return `args[1].paranoid ! ANY';"
          ]
        }
      ],
      "propnames": [
        "max_lines"
      ],
      "propdefs": [
        {
          "value": 30,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "@paranoid database",
            "paranoid"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "This object stores the @paranoid data from :tell.  Normally it is not necessary to access these things directly.  All verbs are controlled by a caller_perms() check.  All data is stored in the old .responsible format.",
            "",
            ":add_data(who,data) adds one line's worth of data to the collection, trimming from the front as necessary.",
            "",
            ":get_data(who) retrieves the entire batch of data.",
            "",
            ":erase_data(who) sets the data to {}",
            "",
            ":set_kept_lines(who,number) Changes the number of kept lines.  Maximum is 20.",
            "",
            "Core verbs that call the above are this are $player:tell, @check, @paranoid, and :erase_paranoid_data.",
            "",
            "Internal:  ",
            "   Properties used are",
            "   tostr(player)+\"lines\"",
            "   tostr(player)+\"pdata\"",
            "   :ensure_props_exist(who,linesname,dataname):  creates the above",
            "   :GC() --- loops over all data and verifies they're for players."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            9154,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "81": {
      "id": 81,
      "name": "Object Quota Utilities",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "initialize_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "args[1].ownership_quota = $wiz_utils.default_player_quota;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "pass(@args);",
            "\"Uncomment this if you want to send the core out with object quota.\";",
            "\"  $quota_utils = this\";",
            "endif"
          ]
        },
        {
          "name": "adjust_quota_for_programmer",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "else",
            "victim = args[1];",
            "oldquota = victim.ownership_quota;",
            "if ($object_utils:has_property($local, \"second_char_registry\") && $local.second_char_registry:is_second_char(victim))",
            "\"don't increment quota for 2nd chars when programmering\";",
            "victim.ownership_quota = oldquota;",
            "else",
            "victim.ownership_quota = oldquota + ($wiz_utils.default_programmer_quota - $wiz_utils.default_player_quota);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "bi_create",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Calls built-in create.\";",
            "set_task_perms(caller_perms());",
            "return `create(@args) ! ANY';"
          ]
        },
        {
          "name": "creation_permitted",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "$recycler:check_quota_scam(args[1]);",
            "return args[1].ownership_quota > 0;"
          ]
        },
        {
          "name": "verb_addition_permitted property_addition_permitted",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "return 1;"
          ]
        },
        {
          "name": "display_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "who = args[1];",
            "if (caller_perms() == who)",
            "q = who.ownership_quota;",
            "total = (typeof(who.owned_objects) == LIST) ? length(setremove(who.owned_objects, who)) | 0;",
            "if (q == 0)",
            "player:tell(tostr(\"You can't create any more objects\", (total < 1) ? \".\" | tostr(\" until you recycle some of the \", total, \" you already own.\")));",
            "else",
            "player:tell(tostr(\"You can create \", q, \" new object\", (q == 1) ? \"\" | \"s\", (total == 0) ? \".\" | tostr(\" without recycling any of the \", total, \" that you already own.\")));",
            "endif",
            "else",
            "if ($perm_utils:controls(caller_perms(), who))",
            "player:tell(tostr(who.name, \"'s quota is currently \", who.ownership_quota, \".\"));",
            "else",
            "player:tell(\"Permission denied.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "get_quota quota_remaining",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "if ($perm_utils:controls(caller_perms(), args[1]) || (caller == this))",
            "return args[1].ownership_quota;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "charge_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Charge args[1] for the quota required to own args[2]\";",
            "{who, what} = args;",
            "if ((caller == this) || caller_perms().wizard)",
            "who.ownership_quota = who.ownership_quota - 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "reimburse_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Reimburse args[1] for the quota required to own args[2]\";",
            "{who, what} = args;",
            "if ((caller == this) || caller_perms().wizard)",
            "who.ownership_quota = who.ownership_quota + 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "set_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Set args[1]'s quota to args[2]\";",
            "{who, quota} = args;",
            "if (caller_perms().wizard || (caller == this))",
            "return who.ownership_quota = quota;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "preliminary_reimburse_quota",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "return 0;"
          ]
        },
        {
          "name": "can_peek",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Is args[1] permitted to examine args[2]'s quota information?\";",
            "return $perm_utils:controls(args[1], args[2]);"
          ]
        },
        {
          "name": "can_touch",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 81,
          "code": [
            "\"Is args[1] permitted to examine args[2]'s quota information?\";",
            "return args[1].wizard;"
          ]
        }
      ],
      "propnames": [
        "byte_based"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is the default package that interfaces to the $player/$prog quota manipulation verbs.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Object Quota Utilities"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This is the Object Quota Utilities utility package.  See `help $object_quota_utils' for more details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            10488,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "82": {
      "id": 82,
      "name": "Server Options",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "help_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 82,
          "code": [
            "output = {\"On $server_options, the following settings have been established by the wizards:\", \"\"};",
            "wizonly = {};",
            "etc = {};",
            "mentioned = {};",
            "for x in (setremove(properties(this), \"help_msg\"))",
            "if (index(x, \"protect_\") == 1)",
            "mentioned = {@mentioned, x[9..$]};",
            "wizonly = {@wizonly, tostr(x[9..$], \"() is \", this.(x) ? \"\" | \"not \", \"wizonly.\")};",
            "else",
            "etc = {@etc, tostr(\"$server_options.\", x, \" = \", $string_utils:print(this.(x)))};",
            "endif",
            "endfor",
            "if (\"set_verb_code\" in wizonly)",
            "wizonly = {@wizonly, \"\", \"Note: since the 'set_verb_code' built-in function is wiz-only, then the '.program' built-in command is wiz-only too.\"};",
            "endif",
            "if (bf = $set_utils:intersection(verbs(#0), mentioned))",
            "bf = $list_utils:sort(bf);",
            "etc = {@etc, \"\", \"In your code, #0:(built-in)(@args) should be called rather than built-in(@args) when you would use one of the following built-in functions:\", $string_utils:english_list(bf) + \".\", (((\"Example: #0:\" + bf[1]) + \"(@args) should be used instead of \") + bf[1]) + \"(@args)\"};",
            "endif",
            "return {@this.help_msg, @output, @wizonly, \"\", @etc};"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 82,
          "code": [
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "this.support_numeric_verbname_strings = 0;",
            "pass(@args);"
          ]
        }
      ],
      "propnames": [
        "protect_chparent",
        "protect_add_verb",
        "protect_add_property",
        "protect_recycle",
        "permit_writable_verbs",
        "protect_set_verb_info",
        "queued_task_limit",
        "help_msg",
        "support_numeric_verbname_strings",
        "connect_msg",
        "protect_force_input",
        "protect_set_property_info",
        "fg_ticks",
        "bg_ticks",
        "boot_msg",
        "protect_read",
        "dump_interval",
        "no_name_lookup",
        "protect_chparents"
      ],
      "propdefs": [
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 300,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "                Server Options <$server_options>",
            "                --------------------------------",
            "",
            "messages: 'boot_msg', 'connect_msg', 'create_msg', 'recycle_msg', 'redirect_from_msg', 'redirect_to_msg', and 'timeout_msg'.",
            "A number of the messages printed to a connection by the server under various circumstances can now be customized or eliminated from within the DB.  In each case, a property on $server_options is checked at the time the message would be printed.  If the property does not exist, the standard message is printed.  If the property exists and its value is not a string, then no message is printed at all.  Otherwise, the string is printed in place of the standard message.  The following list covers all of the newly customizable messages, showing for each the name of the relevant property on $server_options, the default/standard message, and the circumstances under which the message is printed:",
            "'boot_msg'              \"*** Disconnected ***\"",
            "The function boot_player() was called on this connection.",
            "'connect_msg'           \"*** Connected ***\"",
            "The user object that just logged in on this connection existed before #0:do_login_command() was called.",
            "'create_msg'            \"*** Created ***\"",
            "The user object that just logged in on this connection did not exist before #0:do_login_command() was called.",
            "'recycle_msg'           \"*** Recycled ***\"",
            "The logged-in user of this connection has been recycled.",
            "'redirect_from_msg'     \"*** Redirecting connection to new port ***\"",
            "The logged-in user of this connection has just logged in on some other connection.",
            "'redirect_to_msg'       \"*** Redirecting old connection to this port ***\"",
            "The user who just logged in on this connection was already logged in on some other connection.",
            "'timeout_msg'           \"*** Timed-out waiting for login. ***\"",
            "This in-bound network connection was idle and un-logged-in for at least CONNECT_TIMEOUT seconds (as defined in options.h).",
            "",
            "Note: on a 1.8rN server, changes to $server_options will not take effect until load_server_options() has been called.",
            "",
            "",
            "Some properties on $server_options can change the server behavior:",
            "",
            "'bg_seconds', 'bg_ticks', 'fg_seconds', and 'fg_ticks'.",
            "If those properties exist and are numbers, the server use them instead of the constants DEFAULT_BG_SECONDS, DEFAULT_BG_TICKS, DEFAULT_FG_SECONDS and DEFAULT_FG_TICKS (respectively) defined at compile time in \"options.h\"; they are looked up anew every time a task begins or resumes execution. Those define ticks (basic operations)/real-time seconds any task is allowed to use without suspending. 'fg' constants/properties are used only for 'foreground' tasks (those started by either player input or the server's initiative and that have never suspended); the 'bg' constants/properties are used only for 'background' tasks (forked tasks and those of any kind that have suspended).",
            "",
            "'max_stack_depth' This allow to change in-db the the maximum verb-call depth. Originillay the maximum verb-call depth is defined at compile time by the DEFAULT_MAX_STACK_DEPTH constant in \"options.h\". The maximum stack depth for any task is set at the time that task is created and cannot be changed thereafter. This implies that suspended tasks, even after being saved in and restored from the DB, are not affected by later changes to $server_options.max_stack_depth. ",
            "",
            "'queued_task_limit' if this property exist and its value is non-negative, then it is used as the maximum of tasks a verb-owner (more exactly the user's perms the verb run with) can queue (through fork() and suspend()). This setting is overriden if the user has a 'queued_task_limit' property and if its value is non-negative. E_QUOTA is raised of either forking or suspending when the user is over quota for tasks.",
            "",
            "'protect_...' On every call to a built-in function 'foo', if the property $server_options.protect_foo exists and is true, and the programmer is not a wizard, then the server checks for the existence of #0:bf_<fuction> and calls that. If it doesn't exist then E_PERM is raised, i.e. the built-in function is made wiz-only.",
            "",
            "'no_name_lookup' If this property exists and is true, the server will no longer automatically handle DNS name lookups. Instead, you'll have to use the 'connection_name_lookup()' function. This has the advantage of performing name lookups in a separate thread (thus not locking the main MOO until it finishes), but it also has the disadvantage of preventing '#0:do_login_command()' from working properly. To mitigate this, you must use the 'switch_player()' function instead of returning an object number. Note that this is the default behavior of ToastCore.",
            "                --------------------------------"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "*** Connected ***",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 150000,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 80000,
          "owner": 2,
          "perms": 5
        },
        {
          "value": "",
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 3600,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Server Options"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            9190,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "83": {
      "id": 83,
      "name": "Feature Warehouse",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        8
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "list",
          "owner": 36,
          "perms": 157,
          "preps": 3,
          "object": 83,
          "code": [
            "\"Copied from Features Feature Object (#24300):list by Joe (#2612) Mon Oct 10 21:07:35 1994 PDT\";",
            "if (this.contents)",
            "player:tell(\".features objects:\");",
            "player:tell(\"----------------------\");",
            "first = 1;",
            "for thing in (this.contents)",
            "$command_utils:kill_if_laggy(10, \"Sorry, the MOO is very laggy, and there are too many feature objects in here to list!\");",
            "$command_utils:suspend_if_needed(0);",
            "if (!first)",
            "player:tell();",
            "endif",
            "player:tell($string_utils:nn(thing), \":\");",
            "`thing:look_self() ! ANY => player:tell(\"<<Error printing description>>\")';",
            "first = 0;",
            "endfor",
            "player:tell(\"----------------------\");",
            "else",
            "player:tell(\"No objects in \", this.name, \".\");",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 1,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Feature Warehouse",
            "warehouse"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            2626,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "84": {
      "id": 84,
      "name": "Builder Help DB",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 84,
          "code": [
            "if (!caller_perms().wizard)",
            "raise(E_PERM);",
            "endif",
            "pass(@args);",
            "this.(\"@quota\") = {\"*forward*\", \"object-quota\"};"
          ]
        }
      ],
      "propnames": [
        "builder-index",
        "@locations",
        "@sort-owned",
        "@verify-owned",
        "@add-owned",
        "@recreate",
        "@parents",
        "@contents",
        "key-representation",
        "keys",
        "@unlock",
        "@lock",
        "locking",
        "@classes",
        "@audit",
        "@count",
        "@quota",
        "@create",
        "creation",
        "@dig",
        "@recycle",
        "building",
        "@dump",
        "@setprop",
        "@set",
        "@builder-options",
        "@builderoptions",
        "@buildoptions",
        "@build-options",
        "room-messages",
        "@resident",
        "exit-messages",
        "@add-entrance",
        "@add-exit",
        "topology",
        "@entrances",
        "@exits",
        "containers",
        "rooms",
        "@remove-entrance",
        "@remove-exit",
        "@unlock_for_open",
        "@lock_for_open",
        "@opacity",
        "container-messages",
        "thing-messages",
        "common_quota",
        "object-quota",
        "@measure",
        "audit_bytes",
        "audit_float"
      ],
      "propdefs": [
        {
          "value": [
            "*index*",
            "Builder Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @locations object",
            "",
            "Prints out the names and object numbers of all containing objects.",
            "",
            "Example:",
            "  @locations ur-Rog",
            "  ur-Rog(#6349)   ur-Rog's Display Case(#6355)   Editorial Boardroom(#5747)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @sort-owned  [ object | size ]",
            "",
            "Sorts your .owned_objects property so @audit shows up sorted.  See help @audit for more information.",
            "",
            "@sort-owned object will sort by object number (the default).  @sort-owned size will sort by size of object as periodically recorded."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @verify-owned",
            "",
            "Checks that all the objects in your .owned_objects property are actually owned by you, and effects repairs if needed.  See help @audit for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @add-owned <object>",
            "",
            "Adds an object to your .owned_objects property in case it managed not to get updated properly upon creation of that object.  Checks to ensure that the objects is really owned by you and otherwise belongs in your .owned_objects property.  See help @audit for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage: @recreate <object> as <parent> named <name spec>",
            "",
            "This is a combination of @create and @chparent.  It takes an existing object, completely strips it of any verbs, properties, and values for inherited properties.  This object is then reshaped into a child of the parent specified, as though @create had been called, but retaining the same object number as the original.",
            "",
            "You may use \"called\" instead of \"named\" in this command, if you wish.",
            "",
            "The <parent> and <name spec> arguments are as in @create."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @parents object",
            "",
            "A quick way to find out the ancestry of an object.  Prints out the names and object numbers of all ancestors.",
            "",
            "Example:",
            "  @parents Haakon",
            "  Haakon(#2)   generic wizard(#218)   generic programmer(#217)   generic ",
            "  player(#6)   Root Class(#1)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @contents object",
            "",
            "A quick way to find out the contents of an object.  Prints out the names and object numbers of all direct contents.  This can be useful when you need to refer to something by object number because something is wrong with its aliases.",
            "",
            "Example:",
            "  @contents here",
            "  The Entrance Hall(#19) contains:",
            "  Strasbourg Clock(#71)   mirror at about head height(#7444)"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The representation of key expressions is very simple and makes it easy to construct new keys on the fly.",
            "",
            "Objects are represented by their object numbers and all other kinds of key expressions are represented by lists.  These lists have as their first element a string drawn from the following set:",
            "        \"&&\"     \"||\"     \"!\"     \"?\"",
            "For the first two of these, the list should be three elements long; the second and third elements are the representations of the key expressions on the left- and right-hand sides of the appropriate operator.  In the third case, \"!\", the list should be two elements long; the second element is again a representation of the operand.  Finally, in the \"?\" case, the list is also two elements long but the second element must be an object number.",
            "",
            "As an example, the key expression",
            "        #45  &&  ?#46  &&  (#47  ||  !#48)",
            "would be represented as follows:",
            "        {\"&&\", {\"&&\", #45, {\"?\", #46}}, {\"||\", #47, {\"!\", #48}}}"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "LambdaMOO supports a simple but powerful notation for specifying locks on objects, encryption on notes, and other applications.  The idea is to describe a constraint that must be satisfied concerning what some object must be or contain in order to use some other object.",
            "",
            "The constraint is given in the form of a logical expression, made up of object numbers connected with the operators 'and', 'or', and 'not' (written '&&', '||', and '!', for compatibility with the MOO programming language).  When writing such expressions, though, one usually does not use object numbers directly, but rather gives their names, as with most MOO commands.",
            "",
            "These logical expressions (called 'key expressions') are always evaluated in the context of some particular 'candidate' object, to see if that object meets the constraint.  To do so, we consider the candidate object, along with every object it contains (and the ones those objects contain, and so on), to be 'true' and all other objects to be 'false'.",
            "",
            "As an example, suppose the player Munchkin wanted to lock the exit leading to his home so that only he and the holder of his magic wand could use it.  Further, suppose that Munchkin was object #999 and the wand was #1001.  Munchkin would use the '@lock' command to lock the exit with the following key expression:",
            "        me || magic wand",
            "and the system would understand this to mean",
            "        #999 || #1001",
            "That is, players could only use the exit if they were (or were carrying) either #999 or #1001.",
            "",
            "To encrypt a note so that it could only be read by Munchkin or someone carrying his book, his bell, and his candle, Munchkin would use the 'encrypt' command with the key expression",
            "        me || (bell && book && candle)",
            "",
            "Finally, to keep players from taking a large gold coffin through a particularly narrow exit, Munchkin would use this key expression:",
            "        ! coffin",
            "That is, the expression would be false for any object that was or was carrying the coffin.",
            "",
            "There is one other kind of clause that can appear in a key expression:",
            "        ? <object>",
            "This is evaluated by testing whether the given object is unlocked for the candidate object; if so, this clause is true, and otherwise, it is false.  This allows you to have several locks all sharing some single other one; when the other one is changed, all of the locks change their behavior simultaneously.",
            "",
            "[Note to programmers: The internal representation of key expressions, as stored in .key on every object, for example, is very simple and easy to construct on the fly.  For details, see 'help key-representation'.]"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @unlock <object>",
            "",
            "Clear any lock that might exist on the given object.  See 'help locking' for general information about locking."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @lock <object> with <key expression>",
            "",
            "Set a lock on <object> to restrict its use.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.",
            "",
            "N.B.  In the case of rooms, you are actually better off setting room.free_entry to 0 thus preventing teleportation and then @locking the various entrances.  The problem with @locking the room itself is that this can make it impossible to drop objects in the room."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "It is frequently useful to restrict the use of some object.  For example, one might want to keep people from using a particular exit unless they're carrying a bell, a book, and a candle.  Alternatively, one might allow anyone to use the exit unless they're carrying that huge golden coffin in the corner.  LambdaMOO supports a general locking mechanism designed to make such restrictions easy to implement, usually without any programming.",
            "",
            "Every object supports a notion of being 'locked' with respect to certain other objects.  For example, the exit above might be locked for any object that was carrying the coffin object but unlocked for all other objects.  In general, if some object 'A' is locked for another object, 'B', then 'B' is usually prevented from using 'A'.  Of course, the meaning of 'use' in this context depends upon the kind of object.",
            "",
            "The various standard classes of objects use locking as follows:",
            "  + Rooms and containers refuse to allow any object inside them if they're locked for it.",
            "  + Exits refuse to transport any object that they're locked for.",
            "  + Things (including notes and letters) cannot be moved to locations that they're locked for.",
            "",
            "There are two sides to locking:",
            "  + How is it specified whether one object is locked for another one?",
            "  + What is the effect of an object being locked?",
            "Note that these two questions are entirely independent: one could invent a brand-new way to specify locking, but the effect of an exit being locked would be unchanged.",
            "",
            "[Note to programmers: the interface between these two sides is the verb x:is_unlocked_for(y), which is called by x to determine if it is locked for the object y.  The way in which 'is_unlocked_for' is implemented is entirely independent of the ways in which x uses its results.  Note that you can play on either side of this interface with your own objects, either defining new implementations of 'is_unlocked_for' that match your particular circumstances or having your objects interpret their being locked in new ways.]",
            "",
            "There is a default way to specify locks on objects; the following help topics cover the relevant commands:",
            "",
            "@lock -- setting a lock on an object",
            "@unlock -- clearing the lock on an object",
            "keys -- describes the language used to describe lock keys"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @classes",
            "         @classes <class-name> ...",
            "",
            "The wizards have identified several useful classes of objects in the database.  The @classes command is used to see which classes exist and what their member objects are.",
            "",
            "The first form simply lists all of the defined classes along with short descriptions of the membership of each.",
            "",
            "The second form prints an indented listing of that subset of the object parent/child hierarchy containing the objects in the class(es) you specify."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @audit [<player>] [for <string>] [from <number>] [to <number>] ",
            "",
            "`@audit'        prints a report of all of the objects you own.",
            "`@audit player' prints the same report for another player.",
            "",
            "The `for' string restricts the search to objects whose names begin with that string.",
            "It is also possible to restrict the range of object numbers to include only those above a given number (`from') or below a given number (`to').",
            "",
            "All forms of @audit print a report:",
            "",
            "   #14 Gemba                          [The Pool]",
            "  #144 Popgun                         [Gemba]",
            " #1479 Cockatoo                      *[The Living Room]",
            " #1673 Bottom of Swimming Pool       ",
            " #2147 Cavern                        <-*west",
            " #2148 tunnel                         Bottom of Swimming ->Cavern",
            "",
            "The first column is the object's number, the second its name. The third column shows the object's location: Gemba is in The Pool, and is carrying the Popgun (#144).",
            "For exits, the third column shows source ->dest.",
            "For rooms, the third column shows any entrances owned by someone else.",
            "Object location, exit sources and destinations owned by another player are preceded by a *.",
            "",
            "@audit uses a property .owned_objects on the player, for speed.  This property is updated at the time of each object creation and destruction and ownership change.  The verb @auditdb (same args as @audit) actually searches through the entire database for objects.",
            "",
            "See also @verify-owned, @sort-owned, and @add-owned.",
            "",
            "See also @prospectus, which gives some additional information."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @count [player]",
            "",
            "Prints out the number of objects you or another person own.  Do not be surprised if this is one larger than you think it should be: remember that your player object is owned by you as well, even though you didn't create it in the usual way.",
            "",
            "If byte-based quota is enabled, also prints the total usage by all objects at last measurement."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*pass*",
            "@quota"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @create <class-name> named \"<names>\"",
            "         @create <parent-object> named \"<names>\"",
            "",
            "The main command for creating objects other than rooms and exits (for them, see 'help @dig'; it's much more convenient).",
            "",
            "The first argument specifies the 'parent' of the new object: loosely speaking, the 'kind' of object you're creating.  <class-name> is one of the four standard classes of objects: $note, $letter, $thing, or $container.  As time goes on, more 'standard classes' may be added.  If the parent you have in mind for your new object isn't one of these, you may use the parent's name (if it's in the same room as you) or else its object number (e.g., #4562).",
            "",
            "You may use \"called\" instead of \"named\" in this command, if you wish.",
            "",
            "An object must be fertile to be used as a parent-class.  See help @chmod for details.",
            "",
            "The <names> are given in the same format as in the @rename command:",
            "        <name-and-alias>,<alias>,...,<alias> [preferred]",
            "        <name>:<alias>,...,<alias> [not preferred]",
            "",
            "See 'help @rename' for a discussion of the difference between a name and an alias."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The primary means for players to extend the MOO is for them to create new objects with interesting behavior.  There are convenient commands for creating and recycling objects and for keeping track of the objects you've created.  Help is available on these commands in the following topics:",
            "",
            "@dig -- conveniently building new rooms and exits",
            "@create -- making other kinds of objects",
            "@recycle -- destroying objects you no longer want",
            "@quota -- determining how many more objects you can build",
            "@count -- determining how many objects you already own",
            "@audit -- listing all of your objects",
            "@classes -- listing all of the public classes available for your use",
            "@move -- moving your objects from place to place",
            "@parents, @kids -- examine the inheritance hierarchy."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @dig \"<new-room-name>\"",
            "         @dig <exit-spec> to \"<new-room-name>\"",
            "         @dig <exit-spec> to <old-room-object-number>",
            "",
            "This is the basic building tool.  The first form of the command creates a new room with the given name.  The new room is not connected to anywhere else; it is floating in limbo.  The @dig command tells you its object number, though, so you can use the @move command to get there easily.",
            "",
            "The second form of the command not only creates the room, but one or two exits linking your current location to (and possibly from) the new room.  An <exit-spec> has one of the following two forms:",
            "        <names>",
            "        <names>|<names>",
            "where the first form is used when you only want to create one exit, from your current room to the new room, and the second form when you also want an exit back, from the new room to your current room.  In any case, the <names> piece is just a list of names for the exit, separated by commas; these are the names of the commands players can type to use the exit.  It is usually a good idea to include explicitly the standard abbreviations for direction names (e.g., 'n' for 'north', 'se' for 'southeast', etc.).  DO NOT put spaces in the names of exits; they are useless in MOO.",
            "",
            "The third form of the command is just like the second form except that no new room is created; you instead specify by object number the other room to/from which the new exits will connect.",
            "",
            "NOTE: You must own the room at one end or the other of the exits you create.  If you own both, everything is hunky-dorey.  If you own only one end, then after creating the exits you should write down their object numbers.  You must then get the owner of the other room to use @add-exit and @add-entrance to link your new exits to their room.",
            "",
            "Examples:",
            "    @dig \"The Conservatory\"",
            "creates a new room named \"The Conservatory\" and prints out its object number.",
            "    @dig north,n to \"The North Pole\"",
            "creates a new room and also an exit linking the player's current location to the new room; players would say either 'north' or 'n' to get from here to the new room.  No way to get back from that room is created.",
            "    @dig west,w|east,e,out to \"The Department of Auto-Musicology\"",
            "creates a new room and two exits, one taking players from here to the new room (via the commands 'west' or 'w') and one taking them from the new room to here (via 'east', 'e', or 'out').",
            "    @dig up,u to #7164",
            "creates an exit leading from the player's current room to #7164, which must be an existing room."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @recycle <object-name-or-number>",
            "",
            "Destroys the indicated object utterly and irretrievably.  Naturally, you may only do this to objects that you own."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "There are a number of commands available to players for building new parts of the MOO.  Help on them is available under the following topics:",
            "",
            "creation -- making, unmaking, and listing your rooms, exits, and other objects",
            "topology -- making and listing the connections between rooms and exits",
            "descriptions -- setting the names and descriptive texts for new objects",
            "locking -- controlling use of and access to your objects"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @dump <object> [with [id=#<id>] [noprops] [noverbs] [create]]",
            "",
            "This spills out all the properties and verbs on an object, calling suspend at appropriate intervals.",
            "   id=#<id> -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)",
            "   noprops  -- don't show properties.",
            "   noverbs  -- don't show verbs.",
            "   create   -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it."
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @set <object>.<prop-name> to <value>",
            "",
            "Changes the value of the specified object's property to the given value.",
            "You must have permission to modify the property, either because you own the property or if it is writable."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@setprop",
            "@set is a valid abbreviation for @setprop."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@build-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@build-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@build-options"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @build-option",
            "         @build-option <option>",
            "",
            "Synonyms:  @buildoption, @builder-option @builderoption",
            "",
            "The first form displays all of your builder options",
            "The second displays just that one option, which may be one of the flags listed below.  The builder options control various annoying details of your building commands (e.g., @create, ...)",
            "",
            "The remaining forms of this command are for setting your programmer options:",
            "",
            "         @build-option create_flags [is] <flags>",
            "         @build-option create_flags=<flags>",
            "         @build-option -create_flags",
            "                      (equivalent to create_flags=\"\")",
            "",
            "where flags is some substring of \"rwf\".  This option determines the read/write/fertility permissions of an object freshly created with @create or @recreate (see `help @create' and `help @recreate' and `help @chmod').  E.g., to make every object you create henceforth readable by default, do",
            "",
            "         @build-option create_flags=r",
            "",
            "For controlling the behavior of @dig, we have",
            "",
            "         @build-option  dig_room=<room>",
            "         @build-option  dig_room [is] <room>",
            "         @build-option -dig_room",
            "                      (equivalent to dig_room=$room)",
            "         @build-option  dig_exit=<exit>",
            "         @build-option  dig_exit [is] <exit>",
            "         @build-option -dig_exit",
            "                      (equivalent to dig_exit=$exit)",
            "",
            "The following respectively set and reset the specified flag option",
            "",
            "         @build-option +<option>",
            "         @build-option -<option>",
            "         @build-option !<option>           (equivalent to -<option>)",
            "",
            "Currently the only builder flag option available is",
            " -bi_create     @create/@recycle re-use object numbers.",
            " +bi_create     @create/@recycle call create()/recycle() directly ",
            "",
            "we prefer that you not use +bi_create, since this drives up the object numbers."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "A few different messages can be set on a room object (see 'help messages' for instructions on doing so); they are printed to various audiences when a player or other object is ejected from the room.  (See 'help @eject'.)  The standard pronoun substitutions are made on each message before it is printed; see 'help pronouns' for details.",
            "",
            "The default message is given in brackets after each name below:",
            "",
            "@ejection  [%[$room.ejection_msg]]",
            "  Printed to the player doing the ejecting.",
            "",
            "@victim_ejection  [%[$room.victim_ejection_msg]]",
            "  Printed to the object being ejected.",
            "",
            "@oejection  [%[$room.oejection_msg]]",
            "  Printed to others in the room from which the object is being ejected."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @resident player",
            "        @resident !player",
            "        @resident",
            "",
            "Adds or removes a player from the residents list of a room.  The residents list controls who is allowed to use @sethome in that room.  This defaults to just the owner of the room; by manipulating the residents list you may allow additional players to use that room as their home.",
            "",
            "@resident player adds that player to the list.  ",
            "@resident !player removes that player from the list.",
            "@resident with no arguments simply displays the current list (which may be \"none\", indicating no additional people besides the owner may use that room as their home).",
            "",
            "See also help @sethome.",
            "",
            "Hints for programmers: The verb $room:accept_for_abode is called by @sethome.  By overriding this verb you can give different criteria to @sethome.  It should return 1 for allowed and 0 for denied."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Several kinds of messages can be set on an exit object (see 'help messages' for instructions on doing so); they are printed to various audiences at certain times whenever an attempt is made to go through the exit.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.",
            "",
            "The default message is given in brackets after each name below:",
            "",
            "@leave  [%[$exit.leave_msg]]",
            "  Printed to the player just before they successfully use the exit.",
            "",
            "@oleave  [%[$exit.oleave_msg||\"has left.\"]]",
            "  Printed to others in the source room when a player successfully uses the exit.",
            "",
            "@arrive  [%[$exit.arrive_msg]]",
            "  Printed to the player just after they successfully use the exit.",
            "",
            "@oarrive  [%[$exit.oarrive_msg||\"has arrived.\"]]",
            "  Printed to others in the destination room when a player successfully uses the exit.",
            "",
            "@nogo  [%[$exit.nogo_msg||\"You can't go that way.\"]]",
            "  Printed to the player when they fail in using the exit.",
            "",
            "@onogo  [%[$exit.onogo_msg]]",
            "  Printed to others when a player fails in using the exit."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @add-entrance <exit-object-number>",
            "",
            "Add the exit with the given object number as a recognized entrance to the current room (that is, one whose use is not considered teleportation).  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-entrance command to link it up."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @add-exit <exit-object-number>",
            "",
            "Add the exit with the given object number as a conventional exit from the current room (that is, an exit that can be invoked simply by typing its name, like 'east').  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-exit command to link it up."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "The topology of the MOO universe is determined by the rooms that exist and the exits that connect them.  Several commands are available for creating and discovering the topology of the MOO.  Help on them is available under the following topics:",
            "",
            "@dig -- creating new rooms and exits",
            "@add-exit -- adding other players' exits from your rooms",
            "@add-entrance -- adding other player's entrances to your rooms",
            "@remove-exit -- removing exits from your room",
            "@remove-entrance -- removing entrances from your room",
            "@exits -- listing all of the conventional exits from your rooms",
            "@entrances -- listing all of the conventional entrances to your rooms",
            "@resident -- listing or changing the residents of your rooms"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @entrances",
            "",
            "Prints a list of all recognized entrances to the current room (but only if you own the room).  A recognized entrance is one whose use is not considered to be teleportation."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @exits",
            "",
            "Prints a list of all conventional exits from the current room (but only if you own the room).  A conventional exit is one that can be used simply by typing its name, like 'east'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Containers are objects that allow you to store other objects inside them.  The following help topics cover verbs that can be used with containers:",
            "",
            "put -- putting an object into a container",
            "remove -- taking an object out of a container",
            "",
            "Containers may be open or closed, using the verbs 'open container' and 'close container'.  Containers have a separate lock to determine if a player may open them.  See the following help topics:",
            "",
            "@lock_for_open -- setting the lock for opening a container",
            "@unlock_for_open -- clearing the lock",
            "",
            "You can make a container by creating a child of the standard container, $container (see 'help @create').",
            "",
            "Containers have a large number of messages which get printed when players act upon them.  See 'help container-messages' for more information.",
            "",
            "Containers have opacity.  See 'help @opacity' for more information."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Rooms may be made by builders, using the DIG verb. By default, all rooms are instances of _the_ room, $room, or #3, which you can examine to see how it works. If you require a room to have a more specific behaviour, you can make a subclass of room."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @remove-entrance <entrance>",
            "",
            "Remove the specified entrance from the current entrances list of the room.  Entrance may be either the name or object number of an entrance to this room."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @remove-exit <exit>",
            "",
            "Remove the specified exit from the current exits list of the room.  Exit may be either the name or object number of an exit from this room."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:",
            "  @unlock_for_open <container>",
            "",
            "Clears the lock which restricts who may open <container>.  See 'help locking' for general information about locking. ",
            "",
            "See 'help containers' for information on containers."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:",
            "  @lock_for_open <container> with <key expression>",
            "",
            "Set the lock on <container> which restricts who can open it.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.",
            "",
            "See 'help containers' for information on containers."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:",
            "  @opacity <container> is <integer>",
            "",
            "The opacity can take on one of three values:",
            "   0:  The container is transparent and you can always see into it.",
            "   1:  The container is opaque, and you cannot see into it when closed",
            "   2:  The container is a black hole, and you can never see into it whether closed or open.  ",
            "",
            "The default @opacity is 1."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Several kinds of messages can be set on a container object; they are printed to various audiences at certain times whenever an attempt is made to use the container.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.",
            "",
            "The default message is given in brackets after each name below:",
            "",
            "@empty[%[$container.empty_msg]]",
            "  Printed in place of the contents list when the container is empty.",
            "",
            "@open  [%[$container.open_msg]]",
            "  Printed to the player who successfully opens the container.",
            "",
            "@oopen  [%[$container.oopen_msg]]",
            "  Printed to others in the same room if the player successfully opens the container.",
            "",
            "@open_fail  [%[$container.open_fail_msg]]",
            "  Printed to the player who cannot open the container.",
            "",
            "@oopen_fail  [%[$container.oopen_fail_msg]]",
            "  Printed to others in the room when a player fails to open a container.",
            "",
            "@close  [%[$container.close_msg]]",
            "  Printed to the player who closes a container.",
            "",
            "@oclose  [%[$container.oclose_msg]]",
            "  Printed to others in the room when a player closes a container.",
            "",
            "@put  [%[$container.put_msg]]",
            "  Printed to a player when an object is successfully placed in a container.",
            "",
            "@oput  [%[$container.oput_msg]]",
            "  Printed to others in the room when a player successfully places an object in a container.",
            "",
            "@put_fail  [%[$container.put_fail_msg]]",
            "  Printed when a player fails to put an object in a container.",
            "",
            "@oput_fail  [%[$container.oput_fail_msg]]",
            "  Printed to others in the room when a player fails to place an object in a container.",
            "",
            "@remove  [%[$container.remove_msg]]",
            "  Printed when a player succeeds in removing an object from a container.",
            "",
            "@oremove  [%[$container.oremove_msg]]",
            "  Printed to others in the room when a player succeeds in removing an object from a container.",
            "",
            "@remove_fail  [%[$container.remove_fail_msg]]",
            "  Printed when a player fails to remove an object from a container.",
            "",
            "@oremove_fail  [%[$container.oremove_fail_msg]]",
            "  Printed to others in the room when a player fails to remove an object from a container."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*subst*",
            "Several kinds of messages can be set on 'things', objects that have $thing as an ancestor (see 'help messages' for instructions on doing so).  They are printed to various audiences under various circumstances when an attempt is made to 'take' or 'drop' a thing.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.",
            "",
            "The default message is given in brackets after each name below:",
            "",
            "@take_failed  [%[$thing.take_failed_msg]]",
            "  Printed to a player who fails to take the object.",
            "",
            "@otake_failed [%[$thing.otake_failed_msg]]",
            "  Printed to others in the same room if a player fails to take the object.",
            "",
            "@take_succeeded  [%[$thing.take_succeeded_msg]]",
            "  Printed to a player who succeeds in taking the object.",
            "",
            "@otake_succeeded  [%[$thing.otake_succeeded_msg]]",
            "  Printed to others in the same room if a player succeeds in taking the object.",
            "",
            "@drop_failed  [%[$thing.drop_failed_msg]]",
            "  Printed to a player who fails to drop the object.",
            "",
            "@odrop_failed [%[$thing.odrop_failed_msg]]",
            "  Printed to others in the same room if a player fails to drop the object.",
            "",
            "@drop_succeeded  [%[$thing.drop_succeeded_msg]]",
            "  Printed to a player who succeeds in dropping the object.",
            "",
            "@odrop_succeeded  [%[$thing.odrop_succeeded_msg]]",
            "  Printed to others in the room if a player succeeds in dropping the object."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @quota",
            "",
            "Each player has a limit as to how many objects that player may create, called their 'quota'.  Every object they create lowers the quota by one and every object they recycle increases it by one.  If the quota goes to zero, then that player may not create any more objects (unless, of course, they recycle some first).",
            "",
            "The @quota command prints out your current quota.",
            "",
            "The quota mechanism is intended to solve a long-standing problem in many MUDs: database bloat.  The problem is that a large number of people build a large number of dull objects and areas that are subsequently never used or visited.  The database becomes quite large and difficult to manage without getting substantially more interesting.  With the quota system, we can make it possible for players to experiment and learn while simultaneously keeping random building to acceptable levels."
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "common_quota",
            "",
            "To get a larger quota, talk to a wizard.  They will take a look at what you've done with the objects you've built so far and make a determination about whether or not it would be a net gain for the MOO community if you were to build some more things.  If so, they will increase your quota; if not, they will try to explain some ways in which you could build things that were more useful, entertaining, or otherwise interesting to other players.  Wizards may be more impressed by objects which are interactive and employ a fair number of verbs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:",
            "  @measure object <object name>",
            "  @measure summary [player]",
            "  @measure new [player]",
            "  @measure breakdown <object name>",
            "  @measure recent [number of days] [player]",
            "",
            "When the MOO is under byte-quota, objects in the MOO are measured approximately once a week, and the usage tally as reported by @quota is updated.  You may wish to measure an object specially, however, without waiting for the automatic measurement to take place, or if the MOO is under object-quota.  @measure has some subcommands to handle this.",
            "",
            "@measure object will measure an individual object right now, update the usage of that object in your usage as reported by @quota, and update the date of that object's measurement.",
            "",
            "@measure summary will go through your or another player's objects and produce the summary information that is printed by @quota.  Normally this will be just the same as @quota prints out, but occasionally the addition/subtraction done to keep @quota in sync will get out of date, and @measure summary will be needed.",
            "",
            "@measure new will go through all your or another player's objects, measuring exactly those which have never been measured before (that is, are too newly @created to have any measurement data).  This is necessary as any player is only permitted to own 10 unmeasured objects, or object creation will not be permitted.",
            "",
            "@measure breakdown will give you full information on where an object's size is coming from.  It will offer to moomail you the result.  Caution: don't forget to delete this message, as it is large and takes up a lot of space!",
            "",
            "@measure recent will let you re-measure objects of yours or another player's which have not been measured in the specified number of days (the default is the ordinary cycle of the measurement task)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:  @build-option [+|-|!]audit_bytes",
            "Lets you see the actual bytes of small objects in @audit and @prospectus.  Ignored if `audit_float' is turned on.",
            "",
            "  -audit_bytes     @audit/@prospectus shows `<1K'",
            "  +audit_bytes     @audit/@prospectus shows bytes.",
            "",
            "Default: -audit_bytes"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "Usage: @build-option [+|-|!]audit_float",
            "Lets you see object sizes in @audit and @prospectus as floating point numbers to one decimal place.",
            "",
            "  -audit_float     @audit/@prospectus shows integer sizes (1K)",
            "  +audit_float     @audit/@prospectus shows floating-point sizes (1.2K)",
            "",
            "Default: -audit_float"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "builder-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Builder Help DB",
            "BHD"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This help database contains topics about the generic builder and building commands.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            46326,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "85": {
      "id": 85,
      "name": "Mail Commands Help Db",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "mail-index",
        "@mailoptions",
        "@mail-options",
        "mail-forwarding",
        "@forward",
        "@subscribe",
        "@rn",
        "@unsubscribe",
        "@skip",
        "zombie-messages",
        "message-sequences",
        "@unrmmail",
        "@reply",
        "@renumber",
        "@prev",
        "@next",
        "@answer",
        "@rmmail",
        "@read",
        "@send",
        "mail",
        "@mail",
        "@peek",
        "@subscribed",
        "@netforward",
        "@keep-mail",
        "@keepmail",
        "@resend",
        "@qsend",
        "@qreply",
        "@quickreply",
        "@quicksend",
        "@nn",
        "@mail-all-new-mail",
        "@read-all-new-mail",
        "@refile",
        "@copymail",
        "@add-notify",
        "@unsend"
      ],
      "propdefs": [
        {
          "value": [
            "*index*",
            "Mail System Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@mail-options"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @mail-option",
            "         @mail-option <option>",
            "",
            "Synonym:  @mailoption",
            "",
            "The first form displays all of your mail options",
            "The second displays just that one option, which may be either `@mail', `replyto', or one of the flags listed below.  The mail options control various annoying details of your mail reading and mail editing commands.",
            "",
            "The remaining forms of this command are for setting your mail options:",
            "",
            "         @mail-option +<flag>",
            "         @mail-option -<flag>",
            "         @mail-option !<flag>           (equivalent to -<flag>)",
            "",
            "These respectively set and reset the specified flag",
            "",
            " -include          @replys start out with a blank message body",
            " +include          @replys start with original message included",
            " -all              @replys go to sender only",
            " +all              @replys go to sender and all original recipients",
            " -followup         @replys go as directed by `all' flag",
            " +followup         @replys go to first nonplayer recipient if any",
            "                    (if there are no non-player recipients, use `all' flag).",
            " -nosubject        @send forces you to provide a Subject: line",
            " +nosubject        allow entering the mail editor without giving a subject line",
            " -expert           novice mail user (various annoying messages will be printed)",
            " +expert           expert mail user (suppress printing of annoying messages)",
            " -enter            start each mail editing session in the usual command mode.",
            " +enter            start each mail editing session with an implicit `enter'",
            "                    command",
            " -sticky           each mail command applies by default to one's own collection",
            " +sticky           each mail command applies by default to the same message ",
            "                    collection that the previous successful command did",
            " -netmail          mail to you accumulates in your MOO mailbox",
            " +netmail          mail to you is actually forwarded to your registered email",
            "                    address, if you have one.",
            " -resend_forw      @resend puts player in Resent-By: header",
            " +resend_forw      @resend puts player in From: header (like @forward)",
            " -no_auto_forward  @netforward when expiring messages",
            " +no_auto_forward  do not @netforward messages when expiring mail",
            " -expert_netfwd    @netforward confirms before emailing messages",
            " +expert_netfwd    @netforward doesn't confirm before emailing messages",
            " -no_dupcc         send a personal copy even if already subscribed to a ",
            "                    mailing list on the to: line",
            " +no_dupcc         don't send personal copies of mail also sent to lists",
            "                    you are subscribed to",
            " -no_unsend        People may @unsend unread messages they send to you",
            " +no_unsend        No one may @unsend messages they sent to you",
            "",
            "For \"sticky\", `mail command' is one of @mail, @read, @prev, @next, @answer.",
            "All flags default to the `-' settings.  ",
            "",
            "Next, we have",
            "",
            "         @mail-option  manymsgs [is] <number>",
            "         @mail-option  manymsgs=<number>",
            "         @mail-option -manymsgs",
            "",
            "The first two forms specify that if you give a @mail or @read command asking for <number> or more messages, you will first be given a yes-or-no prompt to continue, the idea being that you many not actually have wanted to see that many messages.  The third form turns off this behavior.",
            "",
            "         @mail-option  @mail [is] <message-sequence>",
            "",
            "The \"@mail\" option determines what message-sequence the @mail command uses by ",
            "default.  Initially, this is \"last:15\", but other reasonable choices include",
            "\"new\" and \"1-last\"",
            "",
            "         @mail-option  replyto [is] <recipient> [<recipient>...]",
            "         @mail-option -replyto",
            "",
            "The first form specifies that a Reply-To: field is to be placed in all messages constructed by @send or @answer.  Note this can still be changed before sending via the mail room's reply-to command.  ",
            "The second form resets this option so that no Reply-to: is initially inserted.",
            "",
            "        @mail-option rn_order=<order>",
            "",
            "controls the order in which folders listed by @rn and @subscribed will appear.  <order> can be one of",
            "",
            " read    folders are sorted by last read date. (default)",
            " send    folders are sorted by last send date.",
            " fixed   folders are not sorted",
            "",
            "To control expiration of messages (see `help @keep-mail') we have",
            "",
            "        @mail-option expire [is] <time-interval>",
            "        @mail-option expire=<time-interval>",
            "",
            "<time-interval> can either be a number of seconds or something with units in it, e.g.,",
            "",
            "        @mail-option expire 13 days",
            "        @mail-option expire 1 year 39 days",
            "",
            "A negative number or",
            "",
            "        @mail-option +expire",
            "",
            "disables message expiration entirely",
            "",
            "        @mail-option -expire",
            "",
            "sets your message expiration time to the current default.",
            "",
            "        @mail-option @unsend=<message sequence>",
            "",
            "sets the default message sequence that the @unsend command will operate upon.  The default is \"last:1\"."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "There are 3 personal properties that you can use to customize how your mail is composed and forwarded",
            "",
            ".mail_forward ",
            " -- list of objects that will receive any mail that gets sent to you.",
            "    Objects on this list should either be players or descendants of ",
            "    $mail_recipient.",
            "    If this list is nonempty, you will not receive any mail yourself unless",
            "    you are on it.  E.g., if Rog is #4292 and ur-Rog is #6349",
            "",
            "  #6349.mail_forward={}            -- usual case; ur-Rog gets his own mail.",
            "  #6349.mail_forward={#4292}       -- Rog gets ur-Rog's mail instead.",
            "  #6349.mail_forward={#6349,#4292} -- ur-Rog gets mail and Rog gets a copy.",
            "  #6349.mail_forward={#-1}         -- ur-Rog's mail disappears without a trace.",
            "",
            ".mail_notify",
            " -- list of objects to be notified whenever mail is sent to you.",
            "    This list may include anything that has a :notify_mail() verb.",
            "    Notification will take place regardless of whether or how your mail",
            "    is forwarded.  ",
            "",
            "Thus, in the previous example",
            "",
            "  #4292.mail_notify={#6349} --- means that ur-Rog will be told",
            "                                whenever Rog is sent new mail.",
            "",
            ".mail_options",
            " -- this controls lots of miscellaneous things.  Use the @mail-option command",
            "    to view and set these options (see `help @mail-option')",
            "",
            "See `help mail-resolve' for more detail on how mail forwarding and mail notification work.  See `help MR-subscribing' for information on how to change .mail_forward and .mail_notify on $mail_recipient children, where they are !c properties."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @forward <msg> [on *<collection>] to <recipient> [<recipient>...]",
            "Syntax:  @resend  <msg> [on *<collection>] to <recipient> [<recipient>...]",
            "",
            "Both of these commands take the indicated message in your (or some other) message collection, and sends it on to the indicated recipients in some form.",
            "",
            "@forward sends an entirely new message whose body is the original message (both headers and body).",
            "@resend sends the original message, but with a header containing the lines",
            "",
            "  From:  original-sender",
            "  To:    original-recipients...",
            "  Resent-By: you",
            "  Resent-To: new-recipients...",
            "",
            "If you prefer to have yourself in the From: line of messages you @resend, set the mail option `resend_forw (see `help @mail-options').  In this case, the message will instead have a header containing the lines",
            "",
            "  From:  you",
            "  To:    new-recipients...",
            "  Original-From:  original-sender"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @subscribe *<collection> [with|without notification] [before|after *<collection>]",
            "         @subscribe",
            "         @subscribe-quick",
            "",
            "The second and third form of the command gives a list of all mail collections that are readable by you. The third form omits the mail collection description.",
            "",
            "The first form of this command sets up a current message and a last-read-time for the given mail collection so that when you next log in or issue the @rn command, you will be informed about new mail that has appeared there.  Note that this happens automatically whenever you @read messages on a given collection, so if this much is all you care about, you don't need to use this command; just do, e.g.,",
            "         @read last on *<collection>",
            "",
            "Specifying \"with notification\" causes you to be added to the immediate-notification list (.mail_notify) for that collection, i.e., whenever new mail arrives there, you will be notified immediately.  Specifying \"without notification\" causes you to be removed from the collection's .mail_notify.",
            "",
            "Specifying \"before *<other-collection>\" causes <collection> to be placed immediately before *<collection> in your @rn listing (which see) and likewise for the \"after\" clause.  By default, new collections are placed at the end of your list.  The before/after specification is only useful if you have @mail-option rn_order=fixed set (see `help @mail-options').",
            "",
            "@subscribing to a collection for which you already have a current-message/last-read-time has no effect other from possibly changing that collection's .mail_notify and/or reordering your collections for @rn.",
            "",
            "You can only @subscribe to collections that are readable by you.",
            "",
            "Note that this is entirely different from the Mail Room `subscribe' command",
            "which actually adds you to the .mail_forward list for a given collection/",
            "mailing-list, so that mail sent to the list actually shows up in your own",
            "mail collection.",
            "We're probably going to phase out the Mail Room `subscribe' command..."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @rn",
            "",
            "For each collection of mail messages that you read other from your own, a last-read-time is kept.  This command tells you which collections (out of all those you have ever read) have recently had messages added to them, i.e., more recently than when you last did a @read, @prev, @next, or @skip on that collection.",
            "",
            "Etymologists' note:  If you thought @rn had anything to do with the popular UNIX newsreading program `rn', it's just your imagination."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@skip"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @skip [<collection>...]",
            "         @unsubscribe [<collection>...]",
            "",
            "For each collection of mail messages that you read other from your own, a current message and a last-read-time is kept.  Normally, if you neglect to actually @read any messages on a collection other from your own, @rn (or :check_mail_lists) will continue to remind you that they are there.",
            "",
            "The @skip command indicates that you're not interested in reading the rest of the messages that currently exist in that given collection.  ",
            "",
            "The @unsubscribe command flushes the current-message/last-read-time information completely, indicating that you are not only uninterested in the rest of the messages on that collection, but also likewise uninterested in anything else that may appear on that collection later on.  @unsubscribe also removes you from the collection's .mail_notify list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@unrmmail"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Certain mail commands, including @mail, @read, and @rmmail, allow a <message-sequence> argument that indicates to which messages in one's collection the command is to apply.  Any combination of the following may appear as a <message-sequence> argument to any of the various mail commands (@mail, @read, @answer, @rmm).",
            "",
            "  17        message number 17 if there is one (and likewise for other integers)",
            "  17..23    all messages numbered between 17 and 23 (inclusive), if any.",
            "  cur       the current message",
            "  prev      the message before",
            "  next      the message after",
            "  prev17    the 17 messages prior to the current message",
            "  next17    the 17 messages after the current message",
            "  first     the first message if any",
            "  last      the final message if any (`$' is a synonym for `last')",
            "  new       unread messages if any",
            "",
            "You may use as many of these at once as sanity permits, e.g.,",
            "",
            "  @mail cur 1..5 last",
            "",
            "which will display the header for your current message, your messages in the range 1..5, and your last message.  Though some of these ranges may overlap, the header for any given message is only shown once in any event.",
            "",
            "In addition, there are other message-sequence arguments that act as filters on whatever precedes them. ",
            "",
            " before:<date>               messages strictly before the given date",
            " after:<date>                messages strictly after the given date",
            " since:<date>                messages on or after the given date",
            " until:<date>                messages on or before the given date",
            " from:<player>[|<player...]  messages from the given player(s)",
            " to:<recip>[|<recip>...]     messages to the given recipient(s)",
            " %from:<string>              messages with <string> in the From: line",
            " %to:<string>                messages with <string> in the To: line",
            " subject:<string>            messages with <string> in the subject",
            " body:<string>               messages with <string> in the body (SLOW!!!)",
            " first:<number>              the first <number> messages",
            " last:<number>               the last <number> messages",
            " kept:                       messages marked as kept (see `help @keep-mail')",
            " unkept:                     messages not marked as kept",
            "",
            "<date>  is either a weekday, \"today\", \"yesterday\", or",
            "        a dd-Month, dd-Month-yy or dd-Month-yyyy date",
            "<recip> is either <player> or *<$mail_recipient kid>",
            "",
            "Examples:",
            "",
            "  @read from:G7|Gemba              read all messages from G7 or Gemba",
            "  @rmm to:yduJ|*Core               remove messages that are to yduJ or to *Core",
            "  @mail since:1-Jan before:1-Feb   show messages dated in January",
            "  @mail since:Tues                 show messages dated on or after Tuesday",
            "  @rmm subject:manners             remove msgs with `manners' in the subject:",
            "  @mail subject:\"stupid idiots\"    (search string contains a space => need \"'s)",
            "  @rmm to:yduJ to:*Core            remove messages that are to yduJ and *Core",
            "  @mail from:Haakon last:5         show the last 5 messages from Haakon",
            "  @mail %from:guest                show mail from players with \"guest\" in",
            "                                   their names",
            "  @mail last:10 body:fribble       show those of the last 10 messages having",
            "                                   `fribble' in the body (one should always try",
            "                                   to narrow body searches in this way)."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @unrmmail [list|expunge] [on *<collection>]",
            "",
            "When you do @rmmail on a particular message collection, the messages removed don't go away immediately, but are rather saved elsewhere.  These \"zombie\" messages can be brought back or examined using the @UNrmmail command.",
            "",
            "Without `list' or `expunge', @unrmm restores the zombie messages, thus undoing the effect of the most recent @rmmail command.  Only the most recent @rmmail can be undone in this way; messages deleted by any previous @rmmail commands on this same collection are lost and gone forever.",
            "",
            "The `list' option merely lists the headers of the zombie messages without actually restoring them.",
            "",
            "The `expunge' option banishes the zombie messages forever.",
            "",
            "Note that the message numbers used by zombie messages are held in reserve against the possibility that you might @unrmm them some day; with such messages around, new messages received will be given higher numbers than you might have expected.  @renumber does an implicit @unrmm expunge.",
            "",
            "`@unrmmail' and `@unrmmail expunge' on collections other than your own are only allowed when you have write access.  Likewise, `@unrmmail list' on other collections is only possible when they are readable by you."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@answer"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @renumber [<collection>]",
            "",
            "Renumbers the messages in your collection to go from 1 to however many you have at the moment.  The optional argument allows you to renumber the messages stored in some other collection (@renumber, like @rmmail, requires write access).",
            "",
            "Note that if you have zombie messages from a previous @rmmail command (see `help zombie-messages'), these will be expunged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @prev [<number>] [on <collection>]",
            "",
            "Print the 'previous' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is decremented.  Thus, e.g., one can review all of one's previous messages one-by-one simply by typing '@prev' repeatedly.  If <number> is supplied, print (and decrement current message by) that many messages."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @next [<number>] [on <collection>]",
            "",
            "Print the `next' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is incremented.  Thus, e.g., one can read all of one's new messages one-by-one simply by typing '@next' repeatedly.  If <number> is supplied, prints and advances that many messages."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "Syntax:  @answer [<message-number>] [sender] [all] [include] [noinclude] [followup]",
            "",
            "Synonym: @reply",
            "",
            "Prepares for you to compose a MOO email message to the players who either received or composed the indicated message from your collection.  The usual editor is invoked (see `help editors' for details).  The subject line for the new message will be initialized from that of the indicated message.  If you leave off the message number, the reply will be to your current message, if that exists.  In fact you may give a general message-sequence (see `help message-sequences') argument here, provided that it indicates only a single message (e.g., `@answer last:1')",
            "",
            "If there is a Reply-to: field in the message you are @answer'ing, its contents will be used to initialize the To: line of your reply.  Otherwise, a To: line is determined depending on whether you specified `sender', `all', or `followup' in the command line (or your .mail_options).",
            "  `sender'   replies to sender only",
            "  `all'      replies to sender and all original recipients",
            "  `followup' replies to first original recipient that is a non-player",
            "             (no effect if there are no non-player recipients).",
            "",
            "`include' includes the text of the original message in your reply, `noinclude' does not.  ",
            "",
            "`sender', `all', `followup', `include', and `noinclude' can all be abbreviated (e.g., `@answer i').",
            "",
            "Defaults are `sender' and `noinclude', but you can change this by setting your .mail-options (see `help mail-options').  "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @rmmail [<message-sequence>] [from *<recipient>]",
            "",
            "Deletes the indicated messages from your MOO email collection.",
            "By default, your current message is deleted.",
            "See `help message-sequence' for the full list of possible arguments.",
            "You get the message numbers for use here by typing the '@mail' command.",
            "",
            "There is no confirmation for this action, so be careful.  While it is true that @unrmmail will be able to bring back the messages deleted by the last @rmm, any messages deleted before then are really gone, i.e., irrecoverable.  See `help @unrmmail' for more information.",
            "",
            "This command may be used on other mail recipients (children of $mail_recipient), but only ones to which you have write access (you either have to own it or be on good terms with whoever does...).",
            "",
            "You can try to delete messages that you accidentally sent to a person with the command @unsend (see `help @unsend').  Note there are restrictions on the operation, so it often will not work."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @read <message-number>",
            "         @read",
            "         @peek ...",
            "",
            "Prints the contents of the indiciated messages from your MOO email collection.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @read, then the 'current message' in your collection is printed.  In any case, the 'current message' after @read finishes is the last one printed.",
            "",
            "The most general form of the @read command is",
            "",
            "         @read <message-sequence> [on *<collection>]  ",
            "",
            "where <message-sequence> is as described in `help message-sequences'.",
            "As with the @mail command you may @read messages on any publically readable collection (child of $mail_recipient).",
            "",
            "The @peek command is a variant of @read that works no differently except that it refrains from setting your `current message'.  This is useful, for example, if you want to see some particular message on a collection without losing track of where you are in it."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @send <recipient> [<recipient> ...]  [subj[ect]=\"<subject>\"]",
            "",
            "Prepares for you to compose a MOO email message to the recipients named on the command line.  A recipient can be specified by giving a player name or object-id, or a '*' followed by the name or object-id of some non-player mail recipient (e.g., a mailing list or a mail folder) -- a list of such non-player recipients is available from within the mailroom with the 'showlists' command.",
            "",
            "The usual editor is invoked.   ",
            "You will be prompted for a subject line if you did not specify one in the @send command (see `help mail_options' for how to avoid this).",
            "Use `say' (\") to insert lines in the body of your message.  ",
            "See `help editors' for details.",
            "",
            "Giving this command without arguments resumes editing the previous unsent draft message if one exists."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The MOO email system allows you to send and receive messages to and from other players.  It provides commands to view and manage your own collection of saved messages and, in addition, to browse through other collections that may be available (e.g.,archives of public mailing lists).  Help is available on the following commands:",
            "",
            "@mail     -- seeing a table of contents for a collection of email messages",
            "@read     -- reading individual messages ",
            "@next     -- reading the 'next'     message",
            "@prev     -- reading the 'previous' message",
            "",
            "@send     -- composing and sending a message to other players",
            "@answer   -- replying to one of the messages in a collection",
            "@forward  -- resending one of the messages in a collection somewhere else",
            "",
            "@rmmail   -- discarding some subset of a collection",
            "@unrmmail -- undoing the most recent @rmm on a collection",
            "@unsend   -- try to remove a message you accidentally sent",
            "@renumber -- renumbering the messages in a collection",
            "@keep-mail - marking messages in a collection as exempt from expiration",
            "",
            "@mail-option -- describes and sets various customization flags",
            "",
            "help mail-forwarding",
            " -- describes mail forwarding",
            "help message-sequences",
            " -- describes message-sequences arguments to @mail, @read, @rmm, and @answer.",
            "",
            "For viewing collections other from your own, the following commands are useful:",
            "",
            "@rn          -- list those collections that have new messages on them",
            "@subscribe   -- indicate that you want @rn to report on a given collection",
            "                  and add yourself to its .mail_notify list",
            "@skip        -- ignore any remaining new messages in a given collection",
            "@unsubscribe -- ignore a given collection entirely from now on",
            "                  and remove yourself from its .mail_notify list",
            "@unsubscribed-- show the mailing lists that you aren't subscribed to.",
            "@subscribed  -- like @rn, but shows all lists that you are subscribed to",
            "                even if they have no new activity"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @mail",
            "         @mail new            (to see recent messages)",
            "         @mail 1-$            (to see *all* messages)",
            "",
            "Shows a table of contents for your MOO email message collection.  You are notified when you connect to the MOO if there are any such messages.  A little arrow indicates the mail system's notion of your 'current message'.  ",
            "The first form lists all of your messages or the last 15 if you have more than that many; the second form lists only those messages after your `current message'.  The third form shows your entire collection.",
            "",
            "If you have a large number of mail messages, you can give arguments so that @mail only lists the messages you're interested in.  You can also list messages residing on mail recipients which are public or for which you have read access.",
            "The general format is",
            "",
            "         @mail <message-sequence> [on *<recipient>]",
            "",
            "<recipient> must name some child of $mail_recipient (e.g., a mailing list);",
            "<message-sequence> can be a sequence of message numbers; you can also scan the recipient for articles that fit a given description, as specified in `help message-sequences'.",
            "",
            "Note that if you view mail on some other recipient and have \"sticky\" in your .mail_options (see `help mail-options'), all further mail commands (e.g., @read, @next, @rmm,...) will apply to that recipient.  In this case use `@mail on me' to go back to looking at your own mail."
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@read"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @subscribed",
            "",
            "Like @rn, but shows you ALL mailing lists to which you are subscribed, even those which have no new messages."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @netforward <message-number>",
            "         @netforward ",
            "         @netforward <message-sequence> on *collection",
            "",
            "Forwards the contents of the indiciated messages from your MOO email collection to your registered email address.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @netforward, then the 'current message' in your collection is sent.  In any case, the 'current message' after @netforward finishes is not affected.",
            "",
            "The most general form of the @netforward command is",
            "",
            "         @netforward <message-sequence> [on *<collection>]",
            "",
            "where <message-sequence> is as described in `help message-sequences'.",
            "As with the @mail command you may @netforward messages on any publically readable collection (child of $mail_recipient).",
            "",
            "Before messages are sent, you are asked to confirm the email unless you have set your `expert_netfwd' mail option on.  See `help @mail-options' for details.",
            "",
            "If you do not have a valid registered email address, you will not be able to use this command and must first @registerme or get a wizard to register your address. `help @registerme' for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @keep-mail [<message-sequence>]",
            "         @keep-mail none",
            "",
            "Synonym: @keepmail",
            "",
            "As a space-saving measure, there is a task that runs periodically and from all player collections removes those messages that are",
            "  (1) marked as read (i.e., dated before the last-read-date), ",
            "  (2) older than a certain expire time, and",
            "  (3) not specifically marked as \"kept\".",
            "",
            "\"kept\" messages will show up in your @mail listing with an `=' to the right of the message number.",
            "",
            "The first form of the @keep-mail command marks the indicated messages as kept.  The message-sequence argument is as with other mail commands (see `help message-sequences').  @keep-mail without any arguments marks your current message as kept.",
            "",
            "The second form of the command is used to remove all such marks from your mail collection.",
            "",
            "    @mail kept:",
            "",
            "will produce a list of all messages marked as kept (see `help message-sequences').",
            "",
            "You can use @mail-option expire (see `help @mail-option') to change your expire time.",
            "",
            "You can use the @netforward command (see `help @netforward') to send mail to your email address for local archival.",
            "",
            "[...At the time of this writing, player mail is taking up a large fraction of LambdaMOO's database.  It would be appreciated if you not @keep any more mail than you have to...]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@keep-mail"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@forward"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@quicksend"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@quickreply"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   @quickreply  <msg> [on *<recipient>] [<flags>...]",
            "          @quickreply  <msg> [<flags>...] [on *<recipient>] ",
            "",
            "Synonym:  @qreply",
            "",
            "The @quickreply command allows you to do a short reply to a mail message without heading for the mail room.  As with @reply, the subject line on the reply message is taken from the original.  <flags> are as with @reply, except that `include' is not recognized --- if you're going to include the original message, you *have* to trim it down, and that requires the editor."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   @quicksend <player> [subj=\"<text>\"] <one-line-message>...",
            "          @quicksend <player> [subj=\"<text>\"]",
            "",
            "Synonym:  @qsend",
            "",
            "The @quicksend command allows you to send a short mail message without heading for the mail room.  With the second form of the command you will be prompted for the body of the message (and a subject line unless your `nosubject' mailoption is set (see `help @mail-option') or you already gave a subject line)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Alternative mail reading commands.",
            "",
            "Syntax:  @nn",
            "",
            "This command finds a folder containing an unread message, displays the first such, and updates your last-read-time for that folder.  Your personal mail and all @subscribed folders are checked.",
            "",
            "Syntax:  @mail-all-new-mail",
            "",
            "Displays headers of all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).",
            "",
            "Syntax:  @read-all-new-mail",
            "",
            "Displays all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).  This command ends with a prompt, \"Did you get all of that? [Enter `yes' or `no'].\"  Answering \"yes\" causes all of your last-read times to be updated.  You will probably want to check for <<<n lines flushed>>> indications before you answer this question.",
            "",
            "@read-all-new-mail (with a \"yes\" answer at the end) is equivalent to doing a large number of @nn's."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@nn"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@nn"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  @refile <message-seq> [on mail-recipient] to mail-recipient",
            "         @copymail <message-seq> [on mail-recipient] to mail-recipient",
            "",
            "Moves a message sequence directly from one mail recipient (defaulting as per the sticky @mail-option) to another, without adding headers or reordering.",
            "",
            "NOTE:  The recipient of @refiled messages may well have its mail out of order.  This can confuse a variety of features of the mail system, which expects its messages to always be in chronological order.  Care should be exercised with @refile/@copymail."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@refile"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage:  @add-notify me to player",
            "    Sends mail to player saying that I want to be added to their mail notification property.",
            "Usage:  @add-notify player to me",
            "    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.",
            "",
            "In order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.  This verb facilitates that transaction."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The @unsend command was created by ballot on LambdaMOO, *B:Unsend (#77081).",
            "",
            "Syntax: @unsend [message-sequence] from <user>",
            "",
            "A message cannot be unsent to a player if e has read the message, it has been forwarded to eir e-mail address, or e has set an option to prevent messages being unsent to em.  A message cannot be unsent to a group of players unless it can be unsent to each player in the group.",
            "",
            "The unsender may not view a list of unread messages on a player.  E may only select the message(s) to be unsent by filters such as \"subject:<subject>\" or \"since:today\".",
            "",
            "In order to protect privacy, if any of the restrictions above, such as one of the users having already read the message, are not met, the error message will be quite generic and not tell you exactly what went wrong, but simply that messages could not be unsent.",
            "",
            "The following mail options are available:",
            "",
            "@mail-option +no_unsend      No one may @unsend messages they sent to you",
            "@mail-option -no_unsend      People may @unsend unread messages they send to you",
            "@mail-option @unsend=<message sequence>",
            "",
            "sets the default message sequence that the @unsend command will operate upon.  The default is \"last:1\"."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "mail-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Mail Commands Help Db"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This help database contains topics relating to the general use of the mail system.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            42114,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "86": {
      "id": 86,
      "name": "ToastStunt Help Database",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "stunt",
        "sqlite",
        "fio",
        "fileio",
        "toaststunt",
        "is_member()",
        "listen()",
        "move()",
        "open_network_connection()",
        "binary_hash()",
        "descendents()",
        "notify()",
        "queue_info()",
        "queued_tasks()",
        "random()",
        "string_hash()",
        "task_stack()",
        "value_hash()",
        "all_members()",
        "ancestors()",
        "argon2()",
        "argon2_verify()",
        "binary_hmac()",
        "chparent()",
        "chparents()",
        "chr()",
        "clear_ancestor_cache()",
        "connection_info()",
        "connection_name()",
        "connection_name_lookup()",
        "create()",
        "crypt()",
        "curl()",
        "decode_base64()",
        "delete_verb()",
        "descendants()",
        "disassemble()",
        "encode_base64()",
        "exec()",
        "exp()",
        "explode()",
        "file_chmod()",
        "file_close()",
        "file_count_lines()",
        "file_eof()",
        "file_grep()",
        "file_handles()",
        "file_list()",
        "file_mkdir()",
        "file_mode()",
        "file_name()",
        "file_open()",
        "file_openmode()",
        "file_read()",
        "file_readline()",
        "file_readlines()",
        "file_remove()",
        "file_rename()",
        "file_rmdir()",
        "file_seek()",
        "file_stat()",
        "file_tell()",
        "file_type()",
        "file_write()",
        "file_writeline()",
        "finished_tasks()",
        "frandom()",
        "ftime()",
        "generate_json()",
        "getenv()",
        "index()",
        "isa()",
        "locate_by_name()",
        "locations()",
        "log_cache_stats()",
        "mapdelete()",
        "maphaskey()",
        "mapkeys()",
        "mapvalues()",
        "memory_usage()",
        "new_waif()",
        "next_recycled_object()",
        "occupants()",
        "owned_objects()",
        "panic()",
        "parent()",
        "parents()",
        "parse_json()",
        "pcre_match()",
        "pcre_replace()",
        "random_bytes()",
        "read_http()",
        "recreate()",
        "recycled_objects()",
        "reseed_random()",
        "respond_to()",
        "reverse()",
        "rindex()",
        "salt()",
        "server_log()",
        "set_task_local()",
        "set_thread_mode()",
        "slice()",
        "sort()",
        "spellcheck()",
        "sqlite_close()",
        "sqlite_execute()",
        "sqlite_handles()",
        "sqlite_info()",
        "sqlite_interrupt()",
        "sqlite_last_insert_row_id()",
        "sqlite_limit()",
        "sqlite_open()",
        "sqlite_query()",
        "string_hmac()",
        "strtr()",
        "suspend()",
        "switch_player()",
        "task_local()",
        "thread_info()",
        "thread_pool()",
        "threads()",
        "toaststunt-index()",
        "typeof()",
        "usage()",
        "value_hmac()",
        "verb_args()",
        "verb_cache_stats()",
        "verb_code()",
        "verb_info()",
        "waif_stats()",
        "yin()"
      ],
      "propdefs": [
        {
          "value": [
            "LambdaMOO-Stunt adds the following built-in functions:",
            "",
            "binary_hmac",
            "string_hmac",
            "value_hmac       - Cryptographically secure HMAC functions.",
            "decode_base64",
            "encode_base64    - Encode and decode binary Base64 strings.",
            "exec             - Execute shell scripts and applications.",
            "exp              - Return Eulers number (E) to the power of <x>.",
            "generate_json    - Return the JSON representation of the MOO value.",
            "parse_json       - Return the MOO value representation of a JSON string.",
            "getenv           - Return the value of the named environment variable.",
            "mapdelete        - Delete a key from a map.",
            "mapkeys          - List the keys in a map.",
            "mapvalues        - List the values in a map.",
            "random_bytes     - Return a binary string of <x> bytes.",
            "read_http        - Parse lines from a network connection as HTTP requests.",
            "salt             - Generate a cryptographically secure salt string.",
            "strtr            - Replace characters in a string.",
            "crypt            - Encrypt a string using a variety of algorithms.",
            "task_local       - Return values associated with the current task.",
            "set_task_local   - Set values associated with the current task.",
            "respond_to       - Check if a verb is callable on an object.",
            "isa              - Check if an object is a descendant of another object.",
            "switch_player    - Silently switch a connection to another player.",
            "",
            "",
            "Additionally, the ToastStunt fork adds these:",
            "",
            "argon2                  - Argon2id secure hashing.",
            "argon2_verify           - Compares password to hash",
            "sqlite                  - See HELP SQLITE for a complete list.",
            "pcre_match              - Match a string using Perl Compatible Regular Expressions.",
            "pcre_replace            - Replace text in a string using Perl Compatible Regular Expressions.",
            "frandom                 - Random floats.",
            "distance                - Calculate the distance between an arbitrary number of points.",
            "relative_heading        - Calculate a relative bearing between two points.",
            "memory_usage            - Total memory used, resident set size, shared pages, text, data + stack",
            "ftime                   - Precise time, including an argument for monotonic timing.",
            "locate_by_name          - Quickly locate objects by their name and aliases.",
            "usage                   - Returns a list of system information from the operating system.",
            "explode                 - Return a list of substrings of a string separated by a break.",
            "occupants               - Return a list of objects of parent parent, optionally with a player flag check.",
            "spellcheck              - Check the spelling of a word using Aspell.",
            "locations               - Recursive location reporting function.",
            "clear_ancestor_cache    - Manually clears the ancestor cache.",
            "simplex_noise           - Generate Simplex Noise.",
            "threads                 - Display a list of active threads.",
            "thread_info             - Display specific information about a running thread.",
            "new_waif                - Create a new waif.",
            "waif_stats              - Display a count of instantiated waifs by class.",
            "sort                    - Sorts a list by itself or another list of keys. Also support natural ordering and reverse.",
            "yin                     - Yield if needed. Suspend a task when running out of ticks or seconds.",
            "slice                   - Makes a new list of the index-th elements of the original list.",
            "reverse                 - Reverse a list.",
            "recreate                - Create valid objects from invalid objects.",
            "set_thread_mode         - Enable or disable threading of functions for the current verb.",
            "chr                     - Translate integers into ASCII characters.",
            "recycled_objects        - Return a list of all invalid objects in the database.",
            "next_recycled_object    - Return the first available invalid object.",
            "all_members             - Return the indices of all instances of an element in a list.",
            "owned_objects           - Return a list of all objects owned by the specified player.",
            "sqlite_limit            - Specify limits on various SQLite constructs.",
            "curl                    - Return websites as strings.",
            "connection_name_lookup  - Perform a DNS name lookup in another thread.",
            "thread_pool             - Manipulate the server thread pool. (Caution advised.)",
            "connection_info         - Return network information about a specific connection.",
            "maphaskey               - Return true if a map contains the key specified.",
            "ancestors               - Return all ancestors of an object",
            "finished_tasks          - When enabled, track execution time",
            "listen                  - Updated listen() with ipv6 & tls",
            "open_network_connection - Updated to support ipv6 & tls",
            "reseed_random           - Provide a new seed to the pseudo random number generator.",
            "FileIO                  - See HELP fileio for details",
            "log_cache_stats",
            "verb_cache_stats",
            "create",
            "value_hash",
            "index",
            "rindex",
            "encode_base64",
            "decode_base64",
            "string_hash",
            "binary_hash",
            "server_log",
            "new_waif",
            "sqlite",
            "typeof",
            "reverse",
            "locations",
            "finished_tasks",
            "explode",
            "chparents",
            "parents",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "SQLite allows you to store information in locally hosted SQLite databases. The following functions (see HELP <function name> for detailed information) are available:",
            "",
            "sqlite_open                Opens an SQLite database.",
            "sqlite_close               Closes an SQLite database.",
            "sqlite_handles             Returns a list of open SQLite database handles.",
            "sqlite_info                Returns information about an open SQLite database.",
            "sqlite_query               Runs a raw SQL query on the database.",
            "sqlite_execute             Executes an SQL prepared statement on the database.",
            "sqlite_limit               Set limits on various SQL constructs.",
            "sqlite_interrupt           Abort a database operation.",
            "sqlite_last_insert_row_id  Identifies row ID of the last insert command"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "fileio"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "General-purpose functions:",
            "",
            "FHANDLE file_open(STR pathname, STR mode)",
            "void file_close(FHANDLE fh)",
            "STR file_name(FHANDLE fh)",
            "STR file_openmode(FHANDLE fh)",
            "STR file_readline(FHANDLE fh)",
            "LIST file_readlines(FHANDLE fh, INT start, INT end)",
            "void file_writeline(FHANDLE fh, STR line)",
            "STR file_read(FHANDLE fh, INT bytes)",
            "INT file_write(FHANDLE fh, STR data)",
            "INT file_tell(FHANDLE fh)",
            "void file_seek(FHANDLE fh, INT loc, STR whence)",
            "INT file_eof(FHANDLE fh)",
            "void file_rename(STR oldpath, STR newpath)",
            "void file_remove(STR pathname)",
            "void file_mkdir(STR pathname)",
            "void file_rmdir(STR pathname)",
            "LIST file_list(STR pathname, [ANY detailed])",
            "STR file_type(STR pathname)",
            "STR file_mode(STR filename)",
            "void file_chmod(STR filename, STR mode)",
            "LIST file_handles()",
            "LIST file_grep(FHANDLER fh, STR search [,?match_all=0])",
            "",
            "Attribute functions:",
            "",
            "INT file_size(STR pathname)",
            "STR file_mode(STR pathname)",
            "INT file_last_access(STR pathname)",
            "INT file_last_modify(STR pathname)",
            "INT file_last_change(STR pathname)",
            "INT file_size(FHANDLE fh)",
            "STR file_mode(FHANDLE fh)",
            "INT file_last_access(FHANDLE fh)",
            "INT file_last_modify(FHANDLE fh)",
            "INT file_last_change(FHANDLE fh)",
            "INT file_count_lines(FHANDLE fh)",
            "",
            "void file_stat(STR pathname)",
            "void file_stat(FHANDLE fh)",
            "",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "stunt"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  is_member (ANY value, LIST list [, INT case-sensitive])   => INT",
            "",
            "Returns the index of <value> if there is an element of <list> that is completely indistinguishable from <value>. This is much the same operation as \"<value> in <list>\" except that, unlike `in', the `is_member()' function does not treat upper- and lower-case characters in strings as equal. This treatment of strings can be controlled with the <case-sensitive> argument; setting <case-sensitive> to false will effectively disable this behavior.",
            "",
            "Raises E_ARGS if two values are given or if more than three arguments are given. Raises E_TYPE if the second argument is not a list. Otherwise returns the index of <value> in <list>, or 0 if it's not in there.",
            "",
            "  is_member(3, {3, 10, 11})                  => 1",
            "  is_member(\"a\", {\"A\", \"B\", \"C\"})            => 0",
            "  is_member(\"XyZ\", {\"XYZ\", \"xyz\", \"XyZ\"})    => 3",
            "  is_member(\"def\", {\"ABC\", \"DEF\", \"GHI\"}, 0) => 2"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  listen (OBJ <object>, INT <port> [, MAP <options>])   => value",
            "",
            "Create a new point at which the server will listen for network connections, just as it does normally. <Object> is the object whose verbs `do_login_command', `do_command', `do_out_of_band_command', `user_connected', `user_created', `user_reconnected', `user_disconnected', and `user_client_disconnected' will be called at appropriate points as these verbs are called on #0 for normal connections. (See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for the complete story on when these functions are called.) <Port> is a TCP port number on which to listen. The listen() function will return <port> unless <port> is zero, in which case the return value is a port number assigned by the operating system.",
            "",
            "An optional third argument allows you to set various miscellaneous options for the listening point. These are:",
            "",
            "  print-messages: If true, the various database-configurable messages (also detailed in the chapter on server assumptions) will be printed on connections received at the new listening port.",
            "  ipv6:           Use the IPv6 protocol rather than IPv4.",
            "  tls:            Only accept valid secure TLS connections.",
            "  certificate:    The full path to a TLS certificate. NOTE: Requires the TLS option also be specified and true. This option is only necessary if the certificate differs from the one specified in options.h.",
            "  key:            The full path to a TLS private key. NOTE: Requires the TLS option also be specified and true. This option is only necessary if the key differs from the one specified in options.h.",
            "",
            "listen() raises E_PERM if the programmer is not a wizard, E_INVARG if <object> is invalid or there is already a listening point described by <point>, and E_QUOTA if some network-configuration-specific error occurred.",
            "",
            "",
            "Example:",
            ">;listen(#0, 1234, [\"ipv6\" -> 1, \"tls\" -> 1, \"certificate\" -> \"/etc/certs/something.pem\", \"key\" -> \"/etc/certs/privkey.pem\", \"print-messages\" -> 1]",
            "Listen for IPv6 connections on port 1234 and print messages as appropriate. These connections must be TLS and will use the private key and certificate found in /etc/certs."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  move (OBJ <what>, OBJ <where>[, INT <position>])   => none",
            "",
            "Changes <what>'s location to be <where>.  This is a complex process because a number of permissions checks and notifications must be performed. The actual movement takes place as described in the following paragraphs.",
            "",
            "<what> should be a valid object and <where> should be either a valid object or `#-1' (denoting a location of 'nowhere'); otherwise E_INVARG is raised.  The programmer must be either the owner of <what> or a wizard; otherwise, E_PERM is raised.",
            "",
            "If <where> is a valid object and isn't the same as <what>'s location, then the verb-call",
            "",
            "    <where>:accept(<what>)",
            "",
            "is performed before any movement takes place.  If the verb returns a false value and the programmer is not a wizard, then <where> is considered to have refused entrance to <what>; `move()' raises E_NACC.  If <where> does not define an `accept' verb, then it is treated as if it defined one that always returned false.",
            "",
            "If moving <what> into <where> would create a loop in the containment hierarchy (i.e., <what> would contain itself, even indirectly), then E_RECMOVE is raised instead.",
            "",
            "The `location' property of <what> is changed to be <where>, and the `contents' properties of the old and new locations are modified appropriately.  If <position> is specified, the object will be inserted into the `contents' property of the new location at <position>.",
            "",
            "If <where> differs from <what>'s current location, two additional verb calls take place.  Let <old-where> be the location of <what> before it was moved.  If <old-where> is a valid object, then the verb-call",
            "",
            "    <old-where>:exitfunc(<what>)",
            "",
            "is performed and its result is ignored; it is not an error if <old-where> does not define a verb named `exitfunc'.  Finally, if <where> and <what> are still valid objects, and <where> is still the location of <what>, then the verb-call",
            "",
            "    <where>:enterfunc(<what>)",
            "",
            "is performed and its result is ignored; again, it is not an error if <where> does not define a verb named `enterfunc'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  open_network_connection (STR <host>, INT <port> [, MAP <options>])   => obj",
            "",
            "Establishes a network connection to the place specified by the arguments and more-or-less pretends that a new, normal player connection has been established from there.  The new connection, as usual, will not be logged in initially and will have a negative object number associated with it for use with `read()', `notify()', and `boot_player()'.  This object number is the value returned by this function.",
            "",
            "If the programmer is not a wizard or if the `OUTBOUND_NETWORK' compilation option was not used in building the server, then `E_PERM' is raised.",
            "",
            "<Host> refers to a string naming a host (possibly a numeric IP address) and <port> is an integer referring to a TCP port number.  If a connection cannot be made because the host does not exist, the port does not exist, the host is not reachable or refused the connection, `E_INVARG' is raised.  If the connection cannot be made for other reasons, including resource limitations, then `E_QUOTA' is raised.",
            "",
            "Optionally, you can specify a map with any or all of the following options:",
            "",
            "  listener: An object whose listening verbs will be called at appropriate points. (See HELP LISTEN() for more details.)",
            "  tls:      If true, establish a secure TLS connection.",
            "  ipv6:     If true, utilize the IPv6 protocol rather than the IPv4 protocol.",
            "",
            "The outbound connection process involves certain steps that can take quite a long time, during which the server is not doing anything else, including responding to user commands and executing MOO tasks.  See the chapter on server assumptions about the database for details about how the server limits the amount of time it will wait for these steps to successfully complete.",
            "",
            "It is worth mentioning one tricky point concerning the use of this function.  Since the server treats the new connection pretty much like any normal player connection, it will naturally try to parse any input from that connection as commands in the usual way.  To prevent this treatment, you should use `set_connection_option()' to set the `hold-input' option true on the connection.",
            "",
            "Example:",
            ">;open_network_connection(\"2607:5300:60:4be0::\", 1234, [\"ipv6\" -> 1, \"listener\" -> #6, \"tls\" -> 1])",
            "Open a new connection to the IPv6 address 2607:5300:60:4be0:: on port 1234 using TLS. Relevant verbs will be called on #6."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  string_hash (STR string, [, algo [, binary])",
            "         binary_hash (STR bin-string, [, algo [, binary])",
            "",
            "string_hash -- Returns a 64-character hexadecimal string.",
            "binary_hash -- Returns a 64-character hexadecimal string.",
            "",
            "Returns a 64-character hexadecimal string encoding the result of applying the SHA256 cryptographically secure hash function to the contents of the string text or the binary string bin-string. If algo is provided, it specifies the hashing algorithm to use. \"MD5\", \"SHA1\" and \"SHA256\" are all supported.",
            "",
            "Note that the MD5 hash algorithm is broken from a cryptographic standpoint, as is SHA1. Both are included for interoperability with existing applications (both are still popular).",
            "",
            "All supported hash functions have the property that, if",
            "",
            "string_hash(x) == string_hash(y)",
            "",
            "then, almost certainly,",
            "",
            "equal(x, y)",
            "",
            "This can be useful, for example, in certain networking applications: after sending a large piece of text across a connection, also send the result of applying string_hash() to the text; if the destination site also applies string_hash() to the text and gets the same result, you can be quite confident that the large text has arrived unchanged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "descendants"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: INT notify (OBJ conn, STR string [, INT no-flush [, INT suppress-newline]])",
            "",
            "Enqueues <string> for output (on a line by itself) on the connection <conn>. If the programmer is not <conn> or a wizard, then E_PERM is raised. If <conn> is not a currently-active connection, then this function does nothing. Output is normally written to connections only between tasks, not during execution.",
            "",
            "The server will not queue an arbitrary amount of output for a connection; the `MAX_QUEUED_OUTPUT' compilation option (in `options.h') controls the limit. When an attempt is made to enqueue output that would take the server over its limit, it first tries to write as much output as possible to the connection without having to wait for the other end. If that doesn't result in the new output being able to fit in the queue, the server starts throwing away the oldest lines in the queue until the new output will fit. The server remembers how many lines of output it has `flushed' in this way and, when next it can succeed in writing anything to the connection, it first writes a line like `>> Network buffer overflow; X lines of output to you have been lost <<' where <X> is the number of of flushed lines.",
            "",
            "If <no-flush> is provided and true, then `notify()' never flushes any output from the queue; instead it immediately returns false. `Notify()' otherwise always returns true.",
            "",
            "If no-flush is provided and true, then `notify()` never flushes any output from the queue; instead it immediately returns false. `Notify()` otherwise always returns true.",
            "",
            "",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: LIST queue_info([obj user])",
            "         MAP queue_info([obj user])",
            "",
            "Returns the number of forked tasks that <user> has at the moment.  Since it doesn't say which tasks, security is not a significant issue.  If no argument is given, then gives a list of all users with task queues in the server.  (Essentially all connected players + all open connections + all users with tasks running in the background.)",
            "",
            "If the caller is a wizard a map of debug information about task queues will be returned."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  queued_tasks ([INT <show runtime> [, INT count-only])   => LIST",
            "",
            "Returns information on each of the background tasks (i.e., forked, suspended, or reading)  owned by the programmer (or, if the programmer is a wizard, all queued tasks). The returned value is a list of lists, each of which encodes certain information about a particular queued task in the following format:",
            "",
            "    {<task-id>, <start-time>, <ticks>, <clock-id>,",
            "     <programmer>, <verb-loc>, <verb-name>, <line>, <this>, <task-size>}",
            "",
            "where <task-id> is a numeric identifier for this queued task, <start-time> is the time after which this task will begin execution (in `time()' format), <ticks> is the number of ticks this task will have when it starts (always 20,000 now, though this is changeable. This makes this value obsolete and no longer interesting), <clock-id> is a number whose value is no longer interesting, <programmer> is the permissions with which this task will begin execution (and also the player who \"owns\" this task), <verb-loc> is the object on which the verb that forked this task was defined at the time, <verb-name> is that name of that verb, <line> is the number of the first line of the code in that verb that this task will execute, and <this> is the value of the variable `this' in that verb. For reading tasks, <start-time> is `-1'.  <task-size> is in bytes, and is the size of memory in use by the task for local variables, stack frames, etc.",
            "",
            "If <show runtime> is true, all variables present in the task are presented in a map with the variable name as the key and its value as the value.     ",
            "",
            "If `count-only` is true, then only the number of tasks is returned. This is significantly more performant than length(queued_tasks()). ",
            "",
            "The <ticks> and <clock-id> fields are now obsolete and are retained only for backward-compatibility reasons.  They may disappear in a future version of the server."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: int random ([INT mod [,INT range]])",
            "",
            "random -- Return a random integer ",
            "",
            "mod must be a positive integer; otherwise, E_INVARG is raised. If mod is not provided, it defaults to the largest MOO integer, which will depend on if you are running 32 or 64bit.",
            "",
            "if range is provided then an integer in the range of mod to range (inclusive) is returned.",
            "",
            "random(10)                  => integer between 1-10",
            "random()                    => integer between 1 and maximum integer supported",
            "random(1, 5000)             => integer between 1 and 5000"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "binary_hash()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: task_stack (INT task-id [, INT include-line-numbers [, INT include-variables])  => LIST",
            "",
            "Returns information like that returned by the `callers()' function, but for the suspended task with the given <task-id>; the <include-line-numbers> argument has the same meaning as in `callers()'. Raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task.",
            "",
            "If include-line-numbers is passed and true, line numbers will be included.",
            "",
            "If include-variables is passed and true, variables will be included with each frame of the provided task."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: str value_hash(value, [, STR algo [, binary])",
            "",
            "Returns the same string as string_hash(toliteral(value)). ",
            "",
            "See the description of string_hash() for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  all_members(ANY <value>, LIST <alist>)  => LIST",
            "",
            "Returns the indices of every instance of <value> in <alist>.",
            "",
            "Example:",
            ";all_members(\"a\", {\"a\", \"b\", \"a\", \"c\", \"a\", \"d\"}) => {1, 3, 5}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ancestors(OBJ <object> [, INT <full>])   => LIST",
            "",
            "Return a list of all ancestors of <object> in order ascending up the inheritance hiearchy. If <full> is true, <object> will be included in the list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   argon2 (STR <password>, STR <salt> [, <iterations> 3] [, <memory usage in KB> 4096] [, <CPU threads> 1]) => STR",
            "",
            "The function `argon2()' hashes a password using the Argon2id password hashing algorithm. It is parametrized by three optional arguments:",
            "",
            " * Time: This is the number of times the hash will get run. This defines the amount of computation required and, as a result, how long the function will take to complete.",
            " * Memory: This is how much RAM is reserved for hashing.",
            " * Parallelism: This is the number of CPU threads that will run in parallel.",
            "",
            "The salt for the password should, at minimum, be 16 bytes for password hashing. It is recommended to use the random_bytes() function."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   argon2_verify (STR <hash>, STR <password>)  => INT",
            "",
            "Compares <password> to the previously hashed <hash>. Returns 1 if the two match or 0 if they don't."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  string_hmac (STR text, STR key [, STR algo [, binary]])",
            "         binary_hmac (STR bin-string, STR key [, STR algo [, binary]])",
            "",
            "Returns a string encoding the result of applying the HMAC-SHA256 cryptographically secure HMAC function to the contents of the string text or the binary string bin-string with the specified secret key. If algo is provided, it specifies the hashing algorithm to use. Currently, only \"SHA1\" and \"SHA256\" are supported. If binary is provided and true, the result is in MOO binary string format; by default the result is a hexidecimal string.",
            "",
            "All cryptographically secure HMACs have the property that, if string_hmac(x, a) == string_hmac(y, b) then, almost certainly, equal(x, y) and furthermore, equal(a, b)",
            "",
            " This can be useful, for example, in applications that need to verify both the integrity of the message (the text) and the authenticity of the sender (as demonstrated by the possession of the secret key)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: chparent (OBJ object, OBJ new-parent)    => NONE",
            "        chparents (OBJ object, LIST new-parents) => NONE",
            "",
            "chparent  -- Changes the parent of object to be new-parent.",
            "chparents -- Changes the parent of object to be new-parents.",
            "",
            "If object is not valid, or if new-parent is neither valid nor equal to #-1, then E_INVARG is raised. If the programmer is neither a wizard or the owner of object, or if new-parent is not fertile (i.e., its f bit is not set) and the programmer is neither the owner of new-parent nor a wizard, then E_PERM is raised. If new-parent is equal to object or one of its current ancestors, E_RECMOVE is raised. If object or one of its descendants defines a property with the same name as one defined either on new-parent or on one of its ancestors, then E_INVARG is raised.",
            "",
            "Changing an object's parent can have the effect of removing some properties from and adding some other properties to that object and all of its descendants (i.e., its children and its children's children, etc.). Let common be the nearest ancestor that object and new-parent have in common before the parent of object is changed. Then all properties defined by ancestors of object under common (that is, those ancestors of object that are in turn descendants of common) are removed from object and all of its descendants. All properties defined by new-parent or its ancestors under common are added to object and all of its descendants. As with create(), the newly-added properties are given the same permission bits as they have on new-parent, the owner of each added property is either the owner of the object it's added to (if the c permissions bit is set) or the owner of that property on new-parent, and the value of each added property is clear; see the description of the built-in function clear_property() for details. All properties that are not removed or added in the reparenting process are completely unchanged.",
            "",
            "If new-parent is equal to #-1, then object is given no parent at all; it becomes a new root of the parent/child hierarchy. In this case, all formerly inherited properties on object are simply removed.",
            "",
            "If new-parents is equal to {}, then object is given no parent at all; it becomes a new root of the parent/child hierarchy. In this case, all formerly inherited properties on object are simply removed.",
            "",
            "Warning: On the subject of multiple inheritance, the author (Slither) thinks you should completely avoid it. Prefer composition over inheritance.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "chparent()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  chr(INT <arg>, ...)  => STR",
            "",
            "This function translates integers into ASCII characters. Each argument must be an integer between 0 and 255.",
            "If the programmer is not a wizard, and integers less than 32 are provided, E_INVARG is raised. This prevents control characters or newlines from being written to the database file by non-trusted individuals."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  clear_ancestor_cache()   => none",
            "",
            "The ancestor cache contains a quick lookup of all of an object's ancestors which aids in expediant property lookups. This is an experimental feature and, as such, you may find that something has gone wrong. If that's that case, this function will completely clear the cache and it will be rebuilt as-needed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_info (OBJ <connection>)   => LIST",
            "",
            "Returns a MAP of network connection information for <connection>. At the time of writing, the following information is returned:",
            "",
            "destination_address: The hostname of the connection. For incoming connections, this is the hostname of the connected user.",
            "                     For outbound connections, this is the hostname of the outbound connection's destination.",
            "",
            "destination_ip:      The unresolved numeric IP address of the connection.",
            "",
            "destination_port:    For incoming connections, this is the local port used to make the connection.",
            "                     For outbound connections, this is the port the connection was made to.",
            "",
            "source_address:      This is the hostname of the interface an incoming connection was made on. For outbound connections, this value is meaningless.",
            "",
            "source_ip:           The unresolved numeric IP address of the interface a connection was made on. For outbound connections, this value is meaningless.",
            "",
            "source_port:         The local port a connection connected to. For outbound connections, this value is meaningless.",
            "",
            "protocol:            Describes the protocol used to make the connection. At the time of writing, this could be IPv4 or IPv6.",
            "\t\t       "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_name (OBJ <player>, [INT method])   => STR",
            "",
            "When provided just a player object this function only returns obj's hostname (e.g. 1-2-3-6.someplace.com). An optional argument allows you to specify 1 if you want a numeric IP address, or 2 if you want to return the legacy connection_name string.",
            "",
            "Warning: If you are using a LambdaMOO core, this is a semi-breaking change. You'll want to update any code on your server that runs connection_name to pass in the argument for returning the legacy connection_name string if you want things to work exactly the same.",
            "",
            "If the programmer is not a wizard and not player, then E_PERM is raised. If player is not currently connected, then E_INVARG is raised.",
            "",
            "Legacy Connection String Information:",
            "",
            "For the TCP/IP networking configurations, for in-bound connections, the string has the form:",
            "",
            "\"port lport from host, port port\"",
            "",
            "where lport is the decimal TCP listening port on which the connection arrived, host is either the name or decimal TCP address of the host from which the player is connected, and port is the decimal TCP port of the connection on that host.",
            "",
            "For outbound TCP/IP connections, the string has the form",
            "",
            "\"port lport to host, port port\"",
            "",
            "where lport is the decimal local TCP port number from which the connection originated, host is either the name or decimal TCP address of the host to which the connection was opened, and port is the decimal TCP port of the connection on that host.",
            "",
            "For the System V 'local' networking configuration, the string is the UNIX login name of the connecting user or, if no such name can be found, something of the form:",
            "",
            "\"User #number\"",
            "",
            "where number is a UNIX numeric user ID.",
            "",
            "For the other networking configurations, the string is the same for all connections and, thus, useless."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  connection_name_lookup (OBJ <connection> [, INT record_result])   => STR",
            "",
            "This function performs a DNS name lookup on connection's IP address. If a hostname can't be resolved, the function simply returns the numeric IP address. Otherwise, it will return the resolved hostname.",
            "",
            "If record_result is true, the resolved hostname will be saved with the connection and will overwrite it's existing 'connection_name()'. This means that you can call 'connection_name_lookup()' a single time when a connection is created and then continue to use 'connection_name()' as you always have in the past.",
            "",
            "This function is primarily intended for use when the 'NO_NAME_LOOKUP' server option is set. Barring temporarily failures in your nameserver, very little will be gained by calling this when the server is performing DNS name lookups for you.",
            "",
            "NOTE: This function runs in a separate thread. While this is good for performance (long lookups won't lock your MOO like traditional pre-2.6.0 name lookups), it also means it will require slightly more work to create an entirely in-database DNS lookup solution. Because it explicitly suspends, you won't be able to use it in 'do_login_command()' without also using the 'switch_player()' function. For an example of how this can work, see '#0:do_login_command()' in ToastCore."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: create (obj parent [, obj owner] [, int anon-flag] [, list init-args])   => OBJ",
            "        create (list parents [, obj owner] [, int anon-flag] [, list init-args]) => OBJ",
            "",
            "Creates and returns a new object whose parents are parents (or whose parent is parent) and whose owner is as described below. If any of the given parents are not valid, or if the given parent is neither valid nor #-1, then E_INVARG is raised. The given parents objects must be valid and must be usable as a parent (i.e., their a or f bits must be true) or else the programmer must own parents or be a wizard; otherwise E_PERM is raised. Futhermore, if anon-flag is true then a must be true; and, if anon-flag is false or not present, then f must be true. Otherwise, E_PERM is raised unless the programmer owns parents or is a wizard. E_PERM is also raised if owner is provided and not the same as the programmer, unless the programmer is a wizard.",
            "",
            "After the new object is created, its initialize verb, if any, is called. If init-args were given, they are passed as args to initialize. The new object is assigned the least non-negative object number that has not yet been used for a created object. Note that no object number is ever reused, even if the object with that number is recycled.",
            "",
            "    Note: This is not strictly true, especially if you are using ToastCore and the $recycler, which is a great idea. If you don't, you end up with extremely high object numbers. However, if you plan on reusing object numbers you need to consider this carefully in your code. You do not want to include object numbers in your code if this is the case, as object numbers could change. Use corified references instead (IE: @prop #0.my_object #objnum allows you to use $my_object in your code. If the object number ever changes, you can change the reference without updating all of your code.)",
            "",
            "If anon-flag is false or not present, the new object is a permanent object and is assigned the least non-negative object number that has not yet been used for a created object. Note that no object number is ever reused, even if the object with that number is recycled.",
            "",
            "If anon-flag is true, the new object is an anonymous object and is not assigned an object number. Anonymous objects are automatically recycled when they are no longer used.",
            "",
            "The owner of the new object is either the programmer (if owner is not provided), the new object itself (if owner was given and is invalid, or owner (otherwise).",
            "",
            "The other built-in properties of the new object are initialized as follows:",
            "",
            "name         \"\"",
            "location     #-1",
            "contents     {}",
            "programmer   0",
            "wizard       0",
            "r            0",
            "w            0",
            "f            0",
            "",
            "The function is_player() returns false for newly created objects.",
            "",
            "In addition, the new object inherits all of the other properties on its parents. These properties have the same permission bits as on the parents. If the c permissions bit is set, then the owner of the property on the new object is the same as the owner of the new object itself; otherwise, the owner of the property on the new object is the same as that on the parent. The initial value of every inherited property is clear; see the description of the built-in function clear_property() for details.",
            "",
            "If the intended owner of the new object has a property named ownership_quota and the value of that property is an integer, then create() treats that value as a quota. If the quota is less than or equal to zero, then the quota is considered to be exhausted and create() raises E_QUOTA instead of creating an object. Otherwise, the quota is decremented and stored back into the ownership_quota property as a part of the creation of the new object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: crypt (STR text [, STR salt])",
            "",
            "Encrypts (hashes) the given text using the standard UNIX encryption method. If provided, salt should be a string at least two characters long, and it may dictate a specific algorithm to use. By default, crypt uses the original, now insecure, DES algorithm. Stunt specifically includes the BCrypt algorithm (identified by salts that start with \"$2a$\"), and may include MD5, SHA256, and SHA512 algorithms depending on the libraries used to build the server. The salt used is returned as the first part of the resulting encrypted string.",
            "",
            "Aside from the possibly-random input in the salt, the encryption algorithms are entirely deterministic. In particular, you can test whether or not a given string is the same as the one used to produce a given piece of encrypted text; simply extract the salt from the front of the encrypted text and pass the candidate string and the salt to crypt(). If the result is identical to the given encrypted text, then youve got a match.",
            "",
            "crypt(\"foobar\", \"iB\")                               =>    \"iBhNpg2tYbVjw\"",
            "crypt(\"foobar\", \"$1$MAX54zGo\")                      =>    \"$1$MAX54zGo$UKU7XRUEEiKlB.qScC1SX0\"",
            "crypt(\"foobar\", \"$5$s7z5qpeOGaZb\")                  =>    \"$5$s7z5qpeOGaZb$xkxjnDdRGlPaP7Z ... .pgk/pXcdLpeVCYh0uL9\"",
            "crypt(\"foobar\", \"$5$rounds=2000$5trdp5JBreEM\")      =>    \"$5$rounds=2000$5trdp5JBreEM$Imi ... ckZPoh7APC0Mo6nPeCZ3\"",
            "crypt(\"foobar\", \"$6$JR1vVUSVfqQhf2yD\")              =>    \"$6$JR1vVUSVfqQhf2yD$/4vyLFcuPTz ... qI0w8m8az076yMTdl0h.\"",
            "crypt(\"foobar\", \"$6$rounds=5000$hT0gxavqSl0L\")      =>    \"$6$rounds=5000$hT0gxavqSl0L$9/Y ... zpCATppeiBaDxqIbAN7/\"",
            "crypt(\"foobar\", \"$2a$08$dHkE1lESV9KrErGhhJTxc.\")    =>    \"$2a$08$dHkE1lESV9KrErGhhJTxc.QnrW/bHp8mmBl5vxGVUcsbjo3gcKlf6\"",
            "",
            "Note: The specific set of supported algorithms depends on the libraries used to build the server. Only the BCrypt algorithm, which is distributed with the server source code, is guaranteed to exist. BCrypt is currently mature and well tested, and is recommended for new development."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  curl(STR <url> [, INT <include_headers>, INT timeout]) => STR",
            "",
            "The curl builtin will download a webpage and return it as a string. If <include_headers> is true, the HTTP headers will be included in the return string.",
            "",
            "It's worth noting that the data you get back will be binary encoded. In particular, you will find that line breaks appear as ~0A. You can easily convert a page into a list by passing the return string into the decode_binary() function.",
            "",
            "CURL_TIMEOUT is defined in options.h to specify the maximum amount of time a CURL request can take before failing. For special circumstances, you can specify a longer or shorter timeout using the third argument of curl()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  decode_base64 (STR base64 [, INT safe]) => STR",
            "",
            "Returns the binary string representation of the supplied Base64 encoded string argument. Raises E_INVARG if base64 is not a properly-formed Base64 string. If safe is provide and is true, a URL-safe version of Base64 is used (see RFC4648).",
            "",
            "decode_base64(\"AAEC\")       =>   \"~00~01~02\"",
            "decode_base64(\"AAE\", 1)     =>   \"~00~01\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  delete_verb (OBJ <object>, STR|INT <verb-name>)   => NONE",
            "",
            "BE AWARE: verb-name can be the string name of the verb OR the index from verbs()",
            "",
            "Removes the verb named <verb-name> from the given <object>.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised. If <object> does not define a verb named <verb-name>, then E_VERBNF is raised."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  descendants(OBJ <object> [, INT <full>])   => LIST",
            "",
            "Return a list of all nested children of <object>. If <full> is true, <object> will be included in the list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  disassemble (OBJ object, STR|INT verb-desc)   => LIST",
            "",
            "BE AWARE: verb-name can be the string name of the verb OR the index from verbs()",
            "",
            "Returns a (longish) list of strings giving a listing of the server's internal \"compiled\" form of the verb as specified by <verb-desc> on <object>. This format is not documented and may indeed change from release to release, but some programmers may nonetheless find the output of `disassemble()' interesting to peruse as a way to gain a deeper appreciation of how the server works.",
            "",
            "If <object> is not valid, then E_INVARG is raised. If <object> does not define a verb as specified by <verb-desc>, then E_VERBNF is raised. If the programmer does not have read permission on the verb in question, then disassemble() raises E_PERM."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  encode_base64 (STR binary [, INT safe]) => STR",
            "",
            "Returns the Base64 encoded string representation of the supplied binary string argument. Raises E_INVARG if binary is not a properly-formed binary string. If safe is provide and is true, a URL-safe version of Base64 is used (see RFC4648).",
            "",
            "encode_base64(\"~00~01~02\")     =>   \"AAEC\"",
            "encode_base64(\"~00~01\", 1)     =>   \"AAE\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: exec (LIST command[, STR input][, LIST environment variables])",
            "",
            "Asynchronously executes the specified external executable, optionally sending input. Returns the process return code, output and error. If the programmer is not a wizard, then E_PERM is raised.",
            "",
            "The first argument must be a list of strings, or E_INVARG is raised. The first string is the path to the executable and is required. The rest are command line arguments passed to the executable.",
            "",
            "The path to the executable may not start with a slash (/) or dot-dot (..), and it may not contain slash-dot (/.) or dot-slash (./), or E_INVARG is raised. If the specified executable does not exist or is not a regular file, E_INVARG is raised.",
            "",
            "If the string input is present, it is written to standard input of the executing process.",
            "",
            "Additionally, you can provide a list of environment variables to set in the shell.",
            "",
            "When the process exits, it returns a list of the form:",
            "",
            "{code, output, error}",
            "",
            "code is the integer process exit status or return code. output and error are strings of data that were written to the standard output and error of the process.",
            "",
            "The specified command is executed asynchronously. The function suspends the current task and allows other tasks to run until the command finishes. Tasks suspended this way can be killed with kill_task().",
            "",
            "The strings, input, output and error are all MOO binary strings.",
            "",
            "All external executables must reside in the executables directory.",
            "",
            "exec({\"cat\", \"-?\"})                                      {1, \"\", \"cat: illegal option -- ?~0Ausage: cat [-benstuv] [file ...]~0A\"}",
            "exec({\"cat\"}, \"foo\")                                     {0, \"foo\", \"\"}",
            "exec({\"echo\", \"one\", \"two\"})                             {0, \"one two~0A\", \"\"}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: exp (FLOAT x)",
            "",
            "Returns E (Eulers number) raised to the power of x. "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: explode(STR subject [, STR break [, INT include-sequential-occurrences]) => LIST",
            "",
            "Returns a list of substrings of subject that are separated by break. break defaults to a space.",
            "",
            "Only the first character of break is considered:",
            "",
            "explode(\"slither%is%wiz\", \"%\")      => {\"slither\", \"is\", \"wiz\"}",
            "explode(\"slither%is%%wiz\", \"%%\")    => {\"slither\", \"is\", \"wiz\"}",
            "",
            "You can use include-sequential-occurrences to get back an empty string as part of your list if break appears multiple times with nothing between it, or there is a leading/trailing break in your string:",
            "",
            "explode(\"slither%is%%wiz\", \"%%\", 1)  => {\"slither\", \"is\", \"\", \"wiz\"}",
            "explode(\"slither%is%%wiz%\", \"%\", 1)  => {\"slither\", \"is\", \"\", \"wiz\", \"\"}",
            "explode(\"%slither%is%%wiz%\", \"%\", 1) => {\"\", \"slither\", \"is\", \"\", \"wiz\", \"\"}",
            "",
            "Note: This can be used as a replacement for $string_utils:explode.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_chmod(STR filename, STR mode)",
            "",
            "  Attempts to set mode of a file using mode as an octal string of",
            "  exactly three characters.",
            "",
            "  This is implemented using chmod()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            " Function: void file_close(FHANDLE fh)",
            "",
            "  Closes the file associated with fh.",
            "",
            "  This is implemented using fclose()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: INT file_count_lines (FHANDLER fh)",
            "",
            "Count the lines in a file.",
            "",
            "",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: INT file_eof(FHANDLE fh)",
            "",
            "  Returns true if and only if fh's stream is positioned at EOF.",
            "",
            "  This is implemented using feof()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: LIST file_grep(FHANDLER fh, STR search [,?match_all = 0])",
            "",
            "Search for a string in a file.",
            "",
            "Assume we have a file `test.txt` with the contents:",
            "",
            "asdf asdf 11",
            "11",
            "112",
            "",
            "And we have an open file handler from running:",
            "",
            ";file_open(\"test.txt\", \"r-tn\")",
            "",
            "If we were to execute a file grep:",
            "",
            ";file_grep(1, \"11\")",
            "",
            "We would get the first result:",
            "",
            "{{\"asdf asdf 11\", 1}}",
            "",
            "The resulting LIST is of the form {{STR match, INT line-number}}",
            "",
            "If you pass in the optional third argument",
            "",
            ";file_grep(1, \"11\", 1)",
            "",
            "we will receive all the matching results:",
            "",
            "{{\"asdf asdf 11\", 1}, {\"11\", 2}, {\"112\", 3}}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: LIST file_handles()",
            "",
            "Return a list of open files.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: LIST file_list(STR pathname, [ANY detailed])",
            "",
            "  Attempts to list the contents of the given directory.  Returns a list",
            "  of files in the directory.  If the detailed argument is provided and",
            "  true, then the list contains detailed entries, otherwise it contains a",
            "  simple list of names.",
            "",
            "  detailed entry:",
            "    {STR filename, STR file type, STR file mode, INT file size}",
            "  normal entry:",
            "    STR filename",
            "",
            "  This is implemented using scandir()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_mkdir(STR pathname)",
            "",
            "  Attempts to create the given directory.",
            "",
            "  This is implemented using mkdir()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            " Function: STR file_mode(STR filename)",
            "",
            "  Returns octal mode for a file (e.g. \"644\").",
            "",
            "  This is implemented using stat()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: STR file_name(FHANDLE fh)",
            "",
            "  Returns the pathname originally associated with fh by file_open().",
            "  This is not necessarily the file's current name if it was renamed or",
            "  unlinked after the fh was opened."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            " Function: FHANDLE file_open(STR pathname, STR mode)",
            "",
            "  Raises: E_INVARG if mode is not a valid mode, E_QUOTA if too many files are open.",
            "  This opens a file specified by pathname and returns an FHANDLE for it.",
            "  It ensures pathname is legal.  Mode is a string of characters indicating what mode the file is opened in. ",
            "  The mode string is four characters.",
            "",
            "  The first character must be (r)ead, (w)rite, or (a)ppend.  The second must be '+' or '-'.  This modifies the previous argument.",
            "",
            "  o  r- opens the file for reading and fails if the file does not exist.",
            "",
            "  o  r+ opens the file for reading and writing and fails if the file",
            "     does not exist.",
            "",
            "  o  w- opens the file for writing, truncating if it exists and creating",
            "     if not.",
            "",
            "  o  w+ opens the file for reading and writing, truncating if it exists",
            "     and creating if not.",
            "",
            "  o  a- opens a file for writing, creates it if it does not exist and",
            "     positions the stream at the end of the file.",
            "",
            "  o  a+ opens the file for reading and writing, creates it if does not",
            "     exist and positions the stream at the end of the file.",
            "",
            "     The third character is either (t)ext or (b)inary.  In text mode,",
            "     data is written as-is from the MOO and data read in by the MOO is",
            "     stripped of unprintable characters.  In binary mode, data is",
            "     written filtered through the binary-string->raw-bytes conversion",
            "     and data is read filtered through the raw-bytes->binary-string",
            "     conversion.  For example, in text mode writing \" 1B\" means three",
            "     bytes are written: ' ' Similarly, in text mode reading \" 1B\" means",
            "     the characters ' ' '1' 'B' were present in the file.  In binary",
            "     mode reading \" 1B\" means an ASCII ESC was in the file.  In text",
            "     mode, reading an ESC from a file results in the ESC getting",
            "     stripped.",
            "",
            "  It is not recommended that files containing unprintable ASCII  data be",
            "  read in text mode, for obvious reasons.",
            "",
            "  The final character is either 'n' or 'f'.  If this character is 'f',",
            "  whenever data is written to the file, the MOO will force it to finish",
            "  writing to the physical disk before returning.  If it is 'n' then",
            "  this won't happen.",
            "",
            "  This is implemented using fopen()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: STR file_openmode(FHANDLE fh)",
            "",
            "  Returns the mode the file associated with fh was opened in."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: STR file_read(FHANDLE fh, INT bytes)",
            "",
            "  Reads up to the specified number of bytes from the file and returns",
            "  them.",
            "",
            "  Not recommended for use on files in text mode.",
            "",
            "  This is implemented using fread()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: STR file_readline(FHANDLE fh)",
            "",
            "  Reads the next line in the file and returns it (without the newline).",
            "",
            "  Not recommended for use on files in binary mode.",
            "",
            "  This is implemented using fgetc()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "  Function: LIST file_readlines(FHANDLE fh, INT start, INT end)",
            "",
            "  Rewinds the file and then reads the specified lines from the file,",
            "  returning them as a list of strings.  After this operation, the stream",
            "  is positioned right after the last line read.",
            "",
            "  Not recommended for use on files in binary mode.",
            "",
            "  This is implemented using fgetc()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_remove(STR pathname)",
            "",
            "  Attempts to remove the given file.",
            "",
            "  This is implemented using remove()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_rename(STR oldpath, STR newpath)",
            "",
            "  Attempts to rename the oldpath to newpath.",
            "",
            "  This is implemented using rename()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_rmdir(STR pathname)",
            "",
            "  Attempts to remove the given directory.",
            "",
            "  This is implemented using rmdir()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: void file_seek(FHANDLE fh, INT loc, STR whence)",
            "",
            "  Seeks to a particular location in a file.  whence is one of the",
            "  strings:",
            "",
            "  o  \"SEEK_SET\" - seek to location relative to beginning",
            "",
            "  o  \"SEEK_CUR\" - seek to location relative to current",
            "",
            "  o  \"SEEK_END\" - seek to location relative to end",
            "",
            "  This is implemented using fseek()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            " Function: void file_stat(STR pathname)",
            "  Function: void file_stat(FHANDLE fh)",
            "",
            "  Returns the result of stat() (or fstat()) on the given file.",
            "  Specifically a list as follows:",
            "",
            "  {file size in bytes, file type, file access mode, owner, group,",
            "       last access, last modify, and last change}",
            "",
            "  owner and group are always the empty string.",
            "",
            "  It is recommended that the specific information functions file_size,",
            "  file_type, file_mode, file_last_access, file_last_modify, and",
            "  file_last_change be used instead.  In most cases only one of these",
            "  elements is desired and in those cases there's no reason to make and",
            "  free a list."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: INT file_tell(FHANDLE fh)",
            "",
            "  Returns position in file.",
            "",
            "  This is implemented using ftell()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: STR file_type(STR pathname)",
            "",
            "  Returns the type of the given pathname, one of \"reg\", \"dir\", \"dev\",",
            "  \"fifo\", or \"socket\".",
            "",
            "  This is implemented using stat()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Function: INT file_write(FHANDLE fh, STR data)",
            "",
            "  Writes the specified data to the file.  Returns number of bytes",
            "  written.",
            "",
            "  Not recommended for use on files in text mode.",
            "",
            "  This is implemented using fwrite()."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "  Function: void file_writeline(FHANDLE fh, STR line)",
            "",
            "  Writes the specified line to the file (adding a newline).",
            "",
            "  Not recommended for use on files in binary mode.",
            "",
            "  This is implemented using fputs()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  finished_tasks ()   => LIST",
            "",
            "When enabled (via SAVE_FINISHED_TASKS in options.h), the server will keep track of the execution time of every task that passes through the interpreter. This data is then made available to the database in two ways.",
            "",
            "The first is the finished_tasks() function. This function will return a list of maps of the last several finished tasks (configurable via $server_options.finished_tasks_limit) with the following information:",
            "",
            "",
            "Foreground:    True if this was a foreground task.",
            "Fullverb:      The full name of the verb being executed.",
            "Object:        The object the verb is defined on.",
            "Player:        The result of the 'player' variable.",
            "Programmer:    The player whose permissions the verb is running as.",
            "Receiver:      The object that received the verb invocation. In the case of primitives, this is the primitive's object handler.",
            "Suspended:     True if the task suspended instead of finishing.",
            "This:          The result of the 'this' variable.",
            "Time:          The total time the task took inside the interpreter.",
            "Verb:          The verb name used to invoke the task.",
            "",
            "",
            "The second is via the $handle_lagging_task verb. When the execution threshold defined in $server_options.task_lag_threshold is exceeded, the server will write an entry to the log file and call the $handle_lagging_task verb with the call stack of the task as well as the execution time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  frandom (FLOAT <mod1> [, FLOAT <mod2>)   => FLOAT",
            "",
            "If only one argument is given, a floating point number is chosen randomly from the range `[1.0..<mod1>]` and returned. If two arguments are given, a floating point number is randomly chosen from the range `[<mod1>..<mod2>]`. "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  ftime ([INT monotonic])   => FLOAT",
            "",
            "Returns the current time represented as the number of seconds and nanoseconds that have elapsed since midnight on 1 January 1970, Greenwich Mean Time.",
            "",
            "If the <monotonic> argument is supplied and set to 1, the time returned will be monotonic. This means that will you will always get how much time has elapsed from an arbitrary, fixed point in the past that is unaffected by clock skew or other changes in the wall-clock. This is useful for benchmarking how long an operation takes, as it's unaffected by the actual system time.",
            "",
            "The general rule of thumb is that you should use ftime() with no arguments for telling time and ftime() with the monotonic clock argument for measuring the passage of time."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: generate_json (ANY value [, STR mode])",
            "",
            "Returns the JSON representation of the MOO value.",
            "",
            "MOO supports a richer set of values than JSON allows. The optional mode specifies how this function handles the conversion of MOO values into their JSON representation.",
            "",
            "The common subset mode, specified by the literal mode string \"common-subset\", is the default conversion mode. In this mode, only the common subset of types (strings and numbers) are translated with fidelity between MOO types and JSON types. All other types are treated as alternative representations of the string type. This mode is useful for integration with non-MOO applications.",
            "",
            "The embedded types mode, specified by the literal mode string \"embedded-types\", adds type information. Specifically, values other than strings and numbers, which carry implicit type information, are converted into strings with type information appended. The converted string consists of the string representation of the value (as if tostr() were applied) followed by the pipe (|) character and the type. This mode is useful for serializing/deserializing objects and collections of MOO values.",
            "",
            "generate_json([])                                           =>   \"{}\"",
            "generate_json([\"foo\" -> \"bar\"])                             =>   \"{\\\"foo\\\":\\\"bar\\\"}\"",
            "generate_json([\"foo\" -> \"bar\"], \"common-subset\")            =>   \"{\\\"foo\\\":\\\"bar\\\"}\"",
            "generate_json([\"foo\" -> \"bar\"], \"embedded-types\")           =>   \"{\\\"foo\\\":\\\"bar\\\"}\"",
            "generate_json([\"foo\" -> 1.1])                               =>   \"{\\\"foo\\\":1.1}\"",
            "generate_json([\"foo\" -> 1.1], \"common-subset\")              =>   \"{\\\"foo\\\":1.1}\"",
            "generate_json([\"foo\" -> 1.1], \"embedded-types\")             =>   \"{\\\"foo\\\":1.1}\"",
            "generate_json([\"foo\" -> #1])                                =>   \"{\\\"foo\\\":\\\"#1\\\"}\"",
            "generate_json([\"foo\" -> #1], \"common-subset\")               =>   \"{\\\"foo\\\":\\\"#1\\\"}\"",
            "generate_json([\"foo\" -> #1], \"embedded-types\")              =>   \"{\\\"foo\\\":\\\"#1|obj\\\"}\"",
            "generate_json([\"foo\" -> E_PERM])                            =>   \"{\\\"foo\\\":\\\"E_PERM\\\"}\"",
            "generate_json([\"foo\" -> E_PERM], \"common-subset\")           =>   \"{\\\"foo\\\":\\\"E_PERM\\\"}\"",
            "generate_json([\"foo\" -> E_PERM], \"embedded-types\")          =>   \"{\\\"foo\\\":\\\"E_PERM|err\\\"}\"",
            "",
            "JSON keys must be strings, so regardless of the mode, the key will be converted to a string value.",
            "",
            "generate_json([1 -> 2])                                     =>   \"{\\\"1\\\":2}\"",
            "generate_json([1 -> 2], \"common-subset\")                    =>   \"{\\\"1\\\":2}\"",
            "generate_json([1 -> 2], \"embedded-types\")                   =>   \"{\\\"1|int\\\":2}\"",
            "generate_json([#1 -> 2], \"embedded-types\")                  =>   \"{\\\"#1|obj\\\":2}\"",
            "",
            "tion: value parse_json (str json [, str mode])",
            "",
            "Returns the MOO value representation of the JSON string. If the specified string is not valid JSON, E_INVARG is raised.",
            "",
            "The optional mode specifies how this function handles conversion of MOO values into their JSON representation. The options are the same as for generate_json().",
            "",
            "parse_json(\"{}\")                                            =>   []",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\")                             =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\", \"common-subset\")            =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\", \"embedded-types\")           =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":1.1}\")                                 =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":1.1}\", \"common-subset\")                =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":1.1}\", \"embedded-types\")               =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":\\\"#1\\\"}\")                              =>   [\"foo\" -> \"#1\"]",
            "parse_json(\"{\\\"foo\\\":\\\"#1\\\"}\", \"common-subset\")             =>   [\"foo\" -> \"#1\"]",
            "parse_json(\"{\\\"foo\\\":\\\"#1|obj\\\"}\", \"embedded-types\")        =>   [\"foo\" -> #1]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM\\\"}\")                          =>   [\"foo\" -> \"E_PERM\"]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM\\\"}\", \"common-subset\")         =>   [\"foo\" -> \"E_PERM\"]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM|err\\\"}\", \"embedded-types\")    =>   [\"foo\" -> E_PERM]",
            "",
            "In embedded types mode, key values can be converted to MOO types by appending type information. The full set of supported types are obj, str, err, float and int.",
            "",
            "parse_json(\"{\\\"1\\\":2}\")                                     =>   [\"1\" -> 2]",
            "parse_json(\"{\\\"1\\\":2}\", \"common-subset\")                    =>   [\"1\" -> 2]",
            "parse_json(\"{\\\"1|int\\\":2}\", \"embedded-types\")               =>   [1 -> 2]",
            "parse_json(\"{\\\"#1|obj\\\":2}\", \"embedded-types\")              =>   [#1 -> 2]",
            "",
            "JSON defines types that MOO (currently) does not support, such as boolean true and false, and null. These values are always converted to the strings \"true\", \"false\" and \"null\". "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: getenv (STR name)",
            "",
            "Returns the value of the named environment variable. If no such environment variable exists, 0 is returned. If the programmer is not a wizard, then E_PERM is raised.",
            "",
            "getenv(\"HOME\")       =>  \"/home/foobar\"",
            "getenv(\"XYZZY\")      =>   0"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: index (STR str1, STR str2, [, INT case-matters [, INT skip])  => INT",
            "        rindex (STR str1, STR str2, [, INT case-matters [, INT skip]) => INT",
            "",
            "index -- Returns the index of the first character of the first occurrence of str2 in str1. ",
            "",
            "rindex -- Returns the index of the first character of the last occurrence of str2 in str1.",
            "",
            "These functions will return zero if str2 does not occur in str1 at all.",
            "",
            "By default the search for an occurrence of str2 is done while ignoring the upper/lower case distinction. If case-matters is provided and true, then case is treated as significant in all comparisons.",
            "",
            "By default the search starts at the beginning (end) of str1. If skip is provided, the search skips the first (last) skip characters and starts at an offset from the beginning (end) of str1. The skip must be a positive integer for index() and a negative integer for rindex(). The default value of skip is 0 (skip no characters).",
            "",
            "index(\"foobar\", \"o\")               2",
            "index(\"foobar\", \"o\", 0, 0)         2",
            "index(\"foobar\", \"o\", 0, 2)         1",
            "rindex(\"foobar\", \"o\")              3",
            "rindex(\"foobar\", \"o\", 0, 0)        3",
            "rindex(\"foobar\", \"o\", 0, -4)       2",
            "index(\"foobar\", \"x\")               0",
            "index(\"foobar\", \"oba\")             3",
            "index(\"Foobar\", \"foo\", 1)          0",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  isa(OBJ <object>, OBJ <parent>)",
            "         isa(OBJ <object>, LIST <parent list> [, INT <return_parent>])",
            "",
            "Returns true if <object> is a descendant of <parent>, otherwise false.",
            "",
            "If a third argument is present and true, the return value will be the first parent that object1 descends from in the <parent list>.",
            "",
            "isa(#2, $wiz)                           => 1",
            "isa(#2, {$thing, $wiz, $container})     => 1",
            "isa(#2, {$thing, $wiz, $container}, 1)  => #57 (generic wizard)",
            "isa(#2, {$thing, $room, $container}, 1) => #-1 <$nothing>"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  locate_by_name (STR <object name>)   => LIST",
            "",
            "This function searches every object in the database for those containing <object name> in their .name property."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: locations(OBJ object [, OBJ stop [, INT is-parent]]) => LIST",
            "",
            "Recursively build a list of an object's location, its location's location, and so forth until finally hitting $nothing.",
            "",
            "Example:",
            "",
            "locations(me) => {#20381, #443, #104735}",
            "",
            "$string_utils:title_list(locations(me)) => \"\\\"Butterknife Ballet\\\" Control Room FelElk, the one-person celestial birther \\\"Butterknife Ballet\\\", and Uncharted Space: Empty Space\"",
            "",
            "If stop is in the locations found, it will stop before there and return the list (exclusive of the stop object).",
            "",
            "If the third argument is true, stop is assumed to be a PARENT. And if any of your locations are children of that parent, it stops there.",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "verb_cache_stats()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: mapdelete (MAP map, ANY key)",
            "",
            "Returns a copy of map with the value corresponding to key removed. If key is not a valid key, then E_RANGE is raised.",
            "",
            "x = [\"foo\" -> 1, \"bar\" -> 2, \"baz\" -> 3];",
            "mapdelete(x, \"bar\")       =>  [\"baz\" -> 3, \"foo\" -> 1]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: maphaskey (MAP <map>, STR <key>)   => INT",
            "",
            "Returns 1 if <key> exists in <map>. When not dealing with hundreds of keys, this function is faster (and easier to read) than something like: !(x in mapkeys(map))"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: mapkeys (MAP map)",
            "",
            "Returns the keys of the elements of map.",
            "",
            "x = [\"foo\" -> 1, \"bar\" -> 2, \"baz\" -> 3];",
            "mapkeys(x)    =>  {\"bar\", \"baz\", \"foo\"}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: mapvalues (MAP <map> [, ... STR <key>])",
            "",
            "Returns the values of the elements of map.",
            "",
            "If you only want the values of specific keys in the map, you can specify them as optional arguments. See examples below.",
            "",
            "Examples:  ",
            "x = [\"foo\" -> 1, \"bar\" -> 2, \"baz\" -> 3];",
            "",
            ";mapvalues(x)",
            "=>  {2, 3, 1}",
            ";mapvalues(x, \"foo\", \"baz\")",
            "=> {1, 3}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  memory_usage ()   => LIST",
            "",
            "Return statistics concerning the server's consumption of system memory. The result is a list in the following format:",
            "",
            "{total memory used, resident set size, shared pages, text, data + stack}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: new_waif() => WAIF",
            "",
            "The new_waif() builtin creates a new WAIF whose class is the calling object and whose owner is the perms of the calling verb.",
            "",
            "This wizardly version causes it to be owned by the caller of the verb."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  next_recycled_object(OBJ <start>)  => OBJ | INT",
            "",
            "Return the lowest invalid object. If <start> is specified, no object lower than <start> will be considered. If there are no invalid objects, this function will return 0."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  occupants(LIST <objects> [, OBJ | LIST <parent>, INT <player flag set?>])   => LIST",
            "",
            "Iterates through the list of <objects> and returns those matching a specific set of criteria:",
            "",
            "1. If only <objects> is specified, the occupants function will return a list of objects with the player flag set.",
            "2. If the <parent> argument is specified, a list of <objects> descending from <parent> will be returned. If <parent> is a list, <object> must descend from at least one object in the list.",
            "3. If both <parent> and <player flag set> are specified, occupants will check both that an object is descended from <parent> and also has the player flag set."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  owned_objects(OBJ owner)  => LIST",
            "",
            "Returns a list of all objects in the database owned by <owner>. Ownership is defined by the value of .owner on the object."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  panic([STR <message>])",
            "",
            "Unceremoniously shut down the server, mimicking the behavior of a fatal error. The database will NOT be dumped to the file specified when starting the server. A new file will be created with the name of your database appended with .PANIC."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: parent (OBJ object) => OBJ",
            "        parents (OBJ object) => LIST",
            "",
            "parent -- return the parent of object",
            "parents -- return the parents of object"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "parent()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: parse_json (STR json [, STR mode])",
            "",
            "Returns the MOO value representation of the JSON string. If the specified string is not valid JSON, E_INVARG is raised.",
            "",
            "The optional mode specifies how this function handles conversion of MOO values into their JSON representation. The options are the same as for generate_json().",
            "",
            "parse_json(\"{}\")                                            =>   []",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\")                             =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\", \"common-subset\")            =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":\\\"bar\\\"}\", \"embedded-types\")           =>   [\"foo\" -> \"bar\"]",
            "parse_json(\"{\\\"foo\\\":1.1}\")                                 =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":1.1}\", \"common-subset\")                =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":1.1}\", \"embedded-types\")               =>   [\"foo\" -> 1.1]",
            "parse_json(\"{\\\"foo\\\":\\\"#1\\\"}\")                              =>   [\"foo\" -> \"#1\"]",
            "parse_json(\"{\\\"foo\\\":\\\"#1\\\"}\", \"common-subset\")             =>   [\"foo\" -> \"#1\"]",
            "parse_json(\"{\\\"foo\\\":\\\"#1|obj\\\"}\", \"embedded-types\")        =>   [\"foo\" -> #1]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM\\\"}\")                          =>   [\"foo\" -> \"E_PERM\"]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM\\\"}\", \"common-subset\")         =>   [\"foo\" -> \"E_PERM\"]",
            "parse_json(\"{\\\"foo\\\":\\\"E_PERM|err\\\"}\", \"embedded-types\")    =>   [\"foo\" -> E_PERM]",
            "",
            "In embedded types mode, key values can be converted to MOO types by appending type information. The full set of supported types are obj, str, err, float and int.",
            "",
            "parse_json(\"{\\\"1\\\":2}\")                                     =>   [\"1\" -> 2]",
            "parse_json(\"{\\\"1\\\":2}\", \"common-subset\")                    =>   [\"1\" -> 2]",
            "parse_json(\"{\\\"1|int\\\":2}\", \"embedded-types\")               =>   [1 -> 2]",
            "parse_json(\"{\\\"#1|obj\\\":2}\", \"embedded-types\")              =>   [#1 -> 2]",
            "",
            "JSON defines types that MOO (currently) does not support, such as boolean true and false, and null. These values are always converted to the strings \"true\", \"false\" and \"null\". "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  pcre_match (STR <subject>, STR <pattern> [, <case matters> 0] [, <repeat until no matches> 1]\t=> LIST",
            "",
            "The function `pcre_match()' searches <subject> for <pattern> using the Perl Compatible Regular Expressions library. The return value is a list of maps containing each match. Each returned map will have a key which corresponds to either a named capture group or the number of the capture group being matched. The full match is always found in the key \"0\". The value of each key will be another map containing the keys 'match' and 'position'. Match corresponds to the text that was matched and position will return the indices of the substring within <subject>.",
            "",
            "If <repeat until no matches> is 1, the expression will continue to be evaluated until no further matches can be found or it exhausts the iteration limit. This defaults to 1.",
            "",
            "Additionally, wizards can control how many iterations of the loop are possible by adding a property to $server_options. $server_options.pcre_match_max_iterations is the maximum number of loops allowed before giving up and allowing other tasks to proceed. CAUTION: It's recommended to keep this value fairly low. The default value is 1000. The minimum value is 100.",
            "",
            "Examples:",
            "",
            "Extract dates from a string:",
            "pcre_match(\"09/12/1999 other random text 01/21/1952\", \"([0-9]{2})/([0-9]{2})/([0-9]{4})\")",
            "=> {[\"0\" -> [\"match\" -> \"09/12/1999\", \"position\" -> {1, 10}], \"1\" -> [\"match\" -> \"09\", \"position\" -> {1, 2}], \"2\" -> [\"match\" -> \"12\", \"position\" -> {4, 5}], \"3\" -> [\"match\" -> \"1999\", \"position\" -> {7, 10}]], [\"0\" -> [\"match\" -> \"01/21/1952\", \"position\" -> {30, 39}], \"1\" -> [\"match\" -> \"01\", \"position\" -> {30, 31}], \"2\" -> [\"match\" -> \"21\", \"position\" -> {33, 34}], \"3\" -> [\"match\" -> \"1952\", \"position\" -> {36, 39}]]}",
            "",
            "Explode a string (albeit a contrived example):",
            ";;ret = {}; for x in (pcre_match(\"This is a string of words, with punctuation, that should be exploded. By space. --zippy--\", \"[a-zA-Z]+\", 0, 1)) ret = {@ret, x[\"0\"][\"match\"]}; endfor return ret;",
            "=> {\"This\", \"is\", \"a\", \"string\", \"of\", \"words\", \"with\", \"punctuation\", \"that\", \"should\", \"be\", \"exploded\", \"By\", \"space\", \"zippy\"}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:   pcre_replace (STR <subject>, STR <pattern>) => STR",
            "",
            "The function `pcre_replace()' replaces <subject> with replacements found in <pattern> using the Perl Compatible Regular Expressions library.",
            "",
            "The pattern string has a specific format that must be followed, which should be familiar if you have used the likes of Vim, Perl, or sed. The string is composed of four elements, each separated by a delimiter (typically a slash (/) or an exclamation mark (!)), that tell PCRE how to parse your replacement. We'll break the string down and mention relevant options below:",
            "",
            "1. Type of search to perform. In MOO, only 's' is valid. This parameter is kept for the sake of consistency.",
            "2. The text you want to search for a replacement.",
            "3. The regular expression you want to use for your replacement text.",
            "4. Optional modifiers:",
            "    g: Global. This will replace all occurrences in your string rather than stopping at the first.",
            "    i: Case-insensitive. Uppercase, lowercase, it doesn't matter. All will be replaced.",
            "    ",
            "The replacement text can use placeholders in the form of a dollar sign and a number corresponding to a capture group (e.g. $1 will be replaced with the text from the first capture group, $2 the second, etc).",
            "",
            "Examples:",
            "",
            "Replace one word with another:",
            "pcre_replace(\"I like banana pie. Do you like banana pie?\", \"s/banana/apple/g\")",
            "=> \"I like apple pie. Do you like apple pie?\"",
            "",
            "Replace text from a capture group:",
            ";pcre_replace(\"You can find it in objref #1234.\", \"s/objref (#\\d*)/object $1/g\")",
            "=> \"You can find it in object #1234.\"",
            "",
            "If you find yourself wanting to replace a string that contains slashes, it can be useful to change your delimiter to an exclamation mark:",
            "pcre_replace(\"Unix, wow! /bin/bash is a thing.\", \"s!/bin/bash!/bin/fish!g\")",
            "=> \"Unix, wow! /bin/fish is a thing.\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: random_bytes (INT count)",
            "",
            "Returns a binary string composed of between one and 10000 random bytes. count specifies the number of bytes and must be a positive integer; otherwise, E_INVARG is raised. "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: read_http (request-or-response [, OBJ conn])",
            "",
            "Reads lines from the connection conn (or, if not provided, from the player that typed the command that initiated the current task) and attempts to parse the lines as if they are an HTTP request or response. request-or-response must be either the string \"request\" or \"response\". It dictates the type of parsing that will be done.",
            "",
            "Just like read(), if conn is provided, then the programmer must either be a wizard or the owner of conn; if conn is not provided, then read_http() may only be called by a wizard and only in the task that was last spawned by a command from the connection in question. Otherwise, E_PERM is raised. Likewise, if conn is not currently connected and has no pending lines of input, or if the connection is closed while a task is waiting for input but before any lines of input are received, then read_http() raises E_INVARG.",
            "",
            "If parsing fails because the request or response is syntactically incorrect, read_http() will return a map with the single key \"error\" and a list of values describing the reason for the error. If parsing succeeds, read_http() will return a map with an appropriate subset of the following keys, with values parsed from the HTTP request or response: \"method\", \"uri\", \"headers\", \"body\", \"status\" and \"upgrade\".",
            "",
            "    Fine point: read_http() assumes the input strings are binary strings. When called interactively, as in the example below, the programmer must insert the literal line terminators or parsing will fail. ",
            "",
            "The following example interactively reads an HTTP request from the players connection.",
            "",
            "read_http(\"request\", player)",
            "GET /path HTTP/1.1~0D~0A",
            "Host: example.com~0D~0A",
            "~0D~0A",
            "",
            "In this example, the string ~0D~0A ends the request. The call returns the following (the request has no body):",
            "",
            "[\"headers\" -> [\"Host\" -> \"example.com\"], \"method\" -> \"GET\", \"uri\" -> \"/path\"]",
            "",
            "The following example interactively reads an HTTP response from the players connection.",
            "",
            "read_http(\"response\", player)",
            "HTTP/1.1 200 Ok~0D~0A",
            "Content-Length: 10~0D~0A",
            "~0D~0A",
            "1234567890",
            "",
            "The call returns the following:",
            "",
            "[\"body\" -> \"1234567890\", \"headers\" -> [\"Content-Length\" -> \"10\"], \"status\" -> 200]"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  recreate(OBJ <old>, OBJ <parent> [, OBJ <owner>])  => OBJ",
            "",
            "Recreate invalid object <old> (one that has previously been recycle()ed) as <parent>, optionally owned by <owner>. This has the effect of filling in holes created by recycle() that would normally require renumbering and resetting the maximum object.",
            "",
            "The normal rules apply to parent and owner. You either have to own <parent>, <parent> must be fertile, or you have to be a wizard. Similarly, to change <owner>, you should be a wizard. Otherwise it's superfluous."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  recycled_objects()  => LIST",
            "",
            "Return a list of all invalid objects in the database. An invalid object is one that has been destroyed with the recycle() function."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: reseed_random()",
            "",
            "Provide a new seed to the pseudo random number generator."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: respond_to(OBJ object, STR verb)",
            "",
            "Returns true if <verb> is callable on <object>, taking into account inheritance, wildcards (star verbs), etc. Otherwise, returns false.  If the caller is permitted to read the object (because the object's `r' flag is true, or the caller is the owner or a wizard) the true value is a list containing the object number of the object that defines the verb and the full verb name(s).  Otherwise, the numeric value `1' is returned."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  reverse(LIST <alist>) => LIST | STR",
            "",
            "Return a reversed list or string.",
            "",
            "Examples:",
            "",
            ";reverse({1,2,3,4}) => {4,3,2,1}",
            ";reverse(\"asdf\") => \"fdsa\"",
            ""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "index()"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: salt (STR format, STR input)",
            "",
            "Generate a crypt() compatible salt string for the specified salt format using the specified binary random input. The specific set of formats supported depends on the libraries used to build the server, but will always include the standard salt format, indicated by the format string \"\" (the empty string), and the BCrypt salt format, indicated by the format string \"$2a$NN$\" (where \"NN\" is the work factor). Other possible formats include MD5 (\"$1$\"), SHA256 (\"$5$\") and SHA512 (\"$6$\"). Both the SHA256 and SHA512 formats support optional rounds.",
            "",
            "salt(\"\", \".M\")                                           =>    \"iB\"",
            "salt(\"$1$\", \"~183~1E~C6/~D1\")                            =>    \"$1$MAX54zGo\"",
            "salt(\"$5$\", \"x~F2~1Fv~ADj~92Y~9E~D4l~C3\")                =>    \"$5$s7z5qpeOGaZb\"",
            "salt(\"$5$rounds=2000$\", \"G~7E~A7~F5Q5~B7~0Aa~80T\")       =>    \"$5$rounds=2000$5trdp5JBreEM\"",
            "salt(\"$6$\", \"U7~EC!~E8~85~AB~CD~B5+~E1?\")                =>    \"$6$JR1vVUSVfqQhf2yD\"",
            "salt(\"$6$rounds=5000$\", \"~ED'~B0~BD~B9~DB^,\\\\~BD~E7\")    =>    \"$6$rounds=5000$hT0gxavqSl0L\"",
            "salt(\"$2a$08$\", \"|~99~86~DEq~94_~F3-~1A~D2#~8C~B5sx\")    =>    \"$2a$08$dHkE1lESV9KrErGhhJTxc.\"",
            "",
            "Note: To ensure proper security, the random input must be from a sufficiently random source. "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: server_log (STR message [, INT level]) => NONE",
            "",
            "The text in message is sent to the server log with a distinctive prefix (so that it can be distinguished from server-generated messages)",
            "",
            "If the programmer is not a wizard, then E_PERM is raised.",
            "",
            "If level is provided and is an integer between 0 and 7 inclusive, then message is marked in the server log as one of eight predefined types, from simple log message to error message. Otherwise, if level is provided and true, then message is marked in the server log as an error."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: set_task_local(ANY value)",
            "",
            "Sets a value that gets associated with the current running task. This value persists across verb calls and gets reset when the task is killed, making it suitable for securely passing sensitive intermediate data between verbs. The value can then later be retrieved using the `task_local` function.",
            "",
            "set_task_local(\"arbitrary data\")",
            "set_task_local({\"list\", \"of\", \"arbitrary\", \"data\"})"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  set_thread_mode([INT <mode>])",
            "",
            "With no arguments specified, set_thread_mode will return the current thread mode for the verb. A value of 1 indicates that threading is enabled for functions that support it. A value of 0 indicates that threading is disabled and all functions will execute in the main MOO thread, as functions have done in default LambdaMOO since version 1.",
            "",
            "If you specify an argument, you can control the thread mode of the current verb. A <mode> of 1 will enable threading and a <mode> of 0 will disable it. You can invoke this function multiple times if you want to disable threading for a single function call and enable it for the rest.",
            "",
            "When should you disable threading? In general, threading should be disabled in verbs where it would be undesirable to suspend(). Each threaded function will immediately suspend the verb while the thread carries out its work. This can have a negative effect when you want to use these functions in verbs that cannot or should not suspend, like $sysobj:do_command or $sysobj:do_login_command.",
            "",
            "Note that the threading mode affects the current verb only and does NOT affect verbs called from within that verb."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  slice(LIST <alist> [, INT | LIST | STR <index>, ANY <default map value>])   => LIST",
            "",
            "Return the <index>-th elements of <alist>. By default, index will be 1. If index is a list of integers, the returned list will have those elements from <alist>. This is the built-in equivalent of LambdaCore's $list_utils:slice verb.",
            "",
            "If <alist> is a list of maps, index can be a string indicating a key to return from each map in <alist>.",
            "",
            "If <default map value> is specified, any maps not containing the key <index> will have <default map value> returned in their place. This is useful in situations where you need to maintain consistency with a list index and can't have gaps in your return list.",
            "",
            "Examples:",
            " >slice({{\"z\", 1}, {\"y\", 2}, {\"x\",5}}, 2) => {1, 2, 5}.",
            " >slice({{\"z\", 1, 3}, {\"y\", 2, 4}}, {2, 1}) => {{1, \"z\"}, {2, \"y\"}}",
            " >;slice({[\"a\" -> 1, \"b\" -> 2], [\"a\" -> 5, \"b\" -> 6]}, \"a\") => {1, 5}",
            " >;slice({[\"a\" -> 1, \"b\" -> 2], [\"a\" -> 5, \"b\" -> 6], [\"b\" -> 8]}, \"a\", 0) => {1, 5, 0}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  sort(LIST <list> [, LIST <keys>, INT <natural sort order?>, INT <reverse>])   => LIST",
            "",
            "Sorts <list> either by <keys> or using the list itself. When sorting <list> by itself, you can use an empty list ({}) for <keys> to specify additional optional arguments.",
            "",
            "If <natural sort order> is true, strings containing multi-digit numbers will consider those numbers to be a single character. So, for instance, this means that 'x2' would come before 'x11' when sorted naturally because 2 is less than 11. This argument defaults to 0.",
            "",
            "If <reverse> is true, the sort order is reversed. This argument defaults to 0.",
            "",
            "Examples:",
            "",
            "Sort a list by itself:",
            ">;sort({\"a57\", \"a5\", \"a7\", \"a1\", \"a2\", \"a11\"})",
            "=> {\"a1\", \"a11\", \"a2\", \"a5\", \"a57\", \"a7\"}",
            "",
            "Sort a list by itself with natural sort order:",
            ">;sort({\"a57\", \"a5\", \"a7\", \"a1\", \"a2\", \"a11\"}, {}, 1)",
            "=> {\"a1\", \"a2\", \"a5\", \"a7\", \"a11\", \"a57\"}",
            "",
            "Sort a list of strings by a list of numeric keys:",
            ">;sort({\"foo\", \"bar\", \"baz\"}, {123, 5, 8000})",
            "=> {\"bar\", \"foo\", \"baz\"}"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  spellcheck(STR <word>)   => INT or LIST",
            "",
            "This function checks the English spelling of <word>. If the spelling is correct, the function will return a 1. If the spelling is incorrect, a LIST of suggestions for correct spellings will be returned instead. If the spelling is incorrect and no suggestions can be found, an empty LIST is returned."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_close(INT <database handle) => INT",
            "",
            "This function will close an open database.",
            "",
            "If successful, return 1;",
            "",
            "If unsuccessful, returns E_INVARG."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_execute(INT <database handle>, STR <SQL prepared statement query>, LIST <values>) => [LIST or STR]",
            "",
            "This function will attempt to create and execute the prepared statement query given in <query> on the database referred to by <handle> with the values <values>.",
            "",
            "On success, this function will return a list identifying the returned rows. If the query didn't return rows but was successful, an empty list is returned.",
            "",
            "If the query fails, a string will be returned identifying the SQLite error message.",
            "",
            "sqlite_execute uses prepared statements, so it's the preferred function to use for security and performance reasons.",
            "",
            "Example:",
            "sqlite_execute(0, \"INSERT INTO users VALUES (?, ?, ?);\", {#7, \"lisdude\", \"Albori Sninvel\"})"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_handles() => LIST",
            "",
            "Returns a list of open SQLite database handles."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_info(INT <database handle>) => MAP",
            "",
            "This function returns a map of information about the database at <handle>",
            "",
            "The information returned is:",
            "\tDatabase Path",
            "\tType parsing enabled?",
            "\tObject parsing enabled?",
            "\tString sanitation enabled?"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_interrupt(INT <database handle>)",
            "",
            "This function causes any pending database operation to abort at its earliest opportunity. If the operation is nearly finished when sqlite_interrupt is called, it might not have an opportunity to be interrupted and could continue to completion.",
            "",
            "This can be useful when you execute a long-running query and want to abort it.",
            "",
            "NOTE: As of this writing (server version 2.7.0) the @kill command WILL NOT abort operations taking place in a helper thread. If you want to interrupt an SQLite query, you must use sqlite_interrupt and NOT the @kill command."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_last_insert_row_id(INT <database handle>)",
            "",
            "This function identifies the row ID of the last insert command executed on the database."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_limit(INT <database handle>, STR <category> INT <new value>) => INT",
            "",
            "This function allows you to specify various construct limitations on a per-database basis.",
            "",
            "If <new value> is a negative number, the limit is unchanged. Each limit category has a hardcoded upper bound. Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.",
            "",
            "Regardless of whether or not the limit was changed, the sqlite_limit() function returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.",
            "",
            "As of this writing, the following limits exist:",
            "",
            "LIMIT_LENGTH",
            "    The maximum size of any string or BLOB or table row, in bytes.",
            "",
            "LIMIT_SQL_LENGTH",
            "    The maximum length of an SQL statement, in bytes.",
            "",
            "LIMIT_COLUMN",
            "    The maximum number of columns in a table definition or in the result set of a SELECT or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.",
            "",
            "LIMIT_EXPR_DEPTH",
            "    The maximum depth of the parse tree on any expression.",
            "",
            "LIMIT_COMPOUND_SELECT",
            "    The maximum number of terms in a compound SELECT statement.",
            "",
            "LIMIT_VDBE_OP",
            "    The maximum number of instructions in a virtual machine program used to implement an SQL statement. If sqlite3_prepare_v2() or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.",
            "",
            "LIMIT_FUNCTION_ARG",
            "    The maximum number of arguments on a function.",
            "",
            "LIMIT_ATTACHED",
            "    The maximum number of attached databases.",
            "",
            "LIMIT_LIKE_PATTERN_LENGTH",
            "    The maximum length of the pattern argument to the LIKE or GLOB operators.",
            "",
            "LIMIT_VARIABLE_NUMBER",
            "    The maximum index number of any parameter in an SQL statement.",
            "",
            "LIMIT_TRIGGER_DEPTH",
            "    The maximum depth of recursion for triggers.",
            "",
            "LIMIT_WORKER_THREADS",
            "    The maximum number of auxiliary worker threads that a single prepared statement may start.",
            "",
            "For an up-to-date list of limits, see the SQLite documentation here: https://www.sqlite.org/c3ref/c_limit_attached.html"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_open(STR <path to database>, [INT options]) => INT",
            "",
            "The function `sqlite_open' will attempt to open the database at <path> for use with SQLite.",
            "",
            "The second argument is a bitmask of options. Options are:",
            "",
            "\tSQLITE_PARSE_OBJECTS [4]:    Determines whether strings beginning with a pound symbol (#) are interpreted as MOO object numbers or not.",
            "                                     The default is true, which means that any queries that would return a string (such as \"#123\") will be returned as objects.",
            "\tSQLITE_PARSE_TYPES [2]:      If unset, no parsing of rows takes place and only strings are returned.",
            "\tSQLITE_SANITIZE_STRINGS [8]: If set, newlines (\\n) are converted into tabs (\\t) to avoid corrupting the MOO database. Default is unset.",
            "",
            "NOTE: If the MOO doesn't support bitmasking, you can still specify options. You'll just have to manipulate the int yourself. e.g. if you want to parse objects and types, arg[2] would be a 6. If you only want to parse types, arg[2] would be 2.",
            "",
            "If successful, the function will return the numeric handle for the open database.",
            "",
            "If unsuccessful, the function will return a helpful error message.",
            "",
            "If the database is already open, a traceback will be thrown that contains the already open database handle."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:\t  sqlite_query(INT <database handle>, STR <database query>[, INT <show columns>]) => [LIST or STR]",
            "",
            "This function will attempt to execute the query given in <query> on the database referred to by <handle>.",
            "",
            "On success, this function will return a list identifying the returned rows. If the query didn't return rows but was successful, an empty list is returned.",
            "",
            "If the query fails, a string will be returned identifying the SQLite error message.",
            "",
            "If <show columns> is true, the return list will include the name of the column before its results.",
            "",
            "WARNING: sqlite_query does NOT use prepared statements and should NOT be used on queries that contain user input."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "binary_hmac"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: strtr (STR source, STR str1, STR str2 [, case-matters])",
            "",
            "Transforms the string source by replacing the characters specified by str1 with the corresponding characters specified by str2. All other characters are not transformed. If str2 has fewer characters than str1 the unmatched characters are simply removed from source. By default the transformation is done on both upper and lower case characters no matter the case. If case-matters is provided and true, then case is treated as significant.",
            "",
            "strtr(\"foobar\", \"o\", \"i\")           =>    \"fiibar\"",
            "strtr(\"foobar\", \"ob\", \"bo\")         =>    \"fbboar\"",
            "strtr(\"foobar\", \"\", \"\")             =>    \"foobar\"",
            "strtr(\"foobar\", \"foba\", \"\")         =>    \"r\"",
            "strtr(\"5xX\", \"135x\", \"0aBB\", 0)     =>    \"BbB\"",
            "strtr(\"5xX\", \"135x\", \"0aBB\", 1)     =>    \"BBX\"",
            "strtr(\"xXxX\", \"xXxX\", \"1234\", 0)    =>    \"4444\"",
            "strtr(\"xXxX\", \"xXxX\", \"1234\", 1)    =>    \"3434\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  suspend([INT|FLOAT seconds])  => VALUE",
            "",
            "Suspends the current task, and resumes it after at least <seconds> seconds. Sub-second suspend (IE: 0.1) is possible. (If <seconds> is not provided, the task is suspended indefinitely; such a task can only be resumed by use of the `resume()' function.) When the task is resumed, it will have a full quota of ticks and seconds.  This function is useful for programs that run for a long time or require a lot of ticks.  If <seconds> is negative, then E_INVARG is raised. `Suspend()' returns zero unless it was resumed via `resume()' in which case it returns the second argument given to that function.",
            "",
            "In some sense, this function forks the `rest' of the executing task.  However, there is a major difference between the use of `suspend(<seconds>)' and the use of the `fork (<seconds>)'.  The `fork' statement creates a new task (a \"forked task\") while the currently-running task still goes on to completion, but a `suspend()' suspends the currently-running task (thus making it into a \"suspended task\").  This difference may be best explained by the following examples, in which one verb calls another:",
            "",
            "",
            "    .program   #0:caller_A",
            "",
            "    #0.prop = 1;",
            "",
            "    #0:callee_A();",
            "",
            "    #0.prop = 2;",
            "",
            "    .",
            "",
            "",
            "    .program   #0:callee_A",
            "",
            "    fork(5)",
            "",
            "      #0.prop = 3;",
            "",
            "    endfork",
            "",
            "    .",
            "",
            "",
            "    .program   #0:caller_B",
            "",
            "    #0.prop = 1;",
            "",
            "    #0:callee_B();",
            "",
            "    #0.prop = 2;",
            "",
            "    .",
            "",
            "",
            "    .program   #0:callee_B",
            "",
            "    suspend(5);",
            "",
            "    #0.prop = 3;",
            "",
            "    .",
            "",
            "Consider `#0:caller_A', which calls `#0:callee_A'.  Such a task would assign 1 to `#0.prop', call `#0:callee_A', fork a new task, return to `#0:caller_A', and assign 2 to `#0.prop', ending this task.  Five seconds later, if the forked task had not been killed, then it would begin to run; it would assign 3 to `#0.prop' and then stop.  So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 3.",
            "",
            "Now consider `#0:caller_B', which calls `#0:callee_B' instead of `#0:callee_A'.  This task would assign 1 to `#0.prop', call `#0:callee_B', and suspend.  Five seconds later, if the suspended task had not been killed, then it would resume; it would assign 3 to `#0.prop', return to `#0:caller', and assign 2 to `#0.prop', ending the task. So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 2.",
            "",
            "A suspended task, like a forked task, can be described by the `queued_tasks()' function and killed by the `kill_task()' function. Suspending a task does not change its task id.  A task can be suspended again and again by successive calls to `suspend()'.",
            "",
            "Once `suspend()' has been used in a particular task, then the `read()' function will always raise E_PERM in that task.  For more details, see the description of `read()'.",
            "",
            "By default, there is no limit to the number of tasks any player may suspend, but such a limit can be imposed from within the database. See the chapter in the ToastStunt Programmers Manual on server assumptions about the database for details."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: switch_player(OBJ <object1>, OBJ <object2> [, INT <silent>])",
            "",
            "Silently switches the player associated with this connection from <object1> to <object2>. <object1> must be connected and <object2> must be a player. This can be used in do_login_command() verbs that read or suspend (which prevents the normal player selection mechanism from working.",
            "",
            "If <silent> is true, no connection messages will be printed."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: task_local ()",
            "",
            "Returns the value associated with the current task. The value is set with the `set_task_local` function."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  thread_info(INT <thread handler>)   => LIST",
            "",
            "If a MOO task is running in another thread, its thread handler will give you information about that thread. The information returned in a LIST will be:",
            "",
            "  English Name: This is the name the programmer of the builtin function has given to the task being executed.",
            "  Active: 1 or 0 depending upon whether or not the MOO task has been killed. Not all threads cleanup immediately after the MOO task dies."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  thread_pool(STR <function>, STR <pool> [, INT <value>])",
            "",
            "This function allows you to control any thread pools that the server created at startup. It should be used with care, as it has the potential to create disasterous consequences if used incorrectly.",
            "",
            "The <function> parameter is the function you wish to perform on the thread pool. The functions available are:",
            "",
            "   INIT: Control initialization of a thread pool.",
            "",
            "   ",
            "The <pool> parameter controls which thread pool you wish to apply the designated function to. At the time of writing, the server creates the following thread pool:",
            "",
            "   MAIN: The main thread pool where threaded built-in function work takes place.",
            "",
            "",
            "Finally, <value> is the value you want to pass to the <function> of <pool>. The following functions accept the following values:",
            "",
            "   INIT: The number of threads to spawn. NOTE: When executing this function, the existing <pool> will be destroyed and a new one created in its place.",
            "",
            "",
            "Examples:",
            ";thread_pool(\"INIT\", \"MAIN\", 1)     => Replace the existing main thread pool with a new pool consisting of a single thread."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  threads()   => LIST",
            "",
            "When one or more MOO processes are suspended and working in a separate thread, this function will return a LIST of handlers to those threads. These handlers can then be passed to `thread_info' for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "Stunt / ToastStunt Functions"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: typeof (value) => INT",
            "",
            "Takes any MOO value and returns an integer representing the type of value.",
            "",
            "The result is the same as the initial value of one of these built-in variables: INT, FLOAT, STR, LIST, MAP, OBJ, or ERR, BOOL, MAP, WAIF, ANON. ",
            "",
            "Thus, one usually writes code like this:",
            "",
            "if (typeof(x) == LIST) ...",
            "",
            "and not like this:",
            "",
            "if (typeof(x) == 3) ...",
            "",
            "because the former is much more readable than the latter."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  usage ()   => LIST",
            "",
            "Return statistics concerning the server the MOO is running on. The result is a list in the following format:",
            "",
            "{load averages}, user time, system time, page reclaims, page faults, block input ops, block output ops, voluntary context switches, involuntary context switches, signals received"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: value_hmac (value, STR key [, STR algo [, binary]])",
            "",
            "Returns the same string as string_hmac(toliteral(value), key, ...); see the description of string_hmac() for details. "
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_args (OBJ <object>, STR|INT <verb-name>)   => LIST",
            "         set_verb_args (OBJ <object>, STR|INT <verb-name>, LIST <args>)   => none",
            "",
            "BE AWARE: verb-name can be the string name of the verb OR the index from verbs()",
            "",
            "These two functions get and set (respectively) the direct-object, preposition, and indirect-object specifications for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_args()' (`set_verb_args()') raises E_PERM.  Verb args specifications have the following form:",
            "",
            "    {<dobj>, <prep>, <iobj>}",
            "",
            "where <dobj> and <iobj> are strings drawn from the set `\"this\"', `\"none\"', and `\"any\"', and <prep> is a string that is either `\"none\"', `\"any\"', or one of the prepositional phrases listed much earlier in the description of verbs in the first chapter.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'.  Note that for `set_verb_args()', <prep> must be only one of the prepositional phrases, not (as is shown in that table) a set of such phrases separated by `/' characters.  `Set_verb_args()' raises E_INVARG if any of the <dobj>, <prep>, or <iobj> strings is illegal.",
            "",
            "    verb_args($container, \"take\")",
            "                        =>   {\"any\", \"out of/from inside/from\", \"this\"}",
            "",
            "    set_verb_args($container, \"take\", {\"any\", \"from\", \"this\"})"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: verb_cache_stats() => LIST",
            "        log_cache_stats() => NONE",
            "",
            "The server caches verbname-to-program lookups to improve performance. These functions respectively return or write to the server log file the current cache statistics. For verb_cache_stats the return value will be a list of the form",
            "",
            "{hits, negative_hits, misses, table_clears, histogram},",
            "",
            "though this may change in future server releases. The cache is invalidated by any builtin function call that may have an effect on verb lookups (e.g., delete_verb())."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_code (OBJ <object>, STR|INT <verb-name> [, <fully-paren> [, <indent>]])   => LIST",
            "         set_verb_code (OBJ <object>, STR|INT <verb-name>, LIST <code>)   => LIST",
            "",
            "BE AWARE: verb-name can be the string name of the verb OR the index from verbs()",
            "",
            "These functions get and set (respectively) the MOO-code program associated with the verb named <verb-name> on <object>.  The program is represented as a list of strings, one for each line of the program; this is the kind of value returned by `verb_code()' and expected as the third argument to `set_verb_code()'.  For `verb_code()', the expressions in the returned code are usually written with the minimum-necessary parenthesization; if <full-paren> is true, then all expressions are fully parenthesized. Also for `verb_code()', the lines in the returned code are usually not indented at all; if <indent> is true, each line is indented to better show the nesting of statements.",
            "",
            "If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_code()' (`set_verb_code()') raises E_PERM.  If the programmer is not, in fact, a programmer, then E_PERM is raised.",
            "",
            "For `set_verb_code()', the result is a list of strings, the error messages generated by the MOO-code compiler during processing of <code>.  If the list is non-empty, then `set_verb_code()' did not install <code>; the program associated with the verb in question is unchanged."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  verb_info (OBJ <object>, STR|INT <verb-name>)   => LIST",
            "         set_verb_info (OBJ <object>, STR|INT <verb-name>, LIST <info>)   => none",
            "",
            "BE AWARE: verb-name can be the string name of the verb OR the index from verbs()",
            "",
            "These two functions get and set (respectively) the owner, permission bits, and name(s) for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised. If the programmer does not have read (write) permission on the verb in question, then `verb_info()' (`set_verb_info()') raises E_PERM.  Verb info has the following form:",
            "",
            "    {<owner>, <perms>, <names>}",
            "",
            "where <owner> is an object, <perms> is a string containing only characters from the set `r', `w', `x', and `d', and <names> is a string.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'. The latter function raises E_INVARG if <owner> is not valid, if <perms> contains any illegal characters, or if <names> is the empty string or consists entirely of spaces; it raises E_PERM if <owner> is not the programmer and the programmer is not a wizard."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  waif_stats()   => MAP",
            "",
            "Returns a MAP of statistics about instantiated waifs. Each waif class will be a key in the MAP and its value will be the number of waifs of that class currently instantiated. Additionally, there is a `total' key that will return the total number of instantiated waifs, and a `pending_recycle' key that will return the number of waifs that have been destroyed and are awaiting the call of their :recycle verb."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:  yin([INT <time>, INT <minimum ticks>, INT <minimum seconds>] )   => INT",
            "",
            "Suspend the current task if it's running out of ticks or seconds. This is meant to provide similar functionality to the LambdaCore-based suspend_if_needed verb or manually specifying something like: ticks_left() < 2000 && suspend(0)",
            "",
            "Time: How long to suspend the task. Default: 0",
            "Minimum ticks: The minimum number of ticks the task has left before suspending.",
            "Minimum seconds: The minimum number of seconds the task has left before suspending."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "toaststunt-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "ToastStunt Help Database"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "A help database of the standard form in need of a description. See `help $generic_help'...",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            103117,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "87": {
      "id": 87,
      "name": "password verifier",
      "flags": 16,
      "owner": 2,
      "location": -1,
      "parents": [
        5
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "help_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "if (typeof(base = this.(verb)) == STR)",
            "base = {base};",
            "endif",
            "base = {@base, \"\", tostr(\".minimum_password_length = \", toliteral(x = this.minimum_password_length)), x ? tostr(\"Passwords are required to be a minimum of \", $string_utils:english_number(x), \" characters in length.\") | \"There is no minimum length requirement for passwords.\"};",
            "base = {@base, \"\", tostr(\".check_against_moo = \", toliteral(x = this.check_against_moo)), tostr(\"Passwords \", x ? \"may not\" | \"may\", \" be variants on the MOO's name (\", $network.MOO_name, \").\")};",
            "base = {@base, \"\", tostr(\".check_against_name = \", toliteral(x = this.check_against_name)), tostr(\"Passwords \", x ? \"may not\" | \"may\", \" be variants on the player's MOO name and/or aliases.\")};",
            "base = {@base, \"\", tostr(\".check_against_email = \", toliteral(x = this.check_against_email)), x ? \"Passwords may not be variants on the player's email address.\" | \"Passwords are not checked against the player's email address.\"};",
            "base = {@base, \"\", tostr(\".check_against_hosts = \", toliteral(x = this.check_against_hosts)), x ? \"Passwords may not be variants on the player's hostname(s).\" | \"Passwords are not checked against the player's hostname(s).\"};",
            "base = {@base, \"\", tostr(\".check_against_dictionary = \", toliteral(x = this.check_against_dictionary)), tostr(\"Passwords \", (typeof(x) in {LIST, OBJ}) ? \"may not\" | \"may\", \" be dictionary words.\", (x && (!$network.active)) ? \"  (This option is set but unavailable.)\" | \"\")};",
            "base = {@base, \"\", tostr(\".require_funky_characters = \", toliteral(x = this.require_funky_characters)), tostr(\"Non-alphabetic characters are \", x ? \"\" | \"not \", \"required in passwords.\")};",
            "base = {@base, \"\", tostr(\".check_obscure_stuff = \", toliteral(x = this.check_obscure_stuff)), x ? \"Misc. obscure checks enabled\" | \"No obscure checks in use.\"};",
            "return base;"
          ]
        },
        {
          "name": "reject_password",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "\":reject_password ( STR password [ , OBJ for-whom ] );\";",
            "\"=> string value [if the password is rejected, why?]\";",
            "\"=> false value [if the password isn't rejected]\";",
            "if (length(args) == 1)",
            "trust = 0;",
            "else",
            "if ($perm_utils:controls(caller_perms(), args[2]))",
            "trust = 1;",
            "else",
            "return \"Permissions don't permit setting of that password.\";",
            "endif",
            "endif",
            "\"this is gonna be huge\";",
            "return (((((((this:trivial_check(@args) || (this.minimum_password_length && this:check_length(@args))) || ((this.check_against_name && trust) && this:check_name(@args))) || ((this.check_against_email && trust) && this:check_email(@args))) || ((this.check_against_hosts && trust) && this:check_hosts(@args))) || ((typeof(this.check_against_dictionary) in {LIST, OBJ}) && this:check_dictionary(@args))) || (this.require_funky_characters && this:check_for_funky_characters(@args))) || (this.check_against_moo && this:check_against_moo(@args))) || (this.check_obscure_stuff && this:check_obscure_combinations(@args));"
          ]
        },
        {
          "name": "trivial_check",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "if (typeof(pwd = args[1]) != STR)",
            "return \"Passwords must be strings.\";",
            "elseif (index(pwd, \" \"))",
            "return \"Passwords may not contain spaces.\";",
            "elseif (length(args) == 2)",
            "if (((typeof(who = args[2]) != OBJ) || (!valid(who))) || (!is_player(who)))",
            "return \"That's not a player.\";",
            "elseif (!$perm_utils:controls(caller_perms(), who))",
            "return \"You can't set the password for that player.\";",
            "elseif ($object_utils:isa(who, $guest))",
            "return \"Sorry, but guest characters are not allowed to change their passwords.\";",
            "endif",
            "endif"
          ]
        },
        {
          "name": "check_length",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "if ((l = this.minimum_password_length) && (length(args[1]) < l))",
            "return tostr(\"Passwords must be a minimum of \", $string_utils:english_number(l), (l == 1) ? \" character \" | \" characters \", \"long.\");",
            "endif"
          ]
        },
        {
          "name": "check_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "pwd = args[1];",
            "if (valid($player_db:find_exact(pwd)))",
            "return \"Passwords may not be close to a player's name/alias pair.\";",
            "elseif (valid($player_db:find($string_utils:reverse(pwd))))",
            "return \"Passwords ought not be the reverse of a player's name/alias.\";",
            "endif"
          ]
        },
        {
          "name": "check_email",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "{pwd, who} = args;",
            "if (!$perm_utils:controls(caller_perms(), who))",
            "return \"Permission denied.\";",
            "endif",
            "email = $wiz_utils:get_email_address(who);",
            "if (!email)",
            "\"can't check\";",
            "return;",
            "endif",
            "if (index(email, pwd))",
            "return \"Passwords can't match your registered email address.\";",
            "endif"
          ]
        },
        {
          "name": "check_hosts",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "{pwd, who} = args;",
            "if (!$perm_utils:controls(caller_perms(), who))",
            "return \"Permission denied.\";",
            "endif",
            "hosts = who.all_connect_places;",
            "for x in (hosts)",
            "if (index(x, pwd))",
            "return \"Passwords may not match hostnames.\";",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "check_dictionary",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "pwd = args[1];",
            "if (typeof(dict) == OBJ)",
            "\"assume we're checking mr spell\";",
            "try",
            "if (dict:find_exact(pwd) && (!this:_is_funky_case(pwd)))",
            "return \"Dictionary words are not permitted for passwords.\";",
            "endif",
            "except (ANY)",
            "\"in case this is messed up. Just let it go and return 0;\";",
            "endtry",
            "endif"
          ]
        },
        {
          "name": "check_for_funky_characters",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "if (this:_is_funky_case(pwd = args[1]))",
            "return;",
            "endif",
            "alphabet = $string_utils.alphabet;",
            "for i in [1..length(pwd)]",
            "if (!index(alphabet, pwd[i]))",
            "return;",
            "endif",
            "endfor",
            "return \"At least one unusual capitalization and/or numeric or punctuation character is required.\";"
          ]
        },
        {
          "name": "check_against_moo",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "pwd = args[1];",
            "moo = $network.MOO_Name;",
            "if (this:_is_funky_case(pwd))",
            "return;",
            "endif",
            "if (pwd == moo)",
            "return \"The MOO's name is not secure as a password.\";",
            "endif",
            "if (moo[$ - 2..$] == \"MOO\")",
            "if (pwd == moo[1..$ - 3])",
            "return \"The MOO's name is not secure as a password.\";",
            "endif",
            "endif"
          ]
        },
        {
          "name": "_is_funky_case",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "pwd = args[1];",
            "if (!strcmp(pwd, u = $string_utils:uppercase(pwd)))",
            "return 0;",
            "elseif (!strcmp(pwd, l = $string_utils:lowercase(pwd)))",
            "return 0;",
            "elseif (!strcmp(pwd, tostr(u[1], l[2..$])))",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "check_obscure_combinations",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "pwd = args[1];",
            "if (match(pwd, \"^[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]$\"))",
            "return \"Social security numbers are potentially insecure passwords.\";",
            "elseif (match(pwd, \"^[0-9]+/[0-9]+/[0-9]+$\"))",
            "return \"Passwords which look like dates are potentially insecure passwords.\";",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 87,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "this.minimum_password_length = this.check_against_name = this.check_against_email = this.check_against_hosts = this.check_against_dictionary = this.require_funky_characters = this.check_against_moo = this.check_obscure_stuff = 0;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "minimum_password_length",
        "check_against_name",
        "check_against_email",
        "check_against_hosts",
        "check_against_dictionary",
        "require_funky_characters",
        "help_msg",
        "check_against_moo",
        "check_obscure_stuff"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "Password Verifier",
            "==================",
            "",
            "To check for the validity of a password, use",
            "  :reject_password( password [, for-whom? ] )",
            "... If it returns a true value, that value will contain the string representing the reason why the password was rejected.  If it returns a false value, the password is OK.",
            "",
            "The toggle switches for this checking are:"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "password verifier",
            "password",
            "verifier",
            "pwd"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "The password verifier verifies passwords.",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            15188,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "88": {
      "id": 88,
      "name": "Frand's player class",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        40
      ],
      "children": [
        31,
        4
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@rooms",
          "owner": 36,
          "perms": 13,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@rooms' - List the rooms which are known by name.\";",
            "line = \"\";",
            "for item in (this.rooms)",
            "line = (((line + item[1]) + \"(\") + tostr(item[2])) + \")   \";",
            "endfor",
            "player:tell(line);"
          ]
        },
        {
          "name": "@go",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@go <place>' - Teleport yourself somewhere. Example: '@go liv' to go to the living room.\";",
            "dest = this:lookup_room(dobjstr);",
            "if (dest == $failed_match)",
            "player:tell(\"There's no such place known.\");",
            "else",
            "this:teleport(player, dest);",
            "endif"
          ]
        },
        {
          "name": "lookup_room",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Look up a room in your personal database of room names, returning its object number. If it's not in your database, it checks to see if it's a number or a nearby object.\";",
            "room = args[1];",
            "if (room == \"home\")",
            "return player.home;",
            "elseif (room == \"me\")",
            "return player;",
            "elseif (room == \"here\")",
            "return player.location;",
            "elseif (!room)",
            "return $failed_match;",
            "endif",
            "index = this:index_room(room);",
            "if (index)",
            "return this.rooms[index][2];",
            "else",
            "return this:my_match_object(room);",
            "\"old code no longer used, 2/11/96 Heathcliff\";",
            "source = player.location;",
            "if (!(valid(source) && ($room in $object_utils:ancestors(source))))",
            "source = $room;",
            "endif",
            "return source:match_object(room);",
            "endif"
          ]
        },
        {
          "name": "teleport",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Teleport a player or object. For printing messages, there are three cases: (1) teleport self (2) teleport other player (3) teleport object. There's a spot of complexity for handling the invalid location #-1.\";",
            "set_task_perms((caller == this) ? this | $no_one);",
            "{thing, dest} = args;",
            "source = thing.location;",
            "if (valid(dest))",
            "dest_name = dest.name;",
            "else",
            "dest_name = tostr(dest);",
            "endif",
            "if (source == dest)",
            "player:tell(thing.name, \" is already at \", dest_name, \".\");",
            "return;",
            "endif",
            "thing:moveto(dest);",
            "if (thing.location == dest)",
            "tsd = {thing, source, dest};",
            "if (thing == player)",
            "this:teleport_messages(@tsd, this:self_port_msg(@tsd), this:oself_port_msg(@tsd), this:self_arrive_msg(@tsd), \"\");",
            "elseif (is_player(thing))",
            "this:teleport_messages(@tsd, this:player_port_msg(@tsd), this:oplayer_port_msg(@tsd), this:player_arrive_msg(@tsd), this:victim_port_msg(@tsd));",
            "else",
            "this:teleport_messages(@tsd, this:thing_port_msg(@tsd), this:othing_port_msg(@tsd), this:thing_arrive_msg(@tsd), this:object_port_msg(@tsd));",
            "endif",
            "elseif (thing.location == source)",
            "if ($object_utils:contains(thing, dest))",
            "player:tell(\"Ooh, it's all twisty. \", dest_name, \" is inside \", thing.name, \".\");",
            "else",
            "if ($object_utils:has_property(thing, \"po\"))",
            "pronoun = thing.po;",
            "else",
            "pronoun = \"it\";",
            "endif",
            "player:tell(\"Either \", thing.name, \" doesn't want to go, or \", dest_name, \" didn't accept \", pronoun, \".\");",
            "endif",
            "else",
            "thing_name = (thing == player) ? \"you\" | thing.name;",
            "player:tell(\"A strange force deflects \", thing_name, \" from the destination.\");",
            "endif"
          ]
        },
        {
          "name": "teleport_messages",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Send teleport messages. There's a slight complication in that the source and dest need not be valid objects.\";",
            "{thing, source, dest, pmsg, smsg, dmsg, tmsg} = args;",
            "if (pmsg)",
            "\"The player's own message.\";",
            "player:tell(pmsg);",
            "endif",
            "if (smsg)",
            "`source:room_announce_all_but({thing, player}, smsg) ! E_VERBNF, E_INVIND';",
            "endif",
            "if (dmsg)",
            "`dest:room_announce_all_but({thing, player}, dmsg) ! E_VERBNF, E_INVIND';",
            "endif",
            "if (tmsg)",
            "\"A message to the victim being teleported.\";",
            "thing:tell(tmsg);",
            "endif"
          ]
        },
        {
          "name": "@move",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";",
            "here = player.location;",
            "if ((prepstr != \"to\") || (!iobjstr))",
            "player:tell(\"Usage: @move <object> to <location>\");",
            "return;",
            "endif",
            "if ((!dobjstr) || (dobjstr == \"me\"))",
            "thing = this;",
            "else",
            "thing = `here:match_object(dobjstr) ! E_VERBNF, E_INVIND => $failed_match';",
            "if (thing == $failed_match)",
            "thing = player:my_match_object(dobjstr);",
            "endif",
            "endif",
            "if ($command_utils:object_match_failed(thing, dobjstr))",
            "return;",
            "endif",
            "if ((!player.programmer) && ((thing.owner != player) && (thing != player)))",
            "player:tell(\"You can only move your own objects.\");",
            "return;",
            "endif",
            "dest = this:lookup_room(iobjstr);",
            "if ((dest == #-1) || (!$command_utils:object_match_failed(dest, iobjstr)))",
            "this:teleport(thing, dest);",
            "endif"
          ]
        },
        {
          "name": "index_room",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'index_room (<room name>)' - Look up a room in your personal database of room names, returning its index in the list. Return 0 if it is not in the list. If the room name is the empty string, then only exact matches are considered; otherwise, a leading match is good enough.\";",
            "room = tostr(args[1]);",
            "size = length(room);",
            "index = 1;",
            "match = 0;",
            "for item in (this.rooms)",
            "item_name = item[1];",
            "if (room == item_name)",
            "return index;",
            "elseif ((size && (length(item_name) >= size)) && (room == item_name[1..size]))",
            "match = index;",
            "endif",
            "index = index + 1;",
            "endfor",
            "return match;"
          ]
        },
        {
          "name": "@addr*oom",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@addroom <name> <object>', '@addroom <object> <name>', '@addroom <name>', '@addroom <object>', '@addroom' - Add a room to your personal database of teleport destinations. Example: '@addroom Kitchen #24'. Reasonable <object>s are numbers (#17) and 'here'. If you leave out <object>, the object is the current room. If you leave out <name>, the name is the specified room's name. If you leave out both, you get the current room and its name.\";",
            "if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))",
            "if (!caller)",
            "player:tell(E_PERM);",
            "endif",
            "return E_PERM;",
            "endif",
            "if (!dobjstr)",
            "object = this.location;",
            "name = valid(object) ? object.name | \"Nowhere\";",
            "elseif (command = this:parse_out_object(dobjstr))",
            "name = command[1];",
            "object = command[2];",
            "else",
            "name = dobjstr;",
            "object = this.location;",
            "endif",
            "if (!valid(object))",
            "player:tell(\"This is not a valid location.\");",
            "return E_INVARG;",
            "endif",
            "player:tell(\"Adding \", name, \"(\", tostr(object), \") to your database of rooms.\");",
            "this.rooms = {@this.rooms, {name, object}};"
          ]
        },
        {
          "name": "@rmr*oom",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@rmroom <roomname>' - Remove a room from your personal database of teleport destinations. Example: '@rmroom library'.\";",
            "if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))",
            "if (!caller)",
            "player:tell(E_PERM);",
            "endif",
            "return E_PERM;",
            "endif",
            "index = this:index_room(dobjstr);",
            "if (index)",
            "player:tell(\"Removing \", this.rooms[index][1], \"(\", this.rooms[index][2], \").\");",
            "this.rooms = listdelete(this.rooms, index);",
            "else",
            "player:tell(\"That room is not in your database of rooms. Check '@rooms'.\");",
            "endif"
          ]
        },
        {
          "name": "@join",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@join <player>' - Teleport yourself to the location of any player, whether connected or not.\";",
            "if (dobjstr == \"\")",
            "player:tell(\"Usage: @join <player>. For example, '@join frand'.\");",
            "return;",
            "endif",
            "target = $string_utils:match_player(dobjstr);",
            "$command_utils:player_match_result(target, dobjstr);",
            "if (valid(target))",
            "if (target == this)",
            "if (player == this)",
            "player:tell(\"There is little need to join yourself, unless you are split up.\");",
            "else",
            "player:tell(\"No thank you. Please get your own join verb.\");",
            "endif",
            "return;",
            "endif",
            "dest = target.location;",
            "msg = this:enlist(this:join_msg());",
            "editing = $object_utils:isa(dest, $generic_editor);",
            "if (editing)",
            "dest = dest.original[target in dest.active];",
            "editing_msg = \"%N is editing at the moment. You can wait here until %s is done.\";",
            "if (player.location == dest)",
            "msg = {editing_msg};",
            "else",
            "msg = {@msg, editing_msg};",
            "endif",
            "endif",
            "if (msg && ((player.location != dest) || editing))",
            "player:tell_lines($string_utils:pronoun_sub(msg, target));",
            "elseif (player.location == dest)",
            "player:tell(\"OK, you're there. You didn't need to actually move, though.\");",
            "return;",
            "endif",
            "this:teleport(player, dest);",
            "endif"
          ]
        },
        {
          "name": "@find",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@find #<object>', '@find <player>', '@find :<verb>' '@find .<property>' - Attempt to locate things. Verbs and properties are found on any object in the player's vicinity, and some other places.  '@find ?<help>' looks for a help topic on any available help database.\";",
            "if (!dobjstr)",
            "player:tell(\"Usage: '@find #<object>' or '@find <player>' or '@find :<verb>' or '@find .<property>' or '@find ?<help topic>'.\");",
            "return;",
            "endif",
            "if (dobjstr[1] == \":\")",
            "name = dobjstr[2..$];",
            "this:find_verb(name);",
            "return;",
            "elseif (dobjstr[1] == \".\")",
            "name = dobjstr[2..$];",
            "this:find_property(name);",
            "return;",
            "elseif (dobjstr[1] == \"#\")",
            "target = toobj(dobjstr);",
            "if (!valid(target))",
            "player:tell(target, \" does not exist.\");",
            "endif",
            "elseif (dobjstr[1] == \"?\")",
            "name = dobjstr[2..$];",
            "this:find_help(name);",
            "return;",
            "else",
            "target = $string_utils:match_player(dobjstr);",
            "$command_utils:player_match_result(target, dobjstr);",
            "endif",
            "if (valid(target))",
            "player:tell(target.name, \" (\", target, \") is at \", valid(target.location) ? target.location.name | \"Nowhere\", \" (\", target.location, \").\");",
            "endif"
          ]
        },
        {
          "name": "find_verb",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'find_verb (<name>)' - Search for a verb with the given name. The objects searched are those returned by this:find_verbs_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.\";",
            "name = args[1];",
            "results = \"\";",
            "objects = $list_utils:remove_duplicates(this:find_verbs_on());",
            "for thing in (objects)",
            "if (valid(thing) && (mom = $object_utils:has_verb(thing, name)))",
            "results = ((((results + \"   \") + thing.name) + \"(\") + tostr(thing)) + \")\";",
            "mom = mom[1];",
            "if (thing != mom)",
            "results = ((((results + \"--\") + mom.name) + \"(\") + tostr(mom)) + \")\";",
            "endif",
            "endif",
            "endfor",
            "if (results)",
            "this:tell(\"The verb :\", name, \" is on\", results);",
            "else",
            "this:tell(\"The verb :\", name, \" is nowhere to be found.\");",
            "endif"
          ]
        },
        {
          "name": "@ways",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given).\";",
            "if (dobjstr)",
            "room = dobj;",
            "else",
            "room = this.location;",
            "endif",
            "if ((!valid(room)) || (!($room in $object_utils:ancestors(room))))",
            "player:tell(\"You can only pry into the exits of a room.\");",
            "return;",
            "endif",
            "exits = {};",
            "if ($object_utils:has_verb(room, \"obvious_exits\"))",
            "exits = room:obvious_exits();",
            "endif",
            "exits = this:checkexits(this:obvious_exits(), room, exits);",
            "exits = this:findexits(room, exits);",
            "this:tell_ways(exits, room);"
          ]
        },
        {
          "name": "findexits",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Add to the 'exits' list any exits in the room which have a single-letter alias.\";",
            "{room, exits} = args;",
            "alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";",
            "for i in [1..length(alphabet)]",
            "found = room:match_exit(alphabet[i]);",
            "if (valid(found) && (!(found in exits)))",
            "exits = {@exits, found};",
            "endif",
            "endfor",
            "return exits;"
          ]
        },
        {
          "name": "checkexits",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Check a list of exits to see if any of them are in the given room.\";",
            "{to_check, room, exits} = args;",
            "for word in (to_check)",
            "found = room:match_exit(word);",
            "if (valid(found) && (!(found in exits)))",
            "exits = {@exits, found};",
            "endif",
            "endfor",
            "return exits;"
          ]
        },
        {
          "name": "self_port_msg player_port_msg thing_port_msg join_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"This verb returns messages that go only to you. You don't need to have your name tacked on to the beginning of these. Heh.\";",
            "msg = this.(verb);",
            "if (msg && (length(args) >= 3))",
            "msg = this:msg_sub(msg, @args);",
            "endif",
            "return msg;"
          ]
        },
        {
          "name": "oself_port_msg self_arrive_msg oplayer_port_msg player_arrive_msg victim_port_msg othing_port_msg thing_arrive_msg object_port_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"This verb returns messages that go to other players. It does pronoun substitutions; if your name is not included in the final string, it adds the name in front.\";",
            "msg = this.(verb);",
            "if (!msg)",
            "msg = $frand_class.(verb);",
            "endif",
            "if (length(args) >= 3)",
            "msg = this:msg_sub(msg, @args);",
            "endif",
            "if (!$string_utils:index_delimited(msg, player.name))",
            "msg = (player.name + \" \") + msg;",
            "endif",
            "return msg;"
          ]
        },
        {
          "name": "msg_sub",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Do pronoun and other substitutions on the teleport messages. The arguments are: 1. The original message, before any substitutions; 2. object being teleported; 3. from location; 4. to location. The return value is the final message.\";",
            "{msg, thing, from, to} = args;",
            "msg = $string_utils:substitute(msg, $string_utils:pronoun_quote({{\"%<from room>\", valid(from) ? from.name | \"Nowhere\"}, {\"%<to room>\", valid(to) ? to.name | \"Nowhere\"}}));",
            "msg = $string_utils:pronoun_sub(msg, thing);",
            "return msg;"
          ]
        },
        {
          "name": "obvious_exits",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'obvious_exits()' - Return a list of common exit names which are obviously worth looking for in a room.\";",
            "return {\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"north\", \"northeast\", \"east\", \"southeast\", \"south\", \"southwest\", \"west\", \"northwest\", \"u\", \"d\", \"up\", \"down\", \"out\", \"exit\", \"leave\", \"enter\"};"
          ]
        },
        {
          "name": "tell_ways",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\":tell_ways (<list of exits>)' - Tell yourself a list of exits, for @ways. You can override it to print the exits in any format.\";",
            "exits = args[1];",
            "answer = {};",
            "for e in (exits)",
            "answer = {@answer, ((e.name + \" (\") + $string_utils:english_list(e.aliases)) + \")\"};",
            "endfor",
            "player:tell(\"Obvious exits: \", $string_utils:english_list(answer), \".\");"
          ]
        },
        {
          "name": "tell_obj",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Return the name and number of an object, e.g. 'Root Class (#1)'.\";",
            "o = args[1];",
            "return (((valid(o) ? o.name | \"Nothing\") + \" (\") + tostr(o)) + \")\";"
          ]
        },
        {
          "name": "parse_out_object",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'parse_out_object (<string>)' -> {<name>, <object>}, or 0. Given a string, attempt to find an object at its beginning or its end. An object can be either an object number, or 'here'. If this succeeds, return a list of the object and the unmatched part of the string, called the name. If it fails, return 0.\";",
            "words = $string_utils:words(args[1]);",
            "if (!length(words))",
            "return 0;",
            "endif",
            "word1 = words[1];",
            "wordN = words[$];",
            "if (length(word1) && (word1[1] == \"#\"))",
            "start = 2;",
            "finish = length(words);",
            "what = toobj(word1);",
            "elseif (word1 == \"here\")",
            "start = 2;",
            "finish = length(words);",
            "what = this.location;",
            "elseif (length(wordN) && (wordN[1] == \"#\"))",
            "start = 1;",
            "finish = length(words) - 1;",
            "what = toobj(wordN);",
            "elseif (wordN == \"here\")",
            "start = 1;",
            "finish = length(words) - 1;",
            "what = this.location;",
            "else",
            "return 0;",
            "endif",
            "\"toobj() has the nasty property that invalid strings get turned into #0. Here we just pretend that all references to #0 are actually meant for #-1.\";",
            "if (what == #0)",
            "what = $nothing;",
            "endif",
            "name = $string_utils:from_list(words[start..finish], \" \");",
            "if (!name)",
            "name = valid(what) ? what.name | \"Nowhere\";",
            "endif",
            "return {name, what};"
          ]
        },
        {
          "name": "enlist",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'enlist (<x>)' - If x is a list, just return it; otherwise, return {x}. The purpose here is to turn message strings into lists, so that lines can be added. It is not guaranteed to work for non-string non-lists.\";",
            "x = args[1];",
            "if (!x)",
            "return {};",
            "elseif (typeof(x) == LIST)",
            "return x;",
            "else",
            "return {x};",
            "endif"
          ]
        },
        {
          "name": "@spellm*essages @spellp*roperties",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "\"@spellproperties <object>\";",
            "\"@spellmessages <object>\";",
            "\"Spell checks the string properties of an object, or the subset of said properties which are suffixed _msg, respectively.\";",
            "set_task_perms(player);",
            "if (!dobjstr)",
            "player:notify(tostr(\"Usage: \", verb, \" <object>\"));",
            "return;",
            "elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))",
            "return;",
            "elseif (typeof(props = $object_utils:all_properties(dobj)) == ERR)",
            "player:notify(\"Permission denied to read properties on that object.\");",
            "return;",
            "endif",
            "props = setremove(props, \"messages\");",
            "if (verb[1..7] == \"@spellm\")",
            "spell = {};",
            "for prop in (props)",
            "if ((index(prop, \"_msg\") == (length(prop) - 3)) && index(prop, \"_msg\"))",
            "spell = {@spell, prop};",
            "endif",
            "endfor",
            "props = spell;",
            "endif",
            "if (props == {})",
            "player:notify(tostr(\"No \", (verb[1..7] == \"@spellm\") ? \"messages\" | \"properties\", \" found to spellcheck on \", dobj, \".\"));",
            "return;",
            "endif",
            "for data in (props)",
            "if (typeof(dd = `dobj.(data) ! ANY') == LIST)",
            "text = {};",
            "for linenum in (dd)",
            "text = listappend(text, linenum);",
            "endfor",
            "elseif ((((typeof(dd) == OBJ) || (typeof(dd) == INT)) || (typeof(dd) == ERR)) || (typeof(dd) == FLOAT))",
            "text = \"\";",
            "elseif (typeof(dd) == STR)",
            "text = dd;",
            "endif",
            "if (typeof(text) == STR)",
            "text = {text};",
            "endif",
            "linenumber = 0;",
            "for thisline in (text)",
            "$command_utils:suspend_if_needed(0);",
            "linenumber = linenumber + 1;",
            "if (((((typeof(thisline) != LIST) && (typeof(thisline) != OBJ)) && (typeof(thisline) != INT)) && (typeof(thisline) != FLOAT)) && (typeof(thisline) != ERR))",
            "i = $string_utils:strip_chars(thisline, \"!@#$%^&*()_+1234567890={}[]<>?:;,./|\\\"~'\");",
            "if (i)",
            "i = $string_utils:words(i);",
            "for ii in [1..length(i)]",
            "$command_utils:suspend_if_needed(0);",
            "if (!$spell:valid(i[ii]))",
            "if ((rindex(i[ii], \"s\") == length(i[ii])) && $spell:valid(i[ii][1..$ - 1]))",
            "msg = \"Possible match: \" + i[ii];",
            "elseif ((rindex(i[ii], \"'s\") == (length(i[ii]) - 1)) && $spell:valid(i[ii][1..$ - 2]))",
            "msg = \"Possible match: \" + i[ii];",
            "else",
            "msg = \"Unknown word: \" + i[ii];",
            "endif",
            "if (length(text) == 1)",
            "foo = \": \";",
            "else",
            "foo = (\" (line \" + tostr(linenumber)) + \"): \";",
            "endif",
            "player:notify(tostr(dobj, \".\", data, foo, msg));",
            "endif",
            "endfor",
            "endif",
            "endif",
            "endfor",
            "endfor",
            "player:notify(tostr(\"Done spellchecking \", dobj, \".\"));"
          ]
        },
        {
          "name": "@at",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@at' - Find out where everyone is. '@at <player>' - Find out where <player> is, and who else is there. '@at <obj>' - Find out who else is at the same place as <obj>. '@at <place>' - Find out who is at the place. The place can be given by number, or it can be a name from your @rooms list. '@at #-1' - Find out who is at #-1. '@at me' - Find out who is in the room with you. '@at home' - Find out who is at your home.\";",
            "this:internal_at(argstr);"
          ]
        },
        {
          "name": "at_players",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'at_players ()' - Return a list of players to be displayed by @at.\";",
            "return connected_players();"
          ]
        },
        {
          "name": "do_at_all",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'do_at_all ()' - List where everyone is, sorted by popularity of location. This is called when you type '@at'.\";",
            "locations = {};",
            "parties = {};",
            "counts = {};",
            "for who in (this:at_players())",
            "loc = who.location;",
            "if (i = loc in locations)",
            "parties[i] = setadd(parties[i], who);",
            "counts[i] = counts[i] - 1;",
            "else",
            "locations = {@locations, loc};",
            "parties = {@parties, {who}};",
            "counts = {@counts, 0};",
            "endif",
            "endfor",
            "locations = $list_utils:sort(locations, counts);",
            "parties = $list_utils:sort(parties, counts);",
            "this:print_at_items(locations, parties);"
          ]
        },
        {
          "name": "do_at",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'do_at (<location>)' - List the players at a given location.\";",
            "loc = args[1];",
            "party = {};",
            "for who in (this:at_players())",
            "if (who.location == loc)",
            "party = setadd(party, who);",
            "endif",
            "endfor",
            "this:print_at_items({loc}, {party});"
          ]
        },
        {
          "name": "print_at_items",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'print_at_items (<locations>, <parties>)' - Print a list of locations and people, for @at. Override this if you want to make a change to @at's output that you can't make in :at_item.\";",
            "{locations, parties} = args;",
            "for i in [1..length(locations)]",
            "$command_utils:suspend_if_needed(0);",
            "player:tell_lines(this:at_item(locations[i], parties[i]));",
            "endfor"
          ]
        },
        {
          "name": "at_item",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.\";",
            "{loc, party} = args;",
            "su = $string_utils;",
            "if (this.at_number)",
            "number = su:right(tostr(loc), 7) + \" \";",
            "else",
            "number = \"\";",
            "endif",
            "room = su:left(valid(loc) ? loc.name | \"[Nowhere]\", this.at_room_width);",
            "if (length(room) > this.at_room_width)",
            "room = room[1..this.at_room_width];",
            "endif",
            "text = (number + room) + \" \";",
            "if (party)",
            "filler = su:space(length(text) - 2);",
            "line = text;",
            "text = {};",
            "for who in (party)",
            "name = \" \" + (valid(who) ? who.name | \"[Nobody]\");",
            "if ((length(line) + length(name)) > this:linelen())",
            "text = {@text, line};",
            "line = filler + name;",
            "else",
            "line = line + name;",
            "endif",
            "endfor",
            "text = {@text, line};",
            "else",
            "text = text + \" [deserted]\";",
            "endif",
            "return text;"
          ]
        },
        {
          "name": "internal_at",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'internal_at (<argument string>)' - Perform the function of @at. The argument string is whatever the user typed after @at. This is factored out so that other verbs can call it.\";",
            "where = $string_utils:trim(args[1]);",
            "if (where)",
            "if (where[1] == \"#\")",
            "result = toobj(where);",
            "if ((!valid(result)) && (result != #-1))",
            "player:tell(\"That object does not exist.\");",
            "return;",
            "endif",
            "else",
            "result = this:lookup_room(where);",
            "if (!valid(result))",
            "result = $string_utils:match_player(where);",
            "if (!valid(result))",
            "player:tell(\"That is neither a player nor a room name.\");",
            "return;",
            "endif",
            "endif",
            "endif",
            "if (valid(result) && (!$object_utils:isa(result, $room)))",
            "result = result.location;",
            "endif",
            "this:do_at(result);",
            "else",
            "this:do_at_all();",
            "endif"
          ]
        },
        {
          "name": "confunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'confunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has connected.\";",
            "if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))",
            "return E_PERM;",
            "endif",
            "pass(@args);",
            "set_task_perms(this);",
            "for feature in (this.features)",
            "try",
            "feature:player_connected(player, @args);",
            "except (E_VERBNF)",
            "continue feature;",
            "except id (ANY)",
            "player:tell(\"Feature initialization failure for \", feature, \": \", id[2], \".\");",
            "endtry",
            "$command_utils:suspend_if_needed(0);",
            "endfor"
          ]
        },
        {
          "name": "disfunc",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'disfunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has disconnected.\";",
            "if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))",
            "return E_PERM;",
            "endif",
            "pass(@args);",
            "\"This is forked off to protect :disfunc from buggy :player_disconnected verbs.\";",
            "set_task_perms(this);",
            "fork (max(0, $login:current_lag()))",
            "for feature in (this.features)",
            "try",
            "feature:player_disconnected(player, @args);",
            "except (ANY)",
            "continue feature;",
            "endtry",
            "endfor",
            "endfork"
          ]
        },
        {
          "name": "@addword",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "set_task_perms(player);",
            "if (!argstr)",
            "player:notify(tostr(\"Usage: \", verb, \" one or more words\"));",
            "player:notify(tostr(\"       \", verb, \" object:verb\"));",
            "player:notify(tostr(\"       \", verb, \" object.prop\"));",
            "elseif (!$perm_utils:controls(player, player))",
            "player:notify(\"Cannot modify dictionary on players who do not own themselves.\");",
            "elseif (data = $spell:get_input(argstr))",
            "num_learned = 0;",
            "for i in [1..length(data)]",
            "line = $string_utils:words(data[i]);",
            "for ii in [1..length(line)]",
            "if (seconds_left() < 2)",
            "suspend(0);",
            "endif",
            "if (!$spell:valid(line[ii]))",
            "player.dict = listappend(player.dict, line[ii]);",
            "player:notify(tostr(\"Word added:  \", line[ii]));",
            "num_learned = num_learned + 1;",
            "endif",
            "endfor",
            "endfor",
            "player:notify(tostr(num_learned ? num_learned | \"No\", \" word\", (num_learned != 1) ? \"s \" | \" \", \"added to personal dictionary.\"));",
            "endif"
          ]
        },
        {
          "name": "@spell @cspell",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "\"@spell a word or phrase  -- Spell check a word or phrase.\";",
            "\"@spell thing.prop  -- Spell check a property. The value must be a string or a list of strings.\";",
            "\"@spell thing:verb  -- Spell check a verb. Only the quoted strings in the verb are checked.\";",
            "\"@cspell word  -- Spell check a word, and if it is not in the dictionary, offset suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.\";",
            "\"\";",
            "\"Mr. Spell was written by waffle (waffle@euclid.humboldt.edu), for use by\";",
            "\"MOOers all over this big green earth. (....and other places....)\";",
            "\"This monstrosity programmed Sept-Oct 1991, when I should have been studying.\";",
            "\"Mr. Spell was then gutted by lisdude on 2-17-19 to use ToastStunt builtins.\";",
            "set_task_perms(player);",
            "if (!argstr)",
            "player:notify(tostr(\"Usage: \", verb, \" object.property\"));",
            "player:notify(tostr(\"       \", verb, \" object:verb\"));",
            "player:notify(tostr(\"       \", verb, \" one or more words\"));",
            "else",
            "\"@spell or @cspell.\";",
            "corrected_words = {};",
            "data = $spell:get_input(argstr);",
            "if (data)",
            "misspelling = 0;",
            "for i in [1..length(data)]",
            "line = $string_utils:words(data[i]);",
            "for ii in [1..length(line)]",
            "$command_utils:suspend_if_needed(0);",
            "if (!$spell:valid(line[ii]))",
            "if ((rindex(line[ii], \"s\") == length(line[ii])) && $spell:valid(line[ii][1..$ - 1]))",
            "msg = \"Possible match: \" + line[ii];",
            "msg = (msg + \" \") + ((length(data) != 1) ? (\"(line \" + tostr(i)) + \")  \" | \"  \");",
            "elseif ((rindex(line[ii], \"'s\") == (length(line[ii]) - 1)) && $spell:valid(line[ii][1..$ - 2]))",
            "msg = \"Possible match: \" + line[ii];",
            "msg = (msg + \" \") + ((length(data) != 1) ? (\"(line \" + tostr(i)) + \")  \" | \"  \");",
            "else",
            "misspelling = misspelling + 1;",
            "msg = (\"Unknown word: \" + line[ii]) + ((length(data) != 1) ? (\" (line \" + tostr(i)) + \")  \" | \"  \");",
            "if ((verb == \"@cspell\") && (!(line[ii] in corrected_words)))",
            "corrected_words = listappend(corrected_words, line[ii]);",
            "guesses = $string_utils:from_list($spell:guess_words(line[ii]), \" \");",
            "if (guesses == \"\")",
            "msg = msg + \"-No guesses\";",
            "else",
            "msg = msg + \"-Possible correct spelling\";",
            "msg = msg + (index(guesses, \" \") ? \"s: \" | \": \");",
            "msg = msg + guesses;",
            "endif",
            "endif",
            "endif",
            "player:notify(tostr(msg));",
            "endif",
            "endfor",
            "endfor",
            "player:notify(tostr(\"Found \", misspelling ? misspelling | \"no\", \" misspelled word\", (misspelling == 1) ? \".\" | \"s.\"));",
            "elseif (data != $failed_match)",
            "player:notify(tostr(\"Nothing found to spellcheck!\"));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@rmword",
          "owner": 2,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "set_task_perms(player);",
            "if (argstr in player.dict)",
            "player.dict = setremove(player.dict, argstr);",
            "player:notify(tostr(\"`\", argstr, \"' removed from personal dictionary.\"));",
            "else",
            "player:notify(tostr(\"`\", argstr, \"' not found in personal dictionary.\"));",
            "endif"
          ]
        },
        {
          "name": "find_property",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'find_property (<name>)' - Search for a property with the given name. The objects searched are those returned by this:find_properties_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.\";",
            "name = args[1];",
            "results = \"\";",
            "objects = $list_utils:remove_duplicates(this:find_properties_on());",
            "for thing in (objects)",
            "if (valid(thing) && (mom = $object_utils:has_property(thing, name)))",
            "results = ((((results + \"   \") + thing.name) + \"(\") + tostr(thing)) + \")\";",
            "mom = this:property_inherited_from(thing, name);",
            "if (thing != mom)",
            "if (valid(mom))",
            "results = ((((results + \"--\") + mom.name) + \"(\") + tostr(mom)) + \")\";",
            "else",
            "results = results + \"--built-in\";",
            "endif",
            "endif",
            "endif",
            "endfor",
            "if (results)",
            "this:tell(\"The property .\", name, \" is on\", results);",
            "else",
            "this:tell(\"The property .\", name, \" is nowhere to be found.\");",
            "endif"
          ]
        },
        {
          "name": "find_verbs_on",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'find_verbs_on ()' -> list of objects - Return the objects that @find searches when looking for a verb. The objects are searched (and the results printed) in the order returned. Feature objects are included in the search. Duplicate entries are removed by the caller.\";",
            "return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents(), @this.features};"
          ]
        },
        {
          "name": "find_properties_on",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'find_properties_on ()' -> list of objects - Return the objects that @find searches when looking for a property. The objects are searched (and the results printed) in the order returned. Feature objects are *not* included in the search. Duplicate entries are removed by the caller.\";",
            "return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents()};"
          ]
        },
        {
          "name": "property_inherited_from",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'property_inherited_from (<object>, <property name>)' -> object - Return the ancestor of <object> on which <object>.<property> is originally defined. If <object>.<property> is not actually defined, return 0. The property is taken as originally defined on the earliest ancestor of <object> which has it. If the property is built-in, return $nothing.\";",
            "{what, prop} = args;",
            "if (!$object_utils:has_property(what, prop))",
            "return 0;",
            "elseif (prop in $code_utils.builtin_props)",
            "return $nothing;",
            "endif",
            "ancestor = what;",
            "while ($object_utils:has_property(parent(ancestor), prop))",
            "ancestor = parent(ancestor);",
            "endwhile",
            "return ancestor;"
          ]
        },
        {
          "name": "@ref*use",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@refuse <action(s)> [ from <player> ] [ for <time> ]' - Refuse all of a list of one or more actions. If a player is given, refuse actions from the player; otherwise, refuse all actions. If a time is specified, refuse the actions for the given amount of time; otherwise, refuse them for a week. If the actions are already refused, then the only their times are adjusted.\";",
            "if (!argstr)",
            "player:tell(\"@refuse <action(s)> [ from <player> ] [ for <time> ]\");",
            "return;",
            "endif",
            "stuff = this:parse_refuse_arguments(argstr);",
            "if (stuff)",
            "if (((typeof(who = stuff[1]) == OBJ) && (who != $nothing)) && (!is_player(who)))",
            "player:tell(\"You must give the name of some player.\");",
            "else",
            "\"'stuff' is now in the form {<origin>, <actions>, <duration>}.\";",
            "if ((stuff[3] < 0) || (stuff[3] > (($maxint - time()) - 2)))",
            "stuff[3] = ($maxint - time()) - 2;",
            "player:tell(\"That amount of time is too large.  It has been capped at \", $time_utils:english_time(stuff[3]), \".\");",
            "endif",
            "this:add_refusal(@stuff);",
            "player:tell(\"Refusal of \", this:refusal_origin_to_name(stuff[1]), \" for \", $time_utils:english_time(stuff[3]), \" added.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@unref*use @allow",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@unrefuse <action(s)> [ from <player> ]' - Stop refusing all of a list of actions. If a player is given, stop refusing actions by the player; otherwise, stop refusing all actions of the given kinds. '@unrefuse everything' - Remove all refusals.\";",
            "if (argstr == \"everything\")",
            "if ($command_utils:yes_or_no(\"Do you really want to erase all your refusals?\"))",
            "this:clear_refusals();",
            "player:tell(\"OK, they are gone.\");",
            "else",
            "player:tell(\"OK, no harm done.\");",
            "endif",
            "return;",
            "endif",
            "stuff = this:parse_refuse_arguments(argstr);",
            "if (!stuff)",
            "return;",
            "endif",
            "\"'stuff' is now in the form {<origin>, <actions>, <duration>}.\";",
            "origins = stuff[1];",
            "actions = stuff[2];",
            "if (typeof(origins) != LIST)",
            "origins = {origins};",
            "endif",
            "n = 0;",
            "for origin in (origins)",
            "n = n + this:remove_refusal(origin, actions);",
            "endfor",
            "plural = ((n == 1) && (length(origins) == 1)) ? \"\" | \"s\";",
            "if (n)",
            "player:tell(\"Refusal\", plural, \" removed.\");",
            "else",
            "player:tell(\"You have no such refusal\", plural, \".\");",
            "endif"
          ]
        },
        {
          "name": "@refusals",
          "owner": 36,
          "perms": 73,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@refusals' - List your refusals. '@refusals for <player>' - List the given player's refusals.\";",
            "if (iobjstr)",
            "who = $string_utils:match_player(iobjstr);",
            "if ($command_utils:player_match_failed(who, iobjstr))",
            "return;",
            "endif",
            "if (!$object_utils:has_verb(who, \"refusals_text\"))",
            "player:tell(\"That player does not have the refusal facility.\");",
            "return;",
            "endif",
            "else",
            "who = player;",
            "endif",
            "who:remove_expired_refusals();",
            "player:tell_lines(this:refusals_text(who));"
          ]
        },
        {
          "name": "@refusal-r*eporting",
          "owner": 36,
          "perms": 89,
          "preps": -2,
          "object": 88,
          "code": [
            "\"'@refusal-reporting' - See if refusal reporting is on. '@refusal-reporting on', '@refusal-reporting off' - Turn it on or off..\";",
            "if (!argstr)",
            "player:tell(\"Refusal reporting is \", this.report_refusal ? \"on\" | \"off\", \".\");",
            "elseif (argstr in {\"on\", \"yes\", \"y\", \"1\"})",
            "this.report_refusal = 1;",
            "player:tell(\"Refusals will be reported to you as they happen.\");",
            "elseif (argstr in {\"off\", \"no\", \"n\", \"0\"})",
            "this.report_refusal = 0;",
            "player:tell(\"Refusals will happen silently.\");",
            "else",
            "player:tell(\"@refusal-reporting on     - turn on refusal reporting\");",
            "player:tell(\"@refusal-reporting off    - turn it off\");",
            "player:tell(\"@refusal-reporting        - see if it's on or off\");",
            "endif"
          ]
        },
        {
          "name": "parse_refuse_arguments",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'parse_refuse_arguments (<string>)' -> {<who>, <actions>, <duration>} - Parse the arguments of a @refuse or @unrefuse command. <who> is the player requested, or $nothing if none was. <actions> is a list of the actions asked for. <duration> is how long the refusal should last, or 0 if no expiration is given. <errors> is a list of actions (or other words) which are wrong. If there are any errors, this prints an error message and returns 0.\";",
            "words = $string_utils:explode(args[1]);",
            "possible_actions = this:refusable_actions();",
            "who = $nothing;",
            "actions = {};",
            "until = this.default_refusal_time;",
            "errors = {};",
            "skip_to = 0;",
            "for i in [1..length(words)]",
            "word = words[i];",
            "if (i <= skip_to)",
            "elseif (which = $string_utils:find_prefix(word, possible_actions))",
            "actions = setadd(actions, possible_actions[which]);",
            "elseif ((word[$] == \"s\") && (which = $string_utils:find_prefix(word[1..$ - 1], possible_actions)))",
            "\"The word seems to be the plural of an action.\";",
            "actions = setadd(actions, possible_actions[which]);",
            "elseif (results = this:translate_refusal_synonym(word))",
            "actions = $set_utils:union(actions, results);",
            "elseif ((word == \"from\") && (i < length(words)))",
            "\"Modified to allow refusals from all guests at once. 5-27-94, Gelfin\";",
            "if (words[i + 1] == \"guests\")",
            "who = \"all guests\";",
            "elseif (!(typeof(who = $code_utils:toobj(words[i + 1])) == OBJ))",
            "who = $string_utils:match_player(words[i + 1]);",
            "if ($command_utils:player_match_failed(who, words[i + 1]))",
            "return 0;",
            "endif",
            "endif",
            "skip_to = i + 1;",
            "elseif ((word == \"for\") && (i < length(words)))",
            "n_words = this:parse_time_length(words[i + 1..$]);",
            "until = this:parse_time(words[i + 1..i + n_words]);",
            "if (!until)",
            "return 0;",
            "endif",
            "skip_to = i + n_words;",
            "else",
            "errors = {@errors, word};",
            "endif",
            "endfor",
            "if (errors)",
            "player:tell((length(errors) > 1) ? \"These parts of the command were not understood: \" | \"This part of the command was not understood: \", $string_utils:english_list(errors, 0, \" \", \" \", \" \"));",
            "return 0;",
            "endif",
            "return {this:player_to_refusal_origin(who), actions, until};"
          ]
        },
        {
          "name": "time_word_to_seconds",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'time_word_to_seconds (<string>)' - The <string> is expected to be a time word, 'second', 'minute', 'hour', 'day', 'week', or 'month'. Return the number of seconds in that amount of time (a month is taken to be 30 days). If <string> is not a time word, return 0. This is used both as a test of whether a word is a time word and as a converter.\";",
            "return $time_utils:parse_english_time_interval(\"1\", args[1]);"
          ]
        },
        {
          "name": "parse_time_length",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'parse_time_length (<words>)' -> n - Given a list of words which is expected to begin with a time expression, return how many of them belong to the time expression. A time expression can be a positive integer, a time word, or a positive integer followed by a time word. A time word is anything that this:time_word_to_seconds this is one. The return value is 0, 1, or 2.\";",
            "words = {@args[1], \"dummy\"};",
            "n = 0;",
            "if (toint(words[1]) || this:time_word_to_seconds(words[1]))",
            "n = 1;",
            "endif",
            "if (this:time_word_to_seconds(words[n + 1]))",
            "n = n + 1;",
            "endif",
            "return n;"
          ]
        },
        {
          "name": "parse_time",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'parse_time (<words>)' -> <seconds> - Given a list of zero or more words, either empty or a valid time expression, return the number of seconds that the time expression refers to. This is a duration, not an absolute time.\";",
            "words = args[1];",
            "\"If the list is empty, return the default refusal time.\";",
            "if (!words)",
            "return this.default_refusal_time;",
            "endif",
            "\"If the list has one word, either <units> or <n>.\";",
            "\"If it is a unit, like 'hour', return the time for 1 <unit>.\";",
            "\"If it is a number, return the time for <n> days.\";",
            "if (length(words) == 1)",
            "return this:time_word_to_seconds(words[1]) || (toint(words[1]) * this:time_word_to_seconds(\"days\"));",
            "endif",
            "\"The list must contain two words, <n> <units>.\";",
            "return toint(words[1]) * this:time_word_to_seconds(words[2]);"
          ]
        },
        {
          "name": "clear_refusals",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'clear_refusals ()' - Erase all of this player's refusals.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "this.refused_origins = {};",
            "this.refused_actions = {};",
            "this.refused_until = {};",
            "this.refused_extra = {};"
          ]
        },
        {
          "name": "set_default_refusal_time",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'set_default_refusal_time (<seconds>)' - Set the length of time that a refusal lasts if its duration isn't specified.\";",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "this.default_refusal_time = toint(args[1]);"
          ]
        },
        {
          "name": "refusable_actions",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'refusable_actions ()' -> {'page', 'whisper', ...} - Return a list of the actions that can be refused. This is a verb, rather than a property, so that it can be inherited properly. If you override this verb to add new refusable actions, write something like 'return {@pass (), 'action1', 'action2', ...}'. That way people can add new refusable actions at any level of the player class hierarchy, without clobbering any that were added higher up.\";",
            "return {\"page\", \"whisper\", \"move\", \"join\", \"accept\", \"mail\"};"
          ]
        },
        {
          "name": "translate_refusal_synonym",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'translate_refusal_synonym (<word>)' -> list - If the <word> is a synonym for some set of refusals, return the list of those refusals. Otherwise return the empty list, {}. Programmers can override this verb to provide more synonyms.\";",
            "word = args[1];",
            "if (word == \"all\")",
            "return this:refusable_actions();",
            "endif",
            "return {};"
          ]
        },
        {
          "name": "default_refusals_text_filter",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'default_refusals_text_filter (<origin>, <actions>)' - Return any actions by this <origin> which should be included in the text returned by :refusals_text. This is the default filter, which includes all actions.\";",
            "return args[2];"
          ]
        },
        {
          "name": "refusals_text",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'refusals_text (<player>, [<filter verb name>])' - Return text describing the given player's refusals. The filter verb name is optional; if it is given, this verb takes an origin and a list of actions and returns any actions which should be included in the refusals text. This verb works only if <player> is a player who has the refusals facility; it does not check for this itself.\";",
            "who = args[1];",
            "\"Used to allow you to supply the filter verb name, but that introduced a security hole. --Nosredna\";",
            "filter_verb = \"default_refusals_text_filter\";",
            "text = {};",
            "for i in [1..length(who.refused_origins)]",
            "origin = who.refused_origins[i];",
            "actions = this:(filter_verb)(origin, who.refused_actions[i]);",
            "if (actions)",
            "line = \"\";",
            "for action in (actions)",
            "line = (line + \" \") + action;",
            "endfor",
            "line = (this:refusal_origin_to_name(origin) + \": \") + line;",
            "line = (ctime(who.refused_until[i]) + \" \") + line;",
            "text = {@text, line};",
            "endif",
            "endfor",
            "if (!text)",
            "text = {\"No refusals.\"};",
            "endif",
            "return text;"
          ]
        },
        {
          "name": "player_to_refusal_origin",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'player_to_refusal_origin (<player>)' -> <origin> - Convert a player to a unique identifier called the player's 'refusal origin'. For most players, it's just their object number. For guests, it is a hash of the site they are connecting from. Converting an origin to an origin is a safe no-op--the code relies on this.\";",
            "set_task_perms(caller_perms());",
            "{who} = args;",
            "if (((typeof(who) == OBJ) && valid(who)) && (parent(who) == `$local.guest ! E_PROPNF, E_INVIND => $guest'))",
            "return who:connection_name_hash(\"xx\");",
            "else",
            "return who;",
            "endif"
          ]
        },
        {
          "name": "refusal_origin_to_name",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'refusal_origin_to_name (<origin>)' -> string - Convert a refusal origin to a name.\";",
            "origin = args[1];",
            "if (origin in {\"all guests\", \"everybody\"})",
            "return origin;",
            "elseif ((typeof(origin) == STR) && (origin == \"Permission denied\"))",
            "return \"an errorful origin\";",
            "elseif (typeof(origin) != OBJ)",
            "return \"a certain guest\";",
            "elseif (origin == #-1)",
            "return \"Everybody\";",
            "else",
            "return $string_utils:name_and_number(origin);",
            "endif"
          ]
        },
        {
          "name": "check_refusal_actions",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'check_refusal_actions (<actions>)' - Check a list of refusal actions, and return whether they are all legal.\";",
            "actions = args[1];",
            "legal_actions = this:refusable_actions();",
            "for action in (actions)",
            "if (!(action in legal_actions))",
            "return 0;",
            "endif",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "add_refusal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'add_refusal (<origin>, <actions> [, <duration> [, <extra>]])' - Add refusal(s) to this player's list. <Actions> is a list of the actions to be refused. The list should contain only actions, no synonyms. <Origin> is the actor whose actions are to be refused. <Until> is the time that the actions are being refused until, in the form returned by time(). It is optional; if it's not given, it defaults to .default_refusal_time. <Extra> is any extra information; it can be used for comments, or to make finer distinctions about the actions being refused, or whatever. If it is not given, it defaults to 0. The extra information is per-action; that is, it is stored separately for each action that it applies to.\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{orig, actions, ?duration = this.default_refusal_time, ?extra = 0} = args;",
            "origins = this:player_to_refusal_origin(orig);",
            "if (typeof(origins) != LIST)",
            "origins = {origins};",
            "endif",
            "if (typeof(actions) != LIST)",
            "actions = {actions};",
            "endif",
            "if (!this:check_refusal_actions(actions))",
            "return E_INVARG;",
            "endif",
            "until = time() + duration;",
            "for origin in (origins)",
            "if (i = origin in this.refused_origins)",
            "this.refused_until[i] = until;",
            "for action in (actions)",
            "if (j = action in this.refused_actions[i])",
            "this.refused_extra[i][j] = extra;",
            "else",
            "this.refused_actions[i] = {@this.refused_actions[i], action};",
            "this.refused_extra[i] = {@this.refused_extra[i], extra};",
            "endif",
            "endfor",
            "else",
            "this.refused_origins = {@this.refused_origins, origin};",
            "this.refused_actions = {@this.refused_actions, actions};",
            "this.refused_until = {@this.refused_until, until};",
            "this.refused_extra = {@this.refused_extra, $list_utils:make(length(actions), extra)};",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "remove_refusal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'remove_refusal (<origin>, <actions>)' - Remove any refused <actions> by <origin>. The <actions> list should contain only actions, no synonyms. Return the number of such refusals found (0 if none).\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{origin, actions} = args;",
            "if (typeof(actions) != LIST)",
            "actions = {actions};",
            "endif",
            "count = 0;",
            "i = origin in this.refused_origins;",
            "if (i)",
            "for action in (actions)",
            "if (j = action in this.refused_actions[i])",
            "this.refused_actions[i] = listdelete(this.refused_actions[i], j);",
            "this.refused_extra[i] = listdelete(this.refused_extra[i], j);",
            "count = count + 1;",
            "endif",
            "endfor",
            "if (!this.refused_actions[i])",
            "this.refused_origins = listdelete(this.refused_origins, i);",
            "this.refused_actions = listdelete(this.refused_actions, i);",
            "this.refused_until = listdelete(this.refused_until, i);",
            "this.refused_extra = listdelete(this.refused_extra, i);",
            "endif",
            "endif",
            "return count;"
          ]
        },
        {
          "name": "remove_expired_refusals",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'remove_expired_refusals ()' - Remove refusal entries which are past their time limits.\";",
            "origins = {};",
            "\"Before removing any refusals, figure out which ones to remove. Removing one changes the indices and invalidates the loop invariant.\";",
            "for i in [1..length(this.refused_origins)]",
            "if ((time() >= this.refused_until[i]) || ((typeof(this.refused_origins[i]) == OBJ) && (!$recycler:valid(this.refused_origins[i]))))",
            "origins = {@origins, this.refused_origins[i]};",
            "endif",
            "endfor",
            "for origin in (origins)",
            "this:remove_refusal(origin, this:refusable_actions());",
            "endfor"
          ]
        },
        {
          "name": "refuses_action",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'refuses_action (<origin>, <action>, ...)' - Return whether this object refuses the given <action> by <origin>. <Origin> is typically a player. Extra arguments after <origin>, if any, are used to further describe the action.\";",
            "\"Modified by Diopter (#98842) at LambdaMOO\";",
            "{origin, action, @extra_args} = args;",
            "extra_args = {origin, @extra_args};",
            "rorigin = this:player_to_refusal_origin(origin);",
            "if (((which = rorigin in this.refused_origins) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))",
            "return 1;",
            "elseif (((((typeof(rorigin) == OBJ) && valid(rorigin)) && (which = rorigin.owner in this.refused_origins)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))",
            "return 1;",
            "elseif ((((which = $nothing in this.refused_origins) && (rorigin != this)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))",
            "return 1;",
            "elseif ((((which = \"all guests\" in this.refused_origins) && $object_utils:isa(origin, $guest)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))",
            "return 1;",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "refuses_action_*",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'refuses_action_* (<which>, <origin>, ...)' - The action (such as 'whisper' for the verb :refuses_action_whisper) is being considered for refusal. Return whether the action should really be refused. <Which> is an index into this.refused_origins. By default, always refuse non-outdated actions that get this far.\";",
            "{which, @junk} = args;",
            "if (time() >= this.refused_until[which])",
            "fork (0)",
            "\"This <origin> is no longer refused. Remove any outdated refusals.\";",
            "this:remove_expired_refusals();",
            "endfork",
            "return 0;",
            "else",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "report_refusal",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'report_refusal (<player>, <message>, ...)' - If refusal reporting is turned on, print the given <message> to report the refusal of some action by <player>. The message may take more than one argument. You can override this verb to do more selective reporting.\";",
            "if (this.report_refusal)",
            "this:tell(@listdelete(args, 1));",
            "endif"
          ]
        },
        {
          "name": "wh*isper",
          "owner": 36,
          "perms": 157,
          "preps": 1,
          "object": 88,
          "code": [
            "\"'whisper <message> to <this player>' - Whisper a message to this player which nobody else can see.\";",
            "if (this:refuses_action(player, \"whisper\"))",
            "player:tell(this:whisper_refused_msg());",
            "this:report_refusal(player, \"You just refused a whisper from \", player.name, \".\");",
            "else",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "receive_page",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'receive_page (<message>)' - Receive a page. If the page is accepted, pass(@args) shows it to the player.\";",
            "if (this:refuses_action(player, \"page\"))",
            "this.page_refused = task_id();",
            "return 0;",
            "endif",
            "this.page_refused = 0;",
            "return pass(@args);"
          ]
        },
        {
          "name": "page_echo_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'page_echo_msg ()' - Return a message to inform the pager what happened to their page.\";",
            "if (task_id() == this.page_refused)",
            "this:report_refusal(player, \"You just refused a page from \", player.name, \".\");",
            "return this:page_refused_msg();",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "moveto acceptable",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'moveto (<destination>)', 'accept (<object>)' - Check whether this :moveto or :accept is allowed or refused. If it is allowed, do it. This code is slightly modified from an original verb by Grump.  Upgraded by Bits to account for forthcoming 1.8.0 behavior of callers().\";",
            "by = callers();",
            "\"Ignore all the verbs on this.\";",
            "while (((y = by[1])[1] == this) && (y[2] == verb))",
            "by = listdelete(by, 1);",
            "endwhile",
            "act = (verb == \"moveto\") ? \"move\" | \"accept\";",
            "if ((player != this) && this:refuses_action(player, act, args[1]))",
            "\"check player\";",
            "return 0;",
            "endif",
            "last = #-1;",
            "for k in (by)",
            "if ((((perms = k[3]) == #-1) && (k[2] != \"\")) && (k[1] == #-1))",
            "elseif ((!perms.wizard) && (perms != this))",
            "if (perms != last)",
            "\"check for possible malicious programmer\";",
            "if (this:refuses_action(perms, act, args[1]))",
            "return 0;",
            "endif",
            "last = perms;",
            "endif",
            "endif",
            "endfor",
            "\"Coded added 11/8/98 by TheCat, to refuse spurned objects.\";",
            "if ((act == \"accept\") && (typeof(this.spurned_objects) == LIST))",
            "for item in (this.spurned_objects)",
            "if ($object_utils:isa(args[1], item))",
            "return 0;",
            "endif",
            "endfor",
            "endif",
            "\"(end of code added by TheCat)\";",
            "return pass(@args);"
          ]
        },
        {
          "name": "receive_message",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'receive_message (<message>, <sender>)' - Receive the given mail message from the given sender. This version handles refusal of the message.\";",
            "if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))",
            "return E_PERM;",
            "elseif (this:refuses_action(args[2], \"mail\"))",
            "return this:mail_refused_msg();",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "whisper_refused_msg page_refused_msg mail_refused_msg",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'whisper_refused_msg()', 'page_refused_msg()', etc. - Return a message string.\";",
            "return $string_utils:pronoun_sub(this.(verb), this);"
          ]
        },
        {
          "name": "last_huh",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "set_task_perms(caller_perms());",
            "if (pass(@args))",
            "return 1;",
            "endif",
            "{verb, args} = args;",
            "if (valid(dobj = $string_utils:literal_object(dobjstr)) && (r = $match_utils:match_verb(verb, dobj, args)))",
            "return r;",
            "elseif (valid(iobj = $string_utils:literal_object(iobjstr)) && (r = $match_utils:match_verb(verb, iobj, args)))",
            "return r;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "ping_features",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\":ping_features()\";",
            "\" -- cleans up the .features list to remove !valid objects\";",
            "\" ==> cleaned-up .features list\";",
            "features = this.features;",
            "for x in (features)",
            "if (!$recycler:valid(x))",
            "features = setremove(features, x);",
            "endif",
            "endfor",
            "return this.features = features;"
          ]
        },
        {
          "name": "set_owned_objects",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\":set_owned_objects( LIST owned-objects list )\";",
            "\"  -- set your .owned_objects, ordered as you please\";",
            "\"  -- no, it will NOT let you set to to anything you want\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "new = args[1];",
            "old = this.owned_objects;",
            "\"make sure they're the same\";",
            "if (length(new) != length(old))",
            "return E_INVARG;",
            "endif",
            "for i in (new)",
            "old = setremove(old, i);",
            "endfor",
            "if (old)",
            "\"something's funky\";",
            "return E_INVARG;",
            "endif",
            "return this.owned_objects = new;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "if (caller_perms().wizard)",
            "pass(@args);",
            "if ($code_utils:verb_location() == this)",
            "this.rooms = {};",
            "else",
            "clear_property(this, \"rooms\");",
            "endif",
            "this.features = {$pasting_feature, $stage_talk};",
            "endif"
          ]
        },
        {
          "name": "find_help",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"'find_help (<name>[, databases])'\";",
            "\"Search for a help topic with the given name. [<databases>] defaults to the ones returned by $code_utils:help_db_list().\";",
            "{name, ?databases = $code_utils:help_db_list()} = args;",
            "if (!name)",
            "this:tell(\"What topic do you want to search for?\");",
            "elseif (result = $code_utils:help_db_search(name, databases))",
            "{object, realname} = result;",
            "if (object == $ambiguous_match)",
            "this:tell(\"The help topic \\\"\", name, \"\\\" could refer to any of the following:  \", $string_utils:english_list(realname));",
            "elseif (((object == $help) && (!$object_utils:has_property(object, realname))) && valid(o = $string_utils:match_object(name, player.location)))",
            "if ($object_utils:has_callable_verb(o, \"help_msg\"))",
            "this:tell(\"That help topic was returned by \", $string_utils:nn(o), \":help_msg().\");",
            "elseif ($object_utils:has_property(o, \"help_msg\"))",
            "this:tell(\"That help topic is located in \", $string_utils:nn(o), \".help_msg.\");",
            "else",
            "this:tell(\"That help topic was matched by $help but there doesn't seem to be any help available for it.\");",
            "endif",
            "elseif (object == $help_db[\"verb\"])",
            "if (((what = $code_utils:parse_verbref(realname)) && valid(what[1] = $string_utils:match_object(what[1], player.location))) && $object_utils:has_verb(@what))",
            "this:tell(\"That help topic is located at the beginning of the verb \", $string_utils:nn(what[1]), \":\", what[2], \".\");",
            "else",
            "this:tell(\"That help topic was matched by $help_db[\\\"verb_help\\\"] but there doesn't seem to be any help available for it.\");",
            "endif",
            "else",
            "where = {};",
            "for x in (databases)",
            "if ({realname} == x:find_topics(realname))",
            "where = setadd(where, x);",
            "endif",
            "endfor",
            "asname = (name == realname) ? \"\" | ((\" as \\\"\" + realname) + \"\\\"\");",
            "if (where)",
            "this:tell(\"That help topic is located on \", $string_utils:nn(where), asname, \".\");",
            "else",
            "\"...this shouldn't happen unless $code_utils:help_db_search finds a match we weren't expecting\";",
            "this:tell(\"That help topic appears to be located on \", $string_utils:nn(object), asname, \", although this command could not find it.\");",
            "endif",
            "endif",
            "else",
            "this:tell(\"The help topic \\\"\", name, \"\\\" could not be found.\");",
            "endif"
          ]
        },
        {
          "name": "@spurn",
          "owner": 36,
          "perms": 25,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Prevent an object or any of its descendents from going into your inventory, regardless of whose player perms sent it there.\";",
            "\"Syntax:  @spurn <object>\";",
            "\"         @spurn !<object>\";",
            "\"The second form removes an object from your list of spurned objects.\";",
            "\"Verb created by TheCat, 11/8/98\";",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "if (!argstr)",
            "this:tell(\"Spurn what?\");",
            "elseif (argstr[1] == \"!\")",
            "\"Stop spurning something.\";",
            "item = this:my_match_object(argstr[2..$]);",
            "if (item in this.spurned_objects)",
            "this.spurned_objects = $list_utils:setremove_all(this.spurned_objects, item);",
            "this:tell((\"You are no longer spurning \" + $string_utils:nn(item)) + \" or any kids of it.\");",
            "else",
            "this:tell((\"You are not spurning \" + $string_utils:nn(item)) + \".\");",
            "endif",
            "else",
            "\"Spurn something.\";",
            "item = this:my_match_object(argstr);",
            "if (!$command_utils:object_match_failed(item, argstr))",
            "if (item in this.spurned_objects)",
            "this:tell((\"You are already spurning \" + $string_utils:nn(item)) + \" plus any and all kids of it.\");",
            "else",
            "this.spurned_objects = setadd(this.spurned_objects, item);",
            "this:tell((\"You are now spurning \" + $string_utils:nn(item)) + \" plus any and all kids of it.\");",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@spurned",
          "owner": 36,
          "perms": 9,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Displays a list of spurned objects.\";",
            "\"Verb created by TheCat, 11/8/98\";",
            "if (this.spurned_objects)",
            "this:tell(\"You are spurning the following objects, including any and all descendents:  \" + $string_utils:nn(this.spurned_objects));",
            "else",
            "this:tell(\"You are not spurning any objects.\");",
            "endif"
          ]
        },
        {
          "name": "set_spurned_objects",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 88,
          "code": [
            "\"Permits programmatic setting of .spurned_objects, which is -c.\";",
            "{spurned_objects} = args;",
            "if ($perm_utils:controls(caller_perms(), this))",
            "\"Note, the final result must be a list of objects, otherwise there's no point.\";",
            "if (typeof(spurned_objects) != LIST)",
            "spurned_objects = {spurned_objects};",
            "endif",
            "this.spurned_objects = spurned_objects;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "at_room_width",
        "at_number",
        "join_msg",
        "object_port_msg",
        "victim_port_msg",
        "thing_arrive_msg",
        "othing_port_msg",
        "thing_port_msg",
        "player_arrive_msg",
        "oplayer_port_msg",
        "player_port_msg",
        "self_arrive_msg",
        "oself_port_msg",
        "self_port_msg",
        "rooms",
        "refused_origins",
        "refused_extra",
        "default_refusal_time",
        "report_refusal",
        "refused_actions",
        "refused_until",
        "page_refused",
        "page_refused_msg",
        "whisper_refused_msg",
        "mail_refused_msg",
        "spurned_objects"
      ],
      "propdefs": [
        {
          "value": 30,
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You join %n.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "teleports you.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "teleports you.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%T teleports %n in.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%T teleports %n out.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You teleport %n.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%T teleports %n in.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%T teleports %n out.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "You teleport %n.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%<teleports> in.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%<teleports> out.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 604800,
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "%N refuses your page.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%N refuses your whisper.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": "%N refuses your mail.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 92,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": 62,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            50000,
            0,
            0,
            1
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Frand's player class",
            "player class"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "You see a player who should type '@describe me as ...'.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            94403,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "89": {
      "id": 89,
      "name": "Stage-Talk Feature",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        74
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "stage `* -*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 89,
          "code": [
            "\"Say something out loud, directed at someone or something.\";",
            "\"Usage:\";",
            "\"  `target message\";",
            "\"Example:\";",
            "\"  Munchkin is talking to Kenneth, who's in the same room with him.  He types:\";",
            "\"      `kenneth What is the frequency?\";",
            "\"  The room sees:\";",
            "\"       Munchkin [to Kenneth]: What is the frequency?\";",
            "name = verb[2..$];",
            "who = player.location:match_object(name);",
            "if ($command_utils:object_match_failed(who, name))",
            "return;",
            "endif",
            "player.location:announce_all(player.name, \" [to \", who.name, \"]: \", argstr);"
          ]
        },
        {
          "name": "stage [*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 89,
          "code": [
            "\"Say something out loud, in some specific way.\";",
            "\"Usage:\";",
            "\"  [how]: message\";",
            "\"Example:\";",
            "\"  Munchkin decideds to sing some lyrics.  He types:\";",
            "\"      [sings]: I am the eggman\";",
            "\"  The room sees:\";",
            "\"      Munchkin [sings]: I am the eggman\";",
            "player.location:announce_all((((player.name + \" \") + verb) + \" \") + argstr);"
          ]
        },
        {
          "name": "stage ]*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 89,
          "code": [
            "\"Perform some physical, non-verbal, action.\";",
            "\"Usage:\";",
            "\"  ]third person action\";",
            "\"Example:\";",
            "\"  Munchkin has annoyed some would-be tough guy.  He types:\";",
            "\"      ]hides behind the reactor.\";",
            "\"  The room sees:\";",
            "\"      [Munchkin hides behind the reactor.]\";",
            "player.location:announce_all(\"[\", (((player.name + \" \") + verb[2..$]) + (argstr ? \" \" + argstr | \"\")) + \"]\");"
          ]
        },
        {
          "name": "~*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 89,
          "code": [
            "name = verb[2..$];",
            "argstr = $code_utils:argstr(verb, args, argstr);",
            "player.location:announce_all(player.name, \" [\", name, \"]: \", argstr);"
          ]
        },
        {
          "name": "stage <*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 89,
          "code": [
            "\"Point to yourself.\";",
            "\"Usage:\";",
            "\"  <message\";",
            "\"Example:\";",
            "\"  Muchkin decides he's being strange. He types:\";",
            "\"    <being strange.\";",
            "\"  The room sees:\";",
            "\"    Munchkin <- being strange.\";",
            "player.location:announce_all((((player.name + \" <- \") + verb[2..$]) + \" \") + argstr);"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "This feature contains various verbs used in stage talk, which allows players to describe their actions in terms of stage directions instead of prose."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "`",
            "[",
            "]",
            "-",
            "<"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Stage-Talk Feature"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "This feature contains various verbs used in stage talk, which allows players to describe their actions in terms of stage directions instead of prose."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            6159,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "90": {
      "id": 90,
      "name": "Pasting Feature",
      "flags": 144,
      "owner": 36,
      "location": -1,
      "parents": [
        74
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "@paste",
          "owner": 36,
          "perms": 85,
          "preps": -2,
          "object": 90,
          "code": [
            "\"Usage: @paste <prefix> <suffix>\";",
            "\"Announce a series of entered lines to the room the player is in.\";",
            "\"Before the lines are quoted, player.paste_header is run through\";",
            "\"$string_utils:pronoun_sub(), and if the result contains the player's\";",
            "\"name, it is used as a header.  Otherwise player.name centered in a\";",
            "\"line of dashes is used.\";",
            "\"A footer comes afterwards, likewise derived from player.paste_footer.\";",
            "\"<prefix> and <suffix> are placed before and after each line.\";",
            "\"\";",
            "\"This verb is, as one might guess, designed for pasting text to MOO using\";",
            "\"GnuEmacs or a windowing system.  You should remember that after you\";",
            "\"have pasted the lines in, you must type . on a line by itself, or you'll\";",
            "\"sit around waiting for $command_utils:read_lines() to finish _forever_.\";",
            "{?prefix = \"\", ?suffix = \"\"} = args;",
            "lines = $command_utils:read_lines();",
            "header = $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, \"paste_header\"), \"\") || $string_utils:center(player.name, 75, \"-\");",
            "to_tell = {header};",
            "for line in (lines)",
            "to_tell = listappend(to_tell, (prefix + line) + suffix);",
            "endfor",
            "to_tell = listappend(to_tell, $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, \"paste_footer\"), \"\") || $string_utils:center(\"finished\", 75, \"-\"));",
            "for thing in (player.location.contents)",
            "$command_utils:suspend_if_needed(0);",
            "thing:tell_lines(to_tell);",
            "endfor",
            "player:tell(\"Done @pasting.\");"
          ]
        },
        {
          "name": "|*",
          "owner": 36,
          "perms": 93,
          "preps": -2,
          "object": 90,
          "code": [
            "\"Echo a line prefaced by a vertical bar.\";",
            "\"Usage:\";",
            "\"  |message\";",
            "\"Example:\";",
            "\"  Hacker wants to echo to the room what he just saw. He enters (either by hand, or with Emacs or a windowing system):\";",
            "\"      |Haakon has disconnected.\";",
            "\"  The room sees:\";",
            "\"      Hacker | Haakon has disconnected.\";",
            "player.location:announce_all((((player.name + \" | \") + verb[2..$]) + \" \") + argstr);"
          ]
        },
        {
          "name": "@pasteto @paste-to",
          "owner": 36,
          "perms": 29,
          "preps": -1,
          "object": 90,
          "code": [
            "\"Syntax: @paste-to <player>\";",
            "\"\";",
            "\"Which will then prompt you for the lines to privately send to <player>. The lines will be surrounded by a default footer and header.\";",
            "target = $string_utils:match_player(dobjstr);",
            "$command_utils:player_match_result(target, dobjstr);",
            "if (!valid(target))",
            "return;",
            "endif",
            "prefix = \"\";",
            "suffix = \"\";",
            "lines = $command_utils:read_lines();",
            "to_tell = {$string_utils:center(\"Private message from \" + player.name, 75, \"-\")};",
            "for line in (lines)",
            "to_tell = listappend(to_tell, (prefix + line) + suffix);",
            "endfor",
            "to_tell = listappend(to_tell, $string_utils:center(\"end message\", 75, \"-\"));",
            "target:tell_lines(to_tell);",
            "player:tell(\"Done @pasting.\");"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": "The Pasting Feature is mostly useful to people with fancy clients (such as Emacs) or who connect using a windowing system that allows them to copy text they've already seen.  It's intended to give people a way to quote verbatim text at other people in the room.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "@paste",
            "|",
            "@paste-to"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Pasting Feature"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "Verbs useful to people using a windowing system to paste text at people.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            5854,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "91": {
      "id": 91,
      "name": "Vector and Matrix Utils",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "vector_add vector_sub vector_mul vector_div",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":vector_add(V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...\";",
            "\":vector_sub(V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...\";",
            "\":vector_mul(V1 [,V2 ...]) => VN such that VN[n] = V1[n] * V2[n]...\";",
            "\":vector_div(V1 [,V2 ...]) => VN such that VN[n] = V1[n] / V2[n]...\";",
            "\"Vectors do not need to be the same length, but they should be. VN's length will be the length of the longest vector in the arguments. :vector_add and :vector_sub will pad out the smaller vectors with 0's or 0.0's. :vector_mul and :vector_div will pad out the smaller vectors with 1's or 1.0's. Vectors do not need to contain homogeneous data, but the nth term of each vector must be of the same type.\";",
            "\"I can see a reason for wanting to do vector addition or subtraction, but multiplication and divareion is usually handled in other ways. I've included them here for novelty, and becuase it was easy enough to do.\";",
            "\"\";",
            "\"Vector addition is used when two or more similar vector quantities are at work and need to be resolved into a single vector. For instance, a ship travelling in a current will be acted upon by (at least) two forces: a force propelling it forward (its engine), and a force pushing it off course (the current). The sum of these two forces gives the resultant net force acting upon the ship and, since Force = Mass * Acceleration, the direction the ship is accelerating.\";",
            "\"\";",
            "\"Vector subtraction can be used to reverse the process of vector addition. In the ship problem above, let's say the actual resultant force is known, but it does not match the result of adding the propelling force and the drifting force. Friction is probably acting against the motion of the ship. Subtracting the computed resultant force from the known net force will yield the frictional force acting against the progress of the ship.\";",
            "\"\";",
            "\"Vector multiplication and division do not have RL examples, but vector multiplication of this type makes computing the dot product of two vectors simple.\";",
            "\"\";",
            "if (length(args) == 1)",
            "return args;",
            "elseif (!args)",
            "return raise(E_INVARG);",
            "endif",
            "type = verb[$ - 2..$];",
            "lresult = max = length(args[1]);",
            "results = args[1];",
            "for n in [2..length(args)]",
            "$command_utils:suspend_if_needed(0);",
            "if (type == \"add\")",
            "for m in [1..min(lcurr = length(args[n]), lresult)]",
            "results[m] = results[m] + args[n][m];",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (lcurr > lresult)",
            "results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];",
            "endif",
            "elseif (type == \"sub\")",
            "for m in [1..min(lcurr = length(args[n]), lresult)]",
            "results[m] = results[m] - args[n][m];",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (lcurr > lresult)",
            "for m in [lresult + 1..lcurr]",
            "results = {@results, -args[n][m]};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "elseif (type == \"mul\")",
            "for m in [1..min(lcurr = length(args[n]), lresult)]",
            "results[m] = results[m] * args[n][m];",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (lcurr > lresult)",
            "results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];",
            "endif",
            "else",
            "for m in [1..min(lcurr = length(args[n]), lresult)]",
            "results[m] = results[m] / args[n][m];",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (lcurr > lresult)",
            "for m in [lresult + 1..lcurr]",
            "results = {@results, (typeof(foo = args[n][m]) == INT) ? 1 / foo | (1.0 / foo)};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "endif",
            "endif",
            "endfor",
            "return results;"
          ]
        },
        {
          "name": "matrix_add matrix_sub",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":matrix_add(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...\";",
            "\":matrix_sub(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...\";",
            "\"Matrices should all be of the same size.\";",
            "\"\";",
            "\"Matrix addition and subtraction is simply the addition or subtraction of the vectors contained in the matrices. See 'help $matrix_utils:vector:add' for more help.\";",
            "type = verb[$ - 2..$];",
            "results = args[1];",
            "if (typeof(results[1][1]) == LIST)",
            "for n in [1..length(results)]",
            "results[n] = this:(verb)(results[n], @$list_utils:slice(args[2..$], n));",
            "endfor",
            "else",
            "for n in [1..length(results)]",
            "results[n] = this:(\"vector_\" + type)(results[n], @$list_utils:slice(args[2..$], n));",
            "endfor",
            "endif",
            "return results;"
          ]
        },
        {
          "name": "transpose",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":transpose(Mmn) => Mnm\";",
            "\"Transpose an m by n matrix into an n by m matrix by making the rows in the original the columns in the output.\";",
            "{mat} = args;",
            "if (!this:is_matrix(mat))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "j = this:dimensions(mat)[2];",
            "result = {};",
            "for n in [1..j]",
            "result = {@result, this:column(mat, n)};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "determinant",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":determinant(M) => NUM the determinant of the matrix.\";",
            "\"\";",
            "\"There are several properties of a matrix's determinant. Adding or subtracting a row or column from another row or colum of a matrix does not hange the value of its determinant. Multiplying a row or column of a matrix by a single scalar value has the effect of multiplying the matrix's determinant by the same scalar.\";",
            "\"\";",
            "\"However, the most dramatic use of determinants is in solving linear equations. For example, the solution to this system of equations:\";",
            "\"\";",
            "\"Ax1 + Bx2 + Cx3 = D\";",
            "\"Ex1 + Fx2 + Gx3 = H\";",
            "\"Ix1 + Jx2 + Kx3 = L\";",
            "\"\";",
            "\"is\";",
            "\"\";",
            "\"     1 |D B C|         1 |A D C|        1 |A B D|\";",
            "\"x1 = - |H F G|    x2 = - |E H G|   x3 = - |E F H|\";",
            "\"     Z |L J K|         Z |I L K|        Z |I J L|\";",
            "\"\";",
            "\"          |A B C|\";",
            "\"where Z = |E F G|\";",
            "\"          |I J K|\";",
            "\"\";",
            "\"or, in other words, x1, x2, and x3 are some determinant divided by Z, another determinant.\";",
            "\"\";",
            "\"Determinants are also used in computing the cross product of two vectors. See 'help $matrix_utils:cross_prod' for more info.\";",
            "\"\";",
            "{mat} = args;",
            "if (!this:is_square(mat))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "elseif (this:dimensions(mat) == {1, 1})",
            "return mat[1][1];",
            "elseif (this:dimensions(mat)[1] == 2)",
            "return (mat[1][1] * mat[2][2]) - (mat[1][2] * mat[2][1]);",
            "else",
            "result = (typeof(mat[1][1]) == INT) ? 0 | 0.0;",
            "coeff = (typeof(mat[1][1]) == INT) ? 1 | 1.0;",
            "for n in [1..length(mat[1])]",
            "result = result + ((coeff * mat[1][n]) * this:determinant(this:submatrix(1, n, mat)));",
            "coeff = -coeff;",
            "endfor",
            "return result;",
            "endif",
            "\"elseif dims == {1,1} lines are courtesy of Link (#122143).  21-Oct-05\";",
            "\"Originated by Uther. Modified by Link (#122143) on 16-Nov-2005.\";"
          ]
        },
        {
          "name": "inverse",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":inverse(M) => MN such that M * MN = I\";",
            "\"\";",
            "\"The inverse of a matrix is very similar to the reciprocal of a scalar number. If two numbers, A and B, equal 1 (the scalar identity number) when multiplied together (AB=1), then B is said the be the reciprocal of A, and A is the reciprocal of B. If A and B are matrices, and the result of multiplying them togeter is the Identity Matrix, then B is the inverse of A, and A is the inverse of B.\";",
            "\"\";",
            "\"Computing the inverse involves the solutions of several linear equations. Since linear equations can be easily solved with determinants, this is rather simple. See 'help $matrix_utils:determinant' for more on how determinants solve linear equations.\";",
            "\"\";",
            "{mat} = args;",
            "{i, j} = this:dimensions(mat);",
            "if (tofloat(det = this:determinant(mat)) == 0.0)",
            "return raise(\"E_NOINV\", \"No Inverse Exists\");",
            "endif",
            "result = {};",
            "for k in [1..i]",
            "sub = {};",
            "for l in [1..j]",
            "sub = {@sub, ((((typeof(mat[1][1]) == INT) ? -1 | -1.0) ^ (k + l)) * this:determinant(this:submatrix(l, k, mat))) / det};",
            "endfor",
            "result = {@result, sub};",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "identity",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":identity(INT <size>) => Identity matrix (I) of dimensions <size> by <size>.\";",
            "\"All elements of I are 0, except for the diagonal elements which are 1.\";",
            "\"\";",
            "\"The Identity Matrix has the unique property such that when another matrix is multiplied by it, the other matrix remains unchanged. This is similar to the number 1. a*1 = a. A * I = A, if the dimensions of I and A are the same.\";",
            "\"\";",
            "n = args[1];",
            "result = this:null(n, n);",
            "for i in [1..n]",
            "result[i][i] = 1;",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "null",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":null(INT <size>) => Null matrix (O) of dimensions <size> by <size>.\";",
            "\"All elements of O are 0.\";",
            "\"\";",
            "\"The Null Matrix has the property that is equivalent to the number 0; it reduces the original matrix to itself. a * 0 = 0. A * N = N.\";",
            "\"\";",
            "{m, ?n = m} = args;",
            "result = {};",
            "for i in [1..m]",
            "result = {@result, {}};",
            "for j in [1..n]",
            "result[i] = {@result[i], 0};",
            "endfor",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "is_square",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_square(M) => 1 iff dimensions of M are equal to each other.\";",
            "{m} = args;",
            "return (this:is_matrix(m) && (this:order(m) == 2)) && ((dim = this:dimensions(m))[1] == dim[2]);"
          ]
        },
        {
          "name": "is_null",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_null(M) => 1 iff M is O.\";",
            "m = length(mat = args[1]);",
            "if (!this:is_square(mat))",
            "return 0;",
            "endif",
            "for i in [1..m]",
            "for j in [1..m]",
            "if (mat[i][j] != 0)",
            "return 0;",
            "endif",
            "endfor",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "is_identity",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_identity(M) => 1 iff M is I.\";",
            "m = length(mat = args[1]);",
            "if (!this:is_square(mat))",
            "return 0;",
            "endif",
            "for i in [1..m]",
            "for j in [1..m]",
            "if ((mat[i][j] != 0) && ((i != j) ? 1 | (mat[i][j] != 1)))",
            "return 0;",
            "endif",
            "endfor",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "cross_prod outer_prod vector_prod",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":cross_prod(V1, V2) => VN, the vector perpendicular to both V1 and V2 with length equal to the area of the parallelogram spanned by V1 and V2, and direction governed by the rule of thumb.\";",
            "\"\";",
            "\"If A = a1i + a2j + a3k, represented as a list as {a1, a2, a3}\";",
            "\"and B = b1i + b2j + b3k, or {b1, b2, b3}, then\";",
            "\"\";",
            "\"        |i  j  k |\";",
            "\"A x B = |a1 a2 a3| = |a2 a3|i - |a1 a3|j + |a1 a2|k\";",
            "\"        |b1 b2 b3| = |b2 b3|    |b1 b3|    |b1 b2|\";",
            "\"\";",
            "\"or, in list terms, as the list of the coefficients of i, j, and k.\";",
            "\"\";",
            "\"Note: i, j, and k are unit vectors in the x, y, and z direction respectively.\";",
            "\"\";",
            "\"The rule of thumb: A x B = C  If you hold your right hand out so that your fingers point in the direction of A, and so that you can curl them through B as you make a hitchhiking fist, your thumb will point in the direction of C.\";",
            "\"\";",
            "\"Put another way, A x B = ABsin(THETA) (A cross B equals the magnitude of A times the magnitude of B times the sin of the angle between them) This is expressed as a vector perpendicular the the A-B plane, pointing `up' if you curl your right hand fingers from A to B, and `down' if your right hand fingers curl from B to A.\";",
            "\"\";",
            "\"The cross product has many uses in physics. Angular momentum is the cross product of a particles position vector from the point it is rotating around and it's linear momentum (L = r x p). Torque is the cross product of position and Force (t = r x F).\";",
            "\"\";",
            "{v1, v2} = args;",
            "if (((((l = length(v1)) != length(v2)) || (l != 3)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))",
            "return raise(\"E_INVVEC\", \"Invalid Vector Format\");",
            "endif",
            "mat = {{1, 1, 1}, v1, v2};",
            "coeff = 1;",
            "result = {};",
            "for n in [1..3]",
            "result = {@result, coeff * this:determinant(this:submatrix(1, n, mat))};",
            "coeff = -coeff;",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "norm length",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":norm(V) => FLOAT\";",
            "\":length(V) => FLOAT\";",
            "\"The norm is the length of a vector, the square root of the sum of the squares of its elements.\";",
            "\"\";",
            "\"In school, we all should have learned the Pythagorean Theorem of right triangles: The sum of the squares of the sides of a right triagle is equal to the square of the hypoteneuse. The Theorem holds true no matter how many dimensions are being considered. The length of a vector is equal to the square root of the sum of the squares of its components. The dot product of a vector with itself happens to be the sum of the squares of its components.\";",
            "\"\";",
            "{v} = args;",
            "return this:is_vector(v) ? sqrt(tofloat(this:dot_prod(v, v))) | E_TYPE;"
          ]
        },
        {
          "name": "submatrix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":submatrix(i, j, M1) => M2, the matrix formed from deleting the ith row and jth column from M1.\";",
            "{i, j, mat} = args;",
            "{k, l} = this:dimensions(mat);",
            "result = {};",
            "for m in [1..k]",
            "sub = {};",
            "for n in [1..l]",
            "if ((m != i) && (n != j))",
            "sub = {@sub, mat[m][n]};",
            "endif",
            "endfor",
            "if (sub)",
            "result = {@result, sub};",
            "endif",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "dot_prod inner_prod scalar_prod",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":dot_prod(V1, V2) => NUM\";",
            "\":inner_prod(V1, V2) => NUM\";",
            "\"The dot, or inner, product of two vectors is the sum of the products of the corresponding elements of the vectors.\";",
            "\"If V1 = {1, 2, 3} and V2 = {4, 5, 6}, then V1.V2 = 1*4 + 2*5 + 3*6 = 32\";",
            "\"\";",
            "\"The dot product is useful in computing the angle between two vectors, and the length of a vector. See 'help $matrix_utils:subtended_angle' and 'help $matrix_utils:length'.\";",
            "\"\";",
            "\"A . B = ABcos(THETA)  (A dot B equals the magnitude of A times the magnitude of B times the cosine of the angle between them.)\";",
            "\"\";",
            "{v1, v2} = args;",
            "if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))",
            "return raise(\"E_INVVEC\", \"Invalid Vector Format\");",
            "endif",
            "temp = this:vector_mul(v1, v2);",
            "result = (typeof(temp[1]) == INT) ? 0 | 0.0;",
            "for n in [1..l]",
            "$command_utils:suspend_if_needed(0);",
            "result = result + temp[n];",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "dimension*s",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":dimensions(M) => LIST of dimensional sizes.\";",
            "l = {length(m = args[1])};",
            "if (typeof(m[1]) == LIST)",
            "l = {@l, @this:dimensions(m[1])};",
            "endif",
            "return l;"
          ]
        },
        {
          "name": "order",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":order(M) => INT how many dimensions does this matrix have? 1 means vector\";",
            "return length(this:dimensions(args[1]));"
          ]
        },
        {
          "name": "scalar_vector_add scalar_vector_sub scalar_vector_mul scalar_vector_div",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":scalar_vector_add(S, V) => VN such that VN[n] = V[n] + S...\";",
            "\":scalar_vector_sub(S, V) => VN such that VN[n] = V[n] - S...\";",
            "\":scalar_vector_mul(S, V) => VN such that VN[n] = V[n] * S...\";",
            "\":scalar_vector_div(S, V) => VN such that VN[n] = V[n] / S...\";",
            "\"Actually, arguments can be (S, V) or (V, S). Each element of V is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in V.\";",
            "\"\";",
            "\"I can see a reason for wanting to do scalar/vector multiplcation or division, but addition and subtraction between vector and scalar types is not done. I've included them here for novelty, and because it was easy enough to to.\";",
            "\"\";",
            "\"Scalar-vector multiplication stretches a vector along its direction, generating points along a line. One of the more famous uses from physics is Force equals mass times acceleration. F = ma. Force and acceleration are both vectors. Mass is a scalar quantity.\";",
            "\"\";",
            "if (typeof(args[1]) == LIST)",
            "{vval, sval} = args;",
            "else",
            "{sval, vval} = args;",
            "endif",
            "if (!this:is_vector(vval))",
            "return raise(\"E_INVVEC\", \"Invalid Vector Format\");",
            "endif",
            "type = verb[$ - 2..$];",
            "for n in [1..length(vval)]",
            "if (type == \"add\")",
            "vval[n] = vval[n] + sval;",
            "elseif (type == \"sub\")",
            "vval[n] = vval[n] - sval;",
            "elseif (type == \"mul\")",
            "vval[n] = vval[n] * sval;",
            "else",
            "vval[n] = vval[n] / sval;",
            "endif",
            "endfor",
            "return vval;"
          ]
        },
        {
          "name": "subtended_angle",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":subtended_angle(V1, V2) => FLOAT smallest angle defined by V1, V2 in radians\";",
            "\"\";",
            "\"Any two vectors define two angles, one less than or equal to 180 degrees, the other 180 degrees or more. The larger can be determined from the smaller, since their sum must be 360 degrees.\";",
            "\"\";",
            "\"The dot product of the two angles, divided by the lengths of each of the vectors is the cosine of the smaller angle defined by the two vectors.\";",
            "\"\";",
            "{v1, v2} = args;",
            "if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))",
            "return raise(\"E_INVVEC\", \"Invalid Vector Format\");",
            "endif",
            "return acos(tofloat(this:dot_prod(v1, v2)) / (this:norm(v1) * this:norm(v2)));"
          ]
        },
        {
          "name": "column",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":column(M, INT <n>) => LIST the nth column of M.\";",
            "{mat, i} = args;",
            "j = this:dimensions(mat)[1];",
            "result = {};",
            "for m in [1..j]",
            "result = {@result, mat[m][i]};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "matrix_mul",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":matrix_mul(M1, M2) => MN such that MN[m][n] = the dot product of the mth row of M1 and the transpose of thenth column of M2.\";",
            "\"\";",
            "\"Matrix multiplication is the most common and complex operation performed on two matrices. First, matrices can only be multiplied if they are of compatible sizes. An i by j matrix can only be multiplied by a j by k matrix, and the results of this multiplication will be a matrix of size i by k. Each element in the resulting matrix is the dot product of a row from the first matrix and a column from the second matrix. (See 'help $matrix_utils:dot_prod'.)\";",
            "\"\";",
            "{m1, m2} = args;",
            "{i, j} = this:dimensions(m1);",
            "{k, l} = this:dimensions(m2);",
            "if (((j != k) || (!this:is_matrix(m1))) || (!this:is_matrix(m2)))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "result = {};",
            "for m in [1..i]",
            "sub = {};",
            "for n in [1..l]",
            "$command_utils:suspend_if_needed(0);",
            "sub = {@sub, this:dot_prod(m1[m], this:column(m2, n))};",
            "endfor",
            "result = {@result, sub};",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "scalar_matrix_mul scalar_matrix_div",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":scalar_matrix_add(S, M) => MN such that MN[m][n] = MN[m][n] + S...\";",
            "\":scalar_matrix_sub(S, M) => MN such that MN[m][n] = MN[m][n] - S...\";",
            "\":scalar_matrix_mul(S, M) => MN such that MN[m][n] = MN[m][n] * S...\";",
            "\":scalar_matrix_div(S, M) => MN such that MN[m][n] = MN[m][n] / S...\";",
            "\"Actually, arguments can be (S, M) or (M, S). Each element of M is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in M.\";",
            "\"I can see a reason for wanting to do scalar/matrix multiplication or division, but addition and subtraction between matrix and scalar types is not done. I've included them here for novelty, and because it was easy enough to do.\";",
            "type = verb[$ - 2..$];",
            "if (typeof(args[1]) == LIST)",
            "{mval, sval} = args;",
            "else",
            "{sval, mval} = args;",
            "endif",
            "if (!this:is_matrix(mval))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "results = {};",
            "if (typeof(mval[1][1] == LIST))",
            "for n in [1..length(mval)]",
            "results = {@results, this:(verb)(mval[n], sval)};",
            "endfor",
            "else",
            "for n in [1..length(mval)]",
            "results = {@results, this:(\"scalar_vector_\" + type)(mval[n], sval)};",
            "endfor",
            "endif",
            "return results;"
          ]
        },
        {
          "name": "is_matrix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\"A matrix is defined as a list of vectors, each having the smae number of elements.\";",
            "{m} = args;",
            "if ((typeof(m) != LIST) || (typeof(m[1]) != LIST))",
            "return 0;",
            "endif",
            "len = length(m[1]);",
            "for v in (m)",
            "if ((!this:is_vector(v)) || (length(v) != len))",
            "return 0;",
            "endif",
            "endfor",
            "return 1;"
          ]
        },
        {
          "name": "is_vector",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\"A vector shall be defined as a list of INTs or FLOATs. (I'm not gonna worry about them all being the same type.)\";",
            "flag = 1;",
            "{v} = args;",
            "if (typeof(v) != LIST)",
            "return 0;",
            "endif",
            "for n in (v)",
            "if (((ntype = typeof(n)) != INT) && (ntype != FLOAT))",
            "flag = 0;",
            "break;",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return flag;"
          ]
        },
        {
          "name": "is_reflexive is_areflexive",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,\";",
            "\"                       0 otherwise.\";",
            "\":is_areflexive does the same, but with 1 and -1 reversed.\";",
            "{m} = args;",
            "if (!this:is_square(m))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "good = bad = 0;",
            "for n in [1..length(m)]",
            "if (!m[n][n])",
            "bad = 1;",
            "else",
            "good = 1;",
            "endif",
            "endfor",
            "return this:_relation_result(good, bad, verb[4] == \"a\");"
          ]
        },
        {
          "name": "is_symmetric is_asymmetric",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,\";",
            "\"                       0 otherwise.\";",
            "\":is_asymmetric does the same, but with 1 and -1 reversed.\";",
            "{mat} = args;",
            "if (!this:is_square(mat))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "good = bad = 0;",
            "for m in [1..len = length(mat)]",
            "for n in [m + 1..len]",
            "if (mat[m][n] == mat[n][m])",
            "good = 1;",
            "else",
            "bad = 1;",
            "endif",
            "endfor",
            "endfor",
            "return this:_relation_result(good, bad, verb[4] == \"a\");"
          ]
        },
        {
          "name": "is_transitive is_atransitive",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,\";",
            "\"                       0 otherwise.\";",
            "\":is_atransitive does the same, but with 1 and -1 reversed.\";",
            "{mat} = args;",
            "if (!this:is_square(mat))",
            "return raise(\"E_INVMAT\", \"Invalid Matrix Format\");",
            "endif",
            "good = bad = 0;",
            "for m in [1..len = length(mat)]",
            "for n in [1..len]",
            "if (mat[m][n])",
            "for l in [1..len]",
            "if (mat[n][l])",
            "if (mat[m][l])",
            "good = 1;",
            "else",
            "bad = 1;",
            "endif",
            "endif",
            "endfor",
            "endif",
            "endfor",
            "endfor",
            "return this:_relation_result(good, bad, verb[4] == \"a\");"
          ]
        },
        {
          "name": "_relation_result",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\"Common code for is_reflexive, is_symmetric, and is_transitive.\";",
            "{good, bad, flag} = args;",
            "if (good && (!bad))",
            "result = 1;",
            "elseif ((!good) && bad)",
            "result = -1;",
            "else",
            "result = 0;",
            "endif",
            "return flag * result;"
          ]
        },
        {
          "name": "is_partial_ordering",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 91,
          "code": [
            "\":is_partial_ordering(M) => 1 iff M is a reflexive, asymmetric, transitive relation.\";",
            "{mat} = args;",
            "return ((this:is_asymmetric(mat) == this:is_reflexive(mat)) == this:is_transitive(mat)) == 1;"
          ]
        }
      ],
      "propnames": [
        "note"
      ],
      "propdefs": [
        {
          "value": "Please contact Uther@LambdaMOO if you make changes to this object, so he can make the changes on Lambda and elsewhere.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Utility verbs for manipulating lists as vectors (one dimensional lists) or as matrices (two dimensional lists).",
            "",
            "Some definitions:",
            "A VECTOR is a list of INTs or a list of FLOATs. Each element in the list represents the vector's cartesian coordinate as measured from its tail to its tip. (For instance, {3, 4} represents a vector in the x-y plane with an x component of 3 and a y component of 4. {-2, 5, 10} represents a vector in 3-space with a x component of -2, a y component of 5 and a z component of 10.)",
            "A MATRIX is a list of VECTORs, all of which have the same number (and type) of components.",
            "",
            "Vector verbs:",
            ":vector_add        (V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...",
            ":vector_sub        (V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...",
            ":scalar_vector_mul (V, S)         => VN such that VN[n] = V[n] * S...",
            ":scalar_vector_div (V, S)         => VN such that VN[n] = V[n] / S...",
            ":dot_prod          (V1, V2)       => NUM sum of the products of the ",
            ":inner_prod                          corresponding elements of the two",
            "                                     vectors.",
            ":cross_prod        (V1, V2)       => VN, the vector perpendicular to both V1",
            ":outer_prod                          and V2 with length equal to the area of",
            "                                     the parallelogram spanned by V1 and V2.",
            ":subtended_angle   (V1, V2)       => FLOAT smallest radian angle defined by",
            "                                     V1 and V2.",
            ":length            (V)            => FLOAT length of the vector. ",
            ":norm",
            "",
            "Matrix and Vector verbs:",
            ":dimensions (M) => LIST of dimensional sizes",
            ":order      (M) => NUM of dimensions",
            "",
            "Matrix verbs:",
            ":matrix_add (M1 [,M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...",
            ":matrix_sub (M1 [,M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...",
            ":matrix_mul (M1, M2)       => MN such than MN[m][n] = the dot product of the  ",
            "                              mth row of M1 and the nth column of M2.",
            ":scalar_matrix_mul (M, S)  => MN such that MN[m][n] = M[m][n] * S...",
            ":scalar_matrix_div (M, S)  => MN such that MN[m][n] = M[m][n] / S...",
            ":transpose  (M1)           => M2 such that the rows in M1 are the columns in",
            "                              M2 and vice versa.",
            ":identity   (INT <size>)   => Identity matrix (I) of dimensions <size> by ",
            "                              <size>.",
            ":null       (INT <size>)   => Null matrix (O) of dimensions <size> by <size>.",
            ":is_square  (M)            => 1 iff dimensions of M are equal.",
            ":column     (M, INT <n>)   => LIST the nth column of M.",
            "",
            "Square Matrix verbs:",
            ":determinant (M) => NUM the determinant of the square matrix.",
            ":inverse     (M) => the matrix that M multiplied by :inverse(M) yields I.",
            ":is_identity (M) => 1 iff M is I.",
            ":is_null     (M) => 1 iff M is O.",
            "",
            "Relation verbs:",
            ":is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,",
            "                       0 otherwise.",
            ":is_areflexive  (M) => 1 if M is an areflexive relation, -1 if reflexive,",
            "                       0 otherwise.",
            ":is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,",
            "                       0 otherwise.",
            ":is_asymmetric  (M) => 1 if M is an asymmetric relation, -1 if symmetric,",
            "                       0 otherwise.",
            ":is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,",
            "                       0 otherwise.",
            ":is_atransitive (M) => 1 if M is an atransitive relation, -1 if transitive,",
            "                       0 otherwise.",
            ":is_partial_ordering (M) => 1 if M is a reflexive, asymmetric, transitive",
            "                            relation."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Vector and Matrix Utils",
            "vector",
            "matrix"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is a utilities package for dealing with lists as representations of vectors and matrices. Type `help $matrix_utils' for more details.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            39396,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "92": {
      "id": 92,
      "name": "Frand Help DB",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "frand-index",
        "spelling",
        "@spell",
        "@cspell",
        "@spellproperties",
        "@spellmessages",
        "@rmword",
        "@addword",
        "@find",
        "@rooms",
        "@addroom",
        "@rmroom",
        "@join",
        "@go",
        "@move",
        "teleport-messages",
        "@refuse",
        "@unrefuse",
        "@refusal-reporting",
        "@refusals",
        "refusal-programming",
        "@ways",
        "@at",
        "@spurn",
        "@spurned",
        "@submitted",
        "@addsubmitted",
        "@rmsubmitted"
      ],
      "propdefs": [
        {
          "value": [
            "*index*",
            "Frand's Player Class Help Topics"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "The MOO has a built in spelling checker.  There are several player commands which access the database, as well as some programming features available.  Additional documentation is available under individual commands.",
            "",
            "The spelling checker is backed by the Aspell interface.  Additionally, players have a personal dictionary that can be used to augment the main dictionary.",
            "",
            "@spell a word or phrase - Spell check a word or phrase.",
            "@spell thing.prop - Spell check a property. The value must be a string or a list of strings.",
            "@spell thing:verb - Spell check a verb. Only the quoted strings in the verb are checked.",
            "@spellproperties object - Spell check all text properties of an object.",
            "@spellmessages object - Spell check only message properties of an object.",
            "@cspell word - Spell check a word, and if it is not in the dictionary, offers suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.",
            "@addword word - Add a word to your personal dictionary.",
            "@rmword word - Remove a word from your personal dictionary.",
            "",
            "Questions and comments should be directed to waffle on LambdaMOO."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @spell <any number of words>",
            "           - will check the words from the command line.",
            "        @spell object.property",
            "           - will spellcheck the contents of a prop. Must be a string or",
            "             list of strings.",
            "        @spell object:verb",
            "           - will check everything within quoted strings in a verb. E.g.,",
            "             only the quoted part of player:tell(\"Spellchecking is fun.\");",
            "             will be examined for errors.",
            "",
            "Refer to Help Spelling for general information about the spell checker."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @cspell <any number of words>",
            "        @cspell object.property",
            "        @cspell object:verb",
            "",
            "Like @spell, but attempts to guess at correct spellings for words it believes are spelled incorrectly.   This verb can be quite slow, so correcting large chunks of text may not be a good idea.",
            "",
            "Refer to help spelling and help @spell for more information."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@spellmessages"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @spellproperties <object>",
            "        @spellmessages <object>",
            "These commands will spellcheck all properties or messages, respectively, on an object.  The object must be owned or readable by the user.  Messages and properties will be spellchecked if they contain a string or a list of strings; others will be ignored.",
            "",
            "Refer to help spelling for general information about the spellchecker."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Usage: @rmword <word or words>",
            "",
            "Will remove all words found from your personal dictionary, stored in player property \".dict\"."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax: @addword <word or words>",
            "        @addword object.property",
            "        @addword object:verb",
            "",
            "Will add all words found and unknown into your personal dictionary.",
            "Your dictionary is stored in a property named \".dict\"."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "  @find #<object>   - locate an object by number",
            "  @find <player>    - locate a player",
            "  @find :<verb>     - locate a verb on an object in your vicinity",
            "  @find .<property> - locate a property on objects in your vicinity.",
            "  @find ?<topic>    - locate a help topic on a help database.",
            "",
            "For example, '@find frand' shows Frand's number and location. '@find :jump' lists every object in the same room as you (including you and the room itself) which has a 'jump' verb.  For properties and verbs, output is a list of pairs of objects: each object on which the property or verb exists, and the ancestor that actually defines it."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "When you aren't in the same room with an object, you have to refer to it by number. When teleporting, that means you usually have to give your destination as a number. To avoid this, Frand's player class provides a way for you to store a database of rooms by name. If the library is in your list of rooms, you can just '@go library' to teleport there. Or '@move book to lib' to teleport an object there.",
            "",
            "  @rooms                     - see a list of the rooms you know by name",
            "  @addr*oom <name> <number>  - remember a room by name",
            "  @rmr*oom  <name>           - forget about a room's name",
            "",
            "For example, to add the kitchen to your database of rooms, type '@addr Kitchen #24'. To remove it, type '@rmr kitchen'."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@rooms"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@rooms"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@move"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@move"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "  @move <obj> to <location>  - teleport an object to a given location",
            "  @go <location>             - teleport yourself to a given location",
            "  @join <player>             - teleport yourself to a player's location",
            "",
            "You can teleport an object (if it allows this) to any location that will accept it. For example, `@move rock to #11' will teleport the rock to the closet. `@move #123 to here' will move object #123 to your location. `@go home' will teleport you home. `@join yduj' will teleport you to yduJ's location. You can also teleport an object to #-1, which is nowhere.",
            "",
            "See help teleport-messages for information on customizing the text that appears",
            "(both to you and to others in the vicinity) when you teleport.",
            "See also help @rooms for information on naming rooms for convenient movement.",
            "If @move doesn't work and you own the place where the object is located, try using @eject instead."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Teleporting using @go, @move, or @join causes various messages to appear. The messages are defined on you as properties. Here are the messages, who sees them, and when.",
            "",
            " when you teleport -  yourself      a player        a thing",
            "",
            "           you see -  self_port     player_port     thing_port",
            "        others see -  oself_port    oplayer_port    othing_port",
            "  destination sees -  self_arrive   player_arrive   thing_arrive",
            "   teleportee sees -                victim_port     object_port",
            "",
            "When you @join a player, your join message is printed to you.",
            "",
            "You can set the messages with commands like '@oself_port me is \"vanishes in a shimmering haze.\"', '@join me is \"You visit %n.\"', and so on.",
            "",
            "The messages to you are printed as they stand. The messages to others are printed after your name. If you set a message to \"\", the null string, nothing will print for that message. But if you have a non-empty message which does not include your name, then your name will be added in front of the message. You can use the usual pronoun substitutions, like '%n' to refer to the object you are teleporting. You can also use the special substitutions %<from room> and %<to room> to refer to the original and destination rooms for the teleport.",
            "",
            "If you are leaving your name out of the messages, and relying on its being inserted automatically, you have to be careful about the substitutions you use. If Frand has an oself_port message \"jumps to %<to room>.\", for example, and Frand teleports to Frand's MOOhome, the message printed will be \"jumps to Frand's MOOhome.\" My name is there, so it isn't added in. If you want to include your name as a substitution, the one to use is %t, 'this'. \"%t jumps to %<to room>.\" will work."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "The refusal facility allows you to ignore specific actions by players. You can ignore all mail that Stupid_Jerk (#34567) sends you, for",
            "example, or you can ignore all whispers and pages, no matter who they are from.",
            "",
            "There are three basic refusal commands. They are explained below.",
            "",
            "    @refuse <action> from <player>",
            "    @unrefuse <action> from <player>",
            "    @refusals",
            "",
            "The actions you can refuse are page, whisper, mail, move, join, and accept. These are explained in a table farther down.",
            "",
            "For example, '@refuse mail from Stupid_Jerk'. Any future mail that Stupid_Jerk sends you will be dropped on the floor, and Stupid_Jerk will",
            "be told that you refused to receive it. The refusal stays active for a week; after the week is over, Stupid_Jerk's mail will again get",
            "through. (If you want the refusal to last a longer or shorter time, keep on reading.)",
            "",
            "You can refuse more than one action at a time. '@refuse page whisper from Stupid_Jerk' refuses both pages and whispers.",
            "",
            "You can also refuse actions from everybody.",
            "",
            "    @refuse <actions>",
            "",
            "For example, '@refuse page' refuses every page. These refusals are listed as refusals of 'everybody' when you use the @refusals command,",
            "below.",
            "",
            "See `help @unrefuse' and `help @refusal-reporting' for information on undoing refusals and finding out what you're refusing.",
            "",
            " - the actions",
            "",
            "The actions everybody can refuse are page, whisper, mail, move, and join.",
            "refuse other things as well, depending on your player class.",
            "",
            " refuse this      to prevent somebody from doing this",
            " -----------      -----------------------------------",
            "    page        - tell you a message with the 'page' command",
            "    whisper     - tell you a message with the 'whisper' or 'murmur' command",
            "    mail        - send you a MOOmail message via @send",
            "    move        - teleport you",
            "    join        - enter the same room as you (only works in a some rooms)",
            "    accept      - hand you an object (or teleport it to you)",
            "    flames      - posts are suppressed on mail lists",
            "    politics    - set yourself `apolitical' [see `help apolitical']",
            "    all         - all of the above",
            "",
            "Refusing move is a little tricky. The player will not be able to teleport you, but you will not be able to pass through any special exits",
            "that the player may have programmed either. Refusing move means refusing *all* movement, including movement through programmed exits.",
            "Fortunately most exits are plain exits, and you will always be able to pass through them. Only specially programmed exits by the player you",
            "are refusing move from are barred to you.",
            "",
            "Refusing join only works in special rooms that support it.",
            "",
            " - time limits",
            "",
            "Refusals expire after a certain amount of time has gone by. Unless you say otherwise, they expire after a week. You can add '... for",
            "<time>' to the end of a @refuse command:",
            "",
            "    @refuse <action> from <player> for <time>",
            "    @refuse <action> for <time>",
            "",
            "For example, '@refuse join from Stupid_Jerk for 3 days'.",
            "",
            "The <time> is always a number followed by a unit, like '10 weeks' or '45 seconds'. The possible units are second, minute, hour, day, week,",
            "and month."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "Syntax:",
            "    @unrefuse <actions> from <player>",
            "",
            "If Stupid_Jerk reforms, you can change your mind. '@unrefuse mail from Stupid_Jerk' will remove the refusal.",
            "",
            "'@unrefuse' can also be called '@allow', for those who prefer English over clarity.",
            "",
            "    @unrefuse <actions>",
            "",
            "If you don't mention a player, you remove only refusals that apply to everybody. '@unrefuse page' turns off any '@refuse page' command you",
            "gave before, but does not affect refusals of specific players. You will still be refusing pages from Stupid_Jerk, if you were before.",
            "",
            "    @unrefuse everything",
            "",
            " If you '@unrefuse everything', all your refusals are removed. This command asks if you are sure before erasing them all."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "[See help @refuse for a discussion of the refusal facility]",
            "",
            "    @refusals",
            "    @refusals for <player>",
            "",
            "List the players and actions you are refusing, or the players and actions that another player is refusing. For example, you can see if",
            "Stupid_Jerk is refusing your mail too: '@refusals for Stupid_Jerk'.",
            "",
            "Normally refusal works without your awareness. You don't even notice when Stupid_Jerk attempts to send you mail. If you would rather be",
            "notified when it happens (so you can thumb your nose), then do",
            "",
            "    @refusal-reporting on",
            "",
            "Actually, all you need to type is '@refusal-r on'. You will see a message like 'Mail from Stupid_Jerk (#34567) refused.' as soon as",
            "Stupid_Jerk types 'send' in the mail editor.",
            "",
            "Refusal reporting only works for some actions. It works for page, whisper, and mail, but not for move, join or accept. Sorry.",
            "",
            "You will only be notified if you are connected when the refusal happens. If you are not connected when Stupid_Jerk tries to send you mail,",
            "you won't know about it, no matter whether refusal reporting is on or off.",
            "",
            "You can turn off refusal reporting with '@refusal-r off'. You can check whether it is on or off with '@refusal-r'. Here's the list:",
            "",
            "    @refusal-reporting on     - turn on refusal reporting",
            "    @refusal-reporting off    - turn off refusal reporting",
            "    @refusal-reporting        - see whether it is on or off"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*forward*",
            "@refusal-reporting"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "",
            "  -- -- --  refusal programming",
            "",
            "This entry explains how to program new kinds of refusal for the refusal mechanism. This information is only useful for programmers. For basic information about the refusal mechanism, read the 'refusal' entry.",
            "",
            " - making a new refusable action",
            "",
            "Making a refusable action has several steps. You have to (1) override the verb that lists your refusable actions, (2) write a verb to handle any special cases in determining when an action should be refused, and (3) write the code that does the actual acceptance or refusal of the action.",
            "",
            "You can put new refusable actions on yourself, or on a player class. If you put them on yourself, then you are the only one who can use them. If you put them on a player class, then everyone who belongs to that class can use them.",
            "",
            "I'll walk you through the example of making a refusable action 'smirk'. If you '@refuse smirk from Munchkin' then anything Munchkin tells you with the word 'smirk' in it will be refused. Since this is useless, I'll assume that you're defining it on yourself, instead of on a player class.",
            "",
            "(1) You have to make 'smirk' a refusable action. You do that by overriding your :refusable_actions verb. :Refusable_actions is a verb which returns the actions that you know how to refuse. It is a verb instead of a property so that players can add refusable actions at all levels of the player class hierarchy without interfering with each other.",
            "",
            "    @verb me:refusable_actions this none this",
            "    @program me:refusable_actions",
            "      return {@pass(@args), \"smirk\"};",
            "    .",
            "",
            "'@pass (@args)' means 'include the actions that my parent knows how to refuse, because I know how to refuse them too.'",
            "",
            "(2) The refusal mechanism provides for special cases in deciding whether an action should be refused. None of the refusals defined on Frand's Player Class actually make use of this special case, and you probably won't have to use it either. But you still have to write a verb to deal with it.",
            "",
            "The verb should be named :refuses_action_<action>, where <action> is the action that the verb is for. In this case, it should be :refuses_action_smirk. The verb takes some arguments and returns whether the action should be refused. The details of this will someday be explained in the next section, 'fancy refusable actions', but in all simple cases the verb should simply return 1.",
            "",
            "    @verb me:refuses_action_smirk this none this",
            "    @program me:refuses_action_smirk",
            "      return 1;",
            "    .",
            "",
            "(3) Finally you must implement the refusal itself. The code that performs the action should call <target>:refuses_action (player, <action>). <target> is the target of the action; it is you, because others are smirking at you. 'Player' is the current player, the one who is attempting to perform the action. <action> is the action the player is attempting, 'smirk'.",
            "",
            "In this case, you want to change your :tell verb to check whether its message contains the word 'smirk', and whether you are refusing smirks from the player who's talking. It also has to do two other things: (1) inform the player whose smirk was refused, and (2) call this:report_refusal, which tests whether you have refusal reporting turned on, and if so, reports the refusal to you. The call is this:report_refusal (<player>, <message>).",
            "",
            "    @verb me:tell this none this",
            "    @program me:tell",
            "      line = tostr (@args);",
            "      if (index (line, \"smirk\") &&",
            "          this:refuses_action (player, \"smirk\"))",
            "        player:tell (this.name, \" refuses your s m i r k.\");",
            "        this:report_refusal (player, \"You refused a s m i r k.\");",
            "      else",
            "        pass (@args);",
            "      endif",
            "    .",
            "",
            "The messages say 's m i r k' instead of 'smirk' to prevent an infinite :tell loop.",
            "",
            "It may help to study some examples. To see how whisper refusal works, read #3133:whisper. For page refusal, see #3133:receive_page and #3133:page_echo_msg. For mail refusal, #3133:receive_message. For move and accept refusal, #3133:moveto or #3133:accept (they are the same verb).",
            "",
            " - refusal data structures",
            "",
            "Refusal information is stored in four main properties, all lists.",
            "",
            "    .refused_origins    - who you are refusing actions from",
            "    .refused_actions    - for each, what actions you're refusing",
            "    .refused_until      - when the refusals expire",
            "    .refused_extra      - any further information about each refused action",
            "",
            "These properties are all readable and owned by Frand. You (or anyone) can see their values, but you can only change them by calling verbs for the purpose. The verbs are explained later on.",
            "",
            "Your .refused_origins property remembers who you are refusing actions from. It might have the value {#47, #34567} if you are refusing actions from Frand (#47) and Stupid_Jerk (#34567). If you are refusing actions by guests, it will have entries like \"xxP1Xw.nkQzft\". This weird string is a code word that stands for the guest's connection site; you are refusing actions not by a certain guest character, but by any guest who may connect from that site. The verb :player_to_refusal_origin (<player>) converts a player object to a refusal origin (either the same player object or a guest's site code) suitable to be stored in .refused_origins.",
            "",
            "Your .refused_actions property stores, for each origin in .refused_origins, a list of the actions you are refusing for that origin. Continuing the example from the last paragraph, if you are refusing page from Frand and page, whisper, and mail from Stupid_Jerk, then your .refused_actions has the value {{\"page\"}, {\"page\", \"whisper\", \"mail\"}}.",
            "",
            "Your .refused_until stores an expiration time for each refusal origin, in the form used by time(), the number of seconds since midnight, 1 January 1970, GMT. All actions that you are refusing from a given player expire at the same time. If you are refusing Frand until 19 December 1992, and Stupid_Jerk for seven years, your .refused_until might have the value {724763397, 928384392}.",
            "",
            "Your .refused_extra property stores any additional information needed for fancy refusals. It stores one piece of information for every action you are refusing from every player. In other words, .refused_extra contains a list of lists which are parallel to the lists in .refused_actions. None of the built-in refusals on #3133 is fancy, so for them, the extra piece of information is always 0. In the example, your .refused_extra has the value {{0}, {0, 0, 0}}. The next section explains how to use .refused_extra in fancy refusals.",
            "",
            "Another property, .default_refusal_time, stores the duration in seconds that a refusal lasts by default. This property is readable and owned by Frand. Its value is usually 604800, seven days. You can set it via the verb :set_default_refusal_time.",
            "",
            " - fancy refusable actions",
            "",
            "THIS SECTION IS NOT YET WRITTEN",
            "",
            " - selective refusal reporting",
            "",
            "If you have done '@refusal-reporting on', then you see a message when you refuse somebody else's action (for some actions). This reporting is done by the verb :report_refusal.",
            "",
            "    :report_refusal (<player>, <message>, ...)",
            "",
            "The first argument is the player whose action is refused, and the rest are concatenated to form the message that you see.",
            "",
            "You can override this verb if you want more selective refusal reporting. If you're refusing pages, for example, you might find that the refusal report is just as annoying as the original page--but you still don't want to turn it off. In that case, you might decide to give no more than one refusal report per minute, using code like this:",
            "",
            "    @property me.refusal_time 0",
            "    @property me.refusal_count 0",
            "    @verb me:report_refusal this none this",
            "    @program me:report_refusal",
            "      if (time() - this.refusal_time < 60)",
            "        this.refusal_count = this.refusal_count + 1;",
            "      else",
            "        if (this.refusal_count > 0)",
            "           pass (args [1], \"You've refused \", this.refusal_count+1,",
            "                 \" actions recently.\");",
            "        else",
            "          pass (@args);",
            "        endif",
            "        this.refusal_time = time();",
            "        this.refusal_count = 0;",
            "      endif",
            "    .",
            "",
            "The property that remembers whether refusal reporting is turned on is .report_refusal, which may have the values 0 or 1. The property is owned by Frand, so you can't change it directly.",
            "",
            " - refusal synonyms",
            "",
            "You can give a refusal more than one name by overriding the verb :translate_refusal_synonym. The verb takes one argument, a word from the command line, and it returns a list of refusal names that the word stands for. If the word is not a synonym, :translate_refusal_synonym should return the empty list, {}.",
            "",
            "    :translate_refusal_synonym (<word>) -> <list>",
            "",
            "If you want 'noise' to mean both page and whisper for you, then you'd write this. You need to pass(@args) to get the synonym 'all', which stands for all refusable actions. If you type '@refuse noises from Munchkin', the plural 's' is removed automatically, so you don't have to worry about that.",
            "",
            "    @verb me:translate_refusal_synonym this none this",
            "    @program me:translate_refusal_synonym",
            "      return pass(@args) ||",
            "             (args [1] == \"noise\") ? {\"page\", \"whisper\"} | {};",
            "    .",
            "",
            " - refusing actions by classes of players",
            "",
            "THIS SECTION IS NOT YET WRITTEN"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given)."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            " '@at' - Find out where everyone is.",
            " '@at <player>' - Find out where <player> is, and who else is there.",
            " '@at <obj>' - Find out who else is at the same place as <obj>.",
            " '@at <place>' - Find out who is at the place.",
            " The place can be given by number, or it can be a name from your @rooms list.",
            " '@at #-1' - Find out who is at #-1.",
            " '@at me' - Find out who is in the room with you.",
            " '@at home' - Find out who is at your home."
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "*verbdoc*",
            "$frand_class",
            "@spurn"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$frand_class",
            "@spurned"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$frand_class",
            "@submitted"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@submitted"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "@submitted"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            "frand-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Frand Help DB"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            30023,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "93": {
      "id": 93,
      "name": "Conversion Utils",
      "flags": 16,
      "owner": 36,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "dd_to_dms dh_to_hms",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":dd_to_dms(INT|FLOAT <degrees>) => LIST {INT <degrees>, INT <minutes>, FLOAT <seconds>}\";",
            "\"This verb converts decimal degrees to degrees, minutes, and seconds.\";",
            "dd = tofloat(args[1]);",
            "s = (((dd - tofloat(d = toint(dd))) * 60.0) - tofloat(m = toint((dd - tofloat(d)) * 60.0))) * 60.0;",
            "return {d, m, s};"
          ]
        },
        {
          "name": "dms_to_dd hms_to_dh",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":dms_to_dd(INT|FLOAT <deg>, INT|FLOAT <min>, INT|FLOAT <sec>) => FLOAT <deg>\";",
            "\"This verb converts degrees/minutes/seconds to decimal degrees.\";",
            "{d, m, s} = args[1..3];",
            "d = tofloat(d);",
            "m = tofloat(m);",
            "s = tofloat(s);",
            "return (d + (m / 60.0)) + (s / 3600.0);"
          ]
        },
        {
          "name": "rect_to_polar",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":rect_to_polar(INT|FLOAT <x>, INT|FLOAT <y>) => FLOAT <radius>, FLOAT <angle>.\";",
            "\"This verb converts from rectangular (x,y) coordinates to polar (r, theta) coordinates.\";",
            "{x, y} = args[1..2];",
            "x = tofloat(x);",
            "y = tofloat(y);",
            "return {sqrt((x * x) + (x * x)), `atan(y, x) ! E_INVARG => 0.0'};"
          ]
        },
        {
          "name": "polar_to_rect",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":polar_to_rect(INT|FLOAT <radius>, INT|FLOAT <angle>) => FLOAT <x>, FLOAT <y>\";",
            "\"This verb converts from polar (radius, angle) coordinates to rectangulat (x,y) coordinates.\";",
            "{r, a} = args[1..2];",
            "r = tofloat(r);",
            "a = tofloat(a);",
            "return {(r = r / (1.0 + (z2 = (z = tan(a / 2.0)) * z))) * (1.0 - z2), (r * 2.0) * z};"
          ]
        },
        {
          "name": "F_to_C degF_to_degC",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":F_to_C(INT|FLOAT <Fahrenheit>) => FLOAT <Celsius>\";",
            "\"This verb converts Fahrenheit degrees to Celsius degrees.\";",
            "return (tofloat(args[1]) - 32.0) / 1.8;"
          ]
        },
        {
          "name": "C_to_F degC_to_degF",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":C_to_F(INT|FLOAT <Celsius>) => FLOAT <Fahrenheit>\";",
            "\"This verb converts Celsius degrees to Fahrenheit degrees.\";",
            "return (tofloat(args[1]) * 1.8) + 32.0;"
          ]
        },
        {
          "name": "convert",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":convert(STR <units>, STR <units>) => FLOAT conversion factor | LIST errors.\";",
            "\"This verb attempts to compute the conversion factor between two sets of units. If the two inputs are of the same type (two speeds, two lengths, etc.), the value is returned. If the two inputs are not of the same type, a LIST is returned as follows: {1, {FLOAT <value>, STR <units>}. {FLOAT <value>, STR <units>}}. The 1 indicates that the two inputs were correctly formed. <value> is the conversion factor of the input into the basic <units>. This error output is useful for determining the basic structure and value of an unknown unit of measure. If either of the inputs can not be broken down to known units, a LIST is returned as follows: {0, STR <bad input>}.\";",
            "\"\";",
            "\"The format of the input strings is fairly straight forward: any multiplicative combination of units, ending in an optional digit to represent that unit is raised to a power, the whole of which is preceeded by an initial value. Examples: \\\"100 kg m/sec2\\\", \\\"35 joules\\\", \\\"2000 furlongs/fortnight\\\"\";",
            "\"\";",
            "\"Some example uses:\";",
            "\";$convert_utils:convert(\\\"2000 furlongs/fortnight\\\", \\\"mph\\\")\";",
            "\"=> 0.744047619047619\";",
            "\";$convert_utils:convert(\\\"kilowatt hours\\\", \\\"joules\\\")\";",
            "\"=> 3600000.0\";",
            "\"\";",
            "\";$convert_utils:convert(\\\"furlongs\\\", \\\"mph\\\")\";",
            "\"=> {1, {201.168, \\\"m\\\"}, {044704, \\\"m / s\\\"}}\";",
            "\"\";",
            "\";$convert_utils:convert(\\\"junk\\\", \\\"meters\\\")\";",
            "\"=> {0, \\\"junk\\\"}\";",
            "{havestr, wantstr} = args;",
            "{havenum, havestr} = $string_utils:first_word(havestr);",
            "havestr = $string_utils:trimr(tostr(havenum, \" \", strsub(havestr, \" \", \"\")));",
            "wantstr = strsub(wantstr, \" \", \"\");",
            "\"Preceeding three lines added by GD (#110777) on 23-June-2007 to stop an annoying error when you try to convert to/from things like 'fluid ounces'.\";",
            "have = this:_do_convert(havestr);",
            "want = this:_do_convert(wantstr);",
            "if ((have && want) && (have[2] == want[2]))",
            "return have[1] / want[1];",
            "elseif (have && want)",
            "return {1, {have[1], this:_format_units(@have[2])}, {want[1], this:_format_units(@want[2])}};",
            "else",
            "return {0, have ? wantstr | havestr};",
            "endif"
          ]
        },
        {
          "name": "_do_convert",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";",
            "\":_do_convert is the workhorse of $convert_utils:convert and is based loosely upon the 'units' Perl script the ships with BSD Unix.\";",
            "\"Essentially, it breaks the input up into values and units, attempts to break each unit down into elementary (basic) units, modifies the value as it goes, until it has no more input or can not convert a unit into a basic unit.\";",
            "instr = args[1];",
            "units = this.basic_units_template;",
            "value = 1.0;",
            "top = 1;",
            "\"Ensure that the division mark is a spearate word.\";",
            "instr = $string_utils:substitute(instr, {{\"/\", \" / \"}});",
            "while (instr)",
            "\"Grab the next word to process\";",
            "{first, instr} = $string_utils:first_word(instr);",
            "if (first == \"/\")",
            "\"Now we're working with values under the division mark - units with negative exponents.\";",
            "top = 1 - top;",
            "continue;",
            "elseif (match(first, \"|\"))",
            "\"The word was a value expressed as a ratio. Compute the ratio and adjust the value accordingly.\";",
            "value = this:_do_value(first, value, top);",
            "continue;",
            "elseif ($string_utils:is_integer(first) || $string_utils:is_float(first))",
            "\"The word was a value. Adjust the accumulated value accordingly.\";",
            "value = top ? value * tofloat(first) | (value / tofloat(first));",
            "continue;",
            "elseif (match(first, \"[0-9]$\"))",
            "\"The word ends with a digit, but isn't a value. It must be a powered unit. Expand it: cm3 => cm cm cm\";",
            "subs = match(first, \"%([a-zA-Z]+%)%([0-9]+%)\");",
            "first = substitute(\"%1\", subs);",
            "power = toint(substitute(\"%2\", subs));",
            "while (power > 0)",
            "instr = (first + \" \") + instr;",
            "power = power - 1;",
            "endwhile",
            "continue;",
            "else",
            "\"Check to see if the word starts with one or more metric prefix and attempt to evaluate the prefix.\";",
            "{first, value, top} = this:_try_metric_prefix(first, value, top);",
            "\"Check to see if we have a basic unit. If so, adjust the apropriate unit count.\";",
            "if (index = first in this.basic_units)",
            "units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);",
            "continue;",
            "elseif (prop = `this.(first) ! E_PROPNF => 0')",
            "\"Check to see if this is a known unit. If so, convert it and adjust the value and units.\";",
            "result = this:_do_convert(prop);",
            "value = top ? value * result[1] | (value / result[1]);",
            "for i in [1..length(units)]",
            "units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);",
            "endfor",
            "continue;",
            "elseif (first[$] == \"s\")",
            "\"Check to see if this is a normal 's'-ending plural, and try to do the above checks again.\";",
            "temp = first[1..$ - 1];",
            "if (index = temp in this.basic_units)",
            "units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);",
            "continue;",
            "elseif (prop = `this.(temp) ! E_PROPNF => 0')",
            "result = this:_do_convert(prop);",
            "value = top ? value * result[1] | (value / result[1]);",
            "for i in [1..length(units)]",
            "units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);",
            "endfor",
            "continue;",
            "endif",
            "endif",
            "\"We were unable to find any conversion for the current word, so halt all operation and return 0.\";",
            "return 0;",
            "endif",
            "endwhile",
            "\"We were able to successfully convert each part of the input. Return the equivalent value and units.\";",
            "return {value, units};"
          ]
        },
        {
          "name": "_try_metric_prefix",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";",
            "\":_try_metric_prefix runs through the metrix multipliers and tries to match them against the beginning of the input string. If successful, the given value is adjusted appropritately, and the input string is modified. The verb loops until there are no more prefix matches. (Hence, \\\"kilodecameter\\\" can be matched with only one verb call.\";",
            "\"If anyone knows of other possibilities here, please let me know.\";",
            "{first, value, top} = args;",
            "while (1)",
            "if (subs = match(first, \"^yocto%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1e+24 | (value * 1e+24);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^zepto%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1e+21 | (value * 1e+21);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^atto%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1e+18 | (value * 1e+18);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^femto%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1e+15 | (value * 1e+15);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^pico%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1000000000000.0 | (value * 1000000000000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^nano%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1000000000.0 | (value * 1000000000.0);",
            "continue;",
            "endif",
            "if (match(first, \"^micron\"))",
            "break;",
            "endif",
            "if (subs = match(first, \"^micro%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1000000.0 | (value * 1000000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^milli%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 1000.0 | (value * 1000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^centi%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 100.0 | (value * 100.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^deci%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = top ? value / 10.0 | (value * 10.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^%(deca%|deka%)%(.*%)\"))",
            "first = substitute(\"%2\", subs);",
            "value = (!top) ? value / 10.0 | (value * 10.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^hecto%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 100.0 | (value * 100.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^kilo%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1000.0 | (value * 1000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^mega%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1000000.0 | (value * 1000000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^giga%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1000000000.0 | (value * 1000000000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^tera%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1000000000000.0 | (value * 1000000000000.0);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^peta%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1e+15 | (value * 1e+15);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^exa%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1e+18 | (value * 1e+18);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^zetta%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1e+21 | (value * 1e+21);",
            "continue;",
            "endif",
            "if (subs = match(first, \"^yotta%(.*%)\"))",
            "first = substitute(\"%1\", subs);",
            "value = (!top) ? value / 1e+24 | (value * 1e+24);",
            "continue;",
            "endif",
            "break;",
            "endwhile",
            "return {first, value, top};"
          ]
        },
        {
          "name": "_format_units",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";",
            "\":_format_units takes the associative list of units and powers and construct a more user friendly string.\";",
            "top = bottom = \"\";",
            "for pair in (args)",
            "if (pair[2] > 0)",
            "top = tostr(top, \" \", pair[1], (pair[2] > 1) ? pair[2] | \"\");",
            "elseif (pair[2] < 0)",
            "bottom = tostr(bottom, \" \", pair[1], (pair[2] < -1) ? -pair[2] | \"\");",
            "endif",
            "endfor",
            "if (bottom)",
            "return ((top + \" /\") + bottom)[2..$];",
            "else",
            "return top[2..$];",
            "endif"
          ]
        },
        {
          "name": "K_to_C degK_to_degC",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":K_to_C (INT|FLOAT <Kelvin>) => FLOAT <Celcius>\";",
            "\"This verb converts Kelvin degrees to Celcius degrees.\";",
            "return tofloat(args[1]) - 273.0;"
          ]
        },
        {
          "name": "C_to_K degC_to_degK",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":C_to_K (INT|FLOAT <Celcius>) => FLOAT <Kelvin>\";",
            "\"This verb converts Celcius degrees to Kelvin degrees.\";",
            "return tofloat(args[1]) + 273.0;"
          ]
        },
        {
          "name": "F_to_R degF_to_degR",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":F_to_R (INT|FLOAT <Fahrenheit>) => FLOAT <Rankine>\";",
            "\"This verb converts Fahrenheit degrees to Rankine degrees.\";",
            "return tofloat(args[1]) + 459.67;"
          ]
        },
        {
          "name": "R_to_F degR_to_degF",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\":R_to_F (INT|FLOAT <Rankine>) => FLOAT <Fahrenheit>\";",
            "\"This verb converts Rankine degrees to Fahrenheit degrees.\";",
            "return tofloat(args[1]) - 459.67;"
          ]
        },
        {
          "name": "_do_value",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 93,
          "code": [
            "\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";",
            "\":_do_value takes a string of the form <number>|<number>, interprets it as a ratio, and applies that ratio to the incoming 'value' accordingly with the 'top' input, and returns it back to the calling verb.\";",
            "{first, value, top} = args;",
            "{numer, denom} = $string_utils:explode(first, \"|\");",
            "return top ? (value * tofloat(numer)) / tofloat(denom) | ((value * tofloat(denom)) / tofloat(numer));"
          ]
        }
      ],
      "propnames": [
        "basic_units",
        "pi",
        "c",
        "g",
        "au",
        "mole",
        "e",
        "abcoulomb",
        "force",
        "slug",
        "mercury",
        "hg",
        "torr",
        "%",
        "percent",
        "cg",
        "atmosphere",
        "atm",
        "psi",
        "bar",
        "chemamu",
        "physamu",
        "amu",
        "chemdalton",
        "dalton",
        "physdalton",
        "dozen",
        "bakersdozen",
        "quire",
        "ream",
        "gross",
        "hertz",
        "cps",
        "hz",
        "khz",
        "mhz",
        "rutherford",
        "degree",
        "circle",
        "turn",
        "revolution",
        "rpm",
        "grade",
        "grad",
        "sign",
        "arcdeg",
        "arcmin",
        "arcsec",
        "karat",
        "proof",
        "mpg",
        "curie",
        "stoke",
        "steradian",
        "sr",
        "sphere",
        "ps",
        "us",
        "ns",
        "ms",
        "sec",
        "minute",
        "min",
        "hour",
        "hr",
        "day",
        "week",
        "quadrant",
        "fortnight",
        "year",
        "yr",
        "month",
        "mo",
        "decade",
        "century",
        "millenium",
        "gm",
        "myriagram",
        "mg",
        "metricton",
        "gamma",
        "metriccarat",
        "quintal",
        "lb",
        "pound",
        "lbf",
        "cental",
        "stone",
        "ounce",
        "oz",
        "avdram",
        "usdram",
        "dram",
        "dr",
        "grain",
        "gr",
        "shortton",
        "ton",
        "longquarter",
        "shortquarter",
        "longton",
        "longhundredweight",
        "shorthundredweight",
        "wey",
        "carat",
        "scruple",
        "pennyweight",
        "apdram",
        "apounce",
        "appound",
        "cm",
        "mm",
        "km",
        "parsec",
        "pc",
        "nm",
        "micron",
        "angstrom",
        "fermi",
        "point",
        "pica",
        "caliber",
        "barleycorn",
        "inch",
        "in",
        "mil",
        "palm",
        "hand",
        "span",
        "foot",
        "feet",
        "ft",
        "cubit",
        "pace",
        "yard",
        "yd",
        "fathom",
        "rod",
        "rd",
        "rope",
        "ell",
        "skein",
        "cable",
        "furlong",
        "nmile",
        "nautmile",
        "bolt",
        "mile",
        "mi",
        "league",
        "nautleague",
        "lightyear",
        "engineerschain",
        "engineerslink",
        "gunterchain",
        "gunterlink",
        "ramdenchain",
        "ramdenlink",
        "acre",
        "rood",
        "are",
        "centare",
        "hectare",
        "barn",
        "section",
        "township",
        "cc",
        "liter",
        "l",
        "ml",
        "registerton",
        "cord",
        "boardfoot",
        "boardfeet",
        "cordfoot",
        "cordfeet",
        "last",
        "perch",
        "stere",
        "cfs",
        "gallon",
        "imperial",
        "gal",
        "quart",
        "qt",
        "magnum",
        "pint",
        "pt",
        "cup",
        "gill",
        "fifth",
        "firkin",
        "barrel",
        "petrbarrel",
        "hogshead",
        "hd",
        "tun",
        "kilderkin",
        "noggin",
        "floz",
        "fldr",
        "tablespoon",
        "teaspoon",
        "minim",
        "pk",
        "bushel",
        "dry",
        "bu",
        "british",
        "brbucket",
        "brpeck",
        "brbushel",
        "brfirkin",
        "dryquartern",
        "liqquarten",
        "butt",
        "bag",
        "brbarrel",
        "seam",
        "drachm",
        "newton",
        "pascal",
        "nt",
        "joule",
        "cal",
        "gramcalorie",
        "calorie",
        "btu",
        "frigorie",
        "kcal",
        "kcalorie",
        "langley",
        "dyne",
        "poundal",
        "pdl",
        "erg",
        "horsepower",
        "hp",
        "poise",
        "reyn",
        "rhe",
        "coul",
        "statcoul",
        "ampere",
        "abampere",
        "amp",
        "watt",
        "volt",
        "v",
        "abvolt",
        "statvolt",
        "ohm",
        "abohm",
        "mho",
        "abmho",
        "siemens",
        "farad",
        "abfarad",
        "statfarad",
        "pf",
        "abhenry",
        "henry",
        "stathenry",
        "mh",
        "weber",
        "gauss",
        "electronvolt",
        "ev",
        "kev",
        "mev",
        "bev",
        "faraday",
        "gilbert",
        "oersted",
        "oe",
        "cd",
        "lumen",
        "lux",
        "footcandle",
        "footlambert",
        "lambert",
        "phot",
        "stilb",
        "candle",
        "engcandle",
        "germancandle",
        "carcel",
        "hefnerunit",
        "candlepower",
        "baud",
        "byte",
        "kb",
        "mb",
        "gb",
        "word",
        "long",
        "block",
        "mph",
        "knot",
        "brknot",
        "mach",
        "energy",
        "ccs",
        "peck",
        "arpentcan",
        "apostilb",
        "arpentlin",
        "atomicmassunit",
        "barie",
        "barye",
        "biot",
        "blondel",
        "bottommeasure",
        "refrigeration",
        "centesimalminute",
        "centesimalsecond",
        "chain",
        "circularinch",
        "circularmil",
        "clusec",
        "coomb",
        "crith",
        "dioptre",
        "displacementton",
        "dopplezentner",
        "equivalentfootcandle",
        "equivalentlux",
        "equivalentphot",
        "finger",
        "franklin",
        "galileo",
        "geographicalmile",
        "hefnercandle",
        "homestead",
        "hyl",
        "imaginarycubicfoot",
        "jeroboam",
        "line",
        "link",
        "lusec",
        "marineleague",
        "maxwell",
        "mgd",
        "minersinch",
        "nail",
        "nit",
        "nox",
        "pieze",
        "pipe",
        "pole",
        "quarter",
        "quartersection",
        "ra",
        "rankine",
        "rehoboam",
        "rontgen",
        "rydberg",
        "sabin",
        "shippington",
        "sigma",
        "skot",
        "spat",
        "spindle",
        "square",
        "sthene",
        "tesla",
        "thermie",
        "timberfoot",
        "tonne",
        "water",
        "xunit",
        "k",
        "puncheon",
        "tnt",
        "basic_units_template",
        "meter",
        "gram",
        "second",
        "inches",
        "sennight",
        "cubichectare",
        "astronomicalunit",
        "fluidounce",
        "tsp",
        "tbsp"
      ],
      "propdefs": [
        {
          "value": [
            "m",
            "kg",
            "s",
            "coul",
            "candela",
            "radian",
            "bit",
            "erlang",
            "kelvin"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3.14159265358979323846264338327950288",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2.99792458e8 m/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9.80665 m/sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.49599e11 m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "6.022045e23",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.6020e-19 coul",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 coul",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "g",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lb g sec2/ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.3157895 atm/m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mercury",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mm hg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|100",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "%",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "centigram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.01325 bar",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "atmosphere",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lb g/in2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e6 dyne/cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.66024e-24 g",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.65979e-24 g",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "chemamu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "chemamu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "chemamu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "physamu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "12",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "13",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "25",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "500",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "144",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "hertz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "hertz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kilohz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "megahz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e6/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|180 pi radian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2 pi radian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2 pi radian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "360 degrees",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "revolution/minute",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|400 circle",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|400 circle",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|12 circle",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 degree",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|60 arcdeg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|60 arcmin",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|24",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|200",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mile/gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3.7e10/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 cm2/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "radian radian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "steradian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 pi steradian",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "picosec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "microsec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nanosec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "millisec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "second",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "60 sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "minute",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "60 min",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "hour",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "24 hr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "7 day",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "5400 minute",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "14 day",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "365.24219879 day",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "year",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|12 year",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "month",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 year",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 year",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1000 year",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "gram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "milligram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1000 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-6 g",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "200 mg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.45359237 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lb g",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "14 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|16 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "ounce",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|16 oz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|8 oz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "avdram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "dram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|7000 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2000 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "shortton",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "28 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "500 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2240 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "112 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "252 lb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "205.3 mg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "20 grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "24 grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "60 grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "480 grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "5760 grain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "centimeter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "millimeter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kilometer",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "au radian/arcsec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "parsec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nanometer",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-6 meter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-8 meter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-13 cm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|72.27 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.166044 inch",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.01 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|3 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2.54 cm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "inch",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.001 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "12 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "foot",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "foot",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "18 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "30 inch",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "yard",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "6 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "16.5 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "rod",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "20 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "45 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "360 feet",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "720 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "660 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1852 m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nmile",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "120 feet",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "5280 feet",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mile",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3 mi",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3 nmile",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "c yr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.01 engineerschain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "66 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.01 gunterchain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.01 ramdenchain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "43560 ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.25 acre",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.01 are",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 are",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-24 cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mi2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "36 mi2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cm3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1000 cc",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "liter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "milliliter",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "128 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "144 in3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "boardfoot",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.125 cord",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cordfoot",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "80 bu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "24.75 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "m3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "ft3/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "231 in3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.200949",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "gallon",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "quart",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2 qt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|2 qt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "pint",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|2 pt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 pt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|5 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "72 pint",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "31.5 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "42 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "63 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "hogshead",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "252 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "18 imperial gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 imperial gill",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 gill",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|32 gill",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 fldr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|3 tablespoon",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|480 floz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "peck",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "8 dry gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "268.8025 in3/gallon",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "bushel",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "277.4193|231",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 dry british gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2 dry british gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "8 dry british gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.125 brbushel",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2.272980 l",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.1420613 l",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "126 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3 brbushels",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4.5 brbushels",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "8 brbushels",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3.551531 ml",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kg m/sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nt/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "newton",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nt m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4.1868 joule",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1054.35 joule",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kilocal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kilocal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "kilocal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cal/cm cm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "erg/cm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "ft lb/sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "poundal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-7 joule",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "550 ft lb g/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "horsepower",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "gram/cm sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "6.89476e-6 centipoise",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1/poise",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "coulomb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3.335635e-10 coul",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "coul/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 amp",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "ampere",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "joule/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "watt/amp",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "299.7930 volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "volt/amp",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 ohm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1/ohm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 mho",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mho",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "coul/volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 farad",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.112646e-12 farad",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "picofarad",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 henry",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "sec2/farad",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "8.987584e11 henry",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "millihenry",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "volt sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "maxwell/cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "e volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "e volt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e3 ev",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e6 ev",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e9 ev",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9.648456e4coul",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.7957747154 amp",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 gilbert / cm",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "oersted",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "candela",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd sr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lumen/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lumen/ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/pi ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/pi cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lumen/cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.04 cd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.05 cd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9.61 cd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": ".92 cd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "12.566370 lumen",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "bit/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "8 bit",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1024 byte",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1024 kb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1024 mb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 byte",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 word",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "512 byte",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "mile/hr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nmile/hr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "6080 ft/hr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "331.45 m/sec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "c2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|36 erlang",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2 dry gallon",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "27.52 mi",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/pi m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "191.835 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "amu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-1 nt/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-1 nt/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "10 amp",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/pi m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|40 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "12000 but/ton hr",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-2 grade",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-4 grade",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "gunterchain",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 pi in2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-6|4 pi in2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-8 mm hg m3/s",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 bu",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9.06e-2 gram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1/m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "35 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lumen/pi ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "lumen/pi m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/pi cm2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "7|8 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3.33564e-10 coul",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-2 m/sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "nmile",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "hefnerunit",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 mi2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "gram force sec2/m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.4 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4|5 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|12 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "66|100 ft",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-6 mm hg m3/s",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "3nmile",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-8 weber",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "megagal/day",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.5 ft3/min",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|16 yd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "cd/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-3 lux",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e3 nt/mt2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4 barrel",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "rd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "9 in",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|4 mi2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 erg/gram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.8 kelvin",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "156 floz",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "2.58e-4 curie/kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.36054e1 ev",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "40 ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "microsec",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e-3 apostilb",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "sphere",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "14400 yd",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "100 ft2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e3 nt",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "weber/m2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e6 cal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "ft3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1e6 gram",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "0.22491|2.54 kg/m2 sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.00202e-13 m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1.38047e-16 erg/kelvin",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "84 gal",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "4.6e6 m2/sec2",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            [
              "m",
              0
            ],
            [
              "kg",
              0
            ],
            [
              "s",
              0
            ],
            [
              "coul",
              0
            ],
            [
              "candela",
              0
            ],
            [
              "radian",
              0
            ],
            [
              "bit",
              0
            ],
            [
              "erlang",
              0
            ],
            [
              "kelvin",
              0
            ]
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "m",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1|1000 kg",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "s",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "inch",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1 week",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "1000000 m3",
          "owner": 36,
          "perms": 1
        },
        {
          "value": "au",
          "owner": 2,
          "perms": 1
        },
        {
          "value": "floz",
          "owner": 2,
          "perms": 1
        },
        {
          "value": "teaspoon",
          "owner": 2,
          "perms": 1
        },
        {
          "value": "tablespoon",
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            "Utility verbs for converting from one unit of measure to another.",
            "",
            "Unusual conversions:",
            ":dd_to_dms => converts decimal (INT or FLOAT) Degrees into Degrees, Minutes,",
            "              and Seconds. (Also works for decimal Hours.)",
            ":dms_to_dd => converts from Degrees (or Hours), Minutes, and Seconds to",
            "              decimal Degrees (or Hours).",
            ":rect_to_polar => converts from cartesian (x,y) coordinates to polar.",
            ":polar_to_rect => converts from polar (r, theta) coordinates to cartesian.",
            ":F_to_C => converts from Fahrenheit to Celsius.",
            ":C_to_F => converts from Celsius to Fahrenheit.",
            ":C_to_K => converts from Celsius to Kelvin.",
            ":K_to_C => converts from Kelvin to Celsius.",
            ":F_to_R => converts from Fahrenheit to Rankine.",
            ":R_to_F => converts from Rankine to Fahrenheit.",
            "",
            "Standard conversions:",
            ":convert => takes two string inputs and attempts to determine the ",
            "            multiplicative conversion factor. See the verb help for details",
            "            and input format.\""
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 36,
          "perms": 4
        },
        {
          "value": [
            "Conversion Utils"
          ],
          "owner": 36,
          "perms": 5
        },
        {
          "value": "This is a utilities package for converting from one unit of measurement to another. Type 'help #770' for more details.",
          "owner": 36,
          "perms": 5
        },
        {
          "value": [
            45582,
            1641541193
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "94": {
      "id": 94,
      "name": "Generic Gendered Object",
      "flags": 144,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        35,
        6
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set_gender",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 94,
          "code": [
            "\"set_gender(newgender) attempts to change this.gender to newgender\";",
            "\"  => E_PERM   if you don't own this or aren't its parent\";",
            "\"  => Other return values as from $gender_utils:set.\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))",
            "return E_PERM;",
            "else",
            "result = $gender_utils:set(this, args[1]);",
            "this.gender = (typeof(result) == STR) ? result | args[1];",
            "return result;",
            "endif"
          ]
        },
        {
          "name": "verb_sub",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 94,
          "code": [
            "\"Copied from generic player (#6):verb_sub by ur-Rog (#6349) Fri Jan 22 11:20:11 1999 PST\";",
            "\"This verb was copied by TheCat on 01/22/99, so that the generic gendered object will be able to do verb conjugation as well as pronoun substitution.\";",
            "text = args[1];",
            "if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')",
            "return a[2];",
            "else",
            "return $gender_utils:get_conj(text, this);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "gender",
        "pqc",
        "pq",
        "ppc",
        "pp",
        "prc",
        "pr",
        "poc",
        "po",
        "psc",
        "ps",
        "verb_subs"
      ],
      "propdefs": [
        {
          "value": "neuter",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "its",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "its",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Its",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "its",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "Itself",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "itself",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "It",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "it",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "It",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "it",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Generic Gendered Object"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            3044,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "95": {
      "id": 95,
      "name": "List Editor",
      "flags": 144,
      "owner": 96,
      "location": -1,
      "parents": [
        50
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "e*dit",
          "owner": 96,
          "perms": 25,
          "preps": -1,
          "object": 95,
          "code": [
            "if (this:changed(who = player in this.active))",
            "player:tell(\"You are still editing \", this:working_on(who), \".  Please type ABORT or SAVE first.\");",
            "elseif (spec = this:parse_invoke(dobjstr, verb))",
            "this:init_session(who, @spec);",
            "endif"
          ]
        },
        {
          "name": "save",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 95,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "return;",
            "endif",
            "if (dobjstr)",
            "if (objprop = this:property_match_result(dobjstr))",
            "this.objects[who] = objprop[1];",
            "this.properties[who] = objprop[2];",
            "else",
            "return;",
            "endif",
            "else",
            "objprop = {this.objects[who], this.properties[who]};",
            "endif",
            "value_list = this:to_value(@this:text(who));",
            "if (value_list[1])",
            "player:tell(\"Error on line \", value_list[1], \":  \", value_list[2]);",
            "player:tell(\"Value not saved to \", this:working_on(who));",
            "elseif (result = this:set_property(@objprop, value_list[2]))",
            "player:tell(\"Value written to \", this:working_on(who), \".\");",
            "this:set_changed(who, 0);",
            "else",
            "player:tell(result);",
            "player:tell(\"Value not saved to \", this:working_on(who));",
            "endif"
          ]
        },
        {
          "name": "join* fill",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 95,
          "code": [
            "player:tell(\"I don't understand that.\");"
          ]
        },
        {
          "name": "expl*ode",
          "owner": 96,
          "perms": 89,
          "preps": -2,
          "object": 95,
          "code": [
            "if (!(who = this:loaded(player)))",
            "player:tell(this:nothing_loaded_msg());",
            "elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @args)) != LIST)",
            "player:tell(range);",
            "elseif (range[3])",
            "player:tell(\"Junk at end of cmd:  \", range[3]);",
            "else",
            "text = this.texts[who];",
            "newins = ins = this.inserting[who];",
            "start = range[1];",
            "if (typeof(debris = this:explode_line(\"\", text[start])) == STR)",
            "player:tell(\"Line \", start, \":  \", debris);",
            "return;",
            "endif",
            "if (!debris[1])",
            "debris = listdelete(debris, 1);",
            "endif",
            "newlines = {};",
            "for line in (text[i = start + 1..end = range[2]])",
            "dlen = length(debris);",
            "newlines = {@newlines, @debris[1..dlen - 1]};",
            "if (ins == i)",
            "newins = (start + length(newlines)) + 1;",
            "endif",
            "if (typeof(debris = this:explode_line(debris[dlen], line)) == STR)",
            "player:tell(\"Line \", i, \":  \", debris);",
            "return;",
            "endif",
            "i = i + 1;",
            "endfor",
            "explen = length(newlines) + length(debris);",
            "if (ins > end)",
            "newins = (ins - ((end - start) + 1)) + explen;",
            "endif",
            "this.texts[who] = {@text[1..start - 1], @newlines, @debris, @text[end + 1..length(text)]};",
            "this.inserting[who] = newins;",
            "player:tell(\"--> \", start, \"..\", (start + explen) - 1);",
            "endif"
          ]
        },
        {
          "name": "value",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "if (!(e = this:readable(who = args ? args[1] | (player in this.active)) || this:ok(who)))",
            "return e;",
            "endif",
            "vlist = this:to_value(@this:text(who));",
            "if (vlist[1])",
            "player:tell(\"Error on line \", vlist[1], \":  \", vlist[2]);",
            "return E_INVARG;",
            "else",
            "return vlist[2];",
            "endif"
          ]
        },
        {
          "name": "working_on",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "if (!(who = args[1]))",
            "return \"????\";",
            "endif",
            "object = this.objects[who];",
            "prop = this.properties[who] || \"(???)\";",
            "return valid(object) ? tostr(\"\\\"\", object.name, \"\\\"(\", object, \")\", \".\" + prop) | tostr(\".\", prop, \" on an invalid object (\", object, \")\");"
          ]
        },
        {
          "name": "init_session",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "if (this:ok(who = args[1]))",
            "this:load(who, args[4]);",
            "this.objects[who] = args[2];",
            "this.properties[who] = args[3];",
            "player:tell(\"Now editing \", this:working_on(who), \".\");",
            "endif"
          ]
        },
        {
          "name": "property_match_result",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "if (!(pp = $code_utils:parse_propref(string = args[1])))",
            "player:tell(\"Property specification expected.\");",
            "return 0;",
            "endif",
            "objstr = pp[1];",
            "prop = pp[2];",
            "if ($command_utils:object_match_failed(object = player:my_match_object(objstr, this:get_room(player)), objstr))",
            "elseif (!$object_utils:has_property(object, prop))",
            "player:tell(object.name, \"(\", object, \") has no \\\".\", prop, \"\\\" property.\");",
            "else",
            "return {object, prop};",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "property",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 95,
          "code": [
            "\"WIZARDLY\";",
            "vl = $code_utils:verb_loc();",
            "if ((caller != vl) || (caller_perms() != vl.owner))",
            "return E_PERM;",
            "endif",
            "set_task_perms(player);",
            "return args[1].(args[2]);"
          ]
        },
        {
          "name": "set_property",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 95,
          "code": [
            "\"WIZARDLY\";",
            "vl = $code_utils:verb_loc();",
            "if ((caller != vl) || (caller_perms() != vl.owner))",
            "return E_PERM;",
            "endif",
            "{object, pname, value} = args;",
            "set_task_perms(player);",
            "if ($object_utils:has_callable_verb(object, \"set_\" + pname))",
            "if (typeof(attempt = object:(\"set_\" + pname)(value)) != ERR)",
            "return attempt;",
            "endif",
            "endif",
            "return (typeof(e = object.(pname) = value) == ERR) ? e | 1;"
          ]
        },
        {
          "name": "explode_line",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "su = $string_utils;",
            "prev = args[1];",
            "line = su:triml(args[2]);",
            "indent = length(args[2]) - length(line);",
            "if (line[1] == \"@\")",
            "if (!(splicee = $no_one:eval((\"{\" + line[2..length(line)]) + \"}\"))[1])",
            "return \"Can't eval what's after the @.\";",
            "endif",
            "newlines = this:explode_list(indent + 1, splicee[2]);",
            "return {prev, @newlines};",
            "elseif (line[1] == \"}\")",
            "if (this:is_delimiter(prev) && (!index(prev, \"{\")))",
            "return {tostr(args[2][1..indent], su:trim(prev), \" \", line)};",
            "else",
            "return args;",
            "endif",
            "elseif (line[1] != \"{\")",
            "return args;",
            "elseif (!rindex(line, \"}\"))",
            "if (this:is_delimiter(prev))",
            "return {(su:trimr(prev) + (rindex(prev, \"{\") ? \" \" | \", \")) + line};",
            "else",
            "return args;",
            "endif",
            "elseif (!(v = $no_one:eval(line))[1])",
            "return \"Can't eval this line.\";",
            "else",
            "newlines = {@this:explode_list(indent + 2, v[2]), su:space(indent) + \"}\"};",
            "if (this:is_delimiter(prev))",
            "return {su:trimr(prev) + (rindex(prev, \"{\") ? \" {\" | \", {\"), @newlines};",
            "else",
            "return {prev, su:space(indent) + \"{\", @newlines};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "explode_list",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "\":explode_list(indent,list) => corresponding list of strings to use.\";",
            "lines = {};",
            "indent = $string_utils:space(args[1]);",
            "for element in (args[2])",
            "if (typeof(element) == STR)",
            "lines = {@lines, (indent + \"\\\"\") + element};",
            "else",
            "lines = {@lines, indent + $string_utils:print(element)};",
            "endif",
            "endfor",
            "return lines;"
          ]
        },
        {
          "name": "is_delimiter",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "line = $string_utils:triml(args[1]);",
            "return line && ((line[1] == \"}\") || ((line[1] == \"{\") && (!rindex(line, \"}\"))));"
          ]
        },
        {
          "name": "to_value",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "\":to_value(@list_of_strings) => {line#, error_message} or {0,value}\";",
            "\"converts the given list of strings back into a value if possible\";",
            "stack = {};",
            "curlist = {};",
            "curstr = 0;",
            "i = 0;",
            "for line in (args)",
            "i = i + 1;",
            "if (!(line = $string_utils:triml(line)))",
            "\"skip blank lines\";",
            "elseif ((char = line[1]) == \"+\")",
            "if (curstr == 0)",
            "return {i, \"previous line is not a string\"};",
            "endif",
            "curstr = curstr + line[2..length(line)];",
            "else",
            "if (curstr != 0)",
            "curlist = {@curlist, curstr};",
            "curstr = 0;",
            "endif",
            "if ((char == \"}\") || ((char == \"{\") && (!rindex(line, \"}\"))))",
            "comma = 0;",
            "for c in [1..length(line)]",
            "char = line[c];",
            "if (char == \"}\")",
            "if (comma)",
            "return {i, \"unexpected `}'\"};",
            "elseif (!stack)",
            "return {i, \"too many }'s\"};",
            "endif",
            "curlist = {@stack[1], curlist};",
            "stack = listdelete(stack, 1);",
            "elseif (char == \"{\")",
            "comma = 1;",
            "stack = {curlist, @stack};",
            "curlist = {};",
            "elseif (char == \" \")",
            "elseif ((!comma) && (char == \",\"))",
            "comma = 1;",
            "else",
            "return {i, tostr(\"unexpected `\", char, \"'\")};",
            "endif",
            "endfor",
            "elseif (char == \"\\\"\")",
            "curstr = line[2..length(line)];",
            "elseif (char == \"@\")",
            "if (!(v = $no_one:eval((\"{\" + line[2..length(line)]) + \"}\"))[1])",
            "return {i, \"Can't eval what's after the @\"};",
            "endif",
            "curlist = {@curlist, @v[2]};",
            "else",
            "if (!(v = $no_one:eval(line))[1])",
            "return {i, \"Can't eval this line\"};",
            "endif",
            "curlist = {@curlist, v[2]};",
            "endif",
            "endif",
            "endfor",
            "if (stack)",
            "return {i, \"missing }\"};",
            "endif",
            "if (curstr != 0)",
            "return {0, {@curlist, curstr}};",
            "else",
            "return {0, curlist};",
            "endif"
          ]
        },
        {
          "name": "parse_invoke",
          "owner": 96,
          "perms": 173,
          "preps": -1,
          "object": 95,
          "code": [
            "if (caller != this)",
            "raise(E_PERM);",
            "elseif (!(string = args[1]))",
            "player:tell_lines({(\"Usage:  \" + args[2]) + \" <object>.<property>\", (\"        \" + args[2]) + \"          (continues editing an unsaved property)\"});",
            "elseif (!(objprop = this:property_match_result(string)))",
            "elseif (ERR == typeof(value = this:property(@objprop)))",
            "player:tell(\"Couldn't get property value:  \", value);",
            "elseif (typeof(value) != LIST)",
            "player:tell(\"Sorry... expecting a list-valued property.\");",
            "if (typeof(value) == STR)",
            "player:tell(\"Use @notedit to edit string-valued properties\");",
            "else",
            "player:tell(\"Anyway, you don't need an editor to edit `\", value, \"'.\");",
            "endif",
            "else",
            "return {@objprop, this:explode_list(0, value)};",
            "endif",
            "return 0;"
          ]
        }
      ],
      "propnames": [
        "objects",
        "properties"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [
            [
              "say",
              "emote",
              "lis*t",
              "ins*ert",
              "n*ext,p*rev",
              "del*ete",
              "f*ind",
              "s*ubst",
              "m*ove,c*opy",
              "expl*ode"
            ],
            [
              "w*hat",
              "abort",
              "q*uit,done,pause"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "e*dit",
              "<object>.<prop>"
            ],
            [
              "save",
              "[<object>.<prop>]"
            ],
            [
              "expl*ode",
              "[<range>]"
            ]
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            [
              "properties",
              ""
            ],
            [
              "objects",
              -1
            ],
            [
              "texts",
              0
            ],
            [
              "changes",
              0
            ],
            [
              "inserting",
              1
            ],
            [
              "readable",
              0
            ]
          ],
          "owner": 96,
          "perms": 1
        },
        {
          "value": "%N heads off to edit some properties.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": "%N comes back from editing properties.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            "Partially edited list value will be here when you get back.",
            "To return, give the `@pedit' command with no arguments.",
            "Please come back and SAVE or ABORT if you don't intend to be working on this list value in the immediate future.  Keep Our MOO Clean!  No Littering!"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 0
        },
        {
          "value": [],
          "owner": 96,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 917349705,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": [
            "List Editor"
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            17973,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "96": {
      "id": 96,
      "name": "Editor_Owner",
      "flags": 1,
      "owner": 96,
      "location": -1,
      "parents": [
        4
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            2
          ],
          "owner": 96,
          "perms": 5
        },
        {
          "value": [],
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            90,
            89
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": "",
          "owner": 2,
          "perms": 0
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            48,
            49,
            50,
            95,
            96
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": -10000,
          "owner": 36,
          "perms": 0
        },
        {
          "value": -1,
          "owner": 96,
          "perms": 5
        },
        {
          "value": "impossible password to type",
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 2147483647,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            0,
            135523,
            1671219241,
            0
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": null,
          "owner": 96,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 96,
          "perms": 4
        },
        {
          "value": [
            "Editor_Owner"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "This player owns all editor-related verbs.",
          "owner": 96,
          "perms": 5
        },
        {
          "value": [
            3554,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "97": {
      "id": 97,
      "name": "HTTP Server",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        5
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "handle_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 97,
          "code": [
            "\"HTTP Server\";",
            "\"\";",
            "\"This gets called by the #0:do_login_command\";",
            "\"It keeps track of web browser guests, and it feeds them HTTP instead of Telnet.\";",
            "if ((caller != #0) && (caller != this))",
            "return E_PERM;",
            "endif",
            "not_http = args ? args | {$login.blank_command};",
            "guest = $string_utils:connection_hostname(player);",
            "if (!args)",
            "if ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)",
            "guestinfo = this.guests[guestnum];",
            "if (guestinfo[3] > 1)",
            "\"Three blank requests means this is not a guest anymore.\";",
            "this.guests = listdelete(this.guests, guestnum);",
            "return not_http;",
            "endif",
            "guestinfo[3] = guestinfo[3] + 1;",
            "this.guests[guestnum] = guestinfo;",
            "else",
            "\"Don't know who this is. Do the regular welcome.\";",
            "return not_http;",
            "endif",
            "elseif ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)",
            "\"Previously registered HTTP guest.\";",
            "if (args && (args[1] == \"GET\"))",
            "\"Registered guest does a GET.\";",
            "guestinfo = {guest, time(), 0};",
            "this.guests[guestnum] = guestinfo;",
            "html = {};",
            "keys = $string_utils:explode(args[2], \"/\");",
            "objid = keys ? toobj(keys[1]) | #-1;",
            "if (valid(objid))",
            "if ($object_utils:has_callable_verb(objid, \"html\"))",
            "new_player = $no_one;",
            "if ((length(keys) >= 3) && (length(keys[3]) > 2))",
            "if (keys[3] == this:gen_key(keys[1], keys[2], keys[3][1..2]))",
            "new_player = toobj(keys[2]);",
            "keys = (length(keys) > 3) ? keys[4..$] | {};",
            "endif",
            "endif",
            "old_player = player;",
            "player = new_player;",
            "html = `objid:html(@keys) ! ANY';",
            "player = old_player;",
            "if (typeof(html) == ERR)",
            "html = {\"HTTP/1.1 500 Internal Server Error\", \"Content-Type: text/plain\", \"\", \"\", \"ERROR:\", tostr(objid) + \":html()\", tostr(html)};",
            "endif",
            "elseif ($object_utils:has_readable_property(objid, \"html\"))",
            "html = objid.html;",
            "else",
            "html = {\"HTTP/1.1 404 NOT FOUND\", \"Content-Type: text/plain\", \"\", \"\", \"HTML not found.\"};",
            "endif",
            "else",
            "html = {\"HTTP/1.1 404 NOT FOUND\", \"Content-Type: text/plain\", \"\", \"\", \"Object not found.\"};",
            "endif",
            "\"Default header is HTML\";",
            "html_header = {\"HTTP/1.1 200 OK\", \"Content-Type: text/html\", \"\", \"\"};",
            "if (typeof(html) == STR)",
            "html = {html};",
            "endif",
            "if (`html[1][1..6] == \"<HTML>\" ! ANY => 0')",
            "html = {@html_header, @html};",
            "endif",
            "if ((typeof(html) == LIST) && (length(html) == 0))",
            "html = html_header;",
            "endif",
            "if (html && (typeof(html) == LIST))",
            "for h in (html)",
            "if (typeof(h) == STR)",
            "notify(player, h);",
            "endif",
            "endfor",
            "endif",
            "\"Server options need a suspend before they take effect.\";",
            "old_boot = $server_options.boot_msg;",
            "$server_options.boot_msg = \"\";",
            "suspend(0);",
            "boot_player(player);",
            "$server_options.boot_msg = old_boot;",
            "elseif (args[1][$] == \":\")",
            "\"Client is telling us some HTTP header info.\";",
            "boot_player(player);",
            "else",
            "\"They stopped doing GETs, so remove them as HTTP.\";",
            "this.guests = listdelete(this.guests, guestnum);",
            "return not_http;",
            "endif",
            "elseif (args && (args[1] == \"GET\"))",
            "\"First visit. Register them as a guest and ask them to refresh.\";",
            "guestinfo = {guest, time(), 0};",
            "this.guests = {@this.guests, guestinfo};",
            "html = {\"HTTP/1.1 200 OK\", \"Content-Type: text/html\", \"\", \"\", \"<meta http-equiv=\\\"refresh\\\" content=\\\"0\\\"><br><b>\", \"\", \"\", \"\", \"Web service initialized. Please reload this page.\", \"</b>\"};",
            "for h in (html)",
            "notify(player, h);",
            "endfor",
            "boot_player(player);",
            "else",
            "\"Regular telnet client.\";",
            "return not_http;",
            "endif",
            "\"HTTP Session successful\";",
            "return;"
          ]
        },
        {
          "name": "tell_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 97,
          "code": [
            "\"This makes a URL key for a specific object and player.\";",
            "\"With the keyed URL, the PLAYER will be set correctly when :HTML() is called\";",
            "key = this:gen_key(player, caller);",
            "notify(player, (\"This is the private key for you, \" + player.name) + \". Do not share it.\");",
            "notify(player, (((((((((\"http://\" + $network.site) + \":\") + $network.port) + \"/\") + tostr(caller)[2..$]) + \"/\") + tostr(player)[2..$]) + \"/\") + key) + \"/\");"
          ]
        },
        {
          "name": "gen_key",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 97,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "player = args[1];",
            "object = args[2];",
            "hash = ((toint(player) + toint(object)) + this.master_key) % 100000000;",
            "if (length(args) > 2)",
            "salt = args[3];",
            "key = crypt(tostr(hash), salt);",
            "else",
            "\"Make it only alphanumeric salt, to get through a URL\";",
            "salt = this.alpha[random(length(this.alpha))] + this.alpha[random(length(this.alpha))];",
            "key = crypt(tostr(hash), salt);",
            "endif",
            "\"Clean out the non-alpha to make key work in a URL\";",
            "for i in [1..length(key)]",
            "if (j = index(this.nonalpha, key[i], 1))",
            "key[i] = this.alpha[j];",
            "endif",
            "endfor",
            "return key;"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 97,
          "code": [
            "if (caller_perms().wizard)",
            "this.guests = {};",
            "pass(@args);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "guests",
        "master_key",
        "alpha",
        "nonalpha",
        "help_msg"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "902894a52d08e5cf3c45812a321cac36",
          "owner": 2,
          "perms": 5
        },
        {
          "value": "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
          "owner": 2,
          "perms": 5
        },
        {
          "value": " !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "HTTP Server",
            "-----------",
            "",
            "To use this device, all you need to do is put a .html property on your object. It will then serve a web page at http://SITE:PORT/OBJID where OBJID is the object's ID number without the # sign, SITE is your MOO's address, and PORT is your MOO's port.",
            "If it starts with the line <HTML>, the server will automatically serve it up as HTML code.",
            "Otherwise, you will need to use your own HTTP headers (for example, if you want to serve plain text instead of HTML).",
            "",
            "If you want to have more functionality than this, you can make a verb :html(args), that does the same thing. The args are a list of anything after the OBJID divided by /.",
            "For example, the URL http://SITE:PORT/123/foo/10 will result in a call to #123:html(\"foo\",\"10\"). This call should return a list of strings that is HTML, or HTTP stuff with the appropriate headers.",
            "",
            "Additionally, your object can call http:tell_key(player). This will generate a special keyed URL for that player, so when your :html() verb is called, the built-in variable PLAYER will be set to the person who was issued the key.",
            "This verb tells the player their custom key directly."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "HTTP Server"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            8359,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "98": {
      "id": 98,
      "name": "Core",
      "flags": 3,
      "owner": 98,
      "location": 15,
      "parents": [
        58
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            113,
            116,
            121,
            123
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": [
            50000,
            239212,
            1671219241,
            100
          ],
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            3637,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "99": {
      "id": 99,
      "name": "ANSI Utilities",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "length",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "return length(index(a = args[1], \"[\") ? this:delete(a) | a);"
          ]
        },
        {
          "name": "index rindex",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":[r]index (STR string, STR character, NUM case_matters)\";",
            "\"like index() and rindex() but ignores ANSI codes\";",
            "return (verb == \"index\") ? index(this:delete(args[1]), @listdelete(args, 1)) | rindex(this:delete(args[1]), @listdelete(args, 1));"
          ]
        },
        {
          "name": "contains_codes",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":contains_codes(STR string) => True if <string> contains any ANSI codes\";",
            "return !(!match(args[1], this.all_regexp));"
          ]
        },
        {
          "name": "delete",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":delete (STR string) => STR <string> with ANSI codes stripped out\";",
            "line = args[1];",
            "if (this.active)",
            "while (index = match(line, this.notify_regexp))",
            "line[index[1]..index[2]] = \"\";",
            "endwhile",
            "line = strsub(line, \"[null]\", \"\");",
            "endif",
            "return line;"
          ]
        },
        {
          "name": "update_all",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "if (!this:trusts(caller_perms()))",
            "return E_PERM;",
            "endif",
            "codes = this.extra_codes;",
            "\"...we really don't need group regexps anymore, but I'm going to keep them around for a while just in case...\";",
            "for x in (this.groups)",
            "this.(tostr(\"group_\", x, \"_regexp\")) = tostr(\"%[%(\", $string_utils:from_list(g = this.(\"group_\" + x), \"%|\"), \"%)%]\");",
            "codes = {@codes, @g};",
            "endfor",
            "this.all = codes;",
            "this.all_regexp = tostr(\"%[%(b:%)?%(\", $string_utils:from_list(codes, \"%|\"), \"%|\", this.xterm_256_regexp, \"%|\", this.truecolor_regexp, \"%)%]\");",
            "this.terminate_regexp = tostr(\"%[%(b:%)?%(\", $string_utils:from_list($set_utils:difference(codes, {@this.default_codes, @this.group_extra}), \"%|\"), \"%|\", this.xterm_256_regexp, \"%|\", this.truecolor_regexp, \"%)%]\");",
            "this.notify_regexp = tostr(\"%[%(b:%)?%(\", $string_utils:from_list(setremove(codes, \"null\"), \"%|\"), \"%|\", this.xterm_256_regexp, \"%|\", this.truecolor_regexp, \"%)%]\");",
            "colors = {};",
            "ccs = {};",
            "for x in (this.group_colors)",
            "if (!((a = this:get_code(x, \"ESC\")) in ccs))",
            "colors = setadd(colors, x);",
            "ccs = setadd(ccs, a);",
            "endif",
            "endfor",
            "this.random_colors = colors;",
            "this.replace_code_pointers = {};",
            "index = 0;",
            "leaves = $object_utils:leaves_suspended($ansi_pc);",
            "data = {};",
            "ll = length(leaves);",
            "\"...this will probably have to suspend on most large MOOs but you'll have to rewrite it so it can..\";",
            "while (index <= ll)",
            "index = index + 1;",
            "if (!is_player(leaves[index]))",
            "elseif (typeof(x = this:update_player_codes(leaves[index])) != LIST)",
            "elseif (!(i = $list_utils:iassoc(x, data, 2)))",
            "data = listappend(data, {1, x});",
            "elseif ((((data[i][1] + 1) * length(x)) / ll) >= 6)",
            "\"Must be at least 25% of people for 25 element long lists...\";",
            "\"                 50%               12...\";",
            "\"                 12%               50... etc\";",
            "this.replace_code_pointers = listappend(this.replace_code_pointers, x);",
            "index = 0;",
            "data = {};",
            "else",
            "data[i][1] = data[i][1] + 1;",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "get_code",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{code, escape_char, ?truecolor_match = 0, ?xterm_256_match = 0} = args;",
            "if (truecolor_match)",
            "ret = tostr(escape_char || this.escape, \"[\", (code[1] == \"b\") ? \"48\" | \"38\");",
            "ret = substitute(tostr(ret, \";2;%4;%5;%6m\"), truecolor_match);",
            "return ret;",
            "elseif (xterm_256_match)",
            "ret = tostr(escape_char || this.escape, \"[\", (code[1] == \"b\") ? \"48\" | \"38\");",
            "ret = tostr(ret, \";5;\", code[(code[1] == \"b\") ? 4 | 2..$], \"m\");",
            "return ret;",
            "else",
            "return strsub(strsub(this.(\"code_\" + code), \"e\", escape_char || this.escape, 1), \"b\", this.beep);",
            "endif"
          ]
        },
        {
          "name": "cutoff*_suspended",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":cutoff[_suspended] (STR string, NUM start, NUM end) => STR\";",
            "\"Acts like: string[start..end] but ignores ANSI codes.\";",
            "args = {@args, 0}[1..4];",
            "if (typeof(info = this:cutoff_locs(@args, verb == \"cutoff_suspended\")) == LIST)",
            "return args[1][info[1]..info[2]];",
            "else",
            "return info;",
            "endif"
          ]
        },
        {
          "name": "add_group",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":add_group (STR group)\";",
            "\"Adds <group> to the groups and makes a property for it.\";",
            "if (!this:trusts(caller_perms()))",
            "return E_PERM;",
            "elseif (!((args && args[1]) && (typeof(args[1]) == STR)))",
            "return E_INVARG;",
            "elseif (args[1] in this.groups)",
            "return 0;",
            "else",
            "this.groups = setadd(this.groups, args[1]);",
            "arg1 = {this, \"group_\" + args[1], {}, {$code_utils:verb_perms(), \"r\"}};",
            "arg2 = {this, tostr(\"group_\", args[1], \"_regexp\"), \"\", arg1[4]};",
            "if ($object_utils:has_callable_verb(#0, \"add_property\"))",
            "$add_property(@arg1);",
            "$add_property(@arg2);",
            "else",
            "add_property(@arg1);",
            "add_property(@arg2);",
            "endif",
            "$options[\"ansi\"]:add_name(args[1]);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "add_code",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":add_code (STR code, NUM/STR sequence, STR group)\";",
            "\"Adds a new code, <code> and adds it to group <group>.\";",
            "\"If <sequence> is a string, it is used as the ANSI sequence, otherwise\";",
            "\"it uses 'e[<sequence>m'.  'e' is replaced with the escape character, and\";",
            "\"'b' is replaced with the beep character in <sequence>\";",
            "if (!this:trusts(caller_perms()))",
            "return E_PERM;",
            "elseif (length(args) < 3)",
            "return E_ARGS;",
            "elseif (!(((args[1] && (typeof(args[1]) == STR)) && (!$object_utils:has_property(this, cn = tostr(\"code_\", args[1])))) && ((group = args[3]) in {@this.groups, E_NONE})))",
            "return E_INVARG;",
            "else",
            "code = args[2];",
            "if (typeof(code) == NUM)",
            "code = tostr(\"e[\", n, \"m\");",
            "endif",
            "arg = {this, cn, code, {$code_utils:verb_perms(), \"r\"}};",
            "if ($object_utils:has_verb(#0, \"add_property\"))",
            "$add_property(@arg);",
            "else",
            "add_property(@arg);",
            "endif",
            "if (args[3] == E_NONE)",
            "this.extra_codes = setadd(this.extra_codes, args[1]);",
            "else",
            "this.(\"group_\" + args[3]) = setadd(this.(\"group_\" + args[3]), args[1]);",
            "endif",
            "this:update_all();",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "show_who_listing",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":show_who_listing(players[,more_players])\";",
            "\" prints a listing of the indicated players.\";",
            "\" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.\";",
            "idles = itimes = offs = otimes = listing = {};",
            "for p in (args[2])",
            "if (!valid(p))",
            "listing = {@listing, tostr(p, \" <invalid>\")};",
            "elseif (typeof(t = p.last_disconnect_time) == NUM)",
            "(p in offs) || ((offs = {@offs, p}) && (otimes = {@otimes, {-t, -t, p}}));",
            "elseif (is_player(p))",
            "listing = {@listing, tostr(p.name, \" (\", p, \") \", (t == E_PROPNF) ? \"is not a $player.\" | \"has a garbled .last_disconnect_time.\")};",
            "else",
            "listing = {@listing, tostr(p.name, \" (\", p, \") is not a player.\")};",
            "endif",
            "endfor",
            "for p in (args[1])",
            "if (p in offs)",
            "elseif (!valid(p))",
            "listing = {@listing, tostr(p, \" <invalid>\")};",
            "elseif ((typeof(i = idle_seconds(p)) != ERR) && (p in connected_players()))",
            "(p in idles) || ((idles = {@idles, p}) && (itimes = {@itimes, {i, connected_seconds(p), p}}));",
            "elseif (typeof(t = p.last_disconnect_time) == NUM)",
            "(offs = {@offs, p}) && (otimes = {@otimes, {-t, -t, p}});",
            "elseif (is_player(p))",
            "listing = {@listing, tostr(p.name, \" (\", p, \") not logged in.\", (t == E_PROPNF) ? \"  Not a $player.\" | \"  Garbled .last_disconnect_time.\")};",
            "else",
            "listing = {@listing, tostr(p.name, \" (\", p, \") is not a player.\")};",
            "endif",
            "endfor",
            "if (!(idles || offs))",
            "return 0;",
            "endif",
            "idles = $list_utils:sort_alist(itimes);",
            "offs = $list_utils:sort_alist(otimes);",
            "headers = {\"Player name\", @idles ? {\"Connected\", \"Idle time\"} | {\"Last disconnect time\", \"\"}, \"Location\"};",
            "total_width = caller:linelen() || 79;",
            "max_name = total_width / 4;",
            "name_width = length(headers[1]);",
            "names = locations = {};",
            "for lst in ({@idles, @offs})",
            "((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);",
            "p = lst[3];",
            "\"p.name and this:ansi_title(p) should be the same length, saves a call to this:length\";",
            "namestr = tostr(this:cutoff(this:ansi_title(p), 1, min(max_name, z = length(p.name)), 1), \" (\", p, \")\");",
            "name_width = max((z + 3) + length(tostr(p)), name_width);",
            "names = {@names, namestr};",
            "(typeof(wlm = p.location:who_location_msg(p)) == STR) || (wlm = valid(p.location) ? p.location.name | tostr(\"** Nowhere ** (\", p.location, \")\"));",
            "locations = {@locations, wlm};",
            "endfor",
            "time_width = offs ? 15 | 13;",
            "before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};",
            "su = $string_utils;",
            "tell1 = headers[1];",
            "tell2 = su:space(tell1, \"-\");",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + headers[j];",
            "tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");",
            "endfor",
            "listing = {@listing, tell1[1..min(length(tell1), total_width)]};",
            "listing = {@listing, tell2[1..min(length(tell2), total_width)]};",
            "\"...\";",
            "\"...print lines...\";",
            "\"...\";",
            "active = 0;",
            "for i in [1..total = (ilen = length(idles)) + length(offs)]",
            "if (i <= ilen)",
            "lst = idles[i];",
            "if (lst[1] < (5 * 60))",
            "active = active + 1;",
            "endif",
            "l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};",
            "else",
            "lct = offs[i - ilen][3].last_connect_time;",
            "ldt = offs[i - ilen][3].last_disconnect_time;",
            "ctime = caller:ctime(ldt) || ctime(ldt);",
            "l = {names[i], (lct <= time()) ? ctime | \"Never\", \"\", locations[i]};",
            "if ((i == (ilen + 1)) && idles)",
            "listing = {@listing, su:space(before[2]) + \"------- Disconnected -------\"};",
            "endif",
            "endif",
            "tell1 = l[1];",
            "for j in [2..4]",
            "tell1 = su:left(tell1, before[j]) + l[j];",
            "endfor",
            "listing = {@listing, this:cutoff(tell1, 1, min(this:length(tell1), total_width))};",
            "if ($command_utils:running_out_of_time())",
            "if ($login:is_lagging())",
            "\"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.\";",
            "listing = {@listing, tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\")};",
            "return;",
            "endif",
            "now = time();",
            "suspend(0);",
            "if ((time() - now) > 10)",
            "listing = {@listing, tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\")};",
            "return;",
            "endif",
            "endif",
            "endfor",
            "\"...\";",
            "\"...epilogue...\";",
            "listing = {@listing, \"\"};",
            "if (total == 1)",
            "active_str = \", who has\" + ((active == 1) ? \"\" | \" not\");",
            "else",
            "if (active == total)",
            "active_str = (active == 2) ? \"s, both\" | \"s, all\";",
            "elseif (active == 0)",
            "active_str = \"s, none\";",
            "else",
            "active_str = tostr(\"s, \", active);",
            "endif",
            "active_str = tostr(active_str, \" of whom ha\", (active == 1) ? \"s\" | \"ve\");",
            "endif",
            "listing = {@listing, tostr(\"Total: \", total, \" player\", active_str, \" been active recently.\")};",
            "vrb = ((caller == $login) || $perm_utils:controls($code_utils:verb_perms(), caller)) ? \"notify\" | \"tell\";",
            "for line in (listing)",
            "caller:(vrb)(line);",
            "((seconds_left() < 2) || (ticks_left() < 4000)) && suspend(0);",
            "endfor",
            "return total;"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":notify (OBJ player, STR line[, extra parameters for notify])\";",
            "set_task_perms(caller_perms());",
            "{plr, line, @extra} = args;",
            "\"...use property_info() instead of $object_utils:isa to save ticks...\";",
            "if (((((index(line, \"[\") && valid(plr)) && property_info(plr, \"ansi_options\")) && this.active) && (!(task_id() in this.noansi_queue))) && (!plr:ansi_option(\"ignore\")))",
            "codes = (typeof(z = plr.replace_codes) == NUM) ? this.replace_code_pointers[z] | z;",
            "esc = plr:ansi_option(\"escape\");",
            "\"... save more ticks here by using 'in' instead of 'ansi_option'...\";",
            "truecolor_enabled = \"truecolor\" in plr.ansi_options;",
            "xterm_256 = \"256\" in plr.ansi_options;",
            "backgrounds = \"backgrounds\" in plr.ansi_options;",
            "while (m = match(line, this.notify_regexp))",
            "z = line[m[1] + 1..m[2] - 1];",
            "if (z in codes)",
            "code = this:get_code(z, esc);",
            "elseif ((!backgrounds) && (z[1..2] == \"b:\"))",
            "code = \"\";",
            "elseif ((z[1..2] == \"b:\") && (z[3..$] in codes))",
            "code = this:get_code(z, esc);",
            "elseif (z == \"random\")",
            "code = this:get_code(this.random_colors[random(length(this.random_colors))], esc);",
            "elseif ((z == \":random\") && xterm_256)",
            "code = this:get_code(tostr(\":\", random(255)), esc, 0, 1);",
            "elseif (xterm_256 && ((z[1] == \":\") || (z[1..3] == \"b::\")))",
            "code = this:get_code(z, esc, 0, 1);",
            "elseif (truecolor_enabled && index(z, \":\"))",
            "code = this:get_code(z, esc, m);",
            "else",
            "code = \"\";",
            "endif",
            "line[m[1]..m[2]] = code;",
            "endwhile",
            "line = strsub(line, \"[null]\", \"\");",
            "endif",
            "return notify(plr, line, @extra);"
          ]
        },
        {
          "name": "add_noansi",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":add_noansi()\";",
            "\"Called by tasks to tell players to ignore any ANSI codes from them.\";",
            "\"Can be undone with a call to :remove_noansi\";",
            "if ((length(this.noansi_queue) > 30) && (!$code_utils:task_valid(this.noansi_task)))",
            "fork tid (0)",
            "this:cleanup_noansi();",
            "endfork",
            "this.noansi_task = tid;",
            "endif",
            "this.noansi_queue = setadd(this.noansi_queue, task_id());"
          ]
        },
        {
          "name": "remove_noansi",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":remove_noansi()\";",
            "\"Start translating the ANSI codes from the current task again\";",
            "this.noansi_queue = setremove(this.noansi_queue, task_id());"
          ]
        },
        {
          "name": "tell",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "return;"
          ]
        },
        {
          "name": "self_diagnostic",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":self_diagnostic ([NUM fix[, OBJ plyr]]) => NUM errors fixed\";",
            "\"Reports all errors found to <plyr> or the current player.\";",
            "\"Fixes any errors it can if <fix> is specified and true.\";",
            "\"<errors fixed> is the errors that could have been fixed if <fix> is false.\";",
            "if (!this:trusts(caller_perms()))",
            "return E_PERM;",
            "else",
            "count = 0;",
            "for x in (this.diagnostic_tests)",
            "player:tell(\"Running test \\\"\", x, \"\\\"...\");",
            "count = count + (!(!this:(\"test_\" + x)(@args)));",
            "endfor",
            "return count;",
            "endif"
          ]
        },
        {
          "name": "trusts",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":trusts (OBJ player) => true of <player> is trusted by the ANSI system.\";",
            "return (args[1].wizard || (args[1] == this.owner)) || (args[1] in this.trusted);"
          ]
        },
        {
          "name": "cutoff_locs",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":cutoff_locs (STR string,NUM start,NUM end[,NUM extra][, NUM suspendok])\";",
            "\"                                                       => {nstart, nend}\";",
            "\"Takes <start> and <end>, fixes them to compensate for the ANSI codes, and\";",
            "\"returns them.  If <extra> is provided and true, <nend> will include the\";",
            "\"codes after the ending letter.\";",
            "start = args[2];",
            "end = args[3];",
            "if (typeof(string = args[1]) != STR)",
            "return E_INVARG;",
            "elseif (!(index(string, \"[\") && this.active))",
            "return {start, (end == \"$\") ? length(string) | end};",
            "elseif (start > end)",
            "return args[2..3];",
            "endif",
            "i = begin = 0;",
            "x = 1;",
            "extra = {@args, 0}[4];",
            "reg = this.all_regexp;",
            "l = length(string);",
            "suspendok = {@args, 0}[5];",
            "while (x <= l)",
            "((suspendok && ((ticks_left() < 1000) || (seconds_left() < 2))) && player:tell(\"suspending...\")) && suspend(0);",
            "if (m = match(string, reg))",
            "i = i + (m[1] - 1);",
            "if ((!begin) && ((i + 1) >= start))",
            "begin = (((x + m[1]) - i) + start) - 2;",
            "if (end == \"$\")",
            "return {begin, l};",
            "endif",
            "endif",
            "if (begin && ((i - extra) >= end))",
            "return {begin, (((x + m[1]) - i) + end) - 2};",
            "endif",
            "x = x + m[2];",
            "string[1..m[2]] = \"\";",
            "else",
            "return {begin || (((x - i) + start) - 1), (end == \"$\") ? l | (((x - i) + end) - 1)};",
            "endif",
            "endwhile",
            "return ((end == i) && begin) ? {begin, l} | E_RANGE;"
          ]
        },
        {
          "name": "cleanup_noansi",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "while (this.noansi_queue && (!$command_utils:running_out_of_time()))",
            "x = this.noansi_queue[1];",
            "if (!$code_utils:task_valid(x))",
            "this.noansi_queue = setremove(this.noansi_queue, x);",
            "endif",
            "endwhile"
          ]
        },
        {
          "name": "test_benchmark",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "else",
            "new = $recycler:_create($ansi_pc);",
            "if (typeof(new) != OBJ)",
            "return player:tell(\"Unable to create Benchmark test player: \", new);",
            "endif",
            "new:set_name(\"Benchmark_test_player\");",
            "suspend(0);",
            "ticks = ticks_left();",
            "seconds = seconds_left();",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].\");",
            "endfor",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.\");",
            "endfor",
            "ticks = ticks - ticks_left();",
            "seconds = seconds - seconds_left();",
            "new:set_ansi_option(\"colors\", 1);",
            "new:set_ansi_option(\"escape\", \"~\");",
            "new:set_ansi_option(\"misc\", 1);",
            "ticks = ticks + ticks_left();",
            "seconds = seconds + seconds_left();",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].\");",
            "endfor",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.\");",
            "endfor",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"Testing...\");",
            "endfor",
            "this:add_noansi();",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].\");",
            "endfor",
            "for x in [1..3]",
            "$ansi_utils:notify(new, \"[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.\");",
            "endfor",
            "this:remove_noansi();",
            "ticks = ticks - ticks_left();",
            "seconds = seconds - seconds_left();",
            "$recycler:_recycle(new);",
            "player:tell(\"21 notifies: \", ticks, \" tick\", (ticks == 1) ? \"\" | \"s\", \", \", seconds, \" second\", (seconds == 1) ? \"\" | \"s\", \".\");",
            "endif"
          ]
        },
        {
          "name": "cutoff_assign",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":cutoff_assign (STR string, NUM start, NUM end, STR replacement[, NUM extra])\";",
            "\"                                => STR\";",
            "\"Example:\";",
            "\"  string[2..3] = \\\"test\\\";\";",
            "\"Is the same as:\";",
            "\"  string = $ansi_utils:cutoff_assign(string, 2, 3, \\\"test\\\");\";",
            "\"Except that it ignores the ANSI codes in <string> when finding <start> and\";",
            "\"<end>.  If <extra> is specified and true, any codes after <end> but before\";",
            "\"the next character will also be overwritten.\";",
            "if (typeof(a = this:cutoff_locs(@listdelete(args, 4))) == LIST)",
            "args[1][a[1]..a[2]] = args[4];",
            "return args[1];",
            "else",
            "return a;",
            "endif"
          ]
        },
        {
          "name": "setadd",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":setadd (LIST l, value) => LIST\";",
            "\"Does the same thing as the built-in setadd(), but if <value> is a string,\";",
            "\"it won't be added to <l> if <value> with it's ANSI codes stripped out equals\";",
            "\"any of <l>'s elements with their ANSI codes stripped out.\";",
            "l = args[1];",
            "if ((typeof(value = args[2]) == STR) && this:contains_codes(value))",
            "nvalue = this:delete(value);",
            "for x in (l)",
            "if ((typeof(x) == STR) && (this:delete(x) == nvalue))",
            "return l;",
            "endif",
            "endfor",
            "endif",
            "return setadd(l, value);"
          ]
        },
        {
          "name": "setremove",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":setremove (LIST l, value) => LIST\";",
            "\"Does the same thing as the built-in setremove(), but if <value> is a\";",
            "\"string, it will remove any string in <l> that, when it's ANSI codes are\";",
            "\"stripped out, is equal to <value> with it's ANSI codes stripped out.\";",
            "l = args[1];",
            "if ((typeof(value = args[2]) != STR) || (!this:contains_codes(value)))",
            "return setremove(l, value);",
            "endif",
            "nvalue = this:delete(value);",
            "for x in [-length(l)..-1]",
            "x = -x;",
            "if ((typeof(l[x]) == STR) && (this:delete(l[x]) == nvalue))",
            "l = listdelete(l, x);",
            "endif",
            "endfor",
            "return l;"
          ]
        },
        {
          "name": "ansi_status",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "mess = {};",
            "mess = {@mess, tostr(\"ANSI Version \", this.version, \":\")};",
            "a = 0;",
            "for x in (this.groups)",
            "a = a + length(this.(\"group_\" + x));",
            "endfor",
            "mess = {@mess, tostr(\"It is \", this.active ? \"currently\" | \"not\", \" active.  There are \", $string_utils:english_number(a), \" codes defined in \", $string_utils:english_number(length(this.groups)), \" groups.  There \", (length(this.noansi_queue) == 1) ? \"is\" | \"are\", \" \", $string_utils:english_number(length(this.noansi_queue)), \" tasks in the ignore ANSI task queue, and the cleanup task is \", $code_utils:task_valid(this.noansi_queue) ? \"currently\" | \"not\", \" running.\")};",
            "return mess;"
          ]
        },
        {
          "name": "terminate_normal",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":terminate_normal (STR string) => STR <string> with a [[null]normal] code\";",
            "\"tacked onto the end if there wasn't one\";",
            "if (!index(string = args[1], \"[\"))",
            "return string;",
            "endif",
            "m = rmatch(string, this.terminate_regexp);",
            "while ((string && m) && (m[2] == length(string)))",
            "string = string[1..m[1] - 1];",
            "m = rmatch(string, this.terminate_regexp);",
            "endwhile",
            "return string && (string + ((m && (string[m[1]..m[2]] != \"[normal]\")) ? \"[normal]\" | \"\"));"
          ]
        },
        {
          "name": "left",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"$ansi_utils:left(string,width[,filler])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";",
            "\"\";",
            "\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";",
            "return this:terminate_normal(z = ((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? out + this:space(l - len, ((length(args) >= 3) && args[3]) || \" \") | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));"
          ]
        },
        {
          "name": "right",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"$ansi_utils:right(string,width[,filler])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width>.\";",
            "\"\";",
            "\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";",
            "return this:terminate_normal(((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? this:space(len - l, ((length(args) >= 3) && args[3]) || \" \") + out | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));"
          ]
        },
        {
          "name": "centre center",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"$ansi_utils:center(string,width[,lfiller[,rfiller]])\";",
            "\"\";",
            "\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";",
            "\"\";",
            "\"The <lfiller> is optional and defaults to \\\" \\\"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.\";",
            "return this:terminate_normal(((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? tostr(this:space((len - l) / 2, lfill = ((length(args) >= 3) && args[3]) || \" \"), out, this:space(((len - l) + 1) / -2, (length(args) >= 4) ? args[4] | lfill)) | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));"
          ]
        },
        {
          "name": "columnize columnise",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.\";",
            "items = args[1];",
            "n = args[2];",
            "width = {@args, 79}[3];",
            "height = ((length(items) + n) - 1) / n;",
            "items = {@items, @$list_utils:make((height * n) - length(items), \"\")};",
            "colwidths = {};",
            "for col in [1..n - 1]",
            "colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));",
            "endfor",
            "result = {};",
            "for row in [1..height]",
            "line = tostr(items[row]);",
            "for col in [1..n - 1]",
            "line = tostr(this:terminate_normal(this:left(line, colwidths[col])), \" \", items[row + (col * height)]);",
            "endfor",
            "result = listappend(result, this:terminate_normal(this:cutoff(line, 1, min(this:length(line), width))));",
            "endfor",
            "return result;"
          ]
        },
        {
          "name": "space",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.\";",
            "n = args[1];",
            "(typeof(n) == STR) && (n = this:length(n));",
            "if (\" \" != (fill = {@args, \" \"}[2]))",
            "fill = fill + fill;",
            "fill = fill + fill;",
            "fill = fill + fill;",
            "elseif ((n = abs(n)) < 70)",
            "return \"                                                                      \"[1..n];",
            "else",
            "fill = \"                                                                      \";",
            "endif",
            "m = (n - 1) / this:length(fill);",
            "while (m)",
            "fill = fill + fill;",
            "m = m / 2;",
            "endwhile",
            "return (n > 0) ? this:cutoff(fill, 1, n) | this:cutoff(fill, ((f = this:length(fill)) + 1) + n, f);"
          ]
        },
        {
          "name": "ansi_title",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 99,
          "code": [
            "\":ansi_title (OBJ player[, STR name]) => STR <player>'s title\";",
            "\"If <name> is specified, it will be used instead of <player>.name\";",
            "name = {@args, args[1].name}[2];",
            "for x in (args[1].ansi_title)",
            "if (typeof(x[2]) == LIST)",
            "nn = x[2][random(length(x[2]))];",
            "else",
            "nn = x[2];",
            "endif",
            "nn && (name = strsub(name, x[1], nn));",
            "endfor",
            "return name;"
          ]
        },
        {
          "name": "strip_black",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "gray = 0;",
            "x = 1;",
            "string = args[1];",
            "l = length(string);",
            "while ((x <= l) && (m = match(string[x..l], this.all_regexp)))",
            "code = string[x + m[1]..(x + m[2]) - 2];",
            "if (code in {\"gray\", \"grey\"})",
            "gray = 1;",
            "elseif (code in this.group_colors)",
            "gray = 0;",
            "elseif (gray && (code == \"unbold\"))",
            "string[x + m[2]..(x + m[2]) - 1] = \"[white]\";",
            "x = x + 7;",
            "endif",
            "x = x + m[2];",
            "endwhile",
            "return string;"
          ]
        },
        {
          "name": "quote_ansi",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":quote_ansi (STR string) => STR new_string\";",
            "\"Puts a [[null]null] code in the middle of all of the other codes in <string>\";",
            "\"so they won't be replaced.\";",
            "return strsub(args[1], \"[\", \"[[null]\");",
            "\"...should probably only fix real codes, but this works for now...\";"
          ]
        },
        {
          "name": "update_player_codes",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\":update_player_codes (OBJ player)\";",
            "\"Updates <player>'s .replace_codes property\";",
            "if (!this:trusts(caller_perms()))",
            "return E_PERM;",
            "elseif ($object_utils:isa(plr = args[1], $ansi_pc))",
            "codes = {};",
            "for x in (this.groups)",
            "if (plr:ansi_option(x))",
            "codes = {@codes, @this.(\"group_\" + x)};",
            "(x == \"extra\") || (codes = setadd(codes, \"normal\"));",
            "endif",
            "endfor",
            "return plr.replace_codes = (codes in this.replace_code_pointers) || codes;",
            "endif"
          ]
        },
        {
          "name": "fill_string",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"fill(string,width[,prefix])\";",
            "\"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.\";",
            "if (length(args) < 2)",
            "width = 2 + player:linelen();",
            "prefix = \"\";",
            "else",
            "width = args[2] + 1;",
            "prefix = {@args, \"\"}[3];",
            "endif",
            "if (width < (3 + length(prefix)))",
            "return E_INVARG;",
            "endif",
            "string = (\"$\" + args[1]) + \" $\";",
            "len = this:length(string);",
            "if (len <= width)",
            "last = len - 1;",
            "next = len;",
            "else",
            "last = this:rindex(this:cutoff(string, 1, width), \" \");",
            "if (last < ((width + 1) / 2))",
            "last = width + this:index(this:cutoff(string, width + 1, \"$\", 1), \" \");",
            "endif",
            "next = last;",
            "while (string[next = next + 1] == \" \")",
            "endwhile",
            "endif",
            "while (string[last = last - 1] == \" \")",
            "endwhile",
            "ret = {this:cutoff(string, 2, last)};",
            "width = width - length(prefix);",
            "minlast = (width + 1) / 2;",
            "while (next < len)",
            "string = this:cutoff_assign(string, 1, next - 1, \"$\");",
            "\"string = \\\"$\\\" + string[next..len];\";",
            "len = (len - next) + 2;",
            "if (len <= width)",
            "last = len - 1;",
            "next = len;",
            "else",
            "last = this:rindex(this:cutoff(string, 1, width), \" \");",
            "if (last < minlast)",
            "last = width + this:index(this:cutoff(string, width + 1, \"$\", 1), \" \");",
            "endif",
            "next = last;",
            "while (string[next = next + 1] == \" \")",
            "endwhile",
            "endif",
            "while (string[last = last - 1] == \" \")",
            "endwhile",
            "if (last > 1)",
            "ret = {@ret, prefix + this:cutoff(string, 2, last)};",
            "endif",
            "endwhile",
            "return ret;"
          ]
        },
        {
          "name": "@ansi-setup",
          "owner": 2,
          "perms": 37,
          "preps": -1,
          "object": 99,
          "code": [
            "\"Usage:  @ansi-setup <this>\";",
            "\"Used to fix various core utilities to work with ANSI. This verb can only be used by a wizard, and needs wizperms to run.\";",
            "\"Ugh, this verb is getting out of control, this stuff should all be moved to diagnostic tests.\";",
            "if (!player.wizard)",
            "player:tell(\"This verb was intended to fix up the rest of a MOO's core so it can function properly with the ANSI PC. If something's wrong, ask a wizard to set this up for you.\");",
            "elseif (!$code_utils:verb_perms().wizard)",
            "player:tell(\"This verb needs to be wizpermed before it can work.\");",
            "elseif (!$command_utils:yes_or_no(\"This will change various verbs in the core so they can be used with the ANSI PC, overwriting the previous verbs. Are you sure you want to do this?\"))",
            "player:notify(\"Well, okay then.\");",
            "else",
            "set_task_perms(valid(cp = caller_perms()) ? cp | player);",
            "spiffy = 1;",
            "\"----== Corify Objects ==----\";",
            "for x in ({\"help\", \"pc\", \"utils\", \"options\"})",
            "prop = \"ansi_\" + x;",
            "if (!$object_utils:has_property($sysobj, prop))",
            "add_property($sysobj, prop, #-1, {player, \"r\"});",
            "player:notify(tostr(\"Creating a $\", prop, \" property.\"));",
            "endif",
            "if (valid($sysobj.(prop)))",
            "elseif (x == \"utils\")",
            "player:notify(tostr(\"Setting $\", prop, \" to \", $string_utils:nn(this), \".\"));",
            "$sysobj.(prop) = this;",
            "else",
            "objects = {};",
            "for o in ({@player.owned_objects || {}, @player.public_identity.owned_objects || {}, @player.contents || {}, @player.location.contents || {}})",
            "if (index(o.name, \"ANSI\") && index(o.name, strsub(x, \"s\", \"\")))",
            "objects = setadd(objects, o);",
            "endif",
            "endfor",
            "if (!objects)",
            "return player:notify(tostr(\"Unable to find $\", prop, \", please port this object and set #0.\", prop, \" to it's object number. If you created a new player to own ANSI objects, you might want to temporarily set your .public_identity property to that player and rerun this verb. Remember to reset the property when you're done.\"));",
            "elseif (length(objects) == 1)",
            "player:notify(tostr(\"Setting $\", prop, \" to \", $string_utils:nn(objects[1]), \".\"));",
            "$sysobj.(prop) = objects[1];",
            "else",
            "return player:notify(tostr(\"Found \", length(objects), \" objects that could be $\", prop, \", please set #0.\", prop, \" to the object number of the correct one:  \", $string_utils:nn_list(objects)));",
            "endif",
            "endif",
            "endfor",
            "\"----== Wizperm everything that should be ==----\";",
            "for x in (this.need_wizperms)",
            "if (!(info = verb_info(y = $sysobj.(x[1]), x[2]))[1].wizard)",
            "player:notify(tostr(\"Wizperming $\", x[1], \":\", x[2], \"...\"));",
            "set_verb_info(y, x[2], listset(info, player, 1));",
            "endif",
            "endfor",
            "if (!($ansi_help in ((typeof(ah = $ansi_pc.help) == LIST) ? ah | {ah})))",
            "player:notify(\"Setting $ansi_pc.help...\");",
            "$ansi_pc.help = $ansi_help;",
            "endif",
            "\"----== Various core hacks ==----\";",
            "su = $string_utils;",
            "if (!$object_utils:has_callable_verb(su, \"redirect_ansi\"))",
            "player:notify(\"Adding $string_utils:redirect_ansi...\");",
            "add_verb(su, {$hacker, \"rx\", \"redirect_ansi\"}, {\"this\", \"none\", \"this\"});",
            "set_verb_code(su, \"redirect_ansi\", this.redirect_su_code);",
            "endif",
            "for x in (this.redirect_su_names)",
            "if ((info = verb_info(su, x)) && (!index(info[3], \"redirect_ansi\")))",
            "nn = \"\";",
            "for y in ($string_utils:explode(info[3], \" \"))",
            "nn = tostr(nn, \" \", y, \"(noansi)\");",
            "endfor",
            "set_verb_info(su, x, listset(info, $string_utils:triml(nn), 3));",
            "player:notify(tostr(\"Renaming $string_utils:\\\"\", info[3], \"\\\" to \\\"\", nn, \"\\\"...\"));",
            "endif",
            "endfor",
            "redirect = $string_utils:from_list({\"redirect_ansi\", @this.redirect_su_names}, \" \");",
            "if ((info = verb_info(su, \"redirect_ansi\"))[3] != redirect)",
            "player:notify(tostr(\"Renaming $string_utils:redirect_ansi to \\\"\", redirect, \"\\\".\"));",
            "set_verb_info(su, \"redirect_ansi\", listset(info, redirect, 3));",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "((!((length(vc = verb_code($login, \"notify\")) == 2) && index(vc[2], \"$ansi_utils:delete\"))) && $command_utils:yes_or_no(\"Update $login:notify?\")) ? set_verb_code($login, \"notify\", {\"(caller!=$ansi_utils)&&set_task_perms(caller_perms());notify(player,$ansi_utils:delete(args[1]));\"}) || player:notify(\"$login:notify changed.\") | ((spiffy = 0) || player:notify(\"$login:notify left alone.\"));",
            "thatline = \"line[1..min(width, length(line))]\";",
            "newline = \"$ansi_utils:cutoff(line,1,min(width,$ansi_utils:length(line)))\";",
            "for x in ({\"mail_agent\", \"big_mail_recipient\"})",
            "vc = $string_utils:print(verb_code(y = $sysobj.(x), vn = \"display_seq_headers\"));",
            "player:notify(tostr(\"$\", x, \":\", vn, \" \", ((index(vc, thatline) && $command_utils:yes_or_no(tostr(\"Replace \\\"\", thatline, \"\\\" in $\", x, \":\", vn, \" with \\\"\", newline, \"\\\"?\"))) && (set_verb_code(y, vn, $string_utils:to_value(strsub(vc, thatline, newline))[2]) == {})) ? \"changed.\" | ((spiffy = 0) || \"left alone.\")));",
            "endfor",
            "code = {};",
            "for x in (verb_code($login, \"@who\"))",
            "code = {@code, strsub(x, \"$code_utils:show_who_listing\", \"$ansi_utils:show_who_listing\")};",
            "endfor",
            "if (code != verb_code($login, \"@who\"))",
            "player:notify(\"Setting $login:@who...\");",
            "set_verb_code($login, \"@who\", code);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "code = {};",
            "for x in (verb_code($guest, \"do_reset\", 0, 0))",
            "if ((m = match(x, \"^for x in (%(%{.+%}%))$\")) && (info = $string_utils:to_value(substitute(\"%1\", m)))[1])",
            "x = tostr(\"for x in (\", $string_utils:print($set_utils:union(info[2], $ansi_utils.reset_guest_props)), \")\");",
            "endif",
            "code = {@code, x};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (code != verb_code($guest, \"do_reset\", 0, 0))",
            "player:notify(\"Setting $guest:do_reset...\");",
            "set_verb_code($guest, \"do_reset\", code);",
            "endif",
            "code = {};",
            "for x in (verb_code($prog, \"@list\", 0, 0))",
            "if (code == 0)",
            "elseif (index(x, \"$ansi_utils:add_noansi(\"))",
            "code = 0;",
            "elseif (index(x, \"player:notify(tostr(what, \\\":\\\", fullname, \\\"\") == 1)",
            "code = {@code, \"$ansi_utils:add_noansi();\", x};",
            "else",
            "code = {@code, x};",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "if (code && (code != verb_code($prog, \"@list\", 0, 0)))",
            "player:notify(\"Setting $prog:@list...\");",
            "set_verb_code($prog, \"@list\", code);",
            "endif",
            "code = {};",
            "a = {0, 0};",
            "for x in (verb_code($generic_editor, \"list_line\"))",
            "a[1] = a[1] || index(x, \"$ansi_utils:add_noansi(\");",
            "a[2] = a[2] || index(x, \"$ansi_utils:remove_noansi(\");",
            "code = {@code, x};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "a[1] || (code = {\"$ansi_utils:add_noansi();\", @code});",
            "a[2] || (code = {@code, \"$ansi_utils:remove_noansi();\"});",
            "if (code != verb_code($generic_editor, \"list_line\"))",
            "player:notify(\"Setting $generic_editor:list_line...\");",
            "set_verb_code($generic_editor, \"list_line\", code);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "if (!$object_utils:defines_verb($player_db, \"insert\"))",
            "player:notify(\"Adding $player_db:insert...\");",
            "add_verb($player_db, {player, \"rxd\", \"insert\"}, {\"this\", \"none\", \"this\"});",
            "set_verb_code($player_db, \"insert\", this.plr_db_insert);",
            "elseif (verb_code($player_db, \"insert\") != this.plr_db_insert)",
            "player:notify(\"$player_db:insert already exists, you will have to edit it manually for the ANSI, see $ansi_utils.plr_db_insert for sample code.\");",
            "endif",
            "if (verb_code($generic_editor, \"fill_string\") != this.ge_fill_string)",
            "a = \"\";",
            "while ($object_utils:has_verb($generic_editor, vname = tostr(\"fill_string(noansi\", a, \")\")))",
            "a = toint(a) + 1;",
            "endwhile",
            "set_verb_info($generic_editor, \"fill_string\", listset(verb_info($generic_editor, \"fill_string\"), vname, 3));",
            "add_verb($generic_editor, {player, \"rx\", \"fill_string\"}, {\"this\", \"none\", \"this\"}) || player:notify(\"Adding new $generic_editor:fill_string...\");",
            "set_verb_code($generic_editor, \"fill_string\", this.ge_fill_string);",
            "endif",
            "\"...ugh, I want to put $prog:@dump in here but the one I put on NestMOO is too big to search...\";",
            "\"----== Set the non-printable characters ==----\";",
            "$command_utils:suspend_if_needed(0);",
            "for x in ({{\"escape\", 27, \"033\"}, {\"beep\", 7, \"007\"}})",
            "chr = x[1];",
            "code = x[2];",
            "octal = x[3];",
            "if ((typeof(this.(chr)) != STR) || (length(this.(chr)) != 1))",
            "if (eval(\";return chr(64);\")[1])",
            "player:notify(tostr(\"Setting $ansi_utils.\", chr, \" with chr()...\"));",
            "eval(tostr(\";$ansi_utils.(\\\"\", chr, \"\\\")=chr(\", code, \");\"));",
            "elseif ((eval = eval(\";return filelist(\\\"\\\", \\\"\\\");\"))[1] || (eval = eval(\";return file_list(\\\"\\\");\"))[1])",
            "files = (typeof(eval[2][1]) == LIST) ? eval[2][1] | eval[2];",
            "if ((chr + \".chr\") in files)",
            "player:notify(tostr(\"Setting $ansi_utils.\", chr, \" from file \", chr, \".chr...\"));",
            "if (typeof(eval[2][1]) == LIST)",
            "\"Setup for FUP\";",
            "eval(tostr(\";$ansi_utils.(\\\"\", chr, \"\\\")=fileread(\\\"\\\", \\\"\", chr, \".chr\\\")[1];\"));",
            "else",
            "\"Setup for FIO\";",
            "handle = file_open(tostr(\"/\", chr, \".chr\"), \"r-tn\");",
            "$ansi_utils.(chr) = file_readline(handle);",
            "file_close(handle);",
            "endif",
            "else",
            "player:notify(tostr(\"File builtin detected, please create a file named \\\"\", chr, \".chr\\\" in the files directory and put an ASCII character \", code, \" in it.  This can be done on most systems with the command:  echo -e '\\\\\", octal, \"' > \", chr, \".chr  from the files directory.\"));",
            "spiffy = 0;",
            "endif",
            "else",
            "z = this.(chr) = tostr(\"<----- \", $string_utils:uppercase(chr), \" ----->\");",
            "player:notify(tostr(\"I can't find any way to set $ansi_utils.\", chr, \", please either install the FUP, FileIO, or chr() server patches and rerun this verb, or shut down the MOO, load the DB into an editor, and replace \\\"\", z, \"\\\" with an ASCII character \", code, \".\"));",
            "spiffy = 0;",
            "endif",
            "endif",
            "endfor",
            "if (this.active)",
            "player:notify(\"@ansi-setup finished.\");",
            "elseif (!spiffy)",
            "player:notify(\"@ansi-setup can not verify that everything has been set up correctly, you will probably have to rerun this verb.  If you're sure everything is correct, you can type:  ;;$ansi_utils.active=1;  to activate it.\");",
            "elseif ($command_utils:yes_or_no(\"Everything seems to be set up correctly, activate the ANSI system?\"))",
            "this.active = 1;",
            "\"...raw notify() the first message in case it breaks, we're wizpermed anyway...\";",
            "notify(player, \"The ANSI system is now active, it can be deactivated by typing: ;;$ansi_utils.active = 0;\");",
            "player:notify(tostr(\"Welcome to ANSI version \", this.version, \".\"));",
            "else",
            "player:notify(\"Not activating the ANSI system, you can do this manually by typing: ;;$ansi_utils.active = 1;  when you're sure everything's set up correctly.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "approximate_256",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"Attempt to downscale a 24-bit RGB color into an 8-bit 256 color.\";",
            "\"Disclaimer: Looks terrible.\";",
            "{r, g, b} = args;",
            "red = (toint(r) * 8) / 256;",
            "green = (toint(g) * 8) / 256;",
            "blue = (toint(b) * 7) / 256;",
            "ret = ((red << 5) |. (green << 2)) |. blue;",
            "return ret;"
          ]
        },
        {
          "name": "color_selector",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "{?raw = 0, ?input = 0, ?foreground_color = 0} = args;",
            "colors = {\"Red\", \"Green\", \"Blue\", \"Yellow\", \"Cyan\", \"Purple\", \"Gray\", \"White\"};",
            "backgrounds = {\"Red\", \"Green\", \"Blue\", \"Yellow\", \"Cyan\", \"Purple\", \"White\"};",
            "menu = codes = {};",
            "for x in (colors)",
            "if (!foreground_color)",
            "menu = {@menu, tostr(this:hr_to_code(code = x), x, \"[normal]\")};",
            "codes = {@codes, code};",
            "menu = {@menu, tostr(this:hr_to_code(code = \"bold|\" + x), \"Bold \", x, \"[normal]\")};",
            "codes = {@codes, code};",
            "endif",
            "if (x in backgrounds)",
            "menu = {@menu, tostr(this:hr_to_code(code = \"b:\" + x), (x == \"white\") ? \"[gray]\" | (foreground_color ? this:Hr_to_code(foreground_color) | \"[white]\"), \"Background \", x, \"[normal]\")};",
            "codes = {@codes, code};",
            "endif",
            "endfor",
            "menu = {@menu, xterm = \"Xterm 256 Value\"};",
            "if (player:ansi_option(\"truecolor\"))",
            "menu = {@menu, rgb = \"24-bit [red]R[normal][green]G[normal][blue]B[normal] Value\"};",
            "endif",
            "menu = {@menu, \"None\"};",
            "sel = $menu_utils:menu(menu, [\"hidden_menu\" -> input, \"input\" -> input]);",
            "if (sel in {0, -1})",
            "return 0;",
            "elseif (sel <= length(codes))",
            "retcode = codes[sel];",
            "if (retcode[1..2] == \"b:\")",
            "retcode = ((foreground_color ? foreground_color | \"white\") + \"|\") + retcode;",
            "endif",
            "if (raw)",
            "return $ansi_utils:hr_to_code(retcode);",
            "else",
            "return retcode;",
            "endif",
            "elseif (menu[sel] == \"none\")",
            "return \"\";",
            "elseif (menu[sel] == xterm)",
            "player:tell(\"Please input an Xterm 256 value in between 0-255.\");",
            "val = $command_utils:read();",
            "xtermint = $code_utils:toint(val);",
            "if (((xtermint == E_TYPE) || (xtermint > 255)) || (xtermint < 0))",
            "return player:tell(\"Invalid input. You must enter a number that is in between 0 and 255.\");",
            "endif",
            "if (raw)",
            "return tostr(\"[:\", xtermint, \"]\");",
            "else",
            "return tostr(\":\", xtermint);",
            "endif",
            "elseif (menu[sel] == rgb)",
            "red = green = blue = 0;",
            "invalidmsg = \"Invalid color value.\";",
            "while (((!red) || (!green)) || (!blue))",
            "if (!red)",
            "player:tell(\"Enter a [red]red[normal] value between 0 and 255:\");",
            "red = toint($command_utils:read());",
            "if ((red < 0) || (red > 255))",
            "player:tell(invalidmsg);",
            "red = 0;",
            "continue;",
            "endif",
            "endif",
            "if (!green)",
            "player:tell(\"Enter a [green]green[normal] value between 0 and 255:\");",
            "green = toint($command_utils:read());",
            "if ((green < 0) || (green > 255))",
            "player:tell(invalidmsg);",
            "green = 0;",
            "continue;",
            "endif",
            "endif",
            "if (!blue)",
            "player:tell(\"Enter a [blue]blue[normal] value between 0 and 255:\");",
            "blue = toint($command_utils:read());",
            "if ((blue < 0) || (blue > 255))",
            "player:tell(invalidmsg);",
            "blue = 0;",
            "continue;",
            "endif",
            "endif",
            "endwhile",
            "if (raw)",
            "return tostr(\"[\", red, \":\", green, \":\", blue, \"]\");",
            "else",
            "return tostr(red, \":\", green, \":\", blue);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "hr_to_code",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 99,
          "code": [
            "\"$ansi_utils:hr_to_code(colorstr) - Converts a human readable color sequence to a properly formatted escape code.\";",
            "{colorstr} = args;",
            "if (colorstr in {0, \"\"})",
            "return E_INVARG;",
            "endif",
            "if (colorstr[1] == \"[\")",
            "colorstr = colorstr[2..$ - 1];",
            "endif",
            "if (index(colorstr, \"|\"))",
            "ret = \"\";",
            "for x in ($string_utils:explode(colorstr, \"|\"))",
            "ret = ((ret + \"[\") + x) + \"]\";",
            "endfor",
            "else",
            "ret = (\"[\" + colorstr) + \"]\";",
            "endif",
            "return ret;",
            "\"Last modified 11/01/18 1:38 a.m. by Sinistral (#2)\";"
          ]
        }
      ],
      "propnames": [
        "escape",
        "code_red",
        "code_green",
        "code_yellow",
        "code_blue",
        "code_purple",
        "code_cyan",
        "code_normal",
        "code_inverse",
        "code_underline",
        "code_bold",
        "code_b:black",
        "code_b:red",
        "code_b:green",
        "code_b:yellow",
        "code_b:blue",
        "code_b:magenta",
        "code_b:purple",
        "code_b:cyan",
        "code_b:white",
        "beep",
        "code_bright",
        "group_colors",
        "group_bold",
        "code_unbold",
        "group_misc",
        "code_blink",
        "code_unblink",
        "group_blinking",
        "code_magenta",
        "code_unbright",
        "groups",
        "code_white",
        "noansi_task",
        "all",
        "all_regexp",
        "group_colors_regexp",
        "group_bold_regexp",
        "group_misc_regexp",
        "group_blinking_regexp",
        "truecolor_regexp",
        "version",
        "code_gray",
        "code_grey",
        "test_screen",
        "extra_codes",
        "active",
        "random_colors",
        "ansi_log",
        "noansi_queue",
        "need_wizperms",
        "code_beep",
        "status_message",
        "trusted",
        "diagnostic_tests",
        "redirect_su_names",
        "redirect_su_code",
        "default_codes",
        "code_null",
        "code_random",
        "group_extra",
        "group_extra_regexp",
        "terminate_regexp",
        "replace_code_pointers",
        "notify_regexp",
        "reset_guest_props",
        "ge_fill_string",
        "plr_db_insert",
        "xterm_256_regexp"
      ],
      "propdefs": [
        {
          "value": "\u001b",
          "owner": 98,
          "perms": 0
        },
        {
          "value": "e[31m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[32m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[33m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[34m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[35m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[36m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[0m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[7m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[4m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[1m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[40m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[41m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[42m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[43m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[44m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[45m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[45m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[46m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[47m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "\u0007",
          "owner": 98,
          "perms": 0
        },
        {
          "value": "e[1m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "red",
            "green",
            "yellow",
            "blue",
            "purple",
            "cyan",
            "gray",
            "grey",
            "magenta",
            "white"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "bold",
            "unbold",
            "bright",
            "unbright"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[22m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "underline",
            "inverse"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[5m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[25m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "blink",
            "unblink"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[35m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[22m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "bold",
            "colors",
            "misc",
            "blinking",
            "extra"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[37m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": 828515096,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "random",
            "normal",
            "null",
            "bold",
            "unbold",
            "bright",
            "unbright",
            "red",
            "green",
            "yellow",
            "blue",
            "purple",
            "cyan",
            "gray",
            "grey",
            "magenta",
            "white",
            "underline",
            "inverse",
            "blink",
            "unblink",
            "beep"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(b:%)?%(random%|normal%|null%|bold%|unbold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%|underline%|inverse%|blink%|unblink%|beep%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(bold%|unbold%|bright%|unbright%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(underline%|inverse%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(blink%|unblink%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%([0-9]+%):%([0-9]+%):%([0-9]+%)",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "2.6",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[1;30m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "e[1;30m",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Colors        [red]red[normal]          Bold Colors   [bold][red]red[normal]",
            "              [green]green[normal]                      [bold][green]green[normal]",
            "              [blue]blue[normal]                       [bold][blue]blue[normal]",
            "              [yellow]yellow[normal]                     [bold][yellow]yellow[normal]",
            "              [cyan]cyan[normal]                       [bold][cyan]cyan[normal]",
            "              [purple]purple[normal]                     [bold][purple]purple[normal]",
            "              [gray]gray[normal]                       [bold][gray]gray[normal]",
            "              [white]white[normal]                      [bold][white]white[normal]",
            "",
            "Backgrounds   [b:red][gray]red[normal]          True Color    [128:0:0]maroon[normal]",
            "              [b:green][gray]green[normal]                      [153:255:180]light green[normal]",
            "              [b:blue][gray]blue[normal]                       [153:204:255]light blue[normal]",
            "              [b:yellow][gray]yellow[normal]                     [255:255:153]funky banana[normal]",
            "              [b:cyan][gray]cyan[normal]                       [0:102:102]dark cyan[normal]",
            "              [b:purple][gray]purple[normal]                     [255:204:242]light purple[normal]",
            "              [b:white][gray]white[normal]                      [170:121:65]brown[normal]",
            "",
            "256 Color     [:130]Orange[normal]",
            "              [:125]Pink[normal]",
            "              [:055]Violet[normal]",
            "\t      [:102]Silver[normal]",
            "\t      [:178]Bold Tan[normal]",
            "\t      [:118]Bold Lime[normal]",
            "\t      ",
            "Blinking   - [blink]This text should be blinking.  [unblink]This shouldn't.[normal]",
            "",
            "Bold       - [bold][cyan]This text should be bold.  [unbold][cyan]This shouldn't.[normal]",
            "",
            "Inverse    - [inverse]This should be inverse, and [red]t[green]h[yellow]i[blue]s[normal][inverse] should be inverse and in color.[normal]",
            "",
            "Underline  - [underline]This should be underlined.[normal]",
            "",
            "Random     - [random]All [random]of [random]these [random]words [random]should [random]be [random]written [random]in [random]a [random]different [random]color.[normal]",
            "",
            "Random 256 - [:random]All [:random]of [:random]these [:random]words [:random]should [:random]be [:random]written [:random]in [:random]a [:random]different [:random]color.[normal]",
            "",
            "Beep       - [beep]You should hear a beep."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "random",
            "normal",
            "null"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 1,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "red",
            "green",
            "yellow",
            "blue",
            "purple",
            "cyan",
            "gray",
            "white"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "2.6",
              1637293016,
              "[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]",
              [
                "Fixed an issue in $ansi_pc:notify where it would terminate_normal even if the task was in the noansi queue, resulting in lines with visible ANSI tags gaining a [normal[null]] tag at the end.",
                "Made @dump add the task to the noansi queue, allowing ANSI tags to be visible.",
                "Added a call to 'remove_noansi' to @list to cleanup the noansi queue property."
              ]
            ],
            [
              "2.5",
              1550344231,
              "[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]",
              [
                "Added support for xterm 256 colors. Tags are in the mildly awkward form: [:number] or [b::number] for backgrounds. e.g. [:200[null]]",
                "Also merged True Color into the notify_regexp and removed background codes. Backgrounds are now a modifier to each color class."
              ]
            ],
            [
              "2.4",
              1540863892,
              "[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]",
              [
                "Added support for true color (24-bit) terminals. Tags are in the form: [red:green:blue] or [b:red:green:blue] for backgrounds"
              ]
            ],
            [
              "2.3",
              1112950415,
              "[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]",
              [
                "Added Remco de Groot's 2.2 change to the ANSI log and added support for background colors. Tags for background colors take the form: [b:color]",
                "Also updated @ansi-setup to recognize and use FileIO if it's available."
              ]
            ],
            [
              "2.2",
              820519200,
              "Remco de Groot",
              [
                "Fixed a bug in the setup script where it referenced $player rather than player."
              ]
            ],
            [
              "2.1",
              820519200,
              "[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]",
              [
                "Updated all the documentation. Fixed up $ansi_pc:@ansi-setup. Fixed up $ansi_utils:notify to be a *much* faster. Changed the format of $ansi_utils.ansi_log and made $ansi_help:ansi_log do the formatting itself. Added $ansi_utils:tell, $ansi_pc:title, $ansi_utils:ansi_title, help ansi-cutoff, $ansi_pc:confunc, $ansi_utils:quote_ansi, $ansi_utils.status_message, $ansi_pc:@ansi-status, help @ansi-status, $ansi_utils:trusts, $ansi_utils.trusted, $ansi_utils:setadd, $ansi_utils:setremove, $ansi_utils:terminate_normal, $ansi_utils:self_diagnostic, and a benchmark test. Fixed a bug in $ansi_utils:replace_group where it was ignoring @ansi-o escape. Removed $ansi_utils:maybe_restart_noansi and replaced it with the less server intensive :cleanup_noansi. Moved the main part of $ansi_utils:cutoff into an internal verb, :cutoff_locs, and made a :cutoff_assign verb that also uses it. Removed $ansi_utils:replace_group and :reset_string and moved it to :notify. Got rid of $ansi_utils.su_<whatever> and moved them to regular verbs on $ansi_utils. Fixed up $ansi_pc:linesplit to use $ansi_utils:cutoff_locs. Renamed $ansi_utils:update_regexp to update_all and made it update all the caches. Moved @ansi-setup to $ansi_utils.",
                "NOTE: $ansi_utils:notify doesn't terminate all strings with a [[null]normal] code anymore, you will have to run the string through $ansi_utils:terminate_normal before calling it.",
                "The home of the ANSI system is now NestMOO, instead of EnigMOO."
              ]
            ],
            [
              "2.0",
              817840800,
              "[red]D[gray]ark_[unbold][red]O[gray]wl[normal]",
              "Updated all the documentation, removed $ansi_utils.test_title, added $ansi_pc:set_aliases, added $ansi_pc:@more to fix the one on $player, fixed up @ansi-setup a lot. I'm fairly confident that the ANSI system is now safe and secure."
            ],
            [
              "1.6",
              817840800,
              "[blue]D[gray]ark_[unbold][blue]O[gray]wl[normal]",
              "Made $ansi_utils:notify, moved all the replacing stuff there, and hacked $ansi_pc:notify to call it instead of notify(). Moved the .noansi_queue, :add_noansi, and :remove_noansi from $ansi_pc to $ansi_utils. I also updated 'help ansi-bugs' now that I tracked down a couple of them."
            ],
            [
              "1.5",
              815248800,
              "[green]Grant[normal]",
              "Fixed some security problems that allowed players to get a copy of the escape character and use it for malicious purposes. To do that, I got rid of $ansi_pc:replace_ansi and put the code straight in :notify, which is able to pass() now. Also made an @ansi-setup verb for convenient porting, along with some core verb code on $ansi_utils. Fixed randoms to substitute faster by adding .random_colors. Added $ansi_utils:show_who_listing and changed @who to use it."
            ],
            [
              "1.4",
              815248800,
              "[green]Grant[normal]",
              "In Dark_Owl's absence, I fixed up a lot of code to make it take less ticks, due to the recent lag problems on EnigMOO, which we suspect were called by color codes (most noticeably s). Average :notify call with colors takes around 200 less ticks. Also updated much of the documentation, since I know DO doesn't like to do it ;) Copied the part of $player:set_name that checked whether people had color codes in their name or not to the ANSI PC."
            ],
            [
              "1.3",
              812570400,
              "[green]D[gray]ark_[unbold][green]O[gray]wl[normal]",
              "Fixed up 'help ansi-programming' a little more. Fixed $string_utils:columnize, for some reason it worked fine here but got screwed up on ForestMOO. Added 'help ansi-porting'."
            ],
            [
              "1.2",
              812570400,
              "[purple]D[gray]ark_[unbold][purple]O[gray]wl[normal]",
              "$ansi_utils:replace_group now uses substitute(). Added 'help ansi-programming' and 'help ansi-bugs'. Added @ansi-test and 'help @ansi-test'. Cleaned up a lot of other stuff. Added $ansi_utils.active."
            ],
            [
              "1.1",
              812570400,
              "[green]D[gray]ark_[unbold][green]O[gray]wl[normal]",
              "Fixed up $ansi_pc:notify a little but unfortunately now it requires wizperms and overrides the ones on it's ancestors. Fixed the line wrapping. Added this log, along with $ansi_utils.version. Hacked $ansi_utils:replace_group and $ansi_utils:cutoff to use regexps."
            ],
            [
              "1.0",
              809978400,
              "[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]",
              "$emu disappears and is replaced with $ansi_utils. $ansi_pc, $ansi_help, $ansi_options, are created and everything on $player is moved to $ansi_pc. @ansi is replaced by @ansi-o."
            ],
            [
              "0.9",
              807300000,
              "[white]D[gray]ark_[unbold][white]O[gray]wl[normal]",
              "EnigMOO opens resulting in a lot of bug fixes and more core hacks."
            ],
            [
              "0.6",
              799351200,
              "[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]",
              "Fixed up @ansi some more, fixed a lot more core stuff including $generic_editor, and made it possible to ignore ANSI codes."
            ],
            [
              "0.4",
              788983200,
              "[yellow]D[gray]ark_[unbold][yellow]O[gray]wl[normal]",
              "Fixed up @ansi a little and hacked some core stuff, mostly on $string_utils to fix columnizing. $emu:replace is hacked to use strsub() as opposed to going through letter by letter, ick."
            ],
            [
              "0.2",
              781034400,
              "[purple]D[gray]ark_[unbold][purple]O[gray]wl[normal]",
              "Added an .ansi_on property on $player and a primitive @ansi command to turn it on and off."
            ],
            [
              "0.1",
              778442400,
              "[white]D[gray]ark_[unbold][white]O[gray]wl[normal]",
              "First version, added $emu and hacked $player:notify to call it."
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            414639345
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "ansi_pc",
              "@more"
            ],
            [
              "ansi_pc",
              "notify"
            ],
            [
              "ansi_utils",
              "notify"
            ],
            [
              "ansi_utils",
              "@ansi-setup"
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "b",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "benchmark"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "left",
            "right",
            "center centre",
            "columnize columnise",
            "space"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "\"...redirects verbs to $ansi_utils...\";",
            "if (verb == \"redirect_ansi\")",
            "elseif (valid(au = $ansi_utils))",
            "  return au:(verb)(@args);",
            "else",
            "  return this:(verb + \"(noansi)\")(@args);",
            "endif"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "white",
            "unbold",
            "unblink",
            "null"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "",
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "beep"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(beep%)%]",
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(b:%)?%(random%|normal%|bold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|underline%|inverse%|blink%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": "%[%(b:%)?%(random%|normal%|bold%|unbold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%|underline%|inverse%|blink%|unblink%|beep%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "ansi_options",
            "replace_codes"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "if (valid(au = $ansi_utils) && au.active)",
            "  return au:(verb)(@args);",
            "else",
            "  return this:(verb + \"(noansi)\")(@args);",
            "endif"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "typeof(args[1]) == NUM && typeof(args[2]) == STR && (args[2] = $ansi_utils:delete(args[2]));",
            "typeof(args[1]) == STR && (args[1] = $ansi_utils:delete(args[1]));",
            "return pass(@args);"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": ":%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "A utility package for controlling ANSI sequences from within the MOO.  See 'help ansi-intro' for more info."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "ANSI Utilities",
            "au"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": "{A utility for controlling ANSI sequences from within the MOO.  See 'help ansi-intro' for more info.}",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            77241,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "100": {
      "id": 100,
      "name": "ANSI PC",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        6
      ],
      "children": [
        40
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "ansi_option",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\":ansi_option(name) => returns the value of the specified @ansi option\";",
            "if ((a = args[1]) == \"escape\")",
            "return (i = $list_utils:assoc(a, this.ansi_options)) ? i[2] | 0;",
            "else",
            "return !(!(a in this.ansi_options));",
            "endif"
          ]
        },
        {
          "name": "@ansi-o*ptions",
          "owner": 98,
          "perms": 89,
          "preps": -2,
          "object": 100,
          "code": [
            "\"@ansi-option <option> [is] <value>   sets <option> to <value>\";",
            "\"@ansi-option <option>=<value>        sets <option> to <value>\";",
            "\"@ansi-option +<option>     sets <option>   (usually equiv. to <option>=1\";",
            "\"@ansi-option -<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@ansi-option !<option>     resets <option> (equiv. to <option>=0)\";",
            "\"@ansi-option <option>      displays value of <option>\";",
            "if (!args)",
            "player:notify_lines({\"Current ANSI options:\", \"\", @$options[\"ansi\"]:show(this.ansi_options, $options[\"ansi\"].names)});",
            "return;",
            "elseif (typeof(presult = $options[\"ansi\"]:parse(args)) == STR)",
            "player:notify(presult);",
            "return;",
            "else",
            "if (length(presult) > 1)",
            "if (typeof(sresult = this:set_ansi_option(@presult)) == STR)",
            "player:notify(sresult);",
            "return;",
            "elseif (!sresult)",
            "player:notify(\"No change.\");",
            "return;",
            "endif",
            "endif",
            "player:notify_lines($options[\"ansi\"]:show(this.ansi_options, presult[1]));",
            "endif"
          ]
        },
        {
          "name": "set_ansi_option",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\":set_ansi_option(oname,value)\";",
            "\"Changes the value of the named option.\";",
            "\"Returns a string error if something goes wrong.\";",
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return tostr(E_PERM);",
            "endif",
            "foo_options = \"ansi_options\";",
            "\"...\";",
            "if (typeof(s = $options[\"ansi\"]:set(this.(foo_options), @args)) == STR)",
            "return s;",
            "elseif (s == this.(foo_options))",
            "return 0;",
            "else",
            "this.(foo_options) = s;",
            "$ansi_utils:update_player_codes(this);",
            "return 1;",
            "endif"
          ]
        },
        {
          "name": "notify",
          "owner": 2,
          "perms": 165,
          "preps": -1,
          "object": 100,
          "code": [
            "if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "endif",
            "line = args[1];",
            "if (!valid(au = $ansi_utils))",
            "return pass(@args);",
            "elseif ((\"normal\" in ((typeof(z = this.replace_codes) == NUM) ? au.replace_code_pointers[z] | z)) && (!(task_id() in au.noansi_queue)))",
            "line = au:terminate_normal(line);",
            "endif",
            "if (this.pagelen)",
            "if (!(this in connected_players()))",
            "\"...drop it on the floor...\";",
            "return 0;",
            "endif",
            "\"...need wizard perms if this and this.owner are different, since...\";",
            "\"...only this can notify() and only this.owner can read .linebuffer...\";",
            "if ((player == this) && (this.linetask[2] != task_id()))",
            "\"...player has started a new task...\";",
            "\"....linetask[2] is the taskid of the most recent player task...\";",
            "(this.linetask[2] != this.linetask[1]) && (this.linesleft = this.pagelen - 2);",
            "this.linetask[2] = task_id();",
            "endif",
            "\"... digest the current line...\";",
            "li = this.linelen ? this:linesplit(line, abs(this.linelen)) | {line};",
            "lbuf = {@this.linebuffer, @li};",
            "\"... print out what we can...\";",
            "if (this.linesleft)",
            "howmany = min(this.linesleft, length(lbuf));",
            "for l in (lbuf[1..howmany])",
            "au:notify(this, l);",
            "\"notify(this, l, nocr);\";",
            "endfor",
            "this.linesleft = this.linesleft - howmany;",
            "lbuf[1..howmany] = {};",
            "endif",
            "if (lbuf)",
            "\"...see if we need to say ***More***\";",
            "if (this.linetask[1] != this.linetask[2])",
            "\"....linetask[1] is the taskid of the most recent player task\";",
            "\"...   for which ***More*** was printed...\";",
            "this.linetask[1] = this.linetask[2];",
            "fork (0)",
            "notify(this, strsub(this.more_msg, \"%n\", tostr(length(this.linebuffer))));",
            "endfork",
            "endif",
            "llen = length(lbuf);",
            "if (llen > 500)",
            "\"...way too much saved text, flush some of it...\";",
            "lbuf[1..llen - 100] = {\"*** buffer overflow, lines flushed ***\"};",
            "endif",
            "endif",
            "this.linebuffer = lbuf;",
            "else",
            "if (this.linelen > 0)",
            "for l in (this:linesplit(line, this.linelen))",
            "au:notify(this, l);",
            "endfor",
            "else",
            "au:notify(this, line);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "linesplit",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\":linesplit(line,len) => list of substrings of line\";",
            "\"used by :notify to split up long lines if .linelen>0\";",
            "line = args[1];",
            "len = args[2];",
            "cline = {};",
            "au = $ansi_utils;",
            "\"..this should eventually return E_RANGE or \\\"\\\" and stop...\";",
            "while (z = au:cutoff(line, 1, len + 1))",
            "cutoff = au:rindex(z[1..length(z) - 1], \" \");",
            "if (nospace = cutoff < ((4 * len) / 5))",
            "cutoff = len + 1;",
            "nospace = index(au:cutoff(line, cutoff, cutoff), \" \");",
            "endif",
            "q = au:cutoff_locs(line, 1, cutoff - 1, 1);",
            "cline = {@cline, line[q[1]..q[2]]};",
            "line[q[1]..q[2]] = nospace ? \" \" | \"\";",
            "endwhile",
            "return {@cline, line};"
          ]
        },
        {
          "name": "@ansi-t*est",
          "owner": 98,
          "perms": 9,
          "preps": -1,
          "object": 100,
          "code": [
            "\"Usage:  @ansi-test\";",
            "\"Displays a screen that uses all of the ANSI codes possible.  Useful for testing which codes your terminal program is capable of displaying.\";",
            "player:notify($string_utils:center(tostr(\" ANSI Test Screen \"), l = player:linelen(), \"-\"));",
            "player:notify_lines($ansi_utils.test_screen);",
            "player:notify($string_utils:space(l, \"-\"));"
          ]
        },
        {
          "name": "set_name",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\"This makes sure that people don't have color codes in their name. They shouldn't, anyway since it makes it hard to identify them (especially if they use black.)\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "elseif (!is_player(this))",
            "\"we don't worry about the names of player classes.\";",
            "return pass(@args);",
            "elseif ((name = args[1]) != $ansi_utils:delete(name))",
            "player:notify(\"Sorry, you can't have color codes in your name. It messes up the db listings and people might not know how to address you if you didn't have your normal name as an alias. You can make a :title, though.\");",
            "return E_INVARG;",
            "else",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "say",
          "owner": 98,
          "perms": 85,
          "preps": -2,
          "object": 100,
          "code": [
            "if ($object_utils:has_callable_verb(player.location, \"say\") != {#3})",
            "\"Idiot-proofed it against porting wizards who change $room to something other than #3 (since :say would not be defined on $room.) Clueful wizards can change this.\";",
            "return player.location:(verb)(@args);",
            "endif",
            "au = $ansi_utils;",
            "argstr = au:terminate_normal(argstr);",
            "action = {\"say\", \"ask\", \"exclaim\"}[1 + index(\"?!\", argstr[length(argstr)])];",
            "action = (punct == \"!\") ? \"exclaim\" | ((punct == \"?\") ? \"ask\" | \"say\");",
            "player:tell(tostr(\"You \", action, \", \\\"\", argstr, \"\\\"\"));",
            "player.location:announce(tostr(au:ansi_title(player), \" \", action), \"s, \\\"\", argstr, \"\\\"\");"
          ]
        },
        {
          "name": "@who who",
          "owner": 98,
          "perms": 85,
          "preps": -2,
          "object": 100,
          "code": [
            "\"Redirects calls to @who to $ansi_utils:show_who_listing.\";",
            "if (caller != player)",
            "return E_PERM;",
            "elseif (!(valid(au = $ansi_utils) && au.active))",
            "return pass(@args);",
            "endif",
            "argstr = prepstr = dobjstr = iobjstr = \"\";",
            "plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();",
            "au:show_who_listing(plyrs);"
          ]
        },
        {
          "name": "at_item",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.\";",
            "loc = args[1];",
            "party = args[2];",
            "su = $string_utils;",
            "number = this.at_number ? su:right(tostr(loc), 7) + \" \" | \"\";",
            "room = su:left(valid(loc) ? loc.name | \"[Nowhere]\", this.at_room_width);",
            "($ansi_utils:length(room) > this.at_room_width) && (room = $ansi_utils:cutoff(room, 1, this.at_room_width));",
            "text = (number + room) + \" \";",
            "if (party)",
            "filler = su:space(length(text) - 2);",
            "line = text;",
            "text = {};",
            "for who in (party)",
            "name = \" \" + (valid(who) ? who.name | \"[Nobody]\");",
            "if (($ansi_utils:length(line) + $ansi_utils:length(name)) > this:linelen())",
            "text = {@text, line};",
            "line = filler + name;",
            "else",
            "line = line + name;",
            "endif",
            "endfor",
            "text = {@text, line};",
            "else",
            "text = text + \" [deserted]\";",
            "endif",
            "return text;"
          ]
        },
        {
          "name": "@more",
          "owner": 2,
          "perms": 25,
          "preps": -1,
          "object": 100,
          "code": [
            "if (player != this)",
            "\"... somebody's being sneaky...\";",
            "\"... Can't do set_task_perms(player) since we need to be `this'...\";",
            "\"... to notify and `this.owner' to change +c properties...\";",
            "return;",
            "elseif (!(valid(au = $ansi_utils) && au.active))",
            "return pass(@args);",
            "elseif (!(lbuf = this.linebuffer))",
            "this.linesleft = this.pagelen - 2;",
            "notify(this, \"*** No more ***\");",
            "elseif (index(\"flush\", dobjstr || \"x\") == 1)",
            "this.linesleft = this.pagelen - 2;",
            "notify(this, tostr(\"*** Flushed ***  \", length(lbuf), \" lines\"));",
            "this.linebuffer = {};",
            "elseif ((index(\"rest\", dobjstr || \"x\") == 1) || (!this.pagelen))",
            "this.linesleft = this.pagelen - 2;",
            "for l in (lbuf)",
            "au:notify(this, l);",
            "endfor",
            "this.linebuffer = {};",
            "else",
            "howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));",
            "for l in (lbuf[1..howmany])",
            "au:notify(this, l);",
            "endfor",
            "this.linesleft = (this.pagelen - 2) - howmany;",
            "this.linebuffer = lbuf[howmany + 1..llen];",
            "if (howmany < llen)",
            "notify(this, strsub(this.more_msg, \"%n\", tostr(llen - howmany)));",
            "this.linetask[1] = task_id();",
            "endif",
            "endif",
            "this.linetask[2] = task_id();"
          ]
        },
        {
          "name": "set_aliases",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\"This makes sure that people don't have color codes in their aliases. They shouldn't, anyway since it makes it hard to identify them (especially if they use black.)\";",
            "if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))",
            "return E_PERM;",
            "elseif (!is_player(this))",
            "\"we don't worry about the names of player classes.\";",
            "return pass(@args);",
            "else",
            "for name in (aliases = args[1])",
            "if (name != $ansi_utils:delete(name))",
            "aliases = setremove(aliases, name);",
            "endif",
            "endfor",
            "if (aliases != args[1])",
            "player:notify(\"Sorry, you can't have color codes in your aliases.\");",
            "endif",
            "return pass(aliases);",
            "endif"
          ]
        },
        {
          "name": "title",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 100,
          "code": [
            "return valid(au = $ansi_utils) ? au:ansi_title(this, pass(@args)) | pass(@args);"
          ]
        },
        {
          "name": "confunc",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))",
            "return E_PERM;",
            "else",
            "au = $ansi_utils;",
            "if (au.active)",
            "this:notify(tostr(\"ANSI Version \", au.version, \" is currently active.  Type \\\"?ansi-intro\\\" for more information.\"));",
            "endif",
            "if (((mess = au.status_message) && (!$object_utils:isa(this, $guest))) && (!this:ansi_option(\"no_connect_status\")))",
            "fork (0)",
            "line = $string_utils:space((l = this:linelen()) - 2, \"*\");",
            "btmmsg = \"Type \\\"@ansi-o +no_connect_status\\\" to ignore this message.\";",
            "this:notify(line);",
            "for a in ((typeof(mess) == LIST) ? {\"ANSI Message:\", @mess, btmmsg} | {\"ANSI Message: \" + mess, btmmsg})",
            "for b in ($generic_editor:fill_string(a, l - 2))",
            "this:notify(\"* \" + b);",
            "endfor",
            "endfor",
            "this:notify(line);",
            "endfork",
            "endif",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "@ansi-s*tatus",
          "owner": 98,
          "perms": 89,
          "preps": -2,
          "object": 100,
          "code": [
            "\"Usage:\";",
            "\"  @ansi-status                   - Displays various information about the\";",
            "\"                                   status of the ANSI system.\";",
            "\"  @ansi-status version           - Only displays the version number.\";",
            "\"  @ansi-status message           - Only displays the ANSI message.\";",
            "\"Trusted users only:\";",
            "\"  @ansi-status activate          - Activates the ANSI system.\";",
            "\"  @ansi-status deactivate        - Deactivates the ANSI system.\";",
            "\"  @ansi-status message <message> - Sets the ANSI message to <message>.\";",
            "\"  @ansi-status input             - Same as 'message' but lets you input\";",
            "\"                                   more than one line.\";",
            "\"  @ansi-status clear             - Clears the ANSI message.\";",
            "\"  @ansi-status diagnostic        - Runs the ANSI self-diagnostic and\";",
            "\"                                   reports the results.\";",
            "\"  @ansi-status diagnostic fix    - Same as above but fixes anything it can.\";",
            "\"  @ansi-status update            - Updates all the caches, this should be\";",
            "\"                                   run every once in a while.  See\";",
            "\"                                   'help $ansi_utils:update_all' for more info.\";",
            "au = $ansi_utils;",
            "if (args)",
            "subcommand = args[1];",
            "args[1..1] = {};",
            "else",
            "subcommand = \"\";",
            "endif",
            "trusts = au:trusts(player);",
            "show = 0;",
            "if (player != this)",
            "player:tell(E_PERM);",
            "elseif (!subcommand)",
            "player:notify_lines($ansi_utils:ansi_status());",
            "trusts && player:notify(\"You are trusted by the ANSI system.\");",
            "show = 1;",
            "elseif (subcommand == \"help\")",
            "player:notify_lines($code_utils:verb_documentation());",
            "elseif (subcommand == \"version\")",
            "player:notify(tostr(\"Currently running ANSI Version \", au.version, \".\"));",
            "elseif (subcommand == \"message\")",
            "if (!args)",
            "show = 1;",
            "elseif (trusts)",
            "message = $string_utils:from_list(args, \" \");",
            "au.status_message = message;",
            "player:notify(\"Message set to:  \" + message);",
            "if ($command_utils:yes_or_no(\"Notify users?\"))",
            "notify = tostr(\"The ANSI status message was just set by \", player.name, \"; type \\\"@ansi-status message\\\" to see it.\");",
            "for x in (setremove($object_utils:leaves_suspended($ansi_pc), player))",
            "x:tell(notify);",
            "endfor",
            "endif",
            "else",
            "player:notify(\"The message can only be set by trusted users, type \\\"@ansi-status message\\\" to see the message.\");",
            "endif",
            "elseif (!trusts)",
            "player:notify(tostr(\"The subcommand \\\"\", subcommand, \"\\\" either doesn't exist or is limited to trusted users only.\"));",
            "elseif (subcommand == \"input\")",
            "player:notify(\"What do you want to set the message to?\");",
            "message = $command_utils:read_lines();",
            "au.status_message = message;",
            "player:notify(\"Message set to:\");",
            "player:notify_lines(message);",
            "if ($command_utils:yes_or_no(\"Notify users?\"))",
            "notify = tostr(\"The ANSI status message was just set by \", player.name, \"; type \\\"@ansi-status message\\\" to see it.\");",
            "for x in (setremove($object_utils:leaves_suspended($ansi_pc), player))",
            "x:notify(notify);",
            "endfor",
            "endif",
            "elseif (subcommand == \"clear\")",
            "au.status_message = \"\";",
            "player:notify(\"Cleared status message.\");",
            "elseif (subcommand in {\"activate\", \"active\", \"on\"})",
            "player:notify(au.active ? \"The ANSI system is already active.\" | \"The ANSI system has been activated.\");",
            "au.active = 1;",
            "elseif (subcommand in {\"deactivate\", \"deactive\", \"off\"})",
            "player:notify(au.active ? \"The ANSI system has been deactivated, type \\\"@ansi-status activate\\\" to reactivate it.\" | \"The ANSI system is not active.\");",
            "au.active = 0;",
            "elseif (subcommand == \"diagnostic\")",
            "status = au:self_diagnostic(fix = index(tostr(@args), \"fix\"), player);",
            "player:notify(tostr(\"Diagnostic completed, \", fix ? \"fixed\" | \"found\", \" \", status, \" problem\", (status == 1) ? \"\" | \"s\", \".\"));",
            "elseif (subcommand == \"update\")",
            "player:notify(\"Updating caches...\");",
            "au:update_all();",
            "player:notify(\"Done updating caches.\");",
            "else",
            "player:notify(\"Invalid subcommand: \" + subcommand);",
            "endif",
            "if (show)",
            "if (m = au.status_message)",
            "ml = player:linelen() - 14;",
            "lines = {};",
            "for a in ((typeof(m) == LIST) ? m | {m})",
            "for b in ($generic_editor:fill_string(a, ml))",
            "lines = {@lines, b};",
            "endfor",
            "endfor",
            "player:notify(\"ANSI message: \" + lines[1]);",
            "for x in (listdelete(lines, 1))",
            "player:notify(\"              \" + x);",
            "endfor",
            "else",
            "player:notify(\"There is no ANSI message set.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "@ansi-title",
          "owner": 98,
          "perms": 89,
          "preps": -2,
          "object": 100,
          "code": [
            "\"Usage:\";",
            "\"  @ansi-title                 - Displays your current ANSI title settings\";",
            "\"  @ansi-title <name>          - Displays the title you have set for <name>\";",
            "\"  @ansi-title <name> is <new> - Sets <new> as the title for <name>\";",
            "\"  @ansi-title is <new>        - Sets <new> as the title for your current name\";",
            "name = dobjstr || this.name;",
            "if (player != this)",
            "player:tell(E_PERM);",
            "elseif (!argstr)",
            "if (typeof(this.ansi_title) != LIST)",
            "player:notify(\"Your ANSI title seems to be screwed up, resetting it.\");",
            "this:set_ansi_title({});",
            "elseif (!this.ansi_title)",
            "player:notify(\"You don't have any ANSI titles set.\");",
            "else",
            "player:notify(\"Current ANSI title substrings:\");",
            "l = player:linelen() - 21;",
            "for x in (this.ansi_title)",
            "z = $generic_editor:fill_string($string_utils:english_list((typeof(x[2]) == LIST) ? x[2] | {x[2]}), l);",
            "player:notify(tostr(\"   \", $string_utils:left(x[1], 15), \" - \", z[1]));",
            "for i in (listdelete(z, 1))",
            "player:notify(\"                     \" + i);",
            "endfor",
            "endfor",
            "player:notify(tostr(\"Your current name is set to \", $ansi_utils:ansi_title(player), \".\"));",
            "endif",
            "elseif (iobjstr && (prepstr != \"is\"))",
            "player:notify_lines($code_utils:verb_documentation());",
            "elseif (!prepstr)",
            "if (i = $list_utils:assoc(name, this.ansi_title))",
            "player:notify(tostr(\"The substring \", name, \" will be replaced with \", i[2], \".\"));",
            "else",
            "player:notify(tostr(\"There is no set replacement for the substring \", name, \".\"));",
            "endif",
            "elseif ($ansi_utils:contains_codes(name))",
            "player:notify(\"The replacement string shouldn't contain ANSI codes.\");",
            "else",
            "at = this.ansi_title;",
            "i = $list_utils:iassoc(name, at);",
            "if (iobjstr)",
            "if (i)",
            "at[i][2] = iobjstr;",
            "else",
            "at = listappend(at, {name, iobjstr});",
            "endif",
            "elseif (i)",
            "at = listdelete(at, i);",
            "endif",
            "if (typeof(result = this:set_ansi_title(at)) != ERR)",
            "if (iobjstr)",
            "player:notify(tostr(\"Substring \", name, \" will be replaced with \", iobjstr, \".\"));",
            "else",
            "player:notify(tostr(\"Cleared substring \", name, \".\"));",
            "endif",
            "elseif (result == E_NACC)",
            "player:notify(\"The replacement string must be the same as the string replaced except for the ANSI strings.\");",
            "else",
            "player:notify(tostr(\"Error: \", result));",
            "endif",
            "endif"
          ]
        },
        {
          "name": "set_ansi_title",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 100,
          "code": [
            "\":set_ansi_title (LIST title_list)\";",
            "tl = args[1];",
            "if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))",
            "return E_PERM;",
            "elseif (typeof(tl) != LIST)",
            "return E_INVARG;",
            "else",
            "au = $ansi_utils;",
            "for x in [1..length(tl)]",
            "if (!(((typeof(tl[x]) == LIST) && (length(tl[x]) == 2)) && (typeof(tl[x][1]) == STR)))",
            "return E_INVARG;",
            "elseif (typeof(tl[x][2]) == LIST)",
            "for y in [1..length(tl[x][2])]",
            "if (typeof(tl[x][2][y]) != STR)",
            "return E_INVARG;",
            "elseif (tl[x][1] != strsub(au:delete(tl[x][2][y]), \" \", \"_\"))",
            "return E_NACC;",
            "else",
            "tl[x][2][y] = au:terminate_normal(tl[x][2][y]);",
            "endif",
            "endfor",
            "elseif (tl[x][1] != strsub(au:delete(tl[x][2]), \" \", \"_\"))",
            "return E_NACC;",
            "else",
            "tl[x][2] = au:terminate_normal(tl[x][2]);",
            "endif",
            "endfor",
            "this.ansi_title = tl;",
            "endif"
          ]
        },
        {
          "name": "emote",
          "owner": 98,
          "perms": 85,
          "preps": -2,
          "object": 100,
          "code": [
            "if ($object_utils:has_callable_verb(player.location, \"say\") != {#3})",
            "\"Idiot-proofed it against porting wizards who change $room to something other than #3 (since :say would not be defined on $room.) Clueful wizards can change this.\";",
            "return player.location:(verb)(@args);",
            "endif",
            "if (argstr && (argstr[1] == \":\"))",
            "argstr[1..1] = \"\";",
            "else",
            "argstr[1..0] = \" \";",
            "endif",
            "player.location:announce_all($ansi_utils:ansi_title(player), argstr);"
          ]
        }
      ],
      "propnames": [
        "ansi_options",
        "ansi_title",
        "replace_codes"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 101,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 4
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 36,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 0
        },
        {
          "value": null,
          "owner": 2,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "ANSI PC",
            "apc"
          ],
          "owner": 2,
          "perms": 1
        },
        {
          "value": "A player with the ability to see things in [red]c[bold][yellow]o[green]l[blue]o[purple]r[normal].",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            29845,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "101": {
      "id": 101,
      "name": "ANSI Help",
      "flags": 16,
      "owner": 98,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "ansi_log",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 101,
          "code": [
            "help = {};",
            "linelen = player:linelen();",
            "log = $ansi_utils.(verb);",
            "vmax = 8 + max(@$list_utils:map_builtin($list_utils:slice(log, 1), \"length\"));",
            "for x in (log)",
            "help = {@help, tostr($string_utils:left(tostr(\"Version \", x[1]), vmax), \"  \", $string_utils:left($time_utils:time_sub(\"$N, $Y\", x[2]), 25), x[3])};",
            "for l in ((typeof(x[4]) == LIST) ? x[4] | {x[4]})",
            "for i in ($generic_editor:fill_string(l, (linelen - vmax) - 2))",
            "help = {@help, tostr($string_utils:space(vmax + 2), i)};",
            "endfor",
            "endfor",
            "help = {@help, \"\"};",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "return help;"
          ]
        }
      ],
      "propnames": [
        "ansi-index",
        "ansi-options",
        "ansi-codes",
        "ansi-multimooing",
        "ansi-intro",
        "@ansi-test",
        "ansi-bugs",
        "ansi-programming",
        "ansi-porting",
        "@ansi-setup",
        "ansi-log",
        "ANSI",
        "@ansi-status",
        "@ansi-title",
        "ansi-corehacks"
      ],
      "propdefs": [
        {
          "value": [
            "*index*",
            "ANSI Help Topics"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "You can customize the way the ANSI Player Class works with the @ansi-options",
            "command.  The format of this command is:",
            "",
            "@ansi-option                         shows the ansi options",
            "@ansi-option <option> [is] <value>   sets <option> to <value>",
            "@ansi-option <option>=<value>        sets <option> to <value>",
            "@ansi-option +<option>               sets <option>",
            "@ansi-option -<option>               resets <option> (equiv. to <option>=0)",
            "@ansi-option !<option>               resets <option> (equiv. to <option>=0)",
            "@ansi-option <option>                displays value of <option>",
            "",
            "The ansi options available at this time are:",
            "",
            " [bold][green]colors[normal]        This option specifies whether the MOO will display",
            "               color sequences (such as [[null]blue] and [[null]red]).",
            "",
            " [bold][green]backgrounds[normal]   This option specifies whether the MOO will display",
            "               background color sequences (such as [[null]b:blue] and [[null]b:red]).",
            "\t       Normal color, 256 color, and True Color all support background tags.",
            "\t       e.g. [[null]b:red]  [[null]b::200]  [[null]b:123:23:123]",
            "\t       ",
            " [bold][green]blinking[normal]      This option specifies whether the MOO will allow things to",
            "               blink on and off.  Most people find this annoying so they",
            "               keep this off most of the time.",
            "",
            " [bold][green]bold[normal]          This option specifies whether the MOO will allow bright",
            "               colors.  This probably isn't very useful unless you happen to",
            "               have a hangover (maybe from a MOO bash, right Chapman ;) and",
            "               the bright colors are hurting your eyes or something.",
            "               (Or unless you're using a stupid windoze client that",
            "                bolds as cyan.. gimme the name of a good freeware one",
            "                and I'll be happy.. -Grant)",
            "",
            " [bold][green]misc[normal]          This option specifies whether the MOO should display all the",
            "               ANSI codes not covered by the ones above.  This should usually",
            "               be on if any of the above ones are on and will probably cause",
            "               some very strange effects if it's not.",
            "",
            " [bold][green]extra[normal]         This option specifies whether the MOO will send certain",
            "               non-printable characters.  So far, this option only includes",
            "               beeps.  NOTE: these will probably work even if your terminal",
            "               is not ANSI compatable.",
            "",
            " [bold][green]all[normal]           This turns on all of the above options.  Equivalent to",
            "               '@ansi-options -none' except that it automatically does an",
            "               '@ansi-options -ignore'.",
            "",
            " [bold][green]none[normal]          This turns off all of the above options.  Equivalent to",
            "               @ansi-options -all",
            "",
            " [bold][green]escape[normal]        This option specifies what character the MOO will send for",
            "               an escape character.  The default is an ASCII character 27",
            "               but it can be set to another string in case control characters",
            "               won't get through to your terminal (like say if you are",
            "               multimooing from another MOO or something, see 'help",
            "               ansi-multimooing' for more information on that.)",
            "",
            " [bold][green]ignore[normal]        This option overrides all the other options and tells the",
            "               MOO to completely ignore any ANSI codes.  This means that you",
            "               will see the actual codes (like [[null]blue] or [[null]normal]) instead",
            "               of having them either translated or stripped out like normal.",
            "               This will probably screw up the line wrapping, text centering",
            "               and a bunch of other things and will probably be very spammy",
            "               but it's useful for checking the value of properties and",
            "               other things.",
            "",
            " [bold][green]no_connect_status[normal] This option specifies whether the ANSI status message",
            "               will be displayed when you log on.",
            "",
            " [bold][green]truecolor[normal]    This option enables 24-bit True Color support. Your client",
            "              must offer support for it. ",
            "              Color sequences are in the form [[red]red[normal]:[green]green[normal]:[blue]blue[normal]]",
            "",
            " [bold][green]256[normal]          This option enables Xterm 256 color support. Your client must",
            "              support it.",
            "              Color sequences are in the form [:number]. e.g. [:200[null]]"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "The ANSI Player Class works by either translating codes into the ANSI sequences for them, or by stripping them out before sending the rest of the text to the player. An ANSI code is made up of the name of the code with a pair of brackets ([]'s) around it. Note to put codes into the documentation, they had to be put with a [[null]null] in between the letters, so something like [[[null]null]green] had to be written (and to make that.. sigh)",
            "",
            "These codes can be used in almost anything. MOOmail, messages, names, descriptions, and pages are all good places to put codes. ANSI codes are *not* allowed in player's names though because of all the problems this might cause. You can, however, use the new @ansi-title verb to put codes in your name.",
            "",
            "The codes are separated into 6 main groups:",
            "",
            " [bold][yellow]colors[normal]         Codes that change the text to another color.  These include:",
            "                [[null]red], [[null]green], [[null]yellow], [[null]blue], [[null]purple], [[null]cyan],",
            "                [[null]gray], and [[null]white].  You can also use [[null]magenta] instead",
            "                of [[null]purple] and [[null]grey] instead of [[null]gray] but this isn't",
            "                recommended.  NOTE: [[null]gray] implies a [[null]bold] so if you have:",
            "                [[null]gray]This is gray.  [[null]red]This is red.[[null]normal]",
            "                The 'This is red.' will be bright red, you must put an",
            "                [[null]unbold] in front of it if you want it to be dark red.",
            "                In addition, if your client supports 24-bit True Color and you've enabled the 'truecolor'",
            "                option, you can create tags from any arbitrary combination of red, green, and blue values.",
            "                e.g. [[null]255:255:153] to create the funky banana color.",
            "                These can be turned off with '@ansi-options -colors' and '@ansi-options -truecolor'",
            " ",
            " [bold][yellow]backgrounds[normal]    Codes that change the background of text to another color.",
            "                The same color codes that can be used for normal colors also apply to background.",
            "                To use backgrounds, simply add \"b:\" before your color name. For example:",
            "                [[null]b:red] or [b:255:255:153[null]]",
            "                Backgrounds can be turned off with '@ansi-options -backgrounds'",
            "",
            " [bold][yellow]bold[normal]           Codes that make the text bright or not bright.  These include:",
            "                [[null]bold] and [[null]unbold].  You can also use [[null]bright] and",
            "                [[null]unbright] but, again, this is not recommended.  These can be",
            "                turned off with '@ansi-options -bold'.  This can be used to make",
            "                bright colors by putting a [[null]bold] in front of the color.",
            "                (for example, in: [[null]green]A[[null]bold]B[[null]red]C[[null]unbold]D[[null]normal]",
            "                the A would be dark green, the B would be bright green, the C",
            "                would be bright red, and the D would be dark red)",
            "",
            "[bold][yellow]blinking[normal]       Codes that turn on and off the blinking.  These include:",
            "                [[null]blink] and [[null]unblink].  They can be turned off with",
            "                '@ansi-options -blinking'.",
            "",
            " [bold][yellow]misc.[normal]          All the codes not covered by the ones above.  These include:",
            "                [[null]underline] and [[null]inverse].  NOTE: [[null]underline]",
            "                does not actually underline text on most computers.  These can",
            "                be turned off with '@ansi-options -misc'.",
            "",
            "[bold][yellow]extra[normal]          Codes that are not really ANSI and may work even if your",
            "                terminal is not ANSI compatable .  These include:",
            "                [[null]beep].  It can be turned off with '@ansi-options -extra'."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "For those of you that are multimooing from another MOO (probably using Sunwiz's excellent MultiMOO PC) and your escape characters are getting stripped out, you can tell the MOO to send a certain string instead of an ASCII character 27 by typing:  '@ansi-options escape <string>'. You will then have to set your terminal program to translate <string> into an escape character. I would suggest setting <string> to '~' or some other character that is very rarely used.  You probably shouldn't tell anyone what character you are using though, because then they can clear your screen, reposition your cursor, and some other annoying things. To tell the MOO to start sending character 27's for the escape characters again, type '@ansi-options -escape'. ",
            "",
            "Other MOOs that have the ANSI PC or other color capability have their own method of transmitting colors, so you should probably set '@ansi-options +ignore' on all the MOOs except the one you are actually telnetting too, this is because inter-MOO connecting can't send escape characters, only ASCII text."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "This ANSI system was written and designed by Don Schwarz <darkowl@mcs.net> aka Dark_Owl.  It is composed of an ANSI Player Class ($ansi_pc), an ANSI utility package ($ansi_utils), an ANSI help database ($ansi_help), and an ANSI option database ($ansi_options).",
            "It converts ANSI 'codes', which are composed of a word surrounded by brackets ([]'s), into ANSI sequences which are recognized by most terminal programs and are used to display text in certain colors, underlined, inverse, and to make text blink.  Not all terminal programs support ANSI though so this will not work for everyone.",
            "",
            "You can put these ANSI codes in your descriptions, messages, mails, programs, and virtually anything else that is eventually sent through $player:notify().  See 'help ansi-codes' for a list of valid ANSI codes.",
            "",
            "The ANSI PC is controlled with the @ansi-options command, see 'help @ansi-options' for more information on it.",
            "",
            "To see a list of other ANSI help topics, see 'help ansi-index'."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$ansi_pc",
            "@ansi-test"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "[bold][red]KNOWN BUGS:[normal]",
            "  [bold][blue]1)[normal] Some terminal programs seem to act strangely with lines that start with a [[null]bold] code.  I'm pretty sure this isn't a MOO problem so I can't do anything about it.  I'd recommend always putting [[null]bold] codes *after* color codes, or if you're using TinyFugue, try typing \"/set emulation raw\".",
            "  [bold][blue]2)[normal] You can still write in black with [[null]gray][[null]unbold].  Not a major problem, but it bugs me.",
            "  [bold][blue]3)[normal] Some terminal programs seem to beep not only when they get a character 7, but also on every escape character they receive on the same line.",
            "  [bold][blue]4)[normal] There's no way to set random replacements with @ansi-title."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "There are a few verbs and properties that programmers might need to know about when programming things that interface with the ANSI system.  Some of the more useful ones include:",
            "",
            "  $ansi_pc:ansi_option (STR option) - returns player's setting for <option>",
            "  $ansi_pc:set_ansi_option (LIST    - sets player's options",
            "                        options)",
            "  $ansi_utils:add_noansi ()         - any text sent from the current task",
            "                                      will not be translated by the ANSI PC.",
            "  $ansi_utils:remove_noansi ()      - undoes a call to :add_noansi, this",
            "                                      is not usually necessary because it",
            "                                      gets removed from the queue when the",
            "                                      task ends anyway.",
            "  $ansi_utils.noansi_queue          - list of tasks that are currently",
            "                                      being ignored.",
            "  $ansi_utils:contains_codes (STR text) returns true if <text> contains",
            "                                      any ANSI codes.",
            "  $ansi_utils:delete (STR text)     - returns <text> with all the ANSI",
            "                                      codes stripped.",
            "  $ansi_utils:length (STR text)     - returns the length of <text> not",
            "                                      including the ANSI codes.",
            "  $ansi_utils:index/rindex (STR     - same as the builtins index() and",
            "       text, STR text2[, NUM case]    rindex() but ignore ANSI codes.",
            "  $ansi_utils:cutoff (STR text, NUM - same as text[start..end] for strings",
            "       start, NUM end)                but ignores ANSI codes.",
            "  $ansi_utils:cutoff_assign (STR    - same as text[start..end] = replacement",
            "       text, NUM start, NUM end, STR",
            "       replacement)",
            "  $ansi_utils:notify (OBJ plr, STR  - Same as raw notify() but replaces",
            "                   line)              ANSI.",
            "  $ansi_utils:self_diagnostic ()    - Runs a diagnostic on the ANSI stuff.",
            "  $ansi_utils:trusts (OBJ player)   - Is <player> trusted by the ANSI stuff?",
            "  $ansi_utils:cutoff_locs (STR text - Returns a list of the real starting and",
            "       NUM start, NUM end)            and ending locations.",
            "  $ansi_utils:setadd (LIST l, ANY   - Same as setadd() but doesn't add it if",
            "       element)                       element is already in the list (ignoring",
            "                                      ANSI codes)",
            "  $ansi_utils:setremove (LIST l,    - Same as setremove() but doesn't add it",
            "       ANY element)                   if element is already in the list",
            "                                      (ignoring ANSI codes)",
            "  $ansi_utils:terminate_normal (STR - Returns text with a [[null]normal] code",
            "       text)                          at the end.",
            "  $ansi_utils:ansi_title (OBJ plr)  - Returns <plr>'s name with ANSI codes.",
            "  $ansi_utils:quote_ansi (STR text) - Puts [[null]null] codes in the middle of",
            "                                      all the other codes so they don't show.",
            "  $ansi_utils:update_player_codes   - Should be run whenever <player>'s",
            "          (OBJ player)                options are changed.",
            "",
            "Trusted Users only:",
            "  $ansi_utils:update_all ()         - Updates all the caches and regexps",
            "  $ansi_utils:add_group (STR group) - adds <group> to the list of groups",
            "  $ansi_utils:add_code (STR code,   - adds <code> to the codes in group",
            "       STR group, ANY sequence)       <group> and set's it's ANSI sequence",
            "                                      to <sequence>."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "If you are starting a new MOO and wish to have ANSI on it, the easiest",
            "  way is to use the ANSICore.  The ANSICore is a copy of the December",
            "  25, 1995 LambdaCore in which everything has been fixed to work",
            "  correctly with the ANSI.  The escape and beep characters are already",
            "  present in the database so no set up or installation is necessary.",
            "  The latest ANSICore is available via anonymous FTP from",
            "  ftp.mcs.net in the directory /mcsnet.users/darkowl/ANSI, in a",
            "  file named ANSICore.db.gz. (Sorry, due to file quotas I was unable to",
            "  include the uncompressed version, but it is still available from",
            "  darkowl.pr.mcs.net in the directory /pub/ANSI)",
            "  NOTE: While the ANSI system is activated in the core, all players",
            "    start out with the ANSI defaulting to off, so you will have to type",
            "    '@ansi-options +all' before you can see any color.",
            "",
            "To install the ANSI system on an already existing MOO, you will need the",
            "  installation script.  This file should be uploaded into the MOO as a",
            "  non-wizard (usually the second character of the wizard installing the",
            "  ANSI) and will port the objects and give you instructions on how to",
            "  start up the automatic setup program.  The latest installation script",
            "  is available via anonymous FTP from ftp.mcs.net in the directory",
            "  /mcsnet.users/darkowl/ANSI, in a file named ANSI.moo."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$ansi_utils",
            "@ansi-setup"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*subst*",
            "%;this:ansi_log()"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*forward*",
            "ansi-intro"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$ansi_pc",
            "@ansi-status"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "*verbdoc*",
            "$ansi_pc",
            "@ansi-title"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "                    +-------------+                                    O F",
            "                    | ANSI System |#                                 S u o",
            "                    |    v2.4     |#                           N E C e t r",
            "                    +_____________+#                           e n o t l e",
            "                      ##############                           s i r u a s",
            "        object:verb                   change?                  t g e p w t",
            " +-+---------------------------+--------------------------------------------+",
            " |1| $string_utils:left        | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |1|              :right       | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |1|              :center      | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |1|              :columnize   | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |1|              :space       | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |1| $guest:do_reset           | Clearing props on $ansi_pc   |X|_|X|X|_|_|_|",
            " |1| $prog:@list               | Ignoring ANSI                |X|_|X|X|_|_|_|",
            " |2| $login:notify             | Stripping out ANSI           |X|_|X|X|_|_|_|",
            " |2|       :\"@who who\"         | $ansi_utils:show_who_listing |X|_|X|X|_|_|_|",
            " |2| $m_a:display_seq_headers  | Formatting                   |X|_|X|X|_|_|_|",
            " |2| $bmr:display_seq_headers  | Formatting                   |X|_|X|X|_|_|_|",
            " |2| $generic_editor:list_line | ignore ANSI                  |X|_|X|X|_|_|_|",
            " |2|              :fill_string | Redirect to $ansi_utils      |X|_|X|X|_|_|_|",
            " |2| $player_db:insert         | Stripping out ANSI           |X|_|X|X|_|_|_|",
            " |2| $prog:@dump               | Ignoring ANSI                |*|_|X|_|_|_|_|",
            " |2| $bu:object_audit_string   | Formatting                   |X|_|X|_|_|_|_|",
            " |2|    :do_audit_item         | Formatting                   |X|_|X|_|_|_|_|",
            " |3| $mail_agent:name          | Terminate normal             |X|_|X|_|_|_|_|",
            " |4| $string_utils:from_value  | Terminate normal             |X|_|_|_|_|_|_|",
            " |4|              :print       | Terminate normal             |X|_|_|_|_|_|_|",
            " |4| $player:tell_contents     | Formatting                   |X|_|X|_|_|_|_|",
            " |4| $cu:find_verbs_containing | Stripping out ANSI           |X|_|_|_|_|_|_|",
            " |4| $player:send_self_netmail | Stripping out ANSI           |X|_|_|_|_|_|_|",
            " | |  or $mail_recipient_class |                              |#|#|#|#|#|#|#|",
            " | |                           |                              |_|_|_|_|_|_|_|",
            " |===================--- Popular but Non-Core verbs ---=====================|",
            " |4| MCC FO:xm                 | Terminate normal             |_|_|_|_|_|_|_|",
            " |5|       :organize_columns   | Formatting                   |_|X|_|_|_|_|_|",
            " |5|       :get_name           | Colors in people's names     |_|_|_|_|_|_|_|",
            " | |                           |                              |_|_|_|_|_|_|_|",
            " +-+---------------------------+--------------------------------------------+",
            " ",
            "      +------------------+       +----------------------------------------+",
            "      | X - done         |#      | 1 - Required for MOO operation         |#",
            "      | # - N/A          |#      | 2 - Necessary for things to work right |#",
            "      | * - extra stuff  |#      | 3 - Possible security hazard           |#",
            "      | _ - not done     |#      | 4 - Fixes mild annoyance               |#",
            "      +__________________+#      | 5 - Makes something look better        |#",
            "        ###################      +________________________________________+#",
            "                                   #########################################"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "ansi-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "ANSI Help",
            "ah"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": "A help database of the standard form in need of a description. See `help $generic_help'...",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            26826,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "102": {
      "id": 102,
      "name": "ANSI Options",
      "flags": 16,
      "owner": 98,
      "location": -1,
      "parents": [
        68
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "actual",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 102,
          "code": [
            "if (args[1] == \"all\")",
            "return {{\"colors\", a = args[2]}, {\"backgrounds\", a}, {\"extra\", a}, {\"misc\", a}, {\"blinking\", a}, {\"bold\", a}, {\"ignore\", 0}, {\"truecolor\", a}, {\"256\", a}};",
            "elseif (args[1] == \"none\")",
            "return {{\"colors\", a = !args[2]}, {\"backgrounds\", a}, {\"extra\", a}, {\"misc\", a}, {\"blinking\", a}, {\"bold\", a}, {\"truecolor\", a}, {\"256\", a}};",
            "else",
            "return {args};",
            "endif"
          ]
        },
        {
          "name": "show_escape",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 102,
          "code": [
            "if (value = this:get(@args))",
            "return {value, {tostr(\"Send \\\"\", value, \"\\\" for the escape character.\")}};",
            "else",
            "return {0, {\"Use a character 27 as the escape character.\"}};",
            "endif"
          ]
        },
        {
          "name": "parse_escape",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 102,
          "code": [
            "oname = args[1];",
            "raw = args[2];",
            "if (typeof(raw) == STR)",
            "return {oname, raw};",
            "else",
            "return \"String value expected.\";",
            "endif"
          ]
        }
      ],
      "propnames": [
        "show_colors",
        "show_backgrounds",
        "show_blinking",
        "show_bold",
        "show_misc",
        "show_all",
        "show_none",
        "type_escape",
        "show_ignore",
        "show_no_connect_status",
        "show_extra",
        "show_truecolor",
        "show_approximate_256",
        "show_256"
      ],
      "propdefs": [
        {
          "value": [
            "Strip out standard 16 color sequences.",
            "Translate standard 16 color sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Strip out background color sequences.",
            "Translate background color sequences."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "Do not show blinking sequences.",
            "Show blinking sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Do not show bright colors.",
            "Send bright colors."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Do not send all the other ANSI sequences.",
            "Send all the other ANSI sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Do not send any ANSI sequences.",
            "Send all ANSI sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Send all ANSI sequences.",
            "Do not send any ANSI sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            2
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "See 'help ansi-options' for more information.",
            "Overriding other options and ignoring all ANSI codes."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Don't show any status messages upon connecting.",
            "Show status messages about ANSI upon connecting."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Do not send extra non-ANSI codes (such as beep).",
            "Send extra non-ANSI codes (such as beep)."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "Strip out 24-bit True Color sequences.",
            "Translate 24-bit True Color sequences."
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            "24-bit color sequences are not approximated to 8-bit sequences for older clients.",
            "24-bit color sequences are approximated to 8-bit sequences for older clients."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "Strip out Xterm 256 color sequences.",
            "Translate Xterm 256 color sequences."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "colors",
            "blinking",
            "bold",
            "misc",
            "escape",
            "ignore",
            "no_connect_status",
            "extra",
            "backgrounds",
            "truecolor",
            "256"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": "!colors!blinking!bold!misc!escape!ignore!no_connect_status!extra!backgrounds!truecolor!all!none!256!",
          "owner": 36,
          "perms": 1
        },
        {
          "value": [
            "all",
            "none"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 25,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "ANSI Options",
            "ao"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": "An option package for controlling and customizing the ANSI PC.",
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            5739,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "103": {
      "id": 103,
      "name": "generic message dispatch object",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        1
      ],
      "children": [
        104
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "parse_send_args",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 103,
          "code": [
            "\"Usage:  :parse_send_args(msg, @posargs, @keywordargs)\";",
            "\"\";",
            "\"Transform a given message's arguments (mostly given positionally) into the correct form for MCP.  The cord type has an ordered list of argument keywords for all valid messages; these are matched with the arguments provided to produce an alist.  If more arguments are provided than keywords are available, then the remaining arguments should be {keyword, value} pairs.  This allows the passing of optional arguments and such.\";",
            "\"\";",
            "\"This verb returns an alist suitable for use with :client_notify().\";",
            "\"\";",
            "\"Examples:\";",
            "\"  .messages_out = {{\\\"edit\\\", {\\\"name\\\", \\\"text\\\"}}}\";",
            "\"  :parse_send_args(\\\"edit\\\", \\\"#123.foo\\\", {\\\"This is the first line.\\\"})\";",
            "\"    => {{\\\"name\\\", \\\"#123.foo\\\"}, {\\\"text\\\", {\\\"This is the first line.\\\"}}}\";",
            "\"  :parse_send_args(\\\"edit\\\", \\\"#123:foo\\\", {\\\"Hi!\\\"}, {\\\"type\\\", \\\"MOO-Code\\\"})\";",
            "\"    => {{\\\"name\\\", \\\"#123.foo\\\"}, {\\\"text\\\", {\\\"Hi!\\\"}}, {\\\"type\\\", \\\"MOO-Code\\\"}}\";",
            "{msg, @rest} = args;",
            "a = $list_utils:assoc(msg, this.messages_out);",
            "if (!a)",
            "raise(E_INVARG, \"Invalid message\");",
            "endif",
            "keywords = a[2];",
            "lkeywords = length(keywords);",
            "lrest = length(rest);",
            "if (lrest < lkeywords)",
            "raise(E_ARGS, \"Incorrect number of message arguments\");",
            "endif",
            "return {@$list_utils:make_alist({keywords, rest[1..lkeywords]}), @rest[lkeywords + 1..$]};"
          ]
        },
        {
          "name": "parse_receive_args",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 103,
          "code": [
            "\"Usage:  :parse_receive_args(msg, alist)\";",
            "\"\";",
            "\"Transform a messages arguments from an alist into a mostly-positional list.  The cord type has an ordered list of argument keywords for all valid messages; these are used to construct an ordered list of the items from the alist that correspond to those keywords.  If there are items in the alist that do not match a known keyword, they will be appended to the positional list with keywords attached.\";",
            "\"\";",
            "\"Examples:\";",
            "\"  .messages_in = {{\\\"edit\\\", {\\\"name\\\", \\\"text\\\"}}}\";",
            "\"  :parse_receive_args({{\\\"name\\\", \\\"#123.foo\\\"}, {\\\"text\\\", {\\\"Hi!\\\"}}})\";",
            "\"    => {\\\"#123.foo\\\", \\\"Hi!\\\"}\";",
            "\"  :parse_receive_args({{\\\"name\\\", \\\"#123.foo\\\"}, {\\\"text\\\", {\\\"Hi!\\\"}}, {\\\"type\\\", \\\"MOO-Code\\\"}})\";",
            "\"    => {\\\"#123.foo\\\", \\\"Hi!\\\", {\\\"type\\\", \\\"MOO-Code\\\"}};\";",
            "{msg, alist} = args;",
            "a = $list_utils:assoc(msg, this.messages_in);",
            "if (!a)",
            "\"this should be caught upstream.\";",
            "raise(E_INVARG, \"Invalid cord message\");",
            "endif",
            "ret = {};",
            "for keyword in (a[2])",
            "i = $list_utils:iassoc(keyword, alist);",
            "if (!i)",
            "\"this too should be caught.\";",
            "raise(E_INVARG, \"Missing argument in cord message\");",
            "endif",
            "ret = {@ret, alist[i][2]};",
            "alist = listdelete(alist, i);",
            "endfor",
            "return {@ret, @alist};"
          ]
        },
        {
          "name": "set_messages_in set_messages_out",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 103,
          "code": [
            "\"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.(verb[5..length(verb)]) = args[1];",
            "else",
            "return E_PERM;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "messages_in",
        "messages_out"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "generic message dispatch object",
            "dispatch"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            5312,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "104": {
      "id": 104,
      "name": "generic MCP package",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        103
      ],
      "children": [
        105,
        106,
        113,
        121,
        123
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set_version_range",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 104,
          "code": [
            "\"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.(verb[5..length(verb)]) = args[1];",
            "else",
            "return E_PERM;",
            "endif",
            "\"version: 1.0 Fox Wed Jul  5 17:58:13 1995 EDT\";"
          ]
        },
        {
          "name": "dispatch",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "\"Usage:  :dispatch_request(who, authkey, name, arguments)\";",
            "\"\";",
            "connection = caller;",
            "{message, alist} = args;",
            "if (verbname = this:message_name_to_verbname(message))",
            "set_task_perms(caller_perms());",
            "this:(verbname)(connection, @this:parse_receive_args(message, alist));",
            "endif"
          ]
        },
        {
          "name": "match_request",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "\"Usage:  :match_request(request)\";",
            "\"\";",
            "request = args[1];",
            "if ($object_utils:has_verb(this, verbname = \"mcp_\" + request))",
            "return verbname;",
            "else",
            "return 0;",
            "endif",
            "\"version: 1.0 Fox Wed Jul  5 17:58:14 1995 EDT\";"
          ]
        },
        {
          "name": "initialize_connection",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "\"Usage:  :initialize_connection()\";",
            "\"\";",
            "{version} = args;",
            "connection = caller;",
            "messages = $list_utils:slice(this.messages_in);",
            "connection:register_handlers(messages);"
          ]
        },
        {
          "name": "message_name_to_verbname",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "{message} = args;",
            "if ($object_utils:has_callable_verb(this, vname = \"handle_\" + message))",
            "return vname;",
            "else",
            "return 0;",
            "endif"
          ]
        },
        {
          "name": "finalize_connection",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "connection = caller;",
            "return 0;"
          ]
        },
        {
          "name": "add_cord_type",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "\"Usage:  :add_cord_type(cord_type)\";",
            "\"\";",
            "{cord_type} = args;",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.cord_types = setadd(this.cord_types, cord_type);",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "remove_cord_type",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "\"Usage:  :remove_cord_type(cord_type)\";",
            "\"\";",
            "{cord_type} = args;",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.cord_types = setremove(this.cord_types, cord_type);",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "send_*",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 104,
          "code": [
            "{connection, @args} = args;",
            "if (caller == this)",
            "message = verb[6..$];",
            "`connection:send(message, this:parse_send_args(message, @args)) ! E_VERBNF';",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "version_range",
        "cord_types"
      ],
      "propdefs": [
        {
          "value": [
            "1.0",
            "1.0"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "generic MCP package",
            "package"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            7185,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "105": {
      "id": 105,
      "name": "mcp-negotiate",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        104
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "do_negotiation",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 105,
          "code": [
            "connection = caller;",
            "for keyval in ($mcp.registry:packages())",
            "{name, package} = keyval;",
            "this:send_can(connection, name, @package.version_range);",
            "endfor",
            "this:send_end(connection);"
          ]
        },
        {
          "name": "handle_can",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 105,
          "code": [
            "if (caller == this)",
            "{connection, package, minv, maxv, @rest} = args;",
            "if (valid(pkg = $mcp.registry:match_package(package)))",
            "if (version = $mcp:compare_version_range({minv, maxv}, pkg.version_range))",
            "connection:add_package(pkg, version);",
            "endif",
            "endif",
            "endif"
          ]
        },
        {
          "name": "handle_end",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 105,
          "code": [
            "if (caller == this)",
            "{connection, @rest} = args;",
            "connection:end_negotiation();",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "1.0",
            "2.0"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "can",
              [
                "package",
                "min-version",
                "max-version"
              ]
            ],
            [
              "end",
              []
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "can",
              [
                "package",
                "min-version",
                "max-version"
              ]
            ],
            [
              "end",
              []
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "mcp-negotiate",
            "negotiate"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            3348,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "106": {
      "id": 106,
      "name": "mcp-cord",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        104
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "next_id",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "if (caller == this)",
            "return tostr(\"I\", this.next_id = this.next_id + 1);",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "cord_send",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "{message, alist} = args;",
            "cord = caller;",
            "session = cord.session;",
            "if (cord in $mcp.cord.registry)",
            "return this:send_(session, tostr(cord.id), message, @alist);",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "cord_closed",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "cord = caller;",
            "session = cord.session;",
            "this:send_closed(session, tostr(cord.id));"
          ]
        },
        {
          "name": "handle_",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "{session, id, message, @assocs} = args;",
            "if (caller == this)",
            "$mcp.cord:mcp_receive(id, message, assocs);",
            "endif"
          ]
        },
        {
          "name": "handle_closed",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "{session, id, @rest} = args;",
            "if (caller == this)",
            "$mcp.cord:mcp_closed(id);",
            "endif"
          ]
        },
        {
          "name": "find_type",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "{name} = args;",
            "for i in ($object_utils:leaves($mcp.cord.type_root))",
            "if (name == (($mcp.registry:package_name(i.parent_package) + \"-\") + i.cord_name))",
            "return i;",
            "endif",
            "endfor",
            "return $failed_Match;"
          ]
        },
        {
          "name": "send_open",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "if (caller == $mcp.cord)",
            "return pass(@args);",
            "endif"
          ]
        },
        {
          "name": "finalize_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "session = caller;",
            "len = length($mcp.cord.registry_ids);",
            "for i in [0..len - 1]",
            "idx = len - i;",
            "cord = $mcp.cord.registry[idx];",
            "if (cord.session == session)",
            "$recycler:_recycle(cord);",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "type_name",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 106,
          "code": [
            "{cord_type} = args;",
            "parent = $mcp:package_name(cord_type.parent_package);",
            "if (suffix = cord_type.cord_name)",
            "return (parent + \"-\") + suffix;",
            "else",
            "return parent;",
            "endif"
          ]
        }
      ],
      "propnames": [
        "next_id",
        "cords",
        "registry_ids"
      ],
      "propdefs": [
        {
          "value": 1,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "open",
              [
                "_id",
                "_type"
              ]
            ],
            [
              "",
              [
                "_id",
                "_message"
              ]
            ],
            [
              "closed",
              [
                "_id"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "open",
              [
                "_id",
                "_type"
              ]
            ],
            [
              "",
              [
                "_id",
                "_message"
              ]
            ],
            [
              "closed",
              [
                "_id"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "mcp-cord",
            "cord"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            7708,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "107": {
      "id": 107,
      "name": "MCP 2.1 parser",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "parse_mcp_alist",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "\"take args and return a list in the format:\";",
            "\"{true if contains multiline, { { keyword-name, data, multiline }, ... }\";",
            "alist = {};",
            "if (length(alist) % 2)",
            "raise(E_ARGS);",
            "endif",
            "contains_multiline = 0;",
            "while (args)",
            "{keyword, value, @args} = args;",
            "if (keyword[$] != \":\")",
            "raise(E_INVARG, \"invalid keyword: \" + keyword);",
            "else",
            "if (keyword[$ - 1] == \"*\")",
            "contains_multiline = 1;",
            "value = {};",
            "keyword = keyword[1..$ - 2];",
            "else",
            "keyword = keyword[1..$ - 1];",
            "endif",
            "alist = {@alist, {keyword, value}};",
            "endif",
            "endwhile",
            "return {contains_multiline, alist};"
          ]
        },
        {
          "name": "parse_mcp",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "\"parse_mcp(@args) =>\";",
            "\"relies on argstr being a version of @args unwordified\";",
            "\"{request-name, contains-multiline, authentication-key, data-tag, { { keyword-name, data }, ... } }\";",
            "if (length(args) < 1)",
            "raise(E_INVARG, \"not enough arguments\");",
            "endif",
            "request_name = args[1][4..$];",
            "if (!request_name)",
            "raise(E_INVARG, \"no request name\");",
            "endif",
            "if (request_name == \"*\")",
            "return this:parse_mcp_continuation(@args[2..$]);",
            "endif",
            "\"... if there is an authentication key, the length of args will be even ...\";",
            "if (length(args) % 2)",
            "authentication_key = E_NONE;",
            "message_args = args[2..$];",
            "else",
            "authentication_key = args[2];",
            "message_args = args[3..$];",
            "endif",
            "{contains_multiline, alist} = this:parse_mcp_alist(@message_args);",
            "if (contains_multiline)",
            "if (tag = $list_utils:iassoc(\"_data-tag\", alist))",
            "\"mulitline with a datatag, OK\";",
            "data_tag = alist[tag][2];",
            "alist = listdelete(alist, tag);",
            "else",
            "raise(E_INVARG, \"multiline fields with no data tag\");",
            "endif",
            "else",
            "data_tag = E_NONE;",
            "endif",
            "if (typeof(alist) == LIST)",
            "return {request_name, contains_multiline, authentication_key, data_tag, alist};",
            "else",
            "return alist;",
            "endif"
          ]
        },
        {
          "name": "parse_mcp_continuation",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "{data_tag, keyword, @rest} = args;",
            "value = argstr[(index(argstr, keyword) + length(keyword)) + 1..$];",
            "keyword = keyword[1..$ - 1];",
            "return {\"*\", data_tag, keyword, value};"
          ]
        },
        {
          "name": "parse",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "\"parse(@args) => parsed MCP message ready for dispatch or 0\";",
            "\"                if there was nothing to dispatch for this message\";",
            "\"                (as in multiline continuations, dispatch\";",
            "\"                for those occurs at the END\";",
            "\"returns {message, authkey, alist} or 0\";",
            "\"argstr must equal the unmodified line from the client\";",
            "{argstr, @words} = args;",
            "session = caller;",
            "message = this:parse_mcp(@words);",
            "if (message[1] == \"*\")",
            "{n, data_tag, keyword, value} = message;",
            "session:multiline_add_value(data_tag, keyword, value);",
            "elseif ((message[1] == \":\") || (message[1] == \"END\"))",
            "{request, dummy, data_tag, dummy, dummy} = message;",
            "return session:multiline_finish(player, data_tag);",
            "else",
            "{request, contains_multiline, authkey, data_tag, alist} = message;",
            "if (contains_multiline)",
            "session:multiline_begin(request, authkey, data_tag, alist);",
            "else",
            "return {request, authkey, alist};",
            "endif",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "unparse",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "{request, authkey, alist} = args;",
            "keyvals = \"\";",
            "need_data_tag = 0;",
            "multilines = {};",
            "for keyval in (alist)",
            "{keyword, value, ?maybe_ignore} = keyval;",
            "if (typeof(value) == STR)",
            "if (!match(value, this.unquoted_string))",
            "value = toliteral(value);",
            "endif",
            "elseif (typeof(value) == LIST)",
            "need_data_tag = 1;",
            "multilines = {@multilines, {keyword, value}};",
            "keyword = keyword + \"*\";",
            "value = \"\\\"\\\"\";",
            "else",
            "value = toliteral(value);",
            "endif",
            "keyvals = (((keyvals + \" \") + keyword) + \": \") + value;",
            "endfor",
            "if (need_data_tag)",
            "data_tag = this:next_datakey();",
            "keyvals = (keyvals + \" _data-tag: \") + data_tag;",
            "endif",
            "message = \"#$#\" + request;",
            "if (authkey)",
            "message = (message + \" \") + authkey;",
            "endif",
            "message = {message + keyvals};",
            "if (need_data_tag)",
            "prefix = (\"#$#* \" + data_tag) + \" \";",
            "for field in (multilines)",
            "{keyword, value} = field;",
            "for line in (value)",
            "message = {@message, tostr(prefix, keyword, \": \", (typeof(line) == LIST) ? toliteral(line) | line)};",
            "endfor",
            "endfor",
            "message = {@message, \"#$#: \" + data_tag};",
            "endif",
            "return message;"
          ]
        },
        {
          "name": "next_datakey",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 107,
          "code": [
            "datakey = tostr(random(), this.next_datakey);",
            "this.next_datakey = this.next_datakey + 1;",
            "return datakey;"
          ]
        }
      ],
      "propnames": [
        "next_datakey",
        "unquoted_string"
      ],
      "propdefs": [
        {
          "value": 10176,
          "owner": 98,
          "perms": 1
        },
        {
          "value": "^[]a-zA-Z0-9-%~`!@#$^&()=+{}[|';?/><.,]+$",
          "owner": 2,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "MCP 2.1 parser",
            "parser"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            6944,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "108": {
      "id": 108,
      "name": "generic MCP 2.1 session",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        122
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "set_connection",
          "owner": 98,
          "perms": 165,
          "preps": -1,
          "object": 108,
          "code": [
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "this.connection = args[1];",
            "this:set_name(\"session for \" + tostr(this.connection));",
            "return 1;",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "multiline_begin",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{request, authkey, data_tag, alist} = args;",
            "if (caller != $mcp.parser)",
            "raise(E_PERM);",
            "elseif ($list_utils:assoc(data_tag, this.pending_multilines))",
            "\"it's not valid to begin two requests with the same data tag, drop it\";",
            "return;",
            "endif",
            "this.pending_multilines = {@this.pending_multilines, {data_tag, authkey, request, alist}};"
          ]
        },
        {
          "name": "multiline_finish",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{who, data_tag} = args;",
            "if ((caller != this) && (caller != $mcp.parser))",
            "raise(E_PERM);",
            "elseif (!(n = $list_utils:iassoc(data_tag, this.pending_multilines)))",
            "\"drop it\";",
            "return;",
            "else",
            "{data_tag, authkey, request, alist} = this.pending_multilines[n];",
            "this.pending_multilines = listdelete(this.pending_multilines, n);",
            "return {request, authkey, alist};",
            "endif"
          ]
        },
        {
          "name": "multiline_add_value",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{data_tag, keyword, value} = args;",
            "if (caller != $mcp.parser)",
            "raise(E_PERM);",
            "elseif (!(n = $list_utils:iassoc(data_tag, this.pending_multilines)))",
            "\"drop it\";",
            "return;",
            "elseif (!(nkey = $list_utils:iassoc(keyword, this.pending_multilines[n][4])))",
            "\"drop it\";",
            "return;",
            "elseif (typeof(this.pending_multilines[n][4][nkey][2]) != LIST)",
            "\"not a multiline, drop it.\";",
            "return;",
            "else",
            "this.pending_multilines[n][4][nkey][2] = {@this.pending_multilines[n][4][nkey][2], value};",
            "endif"
          ]
        },
        {
          "name": "do_out_of_band_command",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "if (caller != $mcp)",
            "raise(E_PERM);",
            "else",
            "set_task_perms(caller_perms());",
            "if (`player.MCP_snoop ! ANY')",
            "player:tell(\"C->S: \", argstr);",
            "endif",
            "if (message = $mcp.parser:parse(argstr, @args))",
            "this:dispatch(@message);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "finish",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "if (caller == $mcp)",
            "this:_signal_package_waiter(E_INVARG);",
            "for package in ($list_utils:slice(this.packages))",
            "fork (0)",
            "package:finalize_connection();",
            "endfork",
            "endfor",
            "return $mcp:finalize_connection(this);",
            "endif"
          ]
        },
        {
          "name": "initialize_connection",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "if (caller != $mcp)",
            "raise(E_PERM);",
            "else",
            "this:send(\"mcp\", {{\"version\", \"2.1\"}, {\"to\", \"2.1\"}});",
            "endif"
          ]
        },
        {
          "name": "set_packages set_authentication_key set_phase",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "\"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).\";",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "return this.(verb[5..length(verb)]) = args[1];",
            "else",
            "return E_PERM;",
            "endif"
          ]
        },
        {
          "name": "add_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{package, version} = args;",
            "if (caller in {$mcp.negotiate, this})",
            "if (n = $list_utils:iassoc(package, this.packages))",
            "packages = this.packages;",
            "packages[n][2] = version;",
            "this:set_packages(packages);",
            "else",
            "this:set_packages({@this.packages, {package, version}});",
            "endif",
            "package:initialize_connection(version);",
            "this:_signal_package_waiter(package, version);",
            "endif"
          ]
        },
        {
          "name": "handles_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{package} = args;",
            "if (assoc = $list_utils:assoc(package, this.packages))",
            "return assoc[2];",
            "endif"
          ]
        },
        {
          "name": "register_handlers",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{messages} = args;",
            "package = caller;",
            "{plist, mlist} = this.message_handlers;",
            "prefix = this:package_name(package);",
            "for message in (messages)",
            "message = this:message_fullname(prefix, message);",
            "if (idx = message in mlist)",
            "if (plist[idx] != package)",
            "raise(E_INVARG);",
            "endif",
            "else",
            "plist = {@plist, package};",
            "mlist = {@mlist, message};",
            "endif",
            "endfor",
            "this.message_handlers = {plist, mlist};"
          ]
        },
        {
          "name": "dispatch",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{message, authkey, alist} = args;",
            "if (caller == this)",
            "if ((!this.phase) && (message == \"mcp\"))",
            "authkey = $list_utils:assoc(\"authentication-key\", alist);",
            "minv = $list_utils:assoc(\"version\", alist);",
            "maxv = $list_utils:Assoc(\"to\", alist);",
            "if (((authkey && minv) && maxv) && $mcp:compare_version_range({minv[2], maxv[2]}, {$mcp.version, $mcp.version}))",
            "this:set_authentication_key(authkey[2]);",
            "this:add_package($mcp.negotiate, $mcp.negotiate.version_range[1]);",
            "else",
            "\"woop woop break somehow\";",
            "return;",
            "endif",
            "this:set_phase(1);",
            "$mcp.negotiate:do_negotiation();",
            "elseif (this.phase)",
            "if ((this.authentication_key != E_NONE) && (authkey != this.authentication_key))",
            "return;",
            "endif",
            "package = this:find_handler(message);",
            "if (typeof(package) == OBJ)",
            "set_task_perms(caller_perms());",
            "package:dispatch(this:strip_prefix(this:package_name(package), message), alist);",
            "endif",
            "\"figure out which package to dispatch to\";",
            "\"do dispatch\";",
            "endif",
            "endif"
          ]
        },
        {
          "name": "send",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{message, alist} = args;",
            "who = caller_perms();",
            "if (caller == this)",
            "prefix = \"\";",
            "elseif ($list_utils:assoc(caller, this.packages))",
            "package = caller;",
            "message = this:message_fullname(this:package_name(package), message);",
            "else",
            "raise(E_PERM);",
            "endif",
            "con = this.connection;",
            "snoop = `this.connection.MCP_snoop ! E_PROPNF, E_INVIND => 0';",
            "for line in ($mcp.parser:unparse(message, this.authentication_key, alist))",
            "notify(con, line);",
            "if (snoop)",
            "notify(con, \"S->C: \" + line);",
            "endif",
            "endfor"
          ]
        },
        {
          "name": "find_handler",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{message} = args;",
            "if (assoc = $list_utils:passoc(message, this.message_handlers[2], this.message_handlers[1]))",
            "return assoc[2];",
            "endif"
          ]
        },
        {
          "name": "connection",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "return this.connection;"
          ]
        },
        {
          "name": "package_name",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{package} = args;",
            "return $mcp.registry:package_name(package);"
          ]
        },
        {
          "name": "message_fullname",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{prefix, message} = args;",
            "if (message)",
            "message = (prefix + \"-\") + message;",
            "else",
            "message = prefix;",
            "endif",
            "return message;"
          ]
        },
        {
          "name": "strip_prefix",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{prefix, message} = args;",
            "if (index(message, prefix + \"-\") == 1)",
            "return message[length(prefix) + 2..$];",
            "elseif (index(message, prefix) == 1)",
            "return message[length(prefix) + 1..$];",
            "elseif (message == prefix)",
            "return \"\";",
            "else",
            "return message;",
            "endif"
          ]
        },
        {
          "name": "end_negotiation",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "if (caller == $mcp.negotiate)",
            "this:_signal_package_waiter(0);",
            "endif"
          ]
        },
        {
          "name": "_add_package_waiter",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{package, timeout} = args;",
            "if (caller == this)",
            "this.package_waiters = {@this.package_waiters, {package, task_id()}};",
            "if (timeout < 0)",
            "r = suspend();",
            "else",
            "r = suspend(timeout);",
            "endif",
            "this.package_waiters = setremove(this.package_waiters, {package, task_id()});",
            "return r;",
            "endif"
          ]
        },
        {
          "name": "_signal_package_waiter",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{?package = $nothing, value} = args;",
            "if (caller == this)",
            "all = package == $nothing;",
            "for keyval in (this.package_waiters)",
            "{pkg, tid} = keyval;",
            "if (all || (pkg == package))",
            "`resume(tid, value) ! ANY';",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "wait_for_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 108,
          "code": [
            "{package, ?timeout} = args;",
            "timeout = `timeout ! E_VARNF => -1';",
            "if (v = this:handles_package(package))",
            "return v;",
            "else",
            "return this:_add_package_waiter(package, timeout);",
            "endif"
          ]
        }
      ],
      "propnames": [
        "connection",
        "pending_multilines",
        "packages",
        "authentication_key",
        "phase",
        "package_waiters",
        "message_handlers"
      ],
      "propdefs": [
        {
          "value": -1,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 0
        },
        {
          "value": [],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 0
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [],
          "owner": 98,
          "perms": 0
        },
        {
          "value": [
            [],
            []
          ],
          "owner": 98,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "109": {
      "id": 109,
      "name": "MCP package registry",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "add_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "{name, package} = args;",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "if (name in this.package_names)",
            "raise(E_INVARG, \"Another package with that name already exists\");",
            "elseif (package in this.packages)",
            "raise(E_INVARG, \"That package already is registered under a different name.\");",
            "else",
            "this.package_names = {@this.package_names, name};",
            "this.packages = {@this.packages, package};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "remove_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "{name} = args;",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), this))",
            "if (idx = name in this.package_names)",
            "this.package_names = listdelete(this.package_names, idx);",
            "this.packages = listdelete(this.packages, idx);",
            "else",
            "raise(E_INVARG, \"Not a defined package\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "match_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "{name} = args;",
            "if (idx = name in this.package_names)",
            "return this.packages[idx];",
            "else",
            "return $failed_match;",
            "endif"
          ]
        },
        {
          "name": "package_name",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "{package} = args;",
            "if (idx = package in this.packages)",
            "return this.package_names[idx];",
            "else",
            "return \"\";",
            "endif"
          ]
        },
        {
          "name": "packages",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "return $list_utils:make_alist({this.package_names, this.packages});"
          ]
        },
        {
          "name": "init_for_module init_for_core",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 109,
          "code": [
            "if (caller_perms().wizard)",
            "for name in (this.package_names)",
            "this:remove_package(name);",
            "endfor",
            "for x in (children($mcp.package))",
            "`this:add_package(x.name, x) ! E_INVARG';",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "@add-package @remove-package",
          "owner": 2,
          "perms": 153,
          "preps": 1,
          "object": 109,
          "code": [
            "if (!$perm_utils:controls(player, this))",
            "player:tell(\"You don't have permission to add or remove MCP 2.1 packages.\");",
            "elseif ($command_utils:object_match_failed(dobj, dobjstr))",
            "elseif (!$object_utils:isa(dobj, $mcp.package))",
            "player:tell(dobj.name, \" is not a valid MCP 2.1 package (descendant of \", $mcp.package, \").\");",
            "elseif (!$perm_utils:controls(player, dobj))",
            "player:tell(\"You don't control \", dobj.name, \" in order to add or remove it.\");",
            "else",
            "name = dobj.name;",
            "package = dobj;",
            "try",
            "if (verb == \"@add-package\")",
            "this:add_package(name, package);",
            "player:tell(\"Added \", package.name, \".\");",
            "else",
            "this:remove_package(name);",
            "player:tell(\"Removed \", package.name, \".\");",
            "endif",
            "except v (ANY)",
            "{code, message, value, tb} = v;",
            "player:tell(code, \": \", message);",
            "endtry",
            "endif"
          ]
        }
      ],
      "propnames": [
        "package_names",
        "packages"
      ],
      "propdefs": [
        {
          "value": [
            "mcp-negotiate",
            "mcp-cord",
            "dns-org-mud-moo-simpleedit",
            "dns-com-vmoo-client",
            "dns-com-awns-status"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            105,
            106,
            113,
            121,
            123
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "MCP package registry",
            "registry"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            6696,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "110": {
      "id": 110,
      "name": "MCP 2.1",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "create_session",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{connection} = args;",
            "if (caller != this)",
            "raise(E_PERM);",
            "elseif (typeof(session = this.session:new()) != ANON)",
            "raise(session);",
            "endif",
            "session:set_connection(connection);",
            "session:initialize_connection();",
            "return session;"
          ]
        },
        {
          "name": "destroy_session",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{session} = args;",
            "if (!(caller in {this, session}))",
            "raise(E_PERM);",
            "elseif (!$object_utils:isa(session, this.session))",
            "raise(E_INVARG);",
            "elseif (session == this.session)",
            "raise(E_INVARG);",
            "else",
            "$recycler:_recycle(session);",
            "endif"
          ]
        },
        {
          "name": "initialize_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{who} = args;",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "return this:create_session(who);"
          ]
        },
        {
          "name": "finalize_connection",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{con} = args;",
            "if (caller == con)",
            "this:destroy_session(con);",
            "endif"
          ]
        },
        {
          "name": "parse_version",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "\"string version number -> {major, minor}\";",
            "{version} = args;",
            "if (m = match(version, \"%([0-9]+%)%.%([0-9]+%)\"))",
            "return {toint(substitute(\"%1\", m)), toint(substitute(\"%2\", m))};",
            "endif"
          ]
        },
        {
          "name": "compare_version_range",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{client, server} = args;",
            "{min1, max1} = client;",
            "{min2, max2} = server;",
            "min1 = (typeof(min1) == STR) ? this:parse_version(min1) | min1;",
            "min2 = (typeof(min2) == STR) ? this:parse_version(min2) | min2;",
            "max1 = (typeof(max1) == STR) ? this:parse_version(max1) | max1;",
            "max2 = (typeof(max2) == STR) ? this:parse_version(max2) | max2;",
            "if (!(((min1 && min2) && max1) && max2))",
            "return;",
            "else",
            "if ((this:compare_version(max1, min2) <= 0) && (this:compare_version(max2, min1) <= 0))",
            "if (this:compare_version(max1, max2) < 0)",
            "return max2;",
            "else",
            "return max1;",
            "endif",
            "endif",
            "endif",
            "return 0;"
          ]
        },
        {
          "name": "compare_version",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "\"-1 if v1 > v2, 0 if v1 = v2, 1 if v1 < v2\";",
            "{v1, v2} = args;",
            "if (v1 == v2)",
            "return 0;",
            "else",
            "{major1, minor1} = v1;",
            "{major2, minor2} = v2;",
            "if (major1 == major2)",
            "if (minor1 > minor2)",
            "return -1;",
            "else",
            "return 1;",
            "endif",
            "elseif (major1 > major2)",
            "return -1;",
            "else",
            "return 1;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "unparse_version",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{major, minor} = args;",
            "return tostr(major, \".\", minor);"
          ]
        },
        {
          "name": "session_for",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{who} = args;",
            "return `who.out_of_band_session ! E_PROPNF => $failed_match';"
          ]
        },
        {
          "name": "user_created user_connected user_reconnected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{who} = args;",
            "if (listeners(caller))",
            "if ($recycler:valid(who.out_of_band_session))",
            "`who.out_of_band_session:finish() ! ANY';",
            "endif",
            "who.out_of_band_session = this:initialize_connection(who);",
            "endif"
          ]
        },
        {
          "name": "user_disconnected user_client_disconnected",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{who} = args;",
            "if (listeners(caller))",
            "if ($recycler:valid(who.out_of_band_session))",
            "`who.out_of_band_session:finish() ! ANY';",
            "who.out_of_band_session = $nothing;",
            "endif",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "do_out_of_band_command",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "if (listeners(caller))",
            "if ($recycler:valid(session = player.out_of_band_session))",
            "set_task_perms(player);",
            "return session:do_out_of_band_command(@args);",
            "endif",
            "endif"
          ]
        },
        {
          "name": "package_name match_package packges",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "return this.registry:(verb)(@args);"
          ]
        },
        {
          "name": "handles_package wait_for_package",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "{who, @rest} = args;",
            "if (valid(session = this:session_for(who)))",
            "return session:(verb)(@rest);",
            "endif"
          ]
        },
        {
          "name": "include_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 110,
          "code": [
            "return {\"parser\", \"session\", \"package\", \"negotiate\", \"registry\", \"cord\", \"simpleedit\", \"client\", \"status\", \"dispatch\"};"
          ]
        }
      ],
      "propnames": [
        "parser",
        "session",
        "version",
        "package",
        "negotiate",
        "registry",
        "cord",
        "simpleedit",
        "client",
        "status",
        "dispatch"
      ],
      "propdefs": [
        {
          "value": 107,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 108,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            2,
            1
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": 104,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 105,
          "owner": 2,
          "perms": 1
        },
        {
          "value": 109,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 106,
          "owner": 98,
          "perms": 1
        },
        {
          "value": 113,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 121,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 123,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 103,
          "owner": 98,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "MCP 2.1",
            "mcp"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            11136,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "111": {
      "id": 111,
      "name": "Object Prototype",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        120
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "tell notify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 111,
          "code": [
            "\"Notify a connection of something.\";",
            "set_task_perms(caller_perms());",
            "if (this < #0)",
            "return notify(this, @args);",
            "else",
            "return this:(verb)(@args);",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "112": {
      "id": 112,
      "name": "",
      "flags": 2047,
      "owner": -1,
      "location": -1,
      "parents": [],
      "children": [],
      "last_move": -1,
      "contents": [],
      "verbs": [],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": true
    },
    "113": {
      "id": 113,
      "name": "dns-org-mud-moo-simpleedit",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        104
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "send_content",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "\"Usage:  :send_content()\";",
            "\"\";",
            "if ($perm_utils:controls(caller_perms(), args[1]))",
            "pass(@args);",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "handle_set",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "\"Usage:  :handle_set(session, reference, type, content)\";",
            "\"\";",
            "{session, reference, type, content} = args;",
            "if (caller != this)",
            "raise(E_PERM);",
            "endif",
            "set_task_perms(session.connection);",
            "try",
            "if (type == \"moo-code\")",
            "rval = this:edit_set_program(reference, content);",
            "elseif (reference == \"sendmail\")",
            "rval = this:edit_sendmail(reference, content);",
            "else",
            "rval = this:edit_set_note_value(reference, type, content);",
            "endif",
            "player:notify_lines((typeof(rval) == LIST) ? rval | {rval});",
            "except v (ANY)",
            "player:notify_lines((typeof(v[2]) == LIST) ? v[2] | {v[2]});",
            "\"   player:notify_lines($code_utils:format_traceback(v[4], v[2]));\";",
            "endtry"
          ]
        },
        {
          "name": "edit_set_program",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "{reference, lines} = args;",
            "set_task_perms(caller_perms());",
            "args = $string_utils:words(reference);",
            "punt = 1;",
            "if (!(spec = $code_utils:parse_verbref(args[1])))",
            "raise(E_INVARG, \"Invalid reference: \" + reference);",
            "elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))",
            "return;",
            "elseif ($string_utils:is_numeric(spec[2]))",
            "\"numeric verbref\";",
            "if ((verbname = $code_utils:tonum(spec[2])) == E_TYPE)",
            "raise(E_INVARG, \"Invalid verb number\");",
            "elseif (length(args) > 1)",
            "raise(E_INVARG, \"Invalid reference: \" + reference);",
            "elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM => 0')",
            "raise(E_INVARG, \"Verb number out of range.\");",
            "else",
            "argspec = 0;",
            "punt = 0;",
            "endif",
            "elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)",
            "raise(E_INVARG, tostr(argspec));",
            "elseif (argspec[2])",
            "raise(E_INVARG, $string_utils:from_list(argspec[2], \" \") + \"??\");",
            "elseif (length(argspec = argspec[1]) in {1, 2})",
            "raise(E_INVARG, {\"Missing preposition\", \"Missing iobj specification\"}[length(argspec)]);",
            "else",
            "punt = 0;",
            "verbname = spec[2];",
            "if (index(verbname, \"*\") > 1)",
            "verbname = strsub(verbname, \"*\", \"\");",
            "endif",
            "endif",
            "\"...\";",
            "\"...if we have an argspec, we'll need to reset verbname...\";",
            "\"...\";",
            "if (punt)",
            "elseif (argspec)",
            "named = argspec[4..min(5, $)];",
            "argspec = argspec[1..3];",
            "if (!(argspec[2] in {\"none\", \"any\"}))",
            "argspec[2] = $code_utils:full_prep(argspec[2]);",
            "endif",
            "loc = $code_utils:find_verb_named_1_based(object, verbname);",
            "while (loc && (`verb_args(object, loc) ! E_PERM' != argspec))",
            "loc = $code_utils:find_verb_named_1_based(object, verbname, loc + 1);",
            "endwhile",
            "if (loc)",
            "verbname = loc;",
            "else",
            "punt = \"...can't find it....\";",
            "raise(E_INVARG, \"That object has no verb matching that name + args.\");",
            "endif",
            "else",
            "named = {};",
            "loc = (typeof(verbname) == NUM) ? verbname | 0;",
            "endif",
            "if (!punt)",
            "try",
            "info = verb_info(object, verbname);",
            "except e (ANY)",
            "if (e[1] == E_VERBNF)",
            "raise(E_INVARG, \"That object does not have that verb definition.\");",
            "else",
            "raise(E_INVARG, tostr(e[2]));",
            "endif",
            "punt = 1;",
            "endtry",
            "if (!punt)",
            "aliases = info[3];",
            "if (!loc)",
            "loc = aliases in (verbs(object) || {});",
            "endif",
            "endif",
            "endif",
            "if (punt)",
            "return;",
            "else",
            "\"filter the verb?\";",
            "if (this.v_filter_in)",
            "lines = this.v_filter_in[1]:(this.v_filter_in[2])(lines);",
            "endif",
            "if (0 && named)",
            "\"Disabled: We want to see all of the code in the verb and not in the title.\";",
            "code = $code_utils:split_verb_code(lines);",
            "lines = {@code[1], @$code_utils:named_args_to_code(named), @code[2]};",
            "endif",
            "try",
            "result = set_verb_code(object, verbname, lines);",
            "except e (ANY)",
            "result = e[2] + \" \";",
            "\"just in case some idiot throws an error with an empty string\";",
            "endtry",
            "what = $string_utils:nn(object);",
            "if (result)",
            "if (typeof(result) == STR)",
            "return {\"Error programming \" + what, result, \"Verb not programmed.\"};",
            "else",
            "return {\"Error programming \" + what, @result, tostr(length(result), \" error(s).\"), \"Verb not programmed.\"};",
            "endif",
            "else",
            "return {\"0 errors.\", \"Verb programmed.\"};",
            "endif",
            "endif"
          ]
        },
        {
          "name": "edit_sendmail",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "\"See $player:@@sendmail\";",
            "set_task_perms(caller_perms());",
            "{reference, msg} = args;",
            "end_head = (\"\" in msg) || (length(msg) + 1);",
            "subject = \"\";",
            "replyto = \"\";",
            "rcpts = {};",
            "body = msg[end_head + 1..length(msg)];",
            "for i in [1..end_head - 1]",
            "line = msg[i];",
            "if (index(line, \"Subject:\") == 1)",
            "subject = $string_utils:trim(line[9..length(line)]);",
            "elseif (index(line, \"To:\") == 1)",
            "if (!(rcpts = $mail_agent:parse_address_field(line)))",
            "player:notify(\"No recipients found in To: line\");",
            "return;",
            "endif",
            "elseif (index(line, \"Reply-to:\") == 1)",
            "if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..length(line)]))",
            "player:notify(\"No address found in Reply-to: line\");",
            "return;",
            "endif",
            "elseif (i = index(line, \":\"))",
            "player:notify(tostr(\"Unknown header \\\"\", line[1..i], \"\\\"\"));",
            "return;",
            "else",
            "player:notify(\"Blank line must separate headers from body.\");",
            "return;",
            "endif",
            "endfor",
            "if (!rcpts)",
            "player:notify(\"No To: line found.\");",
            "elseif (!(subject || body))",
            "player:notify(\"Blank message not sent.\");",
            "else",
            "player:notify(\"Sending...\");",
            "result = $mail_agent:send_message(player, rcpts, replyto ? subject | {subject, replyto}, body);",
            "if (e = result && result[1])",
            "if (length(result) == 1)",
            "player:notify(\"Mail actually went to no one.\");",
            "else",
            "player:notify(tostr(\"Mail actually went to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));",
            "endif",
            "else",
            "player:notify(tostr((typeof(e) == ERR) ? e | (\"Bogus recipients:  \" + $string_utils:from_list(result[2]))));",
            "player:notify(\"Mail not sent.\");",
            "endif",
            "endif",
            "return {};"
          ]
        },
        {
          "name": "edit_set_note_value",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "set_task_perms(caller_perms());",
            "{reference, type, content} = args;",
            "\"reference format == [str|val]:#xx[.pname]\";",
            "if (!match(reference, \"^%(str%|val%):.+\"))",
            "return {\"Malformed reference: \" + reference};",
            "else",
            "vtype = reference[1..3];",
            "reference = reference[5..$];",
            "if (((vtype == \"str\") && (type == \"string\")) && (length(content) <= 1))",
            "text = content ? content[1] | \"\";",
            "elseif (vtype == \"val\")",
            "text = {};",
            "for x in [1..length(content)]",
            "$sin(0);",
            "value = $string_utils:to_value(content[x]);",
            "if (value[1] != 1)",
            "return {tostr(\"Error on line \", x, \":  \", value[2]), \"Value not saved.\"};",
            "else",
            "text = {@text, value[2]};",
            "endif",
            "endfor",
            "else",
            "text = content;",
            "endif",
            "endif",
            "if (spec = $code_utils:parse_propref(reference))",
            "o = $code_utils:toobj(spec[1]);",
            "p = spec[2];",
            "if (typeof(o) == OBJ)",
            "if ($object_utils:has_callable_verb(o, setter = \"set_\" + p))",
            "e = o:(setter)(text);",
            "else",
            "e = o.(p) = text;",
            "endif",
            "else",
            "return {\"Malformed reference: You must supply an object number.\"};",
            "endif",
            "if (typeof(e) == ERR)",
            "raise(e, tostr(\"Error: \", e));",
            "else",
            "return tostr(\"Set \", p, \" property of \", o.name, \" (\", o, \").\");",
            "endif",
            "elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)",
            "o = note;",
            "e = note:set_text(text);",
            "if (typeof(e) == ERR)",
            "return {tostr(\"Error: \", e)};",
            "else",
            "return tostr(\"Set text of \", o.name, \".\");",
            "endif",
            "else",
            "raise(E_INVARG, tostr(\"Error: Malformed argument to \", verb, \": \", argstr));",
            "endif"
          ]
        },
        {
          "name": "verbcode_external_to_internal",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "\"Charter: given a block of verb code lines from the user, transform it into code ready to be passed to set_verb_code().  In particular, reverse any transformation made by :verbcode_internal_to_external.\";",
            "\"This version transforms `// foo' comments to `\\\"foo\\\";' comments.\";",
            "lines = args[1];",
            "new_comments = player:prog_option(\"//_comments\");",
            "if (!new_comments)",
            "return lines;",
            "endif",
            "newlines = {};",
            "for line in (lines)",
            "mat = match(line, \"^ *// ?%(.*%)$\");",
            "if (mat)",
            "comment = substitute(\"%1\", mat);",
            "out = $code_utils:commentify({comment});",
            "newlines = {@newlines, out[1]};",
            "else",
            "newlines = {@newlines, line};",
            "endif",
            "endfor",
            "return newlines;"
          ]
        },
        {
          "name": "verbcode_internal_to_external",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 113,
          "code": [
            "\"Charter: given a block of verb code from the verb_code() primitive, transform it into its external representation to be presented to the user.\";",
            "\"This version transforms `\\\"foo\\\";' comments to `// foo' comments.\";",
            "lines = args[1];",
            "new_comments = player:prog_option(\"//_comments\");",
            "if (!new_comments)",
            "return lines;",
            "endif",
            "newlines = {};",
            "for line in (lines)",
            "mat = match(line, \"^%( *%)%(\\\".*\\\";%)$\");",
            "if (mat)",
            "blanks = substitute(\"%1\", mat);",
            "comment = substitute(\"%2\", mat);",
            "uncommented = $code_utils:uncommentify({comment});",
            "out = (blanks + \"// \") + uncommented[1];",
            "newlines = {@newlines, out};",
            "else",
            "newlines = {@newlines, line};",
            "endif",
            "endfor",
            "return newlines;"
          ]
        }
      ],
      "propnames": [
        "foo",
        "v_filter_in",
        "v_filter_out"
      ],
      "propdefs": [
        {
          "value": 1,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            113,
            "verbcode_external_to_internal"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            113,
            "verbcode_internal_to_external"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "1.0",
            "1.0"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "set",
              [
                "reference",
                "type",
                "content"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "content",
              [
                "reference",
                "name",
                "type",
                "content"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "dns-org-mud-moo-simpleedit"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "A very simple local editing protocol.",
            "",
            "S->C #$#dns-org-mud-moo-simpleedit-content (reference, name, type, content*)",
            "",
            "Reference is the tag used when sending back to the server.",
            "User may be allowed to edit it (i.e., save this same text into a",
            "different property), with possibility of disastrous results.",
            "",
            "Name is a human-readable name for the info, suitable for window title,",
            "buffer name, etc.",
            "",
            "Type is one of the following (for version 1.0):",
            " * string",
            " * string-list",
            " * moo-code",
            "",
            "Content is the content interpreted according to the type",
            "info given.  It's multiline (hence the *).",
            "",
            "clients that don't provide special support for moo-code editing can",
            "treat moo-code identically to string-list.",
            "",
            "C->S #$#dns-org-mud-moo-simpleedit-set (reference, content*, type)",
            "",
            "reference, content, and type are as above.  This is the message sent by the client to set when the user 'saves' the value.  Note this does not necessarily save the value.  Errors such as lack of permission to set the given reference or moo-code compliation errors may prevent it.  It is expected that the server will tell the user this (in the in-band text stream).  ",
            "",
            "Clients will probably want to provide a way to just send without closing the window, buffer, etc for this reason.",
            "",
            "",
            "JHCore implementation notes",
            "",
            "JHCore currently understands several different kinds of (local) editing sessions:",
            "handled by $verb_editor:",
            "   * verb editing",
            "handled by $note_editor:",
            "   * list of strings editing for notes and properties",
            "handled by both $note_editor and $list_editor(?):",
            "   * value editing for properties",
            "handled by $mail_editor:",
            "   * sending a mail message",
            "",
            "@edit uses a semi-complicated system to determine (a) what the user is trying to edit and (b) how to edit it.   ",
            "",
            "So it looks like the critical things to modify are $generic_editor:invoke_local_editor, $note_editor:local_editing_info, $verb_editor:local_editing_info, and $mail_editor:local_editing_info.  ",
            "",
            "The current return path for locally edited stuff (in the core) appears to be:",
            "  @program",
            "  @set-note-text",
            "  @set-note-value",
            "  @@sendmail",
            "",
            ".v_filter_in / .v_filter_out are hooks called when receiving/sending verb code.  JHCore supports a '// comment' syntax in verbs and conversion is made from '// blah' to '\"blah\";' by using the verbs :verbcode_external_to_internal / :verbcode_internal_to_external.",
            "",
            ".v_filter_in / .v_filter_out are both 2 element lists containing an object id and a verb.  the JHCore configuration is:",
            "",
            "    this.v_filter_in = { this, \"verbcode_external_to_internal\" }",
            "    this.v_filter_out = { this, \"verbcode_internal_to_external\" }",
            "",
            "Non JHCore installations might choose to set .v_filter_in / .v_filter_out to false (0, \"\" or {}) which leaves code lines unfiltered.",
            "",
            ""
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            16249,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "114": {
      "id": 114,
      "name": "Integer Prototype",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        120
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 114,
          "code": [
            "if (verb in {\"init_for_core\", \"exitfunc\", \"enterfunc\", \"moveto\"})",
            "return `pass(@args) ! ANY => 0';",
            "elseif (verb in {\"sin\", \"cos\", \"sqrt\"})",
            "this = tofloat(this);",
            "elseif (verb == \"english_time\")",
            "return $time_utils:english_time(this);",
            "elseif (verb in {\"include_for_core\", \"proxy_for_core\"})",
            "return {};",
            "endif",
            "return call_function(verb, this, @args);"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "115": {
      "id": 115,
      "name": "List Prototype",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        120
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "add remove",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 115,
          "code": [
            "return call_function(\"set\" + verb, this, @args);"
          ]
        },
        {
          "name": "delete_index",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 115,
          "code": [
            "return call_function(\"listdelete\", this, @args);"
          ]
        },
        {
          "name": "insert append",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 115,
          "code": [
            "return call_function(\"list\" + verb, this, @args);"
          ]
        },
        {
          "name": "merge",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 115,
          "code": [
            "set_task_perms(player);",
            "return $string_utils:from_list(this, args ? args[1] | \" \");"
          ]
        },
        {
          "name": "*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 115,
          "code": [
            "set_task_perms(player);",
            "\"Don't respond to calls from built-ins\";",
            "{_, name, programmer, location, _} = callers()[1];",
            "if ((name && (programmer == $nothing)) && (location == $nothing))",
            "return;",
            "endif",
            "\"Exceptions\";",
            "if (verb in {\"init_for_core\", \"exitfunc\", \"enterfunc\", \"moveto\"})",
            "return `pass(@args) ! ANY => 0';",
            "elseif (verb in {\"from_list\", \"english_list\", \"title_list\", \"generate_symmetrical_columns\"})",
            "return $string_utils:(verb)(this, @args);",
            "elseif (verb == \"include_for_core\")",
            "return {};",
            "elseif ($object_utils:has_callable_verb($list_utils, verb))",
            "return $list_utils:(verb)(this, @args);",
            "elseif (verb == \"len\")",
            "return length(this, @args);",
            "endif",
            "\"Frobs, originally conceptualized by Todd Sundsted for Improvise.\";",
            "if (this && (`prototype = this[1] ! E_RANGE' in $frobs))",
            "return prototype:(verb)(@args);",
            "endif",
            "return pass(@args);"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "116": {
      "id": 116,
      "name": "MCP Help Database",
      "flags": 16,
      "owner": 98,
      "location": -1,
      "parents": [
        30
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [],
      "propnames": [
        "mcp",
        "mcp-authentication",
        "mcp-display-url",
        "mcp-edit",
        "mcp-ftp",
        "mcp-goals",
        "mcp-gopher",
        "mcp-requests",
        "mcp-semantics",
        "mcp-spec",
        "mcp-syntax",
        "mcp-x-audio",
        "mcp-index"
      ],
      "propdefs": [
        {
          "value": [
            "MCP",
            "1==",
            "",
            "Rewritten from `help mcp-spec' June 7, 1994 by Jay Carlson.  Comments solicited; send mail to the `@proj usability client MCP' mailing list, moo-cows, or private email to j@io.com.",
            "",
            "The MOO Client Protocol is a standard for transmitting structured \"requests\" between MUD clients and servers.  The original specification is available as `help mcp-spec', but the skeleton of a rewrite is here:",
            "",
            "mcp-goals -- History and goals of the MCP protocol",
            "mcp-syntax -- Syntactic description of MCP requests",
            "mcp-semantics -- Semantics of MCP requests",
            "mcp-requests -- Documented request types"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP authentication",
            "1=================",
            "",
            "When an MCP client connects to an MCP server, it may set an `authentication key' for the duration of the connection.  The key is simply a string (in the format described in `help mcp-syntax') that must be sent by the server with every MCP request for the request to be authenticated.  The authentication key is a secret shared by the client and the MCP subsystem of the server.",
            "",
            "The syntax for setting the authentication key is:",
            "",
            "  #$#authentication-key <auth-key>",
            " ",
            "",
            "Clients may accept, reject, or query the user about MCP requests that are either missing an authentication key or have the incorrect key.",
            "",
            "Typically, clients will generate a random number or string on connection and use it as their key.",
            "",
            "Proposal: eliminate reference to client and server, and make the authentication scheme symmetric."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP display-url request",
            "1======================",
            "",
            "This is a simplification of the display-url request specification used by AstroVR.  It is intended to represent baseline functionality that most clients can implement.",
            "",
            "display-url presents a document specified by a URL to the user.",
            "",
            "Keywords",
            "2=======",
            "",
            "url:",
            "3===",
            "",
            "Required.  Must be an absolute URL, starting with a name scheme (such as \"http:\").",
            "",
            "Example",
            "2======",
            "",
            "Present the JHM home page:",
            "",
            "  #$#display-url 12345678 url: \"http://jhm.ccs.neu.edu:7043/\"",
            " "
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP edit* requests",
            "1=================",
            "",
            "A multi-line request for the client to invoke a local editor on the attached text, and later send the edited text to the server.",
            "",
            "Keywords",
            "2=======",
            "",
            "type:",
            "3====",
            "",
            "Optional.  Suggested values include program, text, string, value and mail.  The client may be able to use this information to provide a specialized editing mode.",
            "",
            "name:",
            "3====",
            "",
            "Optional.  A human-readable descriptive name for what's being edited.",
            "",
            "In existing Emacs clients, this is used for the buffer name.  In tkmoo, name: is used as the window and icon title for the workspace editing the text.",
            "",
            "upload:",
            "3======",
            "",
            "Required.  Specifies a line to prefix the edited text with before sending to the server.  When the text is sent to the server, it is followed by a line of a single period.",
            "",
            "Notes",
            "2====",
            "",
            "Typically the upload: value will be a command that starts reading input from the player, like @paste or @qsend; the MOO will use $command_utils:read_lines() to consume the uploaded lines.",
            "",
            "Proposal: Every known use of #$#edit requires \".\" as its final line sent back to the server.  Worse, it's not defined that dot-quoting should be performed on the uploaded text, which $command_utils:read_lines() expects.  We should either explicitly state these things, or we should use multi-line MCP requests to send the text back to the server.",
            "",
            "Examples",
            "2=======",
            "",
            "A request to provide an editing session for a property:",
            "",
            "  #$#edit* 12345678 type: text name: Dave.test upload: \"@set-note-text #75.test\"",
            "  @@@This is a test.",
            "  @@@",
            "  #$#END",
            "",
            "A request to provide an editing session for a verb:",
            "",
            "  #$#edit* 12345678 type: program name: Dave:test upload: \"@program #75:test none none none\"",
            "  @@@player:tell(\"This is a test.\");",
            "  #$#END"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP ftp request",
            "1==============",
            "",
            "I don't understand the semantics of the ftp request fully.  AstroVR uses this protocol to move remote files into users' directories.",
            "",
            "This specification does not specify whether anonymous ftp or authenticated ftp is used.",
            "",
            "Keywords",
            "2=======",
            "",
            "host:",
            "3====",
            "",
            "Required.  Name of the FTP host containing the document.",
            "",
            "directory:",
            "3=========",
            "",
            "Required.  The directory containing the document.",
            "",
            "file:",
            "3====",
            "",
            "Required.  The filename of the document.",
            "",
            "type:",
            "3====",
            "",
            "Required.  File type of the document.  Possible values are \"ascii\", \"binary\", \"fits\", \"plaintext\", \"postscript\", \"compressed\", and \"tar\".",
            "",
            "destination:",
            "3===========",
            "",
            "Required.  Directory on the local machine the document is to be placed in.",
            "",
            "Example",
            "2======",
            "",
            "Upload a file from an anonymous ftp site:",
            "",
            "  #$#ftp 12345678 host: ipac.caltech.edu directory: /pub/deposit file: mud.el.Z type: \"compressed ascii\" destination: clients/mud.el.Z",
            " "
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP goals",
            "1========",
            "",
            "Most MUD clients and servers communicate by an informal protocol: lines of printable ASCII characters separated by newlines.  This is closely related to the TELNET protocol, which will in fact interoperate with MUD servers.  But TELNET clients don't provide user interface support for even the simplest of MUD tasks.  Specialized MUD clients provided these tools.",
            "",
            "Once people started to use clients, several realized that intelligence and user interface closer to the user could be exploited by the MUD.  ",
            "",
            "In particular, the LambdaCore editor system allows an option to ship whole documents (to a mud.el variant) to be edited locally, then returned.  The $gopher system can direct clients to fetch Gopher text directly (presenting a better UI and avoiding funneling texts through the MOO).",
            "",
            "Such \"requests\" are out of band; that is, they can occur at any point in the interaction between client and server.  In particular, client requests may occur while a MOO is using the read() primitive.  The MOO server has a compile-time option to process lines starting with a given prefix as if they were truly out of band.",
            "",
            "MCP is a simple protocol for transmitting structured messages between client and server.  It traffics in \"requests\", which have types, properties, and optional multi-line extensions.  Standard requests exist for local editing, URL display and gopher access."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP gopher request",
            "1=================",
            "",
            "The original MOO $gopher system used a private protocol.  This is a rendering of it into MCP.  It has become deprecated in favor of display-url.",
            "",
            "Keywords",
            "2=======",
            "",
            "host:",
            "3====",
            "",
            "Required.  Name of the gopher host to connect to.",
            "",
            "port:",
            "3====",
            "",
            "Optional.  Port number to connect to on gopher host; defaults to 70.",
            "",
            "path:",
            "3====",
            "",
            "Optional.  Pathname to send to the gopher host.  Defaults to the empty string.",
            "",
            "description:",
            "3===========",
            "",
            "Required.  Description string; first character is the gopher type character, rest of characters are the human-readable name of the object.",
            "",
            "Proposal: separate type from description.",
            "",
            "Example",
            "2======",
            "",
            "A request to retrive Gustavus Adolphus College's root menu:",
            "",
            "  #$#gopher 12345678 host: gopher.gac.edu description: \"1Gustavus Adolphus College\"",
            " ",
            "",
            "Note that port and path default to 70 and \"\" respectively."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP requests",
            "1===========",
            "",
            "There are several standard MCP request types.  If clients provide functionality similar to those described below, they should implement the MCP request as documented.",
            "",
            "mcp-edit -- Perform local editing on a text",
            "mcp-gopher -- Display a gopher text to the user",
            "mcp-ftp -- Use ftp to download a file to the user's machine",
            "mcp-display-url -- Display a URL to the user"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP request semantics",
            "1====================",
            "",
            "An MCP request is of the general form:",
            "",
            "  #$#<request-name>[*][ <auth-key>][ <keyword>: <value>]...",
            " ",
            "",
            "<request-name> identifies the `type' of the request.  The type of the request can be thought of as a function that processes the structures in the rest of the line.",
            "",
            "<auth-key> is an optional authentication key.  See `help mcp-authentication'.",
            "",
            "The set of <keyword>: <value> pairs are a function mapping <keyword>s onto <value>s.  <keyword>s are names of arguments to the request; <value>s are the corresponding values of arguments.",
            "",
            "Duplicate <keyword>s are not allowed.  Arbitrary order of <keyword>: <value> pairs is allowed.",
            "",
            "Specific <keyword>s may be optional for a given request type, with default <value>s assumed.",
            "",
            "<keyword>s may be unrecognized by a request type.  A suggested strategy for request handlers is to ignore any <keyword>s they don't understand."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MOO CLIENT REQUEST PROTOCOL",
            "===========================",
            "",
            "Erik Ostrom, Dave Van Buren, Pavel Curtis, David Nichols, Jay Carlson",
            "",
            "22 Feb 1993",
            "",
            "Conversion to `help help-format' 21 May 1994 by Jay Carlson.",
            "",
            "(Any first-person pronouns refer to Erik.)",
            "",
            "AUTHENTICATION",
            "--------------",
            "",
            "An authentication key is generated and uploaded by the client to the server at login.  Proposed method:",
            "",
            "  #$#authentication-key <key>",
            " ",
            "",
            "This requires that the server be compiled with OUT_OF_BAND_PREFIX set to \"#$#\".  (It's actually possible to do it as a verb on $player, but many MOOs have a programmer command \"#\" which does something very different.)  The authentication key may not contain spaces, double-quotes, colons, or backslashes.",
            "",
            "GENERAL RULES",
            "-------------",
            "",
            "String sent by server:",
            "",
            "  #$#<request-name><*-if-data-follows> [<auth-key>] <keyword>: <value> ...",
            " ",
            "",
            "An identifying tag #$# is placed at the beginning of the request line.",
            "",
            "  o  <request-name> is the type of request, e.g. \"edit\" or \"ftp\".",
            "  o  <request-name> cannot contain spaces, double-quotes, backslashes, or asterisks.",
            "  o  <*-if-data-follows> is either \"*\" if this request is followed by additional lines of data, or the empty string.",
            "  o  <keyword> is the name of an argument to the request.  Keywords cannot contain spaces, double-quotes, colons, or backslashes.",
            "  o  <value> is the value of the corresponding argument.  A <value> can contain any printing ASCII character (including space), but must be quoted in the standard MOO style (with double quotes, using backslash to escape quotes and backslashes) if it either contains spaces or is the empty string.  Arbitrary order of keyword: value pairs is allowed.",
            "",
            "Keyword: value pairs may be optional.  We haven't discussed what clients should do with unrecognized keywords; my plan is for the client simply to ignore them and work with the keywords it recognizes.",
            "",
            "REQUEST DEFINITIONS",
            "-------------------",
            "",
            "edit",
            "====",
            "",
            "type: <program|text|string|value|mail|...>",
            "",
            "Type of information.  Clients may or may not be able to use a special editing mode depending on type.",
            "",
            "name: <name>",
            "",
            "User-friendly indication of what's in this.  Good for buffer name.",
            "",
            "upload: <command>",
            "",
            "Command to use to begin upload of this text.",
            "",
            "ftp",
            "===",
            "",
            "host: <name>",
            "",
            "Name of the host that has the document.",
            "",
            "directory: <dir>",
            "",
            "Name of the directory that the document is in.",
            "",
            "file: <name>",
            "",
            "Name of the file within the directory.",
            "",
            "type: <type>",
            "",
            "Type of document.  Current types include ($ftp.recognized_types):",
            "",
            "      {\"ascii\", \"binary\", \"fits\", \"plaintext\", \"postscript\",",
            "       \"compressed\", \"tar\"}",
            "",
            "destination: <dir>",
            "",
            "Place to store the document locally.  I don't fully understand this.",
            "",
            "gopher",
            "======",
            "",
            "(Larry has a local-gopher protocol--this is my attempt to render it into the New Protocol.)",
            "",
            "host: <name>",
            "",
            "Name of the host to connect to.",
            "",
            "port: <number>",
            "",
            "Port to connect to.  Default is 70.",
            "",
            "path: <string>",
            "",
            "String to send to the gopher server.  Default is the empty string.",
            "",
            "description:",
            "",
            "Description string.  First character is the type character, rest of characters are human-readable name of object.  This seems unnecessarily arcane to me--why not separate these?",
            "",
            "EXAMPLES",
            "--------",
            "",
            "A request to provide an editing session for a property.  The request is followed by lines of data, prepended with a special tag (@@@, unless someone has strong feelings about changing it), and marked at the end with another tag (#$#END, again subject to change).  The advantage of this over dot-quoting is that it should be fairly easy for the client to figure out if there's been some breakage on the server end and the transmission has terminated early.  (A line that doesn't start with @@@ and isn't #$#END should set off warning bells.)",
            "",
            "  #$#edit* 12345678 type: text name: Dave.test upload: \"@set-note-text #75.test\"",
            "  @@@This is a test.",
            "  @@@",
            "  #$#END",
            "",
            "A request to provide an editing session for a verb.",
            "",
            "  #$#edit* 12345678 type: program name: Dave:test upload: \"@program #75:test none none none\"",
            "  @@@player:tell(\"This is a test.\");",
            "  #$#END",
            "",
            "A request to upload a file from an anonymous ftp site.  The request line contains all the data necessary.",
            "",
            "  #$#ftp 12345678 host: ipac.caltech.edu directory: /pub/deposit file: mud.el.Z type: \"compressed ascii\" destination: clients/mud.el.Z",
            " ",
            "",
            "A request to retrieve a document from a gopher server.",
            "",
            "  #$#gopher 12345678 host: gopher.gac.edu description: \"1Gustavus Adolphus College\"",
            " ",
            "",
            "In this case, we take advantage of default values for the port: and path: arguments (\"70\" and \"\", respectively)."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP request syntax",
            "1=================",
            "",
            "Input and output to and from client and server is presumed to be divided into records (called `lines' hereafter).",
            "",
            "An MCP request is of the general form:",
            "",
            "  #$#<request-name>[*][ <auth-key>][ <keyword>: <value>]...",
            " ",
            "",
            "\"#$#\" must be the first three characters in the line.",
            "",
            "<request-name> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, backslashes or asterisks.",
            "",
            "Proposal: require <request-name> to start with a letter.  This reserves a substantial part of the namespace for private out-of-band protocols, or other protocol extensions.",
            "",
            "<auth-key> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, colons or backslashes.",
            "",
            "<keyword> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, colons, or backslashes.",
            "",
            "<value> is ",
            "",
            "  o  a string of one or more printable ASCII characters not containing spaces, double-quotes or backslashes ",
            "  o  OR is a string of zero or more printable ASCII characters, enclosed in double-quotes, with double-quotes and backslashes inside the string `quoted' by preceding them with a backslash.",
            "",
            "Note that the empty string must be quoted.  Also, the ASCII TAB character is not allowed in <value>s, at all.",
            "",
            "Proposal: disallow unquoted <value>s with colons in them.  This is not strictly necessary, but it could detect some bugs in MCP request generators.",
            "",
            "If the asterisk after <request-name> is present, this line starts a `multi-line request'.  Zero or more lines of data associated with the request follow, prepended with \"@@@\".  These lines are terminated with a single line of the form \"#$#END\".",
            "",
            "Note that the 1.7.7 LambdaMOO server cannot properly handle multi-line requests sent by a client if OUT_OF_BAND_PREFIX is defined as \"#$#\".",
            "",
            "Proposal: multi-line requests, in their current form, should be deprecated in favor of some other construct providing this functionality."
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "MCP x-audio request",
            "1==================",
            "",
            "This is a description of the interim protocol tkmoo uses to provide a single channel of multicast audio.  New requests change the channel.",
            "",
            "Keywords",
            "2=======",
            "",
            "my-name",
            "3======",
            "",
            "Optional.  Name to identify the user inside a multicast conference.  Defaults to username.",
            "",
            "key",
            "3==",
            "",
            "Optional.  Encryption key for the channel.  Defaults to \"\", which is no key.",
            "",
            "address",
            "3======",
            "",
            "Required.  Multicast address ",
            "",
            "ttl",
            "",
            "",
            "port",
            "",
            "title",
            ""
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "*index*",
            "MCP help topics"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            "mcp-index"
          ],
          "owner": 36,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "MCP Help Database"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            23287,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "117": {
      "id": 117,
      "name": "Map Prototype",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        120
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "keys values delete",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 117,
          "code": [
            "return call_function(\"map\" + verb, this, @args);"
          ]
        },
        {
          "name": "merge",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 117,
          "code": [
            "\"Merges the map with <args>\";",
            "for v, k in (args[1])",
            "this[k] = v;",
            "endfor",
            "return this;"
          ]
        },
        {
          "name": "generate_json json",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 117,
          "code": [
            "\"Map:generate_json()\";",
            "\"Map:json()\";",
            "\"So that programmers can call generate_json directly on a map.\";",
            "\"Just calls the builtin of the same name.\";",
            "return call_function(\"generate_json\", this, @args);"
          ]
        },
        {
          "name": "*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 117,
          "code": [
            "\"This catches everything else that doesn't have a specific function.\";",
            "set_task_perms(caller_perms());",
            "\"don't respond to calls from built-ins\";",
            "{_, name, programmer, location, _} = callers()[1];",
            "if ((name && (programmer == $nothing)) && (location == $nothing))",
            "return;",
            "endif",
            "\"Frobs, originally conceptualized by Todd Sundsted for Improvise.\";",
            "if (this && (`prototype = this[$map_proto.frob_key_name] ! E_RANGE' in $frobs))",
            "return prototype:(verb)(@args);",
            "endif",
            "return pass(@args);"
          ]
        }
      ],
      "propnames": [
        "frob_key_name"
      ],
      "propdefs": [
        {
          "value": "__prototype__",
          "owner": 2,
          "perms": 5
        }
      ],
      "anon": false,
      "recycled": false
    },
    "118": {
      "id": 118,
      "name": "Generic Waif",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        1
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": ":initialize",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 118,
          "code": [
            "\"the perms check you want is probably:\";",
            "if ((caller == this) || (caller == this.class))",
            "\"allows pass() and :new()\";",
            "else",
            "raise(E_PERM);",
            "endif"
          ]
        },
        {
          "name": "new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 118,
          "code": [
            "\"WIZARDLY\";",
            "set_task_perms(caller_perms());",
            "player = caller_perms();",
            "w = new_waif();",
            "w:initialize(@args);",
            "return w;"
          ]
        }
      ],
      "propnames": [
        ":wizard",
        "help_msg"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 0
        },
        {
          "value": [
            "A waif is a kind of datatype in the MOO programming language, akin to integers, floating point numbers, strings, lists, objects and errors.",
            "",
            "Waifs are like objects in that they have inherited properties and verbs.  They are unlike objects in that they do not have object numbers, and do not ordinarily have a name, aliases, a location, or a description -- although they could.",
            "",
            "For those who program in C, it may be helpful to think of a waif as being like the 'struct' datatype:  A waif is a collection of named values.  (A list is a collection of ordered values.)",
            "",
            "Every waif inherits its properties and verbs from its 'class', which is an actual object that is a descendant of $waif.  Only properties and verbs whose names begin with a colon are inherited by the instantiated waif.  To create a waif, you invoke the verb <class>:new(), which returns the newly-minted waif as it's value.",
            "",
            "A logical time to consider using waifs is in lieu of storing data as a list of lists.  Let's consider an example.  Suppose I want to create a bot that serves drinks and canapes, and for reasons of my own I want to specify what drinks are available rather than let some lout order a glass of diesel fuel at my tea party.  So I am going to create a list of drinks, the kind of container the drink comes in, and the number of sips in each, such that a cup of tea might have more sips (and thus take longer to drink) than a glass of sherry.",
            "",
            "If I were to implement my drink list as a list of lists, I might do",
            "",
            "  @prop bot.drink_options {{\"tea\", \"cup\", 10}, {\"sherry\", \"glass\", 4}, {\"milk\", \"glass\", 15}}",
            "",
            "You can see that a glass of milk has more in it than a glass of sherry.  BUT, if you were looking at this code for the first time, you might not know that the third number in that list refers to quantity.  For longer sublists, it can get very confusing, indeed.",
            "",
            "To implement this using waifs, you would first make an object, a kid of $waif, that you would use as a drink specification:",
            "",
            "  @create $waif named \"drink specification\",\"dspec\"",
            "",
            "You would then own an object with the generic waif as its parent.  Next you would add properties to this object that the waifs are to inherit:",
            "",
            "  @prop dspec.:drink_name \"\" rc",
            "  @prop dspec.:drink_container \"\" rc",
            "  @prop dspec.:sips_per_container 0 rc",
            "",
            "Notice that each property name begins with a colon.  Property names that don't begin with a colon are not inherited by the waifs (.name, for example).",
            "",
            "Since your drink specification is a kid of $waif, it inherits the verb :new that can be used to create a waif.  Here is how we would make a few:",
            "",
            "  @prop bot.drink_options {} rc",
            "  @prop bot.drink_spec <dspec> rc",
            "",
            "  @verb bot:add_drink tnt rxd",
            "",
            "  @program bot:add_drink",
            "  \"Adds a drink specification to this bot's .drink_options property.\";",
            "  \"Maybe put in some code only to let the owner do this, but that is not germaine to this example.\";",
            "  {drink_name, drink_container, sips_per_container} = args;",
            "  new_spec = this.drink_spec:new();",
            "  new_spec.drink_name = drink_name;",
            "  new_spec.drink_container = drink_container;",
            "  new_spec.sips_per_container = sips_per_container;",
            "  this.drink_options = {@this.drink_options, new_spec};",
            "  \"A robust version of this verb would check for proper data types in the args, maybe look for duplicates first, etc.\";",
            "  .",
            "",
            "Later on you might want to specify a color for each drink, so that if it comes in a dribble glass, you can say what color the stain on your poor victim's tie is.  You would add the property (.:color -- remember the colon) to the drink spec object, and voila, it would exist on all the waifs.  You would need to set the individual values, of course, but you wouldn't have to do gymnastics on sublists in lists, which can be a delicate operation indeed.",
            "",
            "Further information about waifs is available at http://www.ben.com/MOO/waif.html and http://www.ben.com/MOO/waif-progman.html"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Generic Waif"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            6412,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "119": {
      "id": 119,
      "name": "String Prototype",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        120
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 119,
          "code": [
            "if (verb in {\"init_for_core\", \"exitfunc\", \"enterfunc\", \"moveto\"})",
            "return `pass(@args) ! ANY => 0';",
            "elseif ((verb == \"length\") || (verb == \"len\"))",
            "return length(this);",
            "elseif (verb == \"strip_ansi\")",
            "return $ansi_utils:delete(this);",
            "endif",
            "if (verb in {\"include_for_core\", \"proxy_for_core\"})",
            "return {};",
            "endif",
            "\"So that programmers can call string:json() or string:parse_json(),\";",
            "\"And get a map as the return value (if the string can be parsed into json).\";",
            "if ((verb == \"parse_json\") || (verb == \"json\"))",
            "return call_function(\"parse_json\", this, @args);",
            "endif",
            "r = $string_utils:(verb)(this, @args);",
            "if (r != 0)",
            "return r;",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "120": {
      "id": 120,
      "name": "Generic Base Primitive",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        -1
      ],
      "children": [
        117,
        119,
        115,
        114,
        111
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "length",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 120,
          "code": [
            "\"Last modified 12/10/18 1:14 a.m. by Sinistral (#2) on ChatMUD\";",
            "return length((typeof(this) == MAP) ? this:keys() | this);"
          ]
        },
        {
          "name": "*",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 120,
          "code": [
            "\"Created 02/01/19 1:40 p.m. by Sinistral (#2) on ChatMUD\";",
            "\"Last ditch attempt to do something useful...\";",
            "set_task_perms(caller_perms());",
            "if (verb in {\"init_for_core\", \"include_for_core\", \"proxy_for_core\"})",
            "return {};",
            "elseif (this in {$failed_match, $ambiguous_match, $nothing})",
            "return this;",
            "endif",
            "return call_function(verb, this, @args);"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "121": {
      "id": 121,
      "name": "dns-com-vmoo-client",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        104
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "handle_info",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "{session, @stats} = args;",
            "who = session.connection;",
            "if (i = who in $list_utils:slice(this.client_info, 2))",
            "this.client_info = listset(this.client_info, {time(), who, stats}, i);",
            "else",
            "this.client_info = {@this.client_info, {time(), who, stats}};",
            "endif"
          ]
        },
        {
          "name": "handle_screensize",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "{session, linelen, @args} = args;",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "((ll = toint(linelen)) > 0) && this:adjust_linelen(who = session.connection, (who.linelen > 0) ? ll | (-1 * ll));"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "if ($perm_utils:controls(caller_perms(), this))",
            "this.client_info = {};",
            "endif"
          ]
        },
        {
          "name": "send_disconnect",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "{who, @args} = args;",
            "if ($perm_utils:controls(caller_perms(), who))",
            "if (valid(session = $mcp:session_for(who)) && session:handles_package(this))",
            "return pass(session, @args);",
            "else",
            "return E_INVIND;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "get_client_info",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "if (!$perm_utils:controls(caller_perms(), this))",
            "return E_PERM;",
            "else",
            "info = {};",
            "for dude in (args)",
            "if (i = $list_utils:iassoc(dude, this.client_info, 2))",
            "(ticks_left() < 4000) && suspend(0);",
            "dudeinf = this.client_info[i];",
            "session = $mcp:session_for(dudeinf[2]);",
            "if ((valid(session) && session:handles_package(this)) && `dudeinf[1] >= (dude.last_connect_time - 3) ! ANY')",
            "info = {@info, dudeinf[2..3]};",
            "endif",
            "endif",
            "endfor",
            "return info;",
            "endif"
          ]
        },
        {
          "name": "adjust_linelen",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "{who, linelen} = args;",
            "if (caller != this)",
            "return E_PERM;",
            "endif",
            "who.linelen = linelen;"
          ]
        },
        {
          "name": "prune_client_info",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 121,
          "code": [
            "{clients, users} = this.client_stats;",
            "for x in (this.client_info)",
            "if (is_player(x[2]) == 0)",
            "if ((ind = x[3][1] in clients) == 0)",
            "clients = {@clients, x[3][1]};",
            "users = {@users, 1};",
            "else",
            "users[ind] = users[ind] + 1;",
            "endif",
            "this.client_info = setremove(this.client_info, x);",
            "endif",
            "$command_utils:suspend_if_needed(0);",
            "endfor",
            "this.client_stats = {clients, users};"
          ]
        }
      ],
      "propnames": [
        "client_info",
        "client_stats"
      ],
      "propdefs": [
        {
          "value": [
            [
              1671224789,
              2,
              [
                "RMOO (Emacs)",
                "1.3b",
                "0"
              ]
            ],
            [
              1550351436,
              98,
              [
                "wxpymoo",
                "0.2",
                "0.2"
              ]
            ]
          ],
          "owner": 98,
          "perms": 0
        },
        {
          "value": [],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "screensize",
              [
                "cols",
                "rows"
              ]
            ],
            [
              "info",
              [
                "name",
                "text-version",
                "internal-version"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "disconnect",
              [
                "reason"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "dns-com-vmoo-client"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            6665,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "122": {
      "id": 122,
      "name": "Generic Anonymous Object",
      "flags": 256,
      "owner": 2,
      "location": -1,
      "parents": [
        -1
      ],
      "children": [
        108,
        125,
        127
      ],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 122,
          "code": [
            "{?owner = caller_perms()} = args;",
            "if ((owner != caller_perms()) && (!caller_perms().wizard))",
            "return E_PERM;",
            "endif",
            "return create(this, owner, 1);",
            "\"This could potentially allow people to skirt quota since we're not tracking it.\";",
            "\"I'm not sure of the best fix, though. Maybe make bf_create handle it?\";"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [],
      "anon": false,
      "recycled": false
    },
    "123": {
      "id": 123,
      "name": "dns-com-awns-status",
      "flags": 0,
      "owner": 98,
      "location": -1,
      "parents": [
        104
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "status",
          "owner": 98,
          "perms": 173,
          "preps": -1,
          "object": 123,
          "code": [
            "{session, text} = args;",
            "if ((caller == this) || $perm_utils:controls(caller_perms(), session.connection))",
            "return this:send_(session, text);",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": [
            "1.0",
            "1.0"
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": null,
          "owner": 98,
          "perms": 1
        },
        {
          "value": [
            [
              "",
              [
                "text"
              ]
            ]
          ],
          "owner": 98,
          "perms": 1
        },
        {
          "value": 0,
          "owner": 98,
          "perms": 4
        },
        {
          "value": [
            "dns-com-awns-status"
          ],
          "owner": 98,
          "perms": 5
        },
        {
          "value": null,
          "owner": 98,
          "perms": 5
        },
        {
          "value": [
            1394,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "124": {
      "id": 124,
      "name": "Generic Editor Utilities",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "editor",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{?text = {}, ?prompt = \"[Type lines of input; use `.' to end.]\", ?commandchar = this:get_opt(\"cmd_char\", player), ?verb = 0, ?extra = {}} = args;",
            "\"Arguments:\";",
            "\"  text: The text to be edited.\";",
            "\"  prompt: The prompt displayed to the player to ask for input.\";",
            "\"  commandchar: The character used to indicate an editor command vs text to be added.\";",
            "\"  verb: A flag indicating whether or not this is verb code, which will add editor commands for compilation and commenting.\";",
            "\"  extra: Extra information passed in, primarily for verb info to use with the compile command.\";",
            "if (typeof(text) == STR)",
            "text = {text};",
            "elseif (typeof(text) != LIST)",
            "return raise(E_TYPE, \"Invalid datatype\");",
            "endif",
            "this:log_last_edit(player, task_id());",
            "state = $edit_state:new(text, verb, extra);",
            "\"NOTE: The waif is created AND destroyed in-verb. It is NOT persistant!\";",
            "player:tell(prompt);",
            "if (state.verb && state.extra)",
            "verb_name = tostr($string_utils:nn(state.extra[1][1]), \":\", state.extra[1][2]);",
            "player:tell(\"Now editing \", verb_name, \".\");",
            "state.verb_name = verb_name;",
            "endif",
            "state.ins = length(state.text) + 1;",
            "player:tell(\"Insertion point is before line \", state.ins, \".\");",
            "if (this:get_option(\"expert\") == 0)",
            "player:tell();",
            "player:tell(\"Type '\", commandchar, \"help' for assistance, '\", commandchar, \"abort' to abandon.\");",
            "endif",
            "while loop (1)",
            "try",
            "if (!player:is_listening())",
            "return;",
            "endif",
            "cont = 1;",
            "(!this:get_option(\"no_line_notifies\")) && player:tell(\"  >\");",
            "line = read(player);",
            "if (typeof(line) != STR)",
            "return state.text;",
            "endif",
            "if (line == \"@abort\")",
            "player:tell(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "elseif (line == \"..\")",
            "line = \".\";",
            "elseif (line == \".\")",
            "line = this:get_option(\"cmd_char\") + \"done\";",
            "endif",
            "if (`line[1] ! ANY' == commandchar)",
            "cmd = $string_utils:explode(line[2..$]);",
            "if ((commandchar == \".\") && (!cmd))",
            "line = this:get_option(\"cmd_char\") + \"done\";",
            "elseif (!cmd)",
            "player:tell(\"You must enter a command. (\", commandchar, \"help for help.)\");",
            "continue;",
            "endif",
            "state.command = cmd[1];",
            "state.arg = cmd[2..$];",
            "if (state.command in {\"insert\", \"ins\", \"inse\", \"inser\"})",
            "this:cmd_insert(state);",
            "elseif (state.command in {\"paste\", \"load\"})",
            "this:cmd_load(state);",
            "elseif (state.command in {\"copy\", \"save\"})",
            "this:cmd_save(state);",
            "elseif (state.command == \"pass\")",
            "this:cmd_pass(state);",
            "elseif (state.command in {\"reload\", \"rehash\"})",
            "return this:cmd_reload(@args, state);",
            "elseif (state.command in {\"change\", \"changeline\"})",
            "this:cmd_changeline(state);",
            "elseif (state.command in {\"replace\", \"repl\", \"re\"})",
            "this:cmd_replace(state);",
            "elseif (state.command in {\"find\", \"search\", \"GREP\", \"f\", \"s\"})",
            "this:cmd_grep(state);",
            "elseif (state.command in {\"done\", \"quit\", \"q\"})",
            "if (typeof(ret = this:cmd_quit(state)) == ERR)",
            "continue;",
            "else",
            "return state.text;",
            "endif",
            "elseif (state.command in {\"abort\", \"abandon\", \"q!\"})",
            "player:tell(\">> Command Aborted <<\");",
            "kill_task(task_id());",
            "elseif ((state.verb && state.extra) && (state.command in {\"what\", \"verb\"}))",
            "player:tell(\"Currently editing: \", state.extra[1][1]:nn(), \":\", state.extra[1][2], \".\");",
            "elseif ((state.verb && state.extra) && (state.command in {\"compile\", \"w\", \"send\"}))",
            "{object, verbname} = state.extra[1];",
            "program = this:program_verb(object, verbname, state);",
            "elseif (state.verb && (state.command[1] == \"/\"))",
            "\"Assume they want to make a verb comment.\";",
            "line = (\"\\\"\" + line[3..$]) + \"\\\";\";",
            "cont = 0;",
            "elseif (state.command == \"import\")",
            "this:cmd_paste_letter(state);",
            "elseif (state.command == \"set\")",
            "this:options($string_utils:from_list(state.arg, \" \"));",
            "elseif (state.command in {\"del\", \"dele\", \"delet\", \"delete\", \"erase\", \"rm\"})",
            "this:cmd_delete(state);",
            "elseif (state.command in {\"list\", \"l\", \"view\", \"p\"})",
            "this:cmd_list(state);",
            "elseif (state.verb && (state.command in {\"comment\", \"commentify\"}))",
            "this:cmd_commentify(state);",
            "elseif (state.verb && (state.command in {\"uncomment\", \"uncommentify\"}))",
            "this:cmd_uncommentify(state);",
            "elseif (state.command in {\"spellcheck\", \"spell\"})",
            "state.text = $spell:interactive_spellcheck(state.text);",
            "player:tell(\"Spell check completed.\");",
            "elseif (state.command == \"count\")",
            "this:cmd_count(state);",
            "elseif (state.verb && (state.command in {\"tb\", \"jtb\"}))",
            "this:cmd_traceback(state);",
            "elseif (state.verb && (state.command in {\"ptb\", \"print_traceback\"}))",
            "this:cmd_print_traceback(state);",
            "elseif (state.verb && (state.command in {\"local\", \"localedit\"}))",
            "this:cmd_localedit(state);",
            "elseif (state.command in {\"format\", \"form\"})",
            "this:cmd_format(state);",
            "elseif (state.command in {\"help\", \"?\"})",
            "this:cmd_help(state);",
            "elseif (state.command in {\"clipboard\", \"saved\", \"clip\"})",
            "this:cmd_show_clipboard(state);",
            "else",
            "player:tell(\"Unrecognized command. (\", commandchar, \"help for help.)\");",
            "endif",
            "if (cont != 0)",
            "continue;",
            "endif",
            "endif",
            "this:do_add_line(state, line);",
            "except error (ANY)",
            "player:tell(\"Something has gone wrong...\");",
            "player:tell(toliteral(error));",
            "break;",
            "continue;",
            "endtry",
            "endwhile"
          ]
        },
        {
          "name": "parse_range",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{arg, maxrange, insertion} = args;",
            "if (typeof(arg) == LIST)",
            "arg = $string_utils:from_list(arg, \" \");",
            "endif",
            "range = {0, 0};",
            "explode_by = {\"..\", \" \", \"-\", \"+\"};",
            "exploded_by = 0;",
            "for x in (explode_by)",
            "expl = $string_utils:explode(arg, x);",
            "if (length(expl) > 1)",
            "exploded_by = x;",
            "break;",
            "endif",
            "endfor",
            "if (length(expl) > 2)",
            "return tostr(\"Junk at end of command: \", $string_utils:from_list(expl[3..$], \" \"), \".\");",
            "elseif (length(expl) == 1)",
            "if ((single = expl[1]) == \"$\")",
            "range = {maxrange, maxrange};",
            "elseif (single == \"^\")",
            "range = {insertion, insertion};",
            "elseif ((toint(single) > 0) && (toint(single) <= maxrange))",
            "range = {toint(single), toint(single)};",
            "endif",
            "else",
            "for x in (expl)",
            "if (x == \"$\")",
            "line = maxrange;",
            "elseif (x == \"^\")",
            "line = insertion;",
            "elseif (!$string_utils:is_numeric(x))",
            "return tostr(\"Garbled Range: \", arg, \" - should be integers\");",
            "elseif ((toint(x) <= 0) || (toint(x) > maxrange))",
            "return tostr(\"Lines range from 1 to \", maxrange, \".\");",
            "else",
            "line = toint(x);",
            "endif",
            "range[x in expl] = line;",
            "endfor",
            "endif",
            "if (exploded_by == \"+\")",
            "increment_line = range[1] + range[2];",
            "range = {increment_line, increment_line};",
            "endif",
            "if (range[1] > range[2])",
            "return tostr(\"Garbled Range: \", range[1], \" greater than \", range[2], \". Put smallest index first.\");",
            "elseif (0 in range)",
            "return tostr(\"Garbled Range: \", arg);",
            "endif",
            "return range;"
          ]
        },
        {
          "name": "get_opt*ion",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "\"-1 == option not found\";",
            "{option, ?player = player} = args;",
            "opt = `player.inline_editor_options[option] ! ANY => $nothing';",
            "if (opt != $nothing)",
            "return opt;",
            "else",
            "return $edit_utils.default_options[option];",
            "endif"
          ]
        },
        {
          "name": "options",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{?argstr = 0} = args;",
            "options = {};",
            "options = {@options, [\"name\" -> \"Set Command Prefix\", \"identifier\" -> \"prefix\", \"state\" -> tostr(this:get_option(\"cmd_char\"))]};",
            "options = {@options, [\"name\" -> \"Set Escape Character\", \"identifier\" -> \"escape\", \"state\" -> tostr(this:get_option(\"escape_char\"))]};",
            "options = {@options, [\"name\" -> \"Advanced Mode (suppresses warnings and help prompts)\", \"identifier\" -> \"expert\", \"state\" -> this:get_option(\"expert\")]};",
            "options = {@options, [\"name\" -> \"Suppress Line Added Notifications\", \"identifier\" -> \"suppress\", \"state\" -> this:get_option(\"no_line_notifies\")]};",
            "options = {@options, [\"name\" -> \"Color Line Numbers\", \"identifier\" -> \"color_line\", \"state\" -> ((color = this:get_option(\"color_line\")) != \"\") ? tostr($ansi_utils:hr_to_code(color), color, \"[normal]\") | 0]};",
            "options = {@options, [\"name\" -> \"Color Line Indicator\", \"identifier\" -> \"color_indicator\", \"state\" -> ((color = this:get_option(\"color_indicator\")) != \"\") ? tostr($ansi_utils:hr_to_code(color), color, \"[normal]\") | 0]};",
            "options = {@options, [\"name\" -> \"Set As Default Editor For Verbs and Notes\", \"identifier\" -> \"default_editor\", \"state\" -> this:get_option(\"default_editor\")]};",
            "if (player.programmer)",
            "options = {@options, [\"name\" -> \"Jump to Error Line\", \"identifier\" -> \"jump_to_error\", \"state\" -> this:get_option(\"jump_to_error\")]};",
            "endif",
            "opt = $menu_utils:options_menu(options);",
            "if (opt == 0)",
            "return;",
            "endif",
            "if (opt == \"prefix\")",
            "player:tell(\"Enter a single character that you wish to begin editor commands with. It should preferably be a symbol, not a letter or number.\");",
            "cmd = $command_utils:read();",
            "if (((length(cmd) > 1) || (cmd in $string_utils:char_list($string_utils.alphabet + $string_utils.digits))) || (length(cmd) <= 0))",
            "return player:tell(\"Invalid command prefix. It should not be a number or letter and must be one (1) character in length.\");",
            "endif",
            "result = this:set_option(player, \"cmd_char\", cmd);",
            "if (typeof(result) != STR)",
            "player:tell(\"There was an error setting your command prefix.\");",
            "else",
            "player:tell(\"Command prefix set.\");",
            "endif",
            "elseif (opt == \"escape\")",
            "player:tell(\"Enter a single character that you wish to escape lines with. When lines are started with this character, any editor parsing will be bypassed. It should preferably be a symbol, not a letter or number.\");",
            "esc = $command_utils:read();",
            "if (((length(esc) > 1) || (esc in $string_utils:char_list($string_utils.alphabet + $string_utils.digits))) || (length(esc) <= 0))",
            "return player:tell(\"Invalid escape character. It should not be a number or letter and must be one (1) character in length.\");",
            "endif",
            "result = this:set_option(player, \"escape_char\", esc);",
            "if (typeof(result) != STR)",
            "player:tell(\"There was an error setting your escape character.\");",
            "else",
            "player:tell(\"Escape character set.\");",
            "endif",
            "elseif (opt == \"expert\")",
            "opt = !this:get_option(\"expert\");",
            "result = this:set_option(player, \"expert\", opt);",
            "player:tell(\"You \", opt ? \"activate\" | \"deactivate\", \" advanced mode.\");",
            "elseif (opt == \"suppress\")",
            "opt = !this:get_option(\"no_line_notifies\");",
            "result = this:set_option(player, \"no_line_notifies\", opt);",
            "player:tell(opt ? \"You will no longer receive a message when a line has been added to the working text.\" | \"You will once again receive a message when a line has been added to the working text.\");",
            "elseif (opt == \"default_editor\")",
            "opt = !this:get_option(\"default_editor\");",
            "result = this:set_option(player, \"default_editor\", opt);",
            "player:tell(opt ? \"When editing verbs or notes, you will now use the inline editor by default.\" | \"You will no longer use the inline editor to edit verbs and notes.\");",
            "elseif (opt == \"jump_to_error\")",
            "opt = !this:get_option(\"jump_to_error\");",
            "result = this:set_option(player, \"jump_to_error\", opt);",
            "player:tell(opt ? \"When editing verbs, the cursor will move to the line indicated in the traceback if an error occurs.\" | \"The cursor will no longer move to the traceback line when errors occur.\");",
            "elseif (opt == \"color_line\")",
            "option = \"color_line\";",
            "status = this:get_option(option);",
            "if (((status != \"\") && ($command_utils:yes_or_no(\"Would you like to select a different color?\") == 1)) || (status == \"\"))",
            "choice = $ansi_utils:color_selector();",
            "this:set_option(player, option, choice);",
            "player:tell(\"Color set.\");",
            "else",
            "this:set_option(player, option, \"\");",
            "player:tell(\"Color cleared.\");",
            "endif",
            "elseif (opt == \"color_indicator\")",
            "option = \"color_indicator\";",
            "status = this:get_option(option);",
            "if (((status != \"\") && ($command_utils:yes_or_no(\"Would you like to select a different color?\") == 1)) || (status == \"\"))",
            "choice = $ansi_utils:color_selector();",
            "this:set_option(player, option, choice);",
            "player:tell(\"Color set.\");",
            "else",
            "this:set_option(player, option, \"\");",
            "player:tell(\"Color cleared.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "log_last_edit",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{player, task} = args;",
            "this:refresh_last_edits();",
            "if (pos = player in $list_utils:slice(this.last_edits))",
            "this.last_edits[pos][2] = task;",
            "this.last_edits[pos][3] = ftime();",
            "else",
            "this.last_edits = setadd(this.last_edits, {player, task, ftime()});",
            "endif"
          ]
        },
        {
          "name": "get_last_edit",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{player} = args;",
            "return `this.last_edits[player in $list_utils:slice(this.last_edits)][3] ! ANY => 0';"
          ]
        },
        {
          "name": "refresh_last_edits",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "edits = this.last_edits;",
            "\"Clear out invalid editor sessions.\";",
            "for x in (edits)",
            "if ((!$code_utils:task_valid(x[2])) || (!x[1]:is_listening()))",
            "edits = setremove(edits, x);",
            "endif",
            "endfor",
            "this.last_edits = edits;"
          ]
        },
        {
          "name": "save",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": null
        },
        {
          "name": "session_for",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{player, ?create = 0} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "session = 0;",
            "for x in (this.sessions)",
            "if ((x.last_modified != 0) && ((time() - x.last_modified) > $time_utils.week))",
            "this.sessions = setremove(this.sessions, x);",
            "endif",
            "if (x.player == player)",
            "return x;",
            "endif",
            "endfor",
            "if (create)",
            "session = $edit_session:new();",
            "session.player = player;",
            "this.sessions = {@this.sessions, session};",
            "return session;",
            "endif",
            "return $nothing;"
          ]
        },
        {
          "name": "is_editing",
          "owner": 2,
          "perms": 172,
          "preps": -1,
          "object": 124,
          "code": [
            "{player} = args;",
            "return `$code_utils:task_valid(this.last_edits[player in $list_utils:slice(this.last_edits)][2]) ! ANY => 0';"
          ]
        },
        {
          "name": "program_verb",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{object, verbname, state} = args;",
            "ret = 0;",
            "try",
            "set_task_perms(player);",
            "simpleedit = $mcp.registry:match_package(\"dns-org-mud-moo-simpleedit\");",
            "if (result = set_verb_code(object, verbname, (typeof(simpleedit) == ERR) ? state.text | simpleedit:verbcode_external_to_internal(state.text)))",
            "player:notify_lines(result);",
            "player:notify(tostr(length(result), \" error(s).\"));",
            "player:notify(\"Verb not programmed.\");",
            "state.traceback = result;",
            "line_error = $string_utils:match_string(result[1], \"Line *: *\");",
            "if (line_error != 0)",
            "line_error = toint(line_error[1]);",
            "state.traceback_line = line_error;",
            "if (this:get_option(\"jump_to_error\") && (line_error != 0))",
            "if ((line_error > 0) && (line_error <= (length(state.text) + 1)))",
            "state.ins = line_error;",
            "endif",
            "endif",
            "endif",
            "else",
            "player:notify(\"0 errors.\");",
            "player:notify(tostr(object, \":\", verbname, \" successfully compiled.\"));",
            "endif",
            "except error (ANY)",
            "player:notify(error[2]);",
            "player:notify(\"Verb not programmed.\");",
            "endtry"
          ]
        },
        {
          "name": "cmd_insert",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.arg)",
            "player:tell(\"Insert where? (Use a positive integer or '$' for the last line.)\");",
            "return E_INVARG;",
            "elseif (((state.arg[1] != \"$\") && (toint(state.arg[1]) <= 0)) || (toint(state.arg[1]) > (length(state.text) + 1)))",
            "player:tell(\"Insertion ranges from line 1 to \", length(state.text) + 1, \".\");",
            "return E_INVARG;",
            "endif",
            "if (state.arg[1] == \"$\")",
            "state.ins = length(state.text) + 1;",
            "else",
            "state.ins = toint(state.arg[1]);",
            "endif",
            "(state.ins > 1) && this:list_line(state, state.ins - 1);",
            "(state.ins <= length(state.text)) && this:list_line(state, state.ins);",
            "player:tell(\"Now inserting before line \", state.ins, \".\");"
          ]
        },
        {
          "name": "cmd_load",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (this:session_for(player) == $nothing)",
            "player:tell(\"You have no text saved.\");",
            "return E_INVARG;",
            "endif",
            "if (state.text && ($command_utils:yes_or_no(\"The current text will be lost. Are you sure you wish to load saved text?\") == 0))",
            "player:tell(\"Aborted.\");",
            "return E_INVARG;",
            "endif",
            "state.text = this:session_for(player).text;",
            "player:tell(\"Saved text loaded.\");"
          ]
        },
        {
          "name": "cmd_save",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (this:session_for(player, 1).text && ($command_utils:yes_or_no(\"You already have text saved. Do you wish to overwrite it?\") == 0))",
            "player:tell(\"Aborted.\");",
            "return E_INVARG;",
            "endif",
            "if (!(state.arg in {0, {}}))",
            "range = this:parse_range(state.arg, length(state.text), state.ins);",
            "if (typeof(range) == STR)",
            "player:tell(range);",
            "return E_INVARG;",
            "endif",
            "{start, end} = range;",
            "text = state.text[start..end];",
            "else",
            "text = state.text;",
            "endif",
            "this:session_for(player, 1).text = text;",
            "this:session_for(player).last_modified = time();",
            "player:tell(\"The text has been successfully saved. To load it in for editing later, type \", this:get_opt(\"cmd_char\"), \"paste.\");"
          ]
        },
        {
          "name": "cmd_pass",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "passthrough = $string_utils:from_list(state.arg, \" \");",
            "force_input(player, passthrough);",
            "suspend(0);",
            "while ($command_utils:reading_input(player) && player:is_listening())",
            "yin();",
            "endwhile"
          ]
        },
        {
          "name": "cmd_reload",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "text = args[$].text;",
            "args = args[1..$ - 1];",
            "player:tell(\"Reloading...\");",
            "\"Maintain text through reloads.\";",
            "if (length(args) >= 1)",
            "args[1] = text;",
            "endif",
            "return this:editor(@args);"
          ]
        },
        {
          "name": "cmd_changeline",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (length(state.arg) < 2)",
            "player:tell(\"Usage: \", this:get_option(\"cmd_char\"), \"\", state.command, \" <line-number> <new-text>\");",
            "return E_INVARG;",
            "elseif (!state.text)",
            "player:tell(\"There is no text to change.\");",
            "return E_INVARG;",
            "else",
            "if (state.arg[1] == \"$\")",
            "NUM = length(state.text);",
            "elseif (state.arg[1] == \"^\")",
            "NUM = state.ins;",
            "else",
            "NUM = toint(state.arg[1]);",
            "endif",
            "if ((NUM < 1) || (NUM > length(state.text)))",
            "player:tell(\"There is no line with that number. Lines range from 1 to \", length(state.text), \".\");",
            "return E_INVARG;",
            "else",
            "newline = $string_utils:from_list(state.arg[2..$], \" \");",
            "state.text[NUM] = newline;",
            "player:tell(\"Line \", NUM, \" changed.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "cmd_grep",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.text)",
            "player:tell(\"There is no text to search.\");",
            "return E_INVARG;",
            "elseif (!state.arg)",
            "player:tell(\"Usage: FIND <text>\");",
            "return E_INVARG;",
            "endif",
            "hohum = (state.ins == (length(state.text) + 1)) ? 1 | state.ins;",
            "\"Note: If the caret is at the bottom, search the full text instead of nothing.\";",
            "found = 0;",
            "for x in (state.text[hohum..$])",
            "if (index(x, hoargs = $string_utils:from_list(state.arg, \" \")))",
            "found = hohum;",
            "break;",
            "endif",
            "hohum = hohum + 1;",
            "endfor",
            "if (!found)",
            "player:tell(\"No text matching `\", $string_utils:from_list(state.arg, \" \"), \"'.\");",
            "return E_INVARG;",
            "endif",
            "state.ins = found + 1;",
            "player:tell(found, \": \", state.text[found]);"
          ]
        },
        {
          "name": "cmd_quit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (state.verb && state.extra)",
            "{object, verbname} = state.extra[1];",
            "if ((verb_code(object, verbname) != state.text) && ($command_utils:yes_or_no(\"If you proceed, the text of the working verb could be lost due to failed compilation. Are you sure you wish to continue?\") != 1))",
            "player:tell(\"Aborted.\");",
            "return E_INVARG;",
            "endif",
            "program = this:program_verb(object, verbname, state);",
            "endif"
          ]
        },
        {
          "name": "cmd_delete",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.text)",
            "player:tell(\"There is no text to delete.\");",
            "else",
            "range = this:parse_range(state.arg, length(state.text), state.ins);",
            "if (!state.arg)",
            "if ((state.ins - 1) <= 0)",
            "range = {state.ins, state.ins};",
            "else",
            "range = {state.ins - 1, state.ins - 1};",
            "endif",
            "endif",
            "if (typeof(range) == STR)",
            "player:tell(range);",
            "return E_INVARG;",
            "endif",
            "{start, end} = range;",
            "for x in [start..end]",
            "player:tell(\"   \", state.text[start]);",
            "state.text = listdelete(state.text, start);",
            "endfor",
            "state.ins = start;",
            "if (state.ins > (length(state.text) + 1))",
            "state.ins = length(state.text) + 1;",
            "endif",
            "player:tell(\"---Line\", (end > start) ? \"s\" | \"\", \" deleted. Insertion point is before line \", state.ins, \".\");",
            "endif"
          ]
        },
        {
          "name": "cmd_list",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.text)",
            "player:tell(\"No text to list.\");",
            "return E_INVARG;",
            "\"     elseif (!state.arg)\";",
            "\"       player:tell(\\\"List what lines? (Line ranges from 1 to \\\", state.ins-1, \\\".)\\\");\";",
            "else",
            "if (!state.arg)",
            "if ((state.ins + 8) > length(state.text))",
            "listuntil = length(state.text);",
            "else",
            "listuntil = state.ins + 8;",
            "endif",
            "if ((state.ins - 8) <= 0)",
            "listfrom = 1;",
            "else",
            "listfrom = state.ins - 8;",
            "endif",
            "range = {listfrom, listuntil};",
            "elseif (state.arg == {\"all\"})",
            "range = {1, length(state.text)};",
            "else",
            "range = this:parse_range(state.arg, length(state.text), state.ins);",
            "if (typeof(range) == STR)",
            "player:tell(range);",
            "return E_INVARG;",
            "endif",
            "endif",
            "{start, end} = range;",
            "ind = start;",
            "\"Since we don't want to introduce ANSI into the actual text, we'll create a temp variable.\";",
            "if (state.verb && (\"highlight_syntax\" in player.prog_options))",
            "list_text = $code_utils:highlight_syntax(state.text[start..end]);",
            "else",
            "list_text = state.text[start..end];",
            "endif",
            "for x in (list_text)",
            "$command_utils:suspend_if_needed(0);",
            "line_color = this:get_opt(\"color_line\");",
            "player:tell((line_color != \"\") ? $ansi_utils:hr_to_code(line_color) | \"\", ind, (line_color != \"\") ? \"\" | \"\", \": \", (typeof(x) != STR) ? toliteral(x) | x);",
            "ind = ind + 1;",
            "if (ind == state.ins)",
            "ind_color = this:get_opt(\"color_indicator\");",
            "player:tell((ind_color != \"\") ? $ansi_utils:hr_to_code(ind_color) | \"\", \"^^^^\", (ind_color != \"\") ? \"\" | \"\");",
            "endif",
            "endfor",
            "endif"
          ]
        },
        {
          "name": "cmd_count",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (((length(state.arg) == 1) && (state.arg[1] in {\"line\", \"lines\"})) || (!state.arg))",
            "player:tell(\"Lines: \", length(state.text));",
            "endif",
            "if (((length(state.arg) == 1) && (state.arg[1] in {\"character\", \"letters\", \"chars\", \"char\", \"characters\"})) || (!state.arg))",
            "chars = 0;",
            "for x in (state.text)",
            "chars = chars + length(x);",
            "endfor",
            "player:tell(\"Characters: \", chars);",
            "endif",
            "if (((length(state.arg) == 1) && (state.arg[1] in {\"word\", \"words\"})) || (!state.arg))",
            "words = 0;",
            "for x in (state.text)",
            "words = words + length($string_utils:words(x));",
            "endfor",
            "player:tell(\"Words: \", words);",
            "endif"
          ]
        },
        {
          "name": "cmd_help",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "player:tell(\"Command Help\");",
            "player:tell(dashes = \"-------------\");",
            "cmds = vcmds = {};",
            "for x in (verb_code(this, \"editor\"))",
            "line = $string_utils:trim(x);",
            "if (match = $string_utils:match_string(line, \"*f (state.command in {*})\"))",
            "\"cmds = {@cmds, @$string_utils:to_value(match)[2]};\";",
            "cmds = {@cmds, $string_utils:explode($string_utils:strip_all_but(match[2], $string_utils.alphabet + \",?/\"), \",\")};",
            "elseif (match = $string_utils:match_string(line, \"*f (state.command == \\\"*\\\")\"))",
            "cmds = {@cmds, {match[2]}};",
            "elseif (match = $string_utils:match_string(line, \"elseif (state.verb && state.command == \\\"*\\\")\"))",
            "vcmds = {@vcmds, {match[1]}};",
            "elseif (match = $string_utils:match_string(line, \"elseif (state.verb && state.command in {*})\"))",
            "vcmds = {@vcmds, $string_utils:explode($string_utils:strip_all_but(match[1], $string_utils.alphabet + \",?/\"), \",\")};",
            "elseif (match = $string_utils:match_string(line, \"elseif (state.verb && state.extra && state.command == \\\"*\\\")\"))",
            "vcmds = {@vcmds, {match[1]}};",
            "elseif (match = $string_utils:match_string(line, \"elseif (state.verb && state.extra && state.command in {*})\"))",
            "vcmds = {@vcmds, $string_utils:explode($string_utils:strip_all_but(match[1], $string_utils.alphabet + \",?/\"), \",\")};",
            "endif",
            "endfor",
            "ret = {};",
            "if (!state.arg)",
            "ret = {@ret, \"Help is available on the following topics:\", \"\"};",
            "ret = {@ret, @$string_utils:columnize($list_utils:slice(player.programmer ? {@cmds, @vcmds} | cmds), 3)};",
            "else",
            "for x in ({@cmds, @vcmds})",
            "if (((x in vcmds) && ((player.programmer != 1) || (!state.verb))) || (state.arg && ((state.arg[1] in x) == 0)))",
            "continue x;",
            "endif",
            "ret = {@ret, tostr(x[1], \"\", (length(x) > 1) ? tostr(\" (Aliases: \", $string_utils:english_list(x[2..$]), \")\") | \"\", \":\")};",
            "if (ind = x[1] in $list_utils:slice(this.help))",
            "\"                ret = {@ret, tostr($list_utils:slice(help, 2)[ind])};\";",
            "ret = {@ret, @this.help[ind][2..$]};",
            "else",
            "ret = {@ret, \"No help available.\"};",
            "endif",
            "endfor",
            "endif",
            "if (!ret)",
            "ret = {@ret, tostr(\"No help on that command is presently available. To see a list of commands, type \", this:get_opt(\"cmd_char\", player), \"help without arguments.\")};",
            "endif",
            "player:tell_lines(ret);",
            "player:tell(dashes);",
            "if (!state.arg)",
            "player:tell();",
            "player:tell(\"To work with ranges, do one of the following:\");",
            "player:tell(\"/delete 1..4 -- Erases lines 1 through 4.\");",
            "player:tell(\"/delete 8..$ -- Erases up until the end of the text, starting at line 8.\");",
            "player:tell(\"/list 3 4 -- Lists lines 3-4.\");",
            "player:tell(\"/delete 1 -- Erases line 1.\");",
            "player:tell(\"/list 40+40 -- Lists the contents of line 80.\");",
            "endif"
          ]
        },
        {
          "name": "cmd_paste_letter",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "letters = {};",
            "for x in (player.contents)",
            "if (((x != 0) && (isa(x, $note) || isa(x, $letter))) && x:is_readable_by(player))",
            "letters = {@letters, x};",
            "endif",
            "endfor",
            "if (letters == {})",
            "player:tell(\"You are not carrying any notes.\");",
            "else",
            "if (length(letters) > 1)",
            "player:tell(\"Pick a note to paste into the working text.\");",
            "letter = letters[$command_utils:menu(letters)];",
            "else",
            "letter = letters[1];",
            "endif",
            "if ($command_utils:yes_or_no(tostr(\"Really insert the text of \", letter:title(), \"?\")) == 1)",
            "state.text = {@state.text[1..state.ins - 1], @letter:text(), @state.text[state.ins..$]};",
            "player:tell(\"Text inserted.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "cmd_commentify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.arg)",
            "player:tell(\"You must include what lines you wish to comment.\");",
            "return E_INVARG;",
            "endif",
            "range = this:parse_range(state.arg, length(state.text), state.ins);",
            "if (typeof(range) == STR)",
            "player:tell(range);",
            "return E_INVARG;",
            "endif",
            "{start, end} = range;",
            "for x in [start..end]",
            "state.text[x] = (\"\" + toliteral(state.text[x])) + \";\";",
            "endfor",
            "player:tell(\"Line\", (end < start) ? \"s\" | \"\", \" commented.\");"
          ]
        },
        {
          "name": "cmd_uncommentify",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.arg)",
            "player:tell(\"You must include what lines you wish to uncomment.\");",
            "return E_INVARG;",
            "endif",
            "range = this:parse_range(state.arg, length(state.text), state.ins);",
            "if (typeof(range) == STR)",
            "player:tell(range);",
            "return E_INVARG;",
            "endif",
            "{start, end} = range;",
            "bogus = {};",
            "for x in [start..end]",
            "if (((length(state.text[x]) > 3) && (state.text[x][1] == \"\\\"\")) && (state.text[x][$ - 1..$] == \"\\\";\"))",
            "state.text[x] = state.text[x][2..$ - 2];",
            "else",
            "bogus = {@bogus, state.text[x]};",
            "endif",
            "endfor",
            "player:tell(\"Line\", (end < start) ? \"s\" | \"\", \" uncommented.\");",
            "if (bogus)",
            "player:tell(\"---\", length(bogus), \" \", $s(\"line\", length(bogus)), \" \", (start < end) ? \"were\" | \"was\", \" not comments.\");",
            "endif"
          ]
        },
        {
          "name": "cmd_traceback",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.traceback_line)",
            "player:tell(\"There are no recorded tracebacks.\");",
            "return E_INVARG;",
            "else",
            "if ((state.traceback_line > 0) && (state.traceback_line <= (length(state.text) + 1)))",
            "state.ins = state.traceback_line;",
            "player:tell(\"Insertion point is now at line '\", state.ins, \"'.\");",
            "else",
            "player:tell(\"The recorded traceback line is no longer valid.\");",
            "endif",
            "endif"
          ]
        },
        {
          "name": "cmd_print_traceback",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.traceback)",
            "player:tell(\"There are no recorded tracebacks.\");",
            "return E_INVARG;",
            "else",
            "player:tell(\"Last recorded traceback:\");",
            "player:tell_lines(state.traceback);",
            "endif"
          ]
        },
        {
          "name": "cmd_format",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (!state.text)",
            "player:tell(\"No text to format.\");",
            "return E_INVARG;",
            "endif",
            "ind = 1;",
            "reformatted = {};",
            "player:tell(\"Formatting...\");",
            "for x in (state.text)",
            "if (length(x) > abs(player:linelen()))",
            "player:tell(\"Line \", ind, \" too long: reformatting.\");",
            "reformatted = {@reformatted, @player:linesplit(x, abs(player:linelen()))};",
            "else",
            "reformatted = {@reformatted, x};",
            "endif",
            "ind = ind + 1;",
            "endfor",
            "state.text = reformatted;",
            "player:tell(\"Done.\");"
          ]
        },
        {
          "name": "do_add_line",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state, line} = args;",
            "if (`line[1] == this:get_option(\"escape_char\") ! ANY' && (length(line) > 1))",
            "line = line[2..$];",
            "endif",
            "if (state.ins > length(state.text))",
            "state.text = {@state.text, line};",
            "else",
            "state.text = {@state.text[1..state.ins - 1], line, @state.text[state.ins..$]};",
            "endif",
            "(!this:get_option(\"no_line_notifies\")) && player:tell(\"Line \", state.ins, \" added.\");",
            "this:log_last_edit(player, task_id());",
            "state.ins = state.ins + 1;"
          ]
        },
        {
          "name": "set_option",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{player, option, value} = args;",
            "if (!caller_perms().wizard)",
            "return E_PERM;",
            "endif",
            "options = player.inline_editor_options;",
            "if (this.default_options[option] == #-1)",
            "return -1;",
            "endif",
            "if (options == 0)",
            "player.inline_editor_options = [];",
            "endif",
            "if ((this.default_options[option] == value) && (option in player.inline_editor_options:keys()))",
            "player.inline_editor_options = player.inline_editor_options:delete(option);",
            "else",
            "player.inline_editor_options[option] = value;",
            "endif",
            "\"Sacrificing sanity checks for tick savings.\";",
            "if (this:get_opt(option, player) == value)",
            "return value;",
            "endif",
            "return -1;"
          ]
        },
        {
          "name": "cmd_show_clipboard",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "saved = this:session_for(player, 1);",
            "if (!saved.text)",
            "player:tell(\"You have no text saved.\");",
            "return E_INVARG;",
            "else",
            "player:tell(\"You have the following text saved:\");",
            "player:tell();",
            "player:tell_lines_suspended(saved.text);",
            "player:tell();",
            "player:tell(\"(end of saved text)\");",
            "endif"
          ]
        },
        {
          "name": "cmd_localedit",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "oldoption = this:get_option(\"edit_verbs\");",
            "this:set_option(player, \"edit_verbs\", 0);",
            "$verb_editor:invoke((tostr(state.extra[1][1]) + \":\") + state.extra[1][2], \"@program\", state.text);",
            "this:set_option(player, \"edit_verbs\", oldoption);",
            "kill_task(task_id());"
          ]
        },
        {
          "name": "cmd_replace",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "{state} = args;",
            "if (length(state.arg) < 1)",
            "player:tell(\"Usage: \", this:get_option(\"cmd_char\"), \"\", state.command, \" <PCRE replacement>\");",
            "return E_INVARG;",
            "elseif (!state.text)",
            "player:tell(\"There is no text to change.\");",
            "return E_INVARG;",
            "else",
            "changed = 0;",
            "success = 1;",
            "range = {1, length(state.text)};",
            "if ((length(state.arg) >= 2) && (typeof(this:parse_range(state.arg[$], length(state.text), state.ins)) == LIST))",
            "range = this:parse_range(state.arg[$], length(state.text), state.ins);",
            "player:tell(\"(Running replacement\", (range[1] != range[2]) ? \"s\" | \"\", \" on \", (range[1] == range[2]) ? \"line \" + tostr(range[1]) | tostr(\"lines \", range[1], \" to \", range[2]), \".)\");",
            "endif",
            "for I in [range[1]..range[2]]",
            "try",
            "newline = pcre_replace(state.text[I], $string_utils:from_list(state.arg));",
            "except e (ANY)",
            "player:tell(\"Error on line \", I, \": \", e[2]);",
            "success = 0;",
            "break;",
            "endtry",
            "if (newline != state.text[I])",
            "changed = changed + 1;",
            "state.text[I] = newline;",
            "endif",
            "yin();",
            "endfor",
            "player:tell(\"Replacement \", success ? \"complete\" | \"failed\", \". \", changed, \" \", $s(\"line\", changed), \" affected.\");",
            "endif"
          ]
        },
        {
          "name": "init_for_core",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "if (caller_perms().wizard)",
            "this.last_edits = {};",
            "this.sessions = {};",
            "pass(@args);",
            "endif"
          ]
        },
        {
          "name": "list_line",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 124,
          "code": [
            "$ansi_utils:add_noansi();",
            "{state, line} = args;",
            "f = 1 + (line in {(ins = state.ins) - 1, ins});",
            "text = state.text[line];",
            "player:tell($string_utils:right(line, 3, \" _^\"[f]), \":_^\"[f], \" \", text);",
            "$ansi_utils:remove_noansi();"
          ]
        }
      ],
      "propnames": [
        "default_options",
        "last_edits",
        "sessions",
        "help"
      ],
      "propdefs": [
        {
          "value": {
            "buffer_external_output": 0,
            "cmd_char": "/",
            "color_indicator": "",
            "color_line": "",
            "default_editor": 0,
            "escape_char": "\\",
            "expert": 0,
            "jump_to_error": 0,
            "no_line_notifies": 1
          },
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": [],
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            [
              "insert",
              "Change the insertion point."
            ],
            [
              "del",
              "Delete a line or multiple lines using ranges."
            ],
            [
              "pass",
              "Pass a command through the editor to your character. (For example, '/pass say Hello.' would allow you to say hello while still editing text.)"
            ],
            [
              "list",
              "View text written so far. To change what is shown, insert at a different line. You can use line ranges with this command. Providing 'all' as an argument will list everything."
            ],
            [
              "abort",
              "Throw away text."
            ],
            [
              "done",
              " Same as hitting period (.)."
            ],
            [
              "help",
              "This help."
            ],
            [
              "find",
              "Search text from the insertion point onward. Will place the caret on any results located.",
              "",
              "If the insertion point is at the very end, it will search from the beginning of the text."
            ],
            [
              "format",
              "Format lines correctly so they don't go off the screen, based on your linelength preferences."
            ],
            [
              "set",
              "Change editor options; is a shortcut for the EDIT-OPTIONS command."
            ],
            [
              "spellcheck",
              "Check the text you've written for spelling errors."
            ],
            [
              "count",
              "Displays how many <lines|words|characters> are written so far."
            ],
            [
              "import",
              "Insert the text of a note or letter that's in your hand. (You can only insert notes that you can read.)"
            ],
            [
              "change",
              "Replace <line-number> with <text>."
            ],
            [
              "tb",
              "Jump to the line indicated in the last traceback."
            ],
            [
              "ptb",
              "Print the last traceback."
            ],
            [
              "verb",
              "Display the verb you're currently editing."
            ],
            [
              "compile",
              "Send the editor contents to the MOO as code for the currently edited verb. Does NOT close the editor session."
            ],
            [
              "copy",
              "By default, copies the full text of the buffer to a temporary clipboard. You can optionally specify a range (e.g. COPY 2..5). You can then PASTE it in another edit session."
            ],
            [
              "paste",
              "Paste copied text."
            ],
            [
              "clipboard",
              "Review text that's currently on your clipboard."
            ],
            [
              "comment",
              "Turn a verb line into a comment."
            ],
            [
              "uncomment",
              "Turn a comment into a line of code."
            ],
            [
              "replace",
              "Run a Perl Compatible Regular Expressions replacement on the body of the text.",
              "For information on how PCRE replacements work, check https://www.regular-expressions.info/perl.html"
            ]
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            "The inline editor is a vastly improved version of the current prompt that accepts multiple lines. It allows for insert and delete operations, text pasting or auto-formatting, as well as spell checking and other functions. ",
            "",
            "The editor is highly customizable. To change different aspects of editing, type EDIT-OPTIONS (or simply EDIT-O). For help on the different commands available to you while editing, you can use the HELP command inside the editor. This is accessible by typing your command character, which is a forward slash (/) by default, followed by the word HELP.",
            "",
            "Credit goes to:",
            "",
            "        - Initially created in 2015 by Victor@Toastsoft.net.",
            "        - Improved by Lisdude in 2017-2018 in numerous ways."
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "generic inline editor",
            "inline editor",
            "inline",
            "flexible editor interface utilities",
            "editor interface utilities",
            "interface utilities",
            "utilities",
            "editor",
            "interface",
            "flexible"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": "This is a placeholder parent for all the $..._utils packages, to more easily find them and manipulate them. At present this object defines no useful verbs or properties. (Filfre.)",
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            52489,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "125": {
      "id": 125,
      "name": "Generic Editing State Anon",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        122
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "new",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 125,
          "code": [
            "{text, verb, extra, @overflow} = args;",
            "new = pass(player);",
            "new.text = text;",
            "new.verb = verb;",
            "new.extra = extra;",
            "return new;"
          ]
        }
      ],
      "propnames": [
        "text",
        "cursor",
        "error_line",
        "verb",
        "extra",
        "ins",
        "command",
        "arg",
        "verb_name",
        "traceback",
        "traceback_line"
      ],
      "propdefs": [
        {
          "value": [],
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        }
      ],
      "anon": false,
      "recycled": false
    },
    "126": {
      "id": 126,
      "name": "Menu Utilities",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        78
      ],
      "children": [],
      "last_move": 0,
      "contents": [],
      "verbs": [
        {
          "name": "menu",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 126,
          "code": [
            "\"Usage: $menu_utils:menu(menu, options)\";",
            "\"Menu: Should be a list of strings.\";",
            "\"Options: A map containing option modifiers.\";",
            "\"You can insert an _ in your menu if you wish to create a blank line and not include it in the numeric output.\";",
            "\"Similarly, you can include ##<header> as a menu item if you want to render an automatically capitalized heading in the midst of your menu.\";",
            "SU = $string_utils;",
            "{menu, ?options = 0} = args;",
            "default_options = [\"invalid_selection_msg\" -> \"Invalid selection.\", \"prompt\" -> \"Enter your selection:\", \"map_verb\" -> \"title\", \"kill_after_invalid_selection\" -> 1, \"expires_in\" -> 0, \"expired_msg\" -> \"Selection time expired; menu closed.\", \"target\" -> player, \"header_msg\" -> 0, \"blank_input_msg\" -> 0, \"input\" -> 0, \"hidden_menu\" -> 0, \"autofit_header\" -> {}, \"autofit_padding\" -> 2, \"columns\" -> 0, \"capitalize_string_entries\" -> 1];",
            "if (options == 0)",
            "options = default_options;",
            "else",
            "for x in (mapkeys(default_options))",
            "if ((x in mapkeys(options)) == 0)",
            "options[x] = default_options[x];",
            "endif",
            "endfor",
            "endif",
            "if (typeof(options[\"prompt\"]) == STR)",
            "options[\"  prompt\"] = {options[\"prompt\"]};",
            "endif",
            "player = options[\"target\"];",
            "names = {};",
            "i = 0;",
            "for x in (menu)",
            "number = 0;",
            "if (x == \"_\")",
            "\"Blank Line\";",
            "name = \"\";",
            "menu = setremove(menu, x);",
            "elseif ((((typeof(x) in {OBJ, ANON, WAIF}) == 0) && (length(x) > 2)) && (x[1..2] == \"##\"))",
            "name = SU:capitalize_each(x[3..$]);",
            "menu = setremove(menu, x);",
            "elseif (typeof(x) in {OBJ, ANON, WAIF})",
            "i = i + 1;",
            "name = this:return_map_verb(x, options[\"map_verb\"]);",
            "number = 1;",
            "elseif (typeof(x) == STR)",
            "i = i + 1;",
            "name = options[\"capitalize_string_entries\"] ? x:capitalize_each() | x;",
            "number = 1;",
            "else",
            "name = x;",
            "endif",
            "if (number)",
            "name = tostr(\"[\", i, \"] \", name);",
            "endif",
            "names = {@names, name};",
            "$sin();",
            "endfor",
            "if (!options[\"hidden_menu\"])",
            "(options[\"header_msg\"] != 0) && player:tell(options[\"header_msg\"]);",
            "if (typeof(`menu[1] ! ANY => STR') == LIST)",
            "\"Autofit the menu according to lengths.\";",
            "for x in [1..length(names)]",
            "names[x] = {tostr(\"[\", x, \"]\"), @names[x]};",
            "endfor",
            "header = options[\"autofit_header\"];",
            "names = SU:autofit(header ? {header, @names} | names, options[\"autofit_padding\"], header);",
            "if (header)",
            "\"If we have a header, we need to move it to the right of the numeric options so that it's not a heading for the numbers.\";",
            "space = SU:space(length(tostr(length(names))) + 4);",
            "\"Two for brackets, two for space, the rest for how many numbers display\";",
            "for x in [1..2]",
            "player:tell(space, names[x]);",
            "endfor",
            "names = names[3..$];",
            "endif",
            "endif",
            "if (options[\"columns\"])",
            "player:tell_lines($ansi_utils:columnize(names, options[\"columns\"], player:linelen()));",
            "else",
            "player:tell_lines(names);",
            "endif",
            "endif",
            "\"Fork a task to kill the menu if a selection wasn't chosen in the given time period.\";",
            "if ((options[\"expires_in\"] > 0) && (!options[\"hidden_menu\"]))",
            "menu_task_id = task_id();",
            "fork (options[\"expires_in\"])",
            "if ($code_utils:task_valid(menu_task_id))",
            "kill_task(menu_task_id);",
            "player:tell(options[\"expired_msg\"]);",
            "endif",
            "endfork",
            "endif",
            "if (!options[\"input\"])",
            "options[\"hidden_menu\"] && player:tell();",
            "player:tell_lines(options[\"prompt\"]);",
            "player:notify(tostr(\"[Type a line of input or `@abort' to abort the command.]\"));",
            "selection = read(player);",
            "else",
            "selection = tostr(options[\"input\"]);",
            "endif",
            "if ((!selection) && options[\"blank_input_msg\"])",
            "player:tell(options[\"blank_input_msg\"]);",
            "if (options[\"kill_after_invalid_selection\"])",
            "return kill_task(task_id());",
            "else",
            "return 0;",
            "endif",
            "elseif (SU:is_numeric(selection))",
            "selection = toint(selection);",
            "if ((selection <= 0) || (selection > length(menu)))",
            "player:tell(options[\"invalid_selection_msg\"]);",
            "if (options[\"kill_after_invalid_selection\"])",
            "return kill_task(task_id());",
            "else",
            "return -1;",
            "endif",
            "endif",
            "return selection;",
            "elseif (selection == \"$\")",
            "return length(menu);",
            "elseif (selection == \"^\")",
            "return 1;",
            "else",
            "if (selection != \"\")",
            "if (selection == \"@abort\")",
            "player:tell(\">> Command Aborted <<\");",
            "return kill_task(task_id());",
            "endif",
            "i = 0;",
            "matches = {};",
            "for x in (menu)",
            "if ((x == \"\") || ((length(x) > 2) && (x[1..2] == \"##\")))",
            "continue;",
            "elseif (typeof(x) == LIST)",
            "x = x[1];",
            "\"       x = $string_utils:from_list(x, \\\" \\\");\";",
            "endif",
            "i = i + 1;",
            "for y in ($string_utils:words(x:strip_ansi()))",
            "if (index(y, selection) == 1)",
            "matches = {@matches, i};",
            "endif",
            "endfor",
            "endfor",
            "if (matches)",
            "if (length(matches) == 1)",
            "return matches[1];",
            "else",
            "match_menu = {};",
            "for x in (matches)",
            "match_menu = {@match_menu, menu[x]};",
            "endfor",
            "player:tell(\"Multiple matches were detected. Please be more specific.\");",
            "for x in ({\"hidden_menu\", \"input\"})",
            "`options = options:delete(x) ! ANY';",
            "endfor",
            "return matches[this:menu(match_menu, options)];",
            "endif",
            "endif",
            "endif",
            "player:tell(options[\"invalid_selection_msg\"]);",
            "if (options[\"kill_after_invalid_selection\"])",
            "return kill_task(task_id());",
            "else",
            "return -1;",
            "endif",
            "endif"
          ]
        },
        {
          "name": "return_map_verb",
          "owner": 36,
          "perms": 173,
          "preps": -1,
          "object": 126,
          "code": [
            "{OBJ, verb} = args;",
            "return `OBJ:(verb)() ! ANY => \"Unknown\"';"
          ]
        },
        {
          "name": "options_menu",
          "owner": 2,
          "perms": 173,
          "preps": -1,
          "object": 126,
          "code": [
            "\"$menu_utils:options_menu(options[,input[,  menu_op]])\";",
            "\"This is a menu verb, specifically intended for option menus that need complexity and robustness not provided by $option_utils.\";",
            "\"It's only real purpose is option matching, not setting. Setting is left as an exercise to the programmer.\";",
            "\"Options: This should be a list of maps with the following keys-\";",
            "\"\";",
            "\"       Name: The name, as displayed to the user\";",
            "\"       Identifier: An internal identifier that's returned with the selection.\";",
            "\"       State: The state of the option that should be displayed to the user, such as on or off.\";",
            "\"       If the state is an integer, we'll automatically assume \\\"[red]Off[normal]\\\" for false booleans and \\\"[green]On[normal]\\\" for true ones.\";",
            "\"\";",
            "\"Input: Defaults to argstr, which should be set by the server before this verb is executed. This is used to optionally match on option names rather than printing a menu.\";",
            "\"Menu_op: This is a map of options to pass to the corresponding menu call later.\";",
            "\"This verb simply returns the corresponding number.\";",
            "\"If the option has a corresponding identifier, this returns the identifier instead of the index.\";",
            "{options, ?input = argstr, ?menu_op = []} = args;",
            "default_off = \"[red]Off[normal]\";",
            "default_on = \"[green]On[normal]\";",
            "if (input)",
            "menu_op[\"hidden_menu\"] = 1;",
            "menu_op[\"invalid_selection_msg\"] = \"Invalid option.\";",
            "menu_op[\"input\"] = input;",
            "menu_op[\"kill_after_invalid_selection\"] = 0;",
            "endif",
            "menu = {};",
            "IDs = [];",
            "names = {};",
            "for x in (options)",
            "name = x[\"name\"];",
            "names = {@names, name};",
            "if (\"identifier\" in x:keys())",
            "IDs[name] = x[\"identifier\"];",
            "endif",
            "state = x[\"state\"];",
            "if (typeof(state) == INT)",
            "display = state ? default_on | default_off;",
            "elseif ((typeof(state) in {STR, ANON, OBJ}) == 0)",
            "display = toliteral(state);",
            "else",
            "display = state;",
            "endif",
            "display = (\"[\" + display) + \"]\";",
            "menu = {@menu, {name, display}};",
            "endfor",
            "ret = this:menu(menu, menu_op);",
            "if (ret == -1)",
            "return 0;",
            "else",
            "if (names[ret] in IDs:keys())",
            "return IDs[names[ret]];",
            "else",
            "return ret;",
            "endif",
            "endif"
          ]
        }
      ],
      "propnames": [],
      "propdefs": [
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 4
        },
        {
          "value": [
            "Menu Utilities"
          ],
          "owner": 2,
          "perms": 5
        },
        {
          "value": null,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [
            8055,
            1671219241
          ],
          "owner": 36,
          "perms": 1
        }
      ],
      "anon": false,
      "recycled": false
    },
    "127": {
      "id": 127,
      "name": "Generic Editor Session",
      "flags": 0,
      "owner": 2,
      "location": -1,
      "parents": [
        122
      ],
      "children": [],
      "last_move": {},
      "contents": [],
      "verbs": [],
      "propnames": [
        "last_modified",
        "player",
        "text"
      ],
      "propdefs": [
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": 0,
          "owner": 2,
          "perms": 5
        },
        {
          "value": [],
          "owner": 2,
          "perms": 5
        }
      ],
      "anon": false,
      "recycled": false
    }
  },
  "queuedTasks": [
    {
      "firstLineno": 1,
      "id": 419331400,
      "st": 1671264001,
      "unused": 0,
      "value": null,
      "activation": {
        "this": 79,
        "threaded": 1,
        "player": 2,
        "programmer": 2,
        "vloc": 79,
        "debug": true,
        "verb": "schedule_measurement_task",
        "verbname": "schedule_measurement_task",
        "code": [],
        "stack": [],
        "unused1": -7,
        "unused2": -8,
        "unused3": -9,
        "unused4": -10,
        "rtEnv": {},
        "temp": null,
        "pc": 0,
        "bi_func": 0,
        "func_name": "",
        "error": 0
      },
      "rtEnv": {
        "NUM": 0,
        "OBJ": 1,
        "STR": 2,
        "LIST": 4,
        "ERR": 3,
        "player": 2,
        "this": 79,
        "caller": 79,
        "verb": "schedule_measurement_task",
        "args": [],
        "argstr": "",
        "dobj": -1,
        "dobjstr": "",
        "prepstr": "",
        "iobj": -1,
        "iobjstr": "",
        "INT": 0,
        "FLOAT": 9,
        "MAP": 10,
        "ANON": 12,
        "WAIF": 13,
        "BOOL": 14,
        "true": true,
        "false": false
      },
      "code": [
        "this:schedule_measurement_task();",
        "this.measurement_task_running = task_id();",
        "this:measurement_task(this.task_time_limit);",
        "this.measurement_task_running = 0;"
      ]
    }
  ],
  "suspendedTasks": [],
  "interruptedTasks": [],
  "connections": [],
  "waifs": {},
  "players": [
    2,
    71,
    36,
    38,
    96,
    98
  ]
}